private static String uploadedJarLocation ( List < String > tmpArgs ) { int position = tmpArgs . size ( ) - 1 ; String uploadedJarLocation = tmpArgs . get ( position ) ; tmpArgs . remove ( position ) ; return uploadedJarLocation ; }
private void writeString ( String s , CharacterOutput output ) { if ( canBeUnquoted ( s ) ) { output . write ( s ) ; return ; } output . write ( '"' ) ; final int length = s . length ( ) ; for ( int i = 0 ; i < length ; i + + ) { char c = s . charAt ( i ) ; int escapeIndex = Utils . arrayIndexOf ( TO_ESCAPE , c ) ; if ( escapeIndex ! = - 1 ) { char escaped = ESCAPED [ escapeIndex ] ; output . write ( '\\' ) ; output . write ( escaped ) ; } else { output . write ( c ) ; } } output . write ( '"' ) ; }
public MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) { return new MutatorOperationImpl ( m , key , by , def , exp , cb ) ; }
public terminal_set check_first_set ( ) throws internal_error { int part ; symbol sym ; for ( part = 0 ; part < rhs_length ( ) ; part + + ) { if ( ! rhs ( part ) . is_action ( ) ) { sym = ( ( symbol_part ) rhs ( part ) ) . the_symbol ( ) ; if ( sym . is_non_term ( ) ) { _first_set . add ( ( ( non_terminal ) sym ) . first_set ( ) ) ; if ( ! ( ( non_terminal ) sym ) . nullable ( ) ) break ; } else { _first_set . add ( ( terminal ) sym ) ; break ; } } } return first_set ( ) ; }
static void structuralDecompose1 ( final CompoundTerm compound , final short index , final Statement statement , final DerivationContext nal ) { if ( index > = compound . term . length ) { return ; } final Term component = compound . term [ index ] ; final Task task = nal . getCurrentTask ( ) ; final Sentence sentence = task . sentence ; final int order = sentence . getTemporalOrder ( ) ; final TruthValue truth = sentence . truth ; if ( truth = = null ) { return ; } final float reliance = Parameters . reliance ; final TruthValue truthDed = TruthFunctions . deduction ( truth , reliance ) ; final TruthValue truthNDed = TruthFunctions . negation ( TruthFunctions . deduction ( truth , reliance ) ) ; final Term subj = statement . getSubject ( ) ; final Term pred = statement . getPredicate ( ) ; if ( compound . equals ( subj ) ) { if ( compound instanceof IntersectionInt ) {
public static Term make ( final Term t ) { final TreeSet < Term > set = new TreeSet < > ( ) ; set . add ( t ) ; return make ( set ) ; }
public void onCreate ( ) { Log . d ( TAG , " Creating service " ) ; app = ( MPDApplication ) getApplication ( ) ; if ( app = = null ) { stopSelf ( ) ; } mAudioFocusHelper = new AudioFocusHelper ( app , this ) ; app . addConnectionLock ( this ) ; app . oMPDAsyncHelper . addStatusChangeListener ( this ) ; mNotificationManager = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; mAudioManager = ( AudioManager ) getSystemService ( AUDIO_SERVICE ) ; mMediaButtonReceiverComponent = new ComponentName ( this , RemoteControlReceiver . class ) ; mAudioManager . registerMediaButtonEventReceiver ( mMediaButtonReceiverComponent ) ; tryToGetAudioFocus ( ) ; buildStaticPendingIntents ( this ) ; }
abstract public E takeOut ( boolean removeFromNameTable ) ; abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } public void addBagObserver ( BagObserver < E > bagObserver , String title ) { this . bagObserver = bagObserver ; bagObserver . post ( toString ( ) ) ; bagObserver . setTitle ( title ) ; bagObserver . setBag ( this ) ; } protected int forgetRate ( ) { if ( forgettingRate ! = null ) { return forgettingRate . get ( ) ; } return - 1 ; } public void play ( ) { if ( bagObserver ! = null ) { bagObserver . post ( toString ( ) ) ; } } protected void reprocess ( E x ) { int r = forgetRate ( ) ; if ( r > 0 ) { BudgetFunctions . forget ( x . budget , forgetRate ( ) , RELATIVE_THRESHOLD ) ; } } public void stop ( ) { if ( bagObserver ! = null ) { bagObserver . stop ( ) ; } } public boolean putBack ( final E oldItem , boolean insertIntoNameTable ) { reprocess ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( ) { final E x = takeOut ( false ) ; if ( x ! = null ) { reprocess ( x ) ; boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else return null ; } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( CharSequence key ) ; }
Map < String , String > getParameters ( ) ; ISession getSession ( ) ; void initDynamicComponent ( ISession aSession , Map < String , String > aParameters ) throws OpenAS2Exception ; }
public void handle ( final AbstractActiveNetModule aOwner , @Nonnull final Socket aSocket ) { final String sClientInfo = getClientInfo ( aSocket ) ; s_aLogger . info ( " Incoming connection  " + sClientInfo ) ; final AS2Message aMsg = createMessage ( aSocket ) ; final IAS2HttpResponseHandler aResponseHandler = new AS2HttpResponseHandlerSocket ( aSocket ) ; final StopWatch aSW = StopWatch . createdStarted ( ) ; byte [ ] aMsgData = null ; try { aMsgData = readAndDecodeHttpRequest ( new AS2InputStreamProviderSocket ( aSocket ) , aResponseHandler , aMsg ) ; } catch ( final Exception ex ) { final NetException ne = new NetException ( aSocket . getInetAddress ( ) , aSocket . getPort ( ) , ex ) ; ne . terminate ( ) ; } aSW . stop ( ) ; if ( aMsgData ! = null ) {
private void unregisterMediaButtonEvent ( ) { if ( unregisterMediaButtonEventReceiver = = null ) return ; try { unregisterMediaButtonEventReceiver . invoke ( audioManager , remoteControlResponder ) ;
public void run ( ) { s . nar . start ( 4 ) ; s . cells . click ( " " , " " , " opened " ) ; }
public void sendHttpResponse ( @Nonnegative final int nHttpResponseCode , @Nonnull final InternetHeaders aHeaders , @Nonnull @WillNotClose final IWriteToStream aData ) throws IOException { ValueEnforcer . isGT0 ( nHttpResponseCode , " HttpResponseCode " ) ; ValueEnforcer . notNull ( aHeaders , " Headers " ) ; ValueEnforcer . notNull ( aData , " Data " ) ; try ( final OutputStream aOS = createOutputStream ( ) ) {
public void testLastUpdated ( ) { Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( SystemTimeUpsertPlanner . LAST_UPDATED_FIELD_NAME_CONFIG_NAME , " lastupdated " ) ; Config config = ConfigFactory . parseMap ( configMap ) ; RandomWritePlanner planner = new SystemTimeUpsertPlanner ( config ) ; StructType schema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " key " , DataTypes . StringType , false ) ) ) ; Row row = new RowWithSchema ( schema , " a " ) ; List < PlannedRow > planned = planner . planMutationsForRow ( row ) ; assertEquals ( planned . size ( ) , 1 ) ; assertEquals ( planned . get ( 0 ) . getRow ( ) . length ( ) , 2 ) ; }
public boolean includeConcept ( final Concept c ) { final Term t = c . term ; if ( include . contains ( t ) ) return true ; return false ; }
public void updateTrackInfo ( MPDStatus status ) { new updateTrackInfoAsync ( ) . execute ( status ) ; }
@Override public void init ( ) { } @Override public void run ( boolean warmup ) { DefaultBag < Item > b = new DefaultBag < Item > ( levels , capacity , forgetRate ) { @Override protected Deque < Item > newLevel ( ) { if ( arraylist ) return super . newLevel ( ) ; return new LinkedList < Item > ( ) ; } } ; randomBagIO ( b , randomAccesses , insertRatio ) ; if ( ! warmup ) { totalPriority + = b . getAveragePriority ( ) ; totalMass + = b . getMass ( ) ; totalMinItemsPerLevel + = b . getMinItemsPerLevel ( ) ; totalMaxItemsPerLevel + = b . getMaxItemsPerLevel ( ) ; } } } . printCSV ( true ) ; System . out . print ( ( totalMaxItemsPerLevel / p . repeats ) + " , " ) ; System . out . print ( totalPriority / p . repeats + " , " ) ; System . out . print ( totalMass / repeats / levels + " , " ) ; System . out . println ( ) ; } public static int itemID = 0 ; public static class NullItem extends Item { public NullItem ( ) { this ( ( float ) Math . random ( ) ) ; } public NullItem ( float priority ) { super ( " " + ( itemID + + ) , new BudgetValue ( ) ) ; setPriority ( priority ) ; } } public static void randomBagIO ( AbstractBag < NullItem > b , int accesses , double insertProportion ) { for ( int i = 0 ; i < accesses ; i + + ) { if ( Math . random ( ) > insertProportion ) { b . takeOut ( ) ; } else { b . putIn ( new NullItem ( ) ) ; } } } public static void iterate ( AbstractBag < NullItem > b ) { Iterator < NullItem > i = b . iterator ( ) ; int count = 0 ; while ( i . hasNext ( ) ) { i . next ( ) ; count + + ; } if ( count ! = b . size ( ) ) { System . err . println ( " Error itrating  " + b ) ; } } public interface BagBuilder < E extends Item > { public AbstractBag < E > newBag ( ) ; } public static double compare ( String label , BagBuilder b , final int iterations , final int randomAccesses , final float insertRatio , int repeats , int warmups ) { Performance p = new Performance ( label , repeats , warmups ) { @Override public void init ( ) { } @Override public void run ( boolean warmup ) { AbstractBag bag = b . newBag ( ) ; randomBagIO ( bag , randomAccesses , insertRatio ) ; for ( int i = 0 ; i < iterations ; i + + ) iterate ( bag ) ; if ( ! warmup ) { } } } ; return p . getCycleTimeMS ( ) ; } public BagPerf ( ) { for ( int capacity = 8 ; capacity < 40000 ; capacity * = capacity ) { randomAccesses = capacity * 64 ; for ( int i = 5 ; i < 200 ; i + = 5 ) { testBag ( false , i , capacity , forgetRate ) ; testBag ( true , i , capacity , forgetRate ) ; } } } public static void main ( String [ ] args ) { int capacityPerLevel = 10 ; int repeats = 4 ; int warmups = 1 ; double totalDiff = 0 ; final int iterations = 10 ; for ( float insertRatio = 0.1f ; insertRatio < = 1.0f ; insertRatio + = 0.1f ) { for ( int levels = 10 ; levels < = 150 ; levels + = 20 ) { int randomAccesses = 512 * levels ; final int capacity = levels * capacityPerLevel ; final int _levels = levels ; double a = 0 , b = 0 ; a = compare ( " ArrayDeque " , new BagBuilder ( ) { @Override public AbstractBag newBag ( ) { return new DefaultBag < Item > ( _levels , capacity , forgetRate ) { @Override protected Deque < Item > newLevel ( ) { return new ArrayDeque < > ( 1 + capacity / _levels ) ; } } ; } } , iterations , randomAccesses , insertRatio , repeats , warmups ) ; b = compare ( " LinkedList " , new BagBuilder ( ) { @Override public AbstractBag newBag ( ) { return new DefaultBag < Item > ( _levels , capacity , forgetRate ) { @Override protected Deque < Item > newLevel ( ) { return new LinkedList < > ( ) ; } } ; } } , iterations , randomAccesses , insertRatio , repeats , warmups ) ; System . out . print ( insertRatio + " ,  " + levels + " ,  " + capacity + " ,  " ) ; System . out . println ( ( a - b ) / ( ( a + b ) / 2.0 ) ) ; totalDiff + = ( a - b ) ; } } if ( totalDiff > 0 ) System . out . print ( " B faster:  " ) ; else System . out . print ( " A faster:  " ) ; System . out . println ( " total difference (ms):  " + totalDiff ) ; } }
public void setMessageID ( final String sMessageID ) { setHeader ( " Message-ID " , sMessageID ) ; }
public void testNoLengthMessageRegular ( ) throws Exception { final IAS2HttpResponseHandler mockedResponseHandler = MOCK_RH ; final NonBlockingByteArrayInputStream is = new NonBlockingByteArrayInputStream ( m_sNoLengthMessage . getBytes ( StandardCharsets . UTF_8 ) ) ; final AS2Message aMsg = new AS2Message ( ) ; final IAS2InputStreamProvider mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; HTTPHelper . readHttpRequest ( mockStreamProvider , mockedResponseHandler , aMsg ) ; }
private void readObject ( final ObjectInputStream aOIS ) throws IOException , ClassNotFoundException { baseReadObject ( aOIS ) ; try { if ( aOIS . read ( ) = = 1 ) m_aData = new MimeBodyPart ( aOIS ) ; } catch ( final MessagingException ex ) { throw new IOException ( " Messaging exception " , ex ) ; } m_aMDN = ( IMessageMDN ) aOIS . readObject ( ) ; if ( m_aMDN ! = null ) m_aMDN . setMessage ( this ) ; m_aHistory = ( DataHistory ) aOIS . readObject ( ) ; }
public void updatePartnership ( final IMessageMDN aMdn , final boolean bOverwrite ) throws AS2Exception { final Partnership aPartnership = getPartnership ( aMdn . partnership ( ) ) ; aMdn . partnership ( ) . copyFrom ( aPartnership ) ; }
public void call ( JavaRDD < ? > raw ) throws Exception { StepUtils . resetRepeatingSteps ( steps ) ; runBatch ( independentNonStreamingSteps ) ; streamingStep . setData ( streamingStep . translate ( raw ) ) ; streamingStep . setState ( StepState . FINISHED ) ; Set < Step > batchSteps = StepUtils . mergeLoadedSteps ( steps , streamingStep , baseConfig ) ; Set < Step > dependentSteps = StepUtils . getAllDependentSteps ( streamingStep , batchSteps ) ; batchSteps . add ( streamingStep ) ; batchSteps . addAll ( streamingStep . loadNewBatchSteps ( ) ) ; batchSteps . addAll ( independentNonStreamingSteps ) ; runBatch ( batchSteps ) ; StepUtils . resetSteps ( dependentSteps ) ; streamingStep . recordProgress ( raw ) ; }
boolean isTimedOut ( ) ; void cancel ( ) ; void timeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }
public static void main ( String [ ] args ) { int repeats = 2 ; int warmups = 1 ; int maxConcepts = 2000 ; int extraCycles = 2048 ; int randomExtraCycles = 512 ; Parameters . THREADS = 1 ; NAR n = new CurveBagNARBuilder ( ) . setConceptBagSize ( maxConcepts ) . build ( ) ; Collection c = NALTest . params ( ) ; while ( true ) { for ( Object o : c ) {
public void doublePremiseTask ( Term newContent , TruthValue newTruth , BudgetValue newBudget ) { if ( newContent ! = null ) { Sentence newSentence = new Sentence ( newContent , currentTask . getSentence ( ) . getPunctuation ( ) , newTruth , newStamp ) ;
public String getAsString ( ) { final StringBuilder aSB = new StringBuilder ( ) ; aSB . append ( " MDN From: " ) . append ( partnership ( ) . getAllSenderIDs ( ) . toString ( ) ) . append ( CHttp . EOL ) . append ( " To: " ) . append ( partnership ( ) . getAllReceiverIDs ( ) . toString ( ) ) . append ( CHttp . EOL ) . append ( " Headers: " ) . append ( headers ( ) . toString ( ) ) . append ( CHttp . EOL ) . append ( " Attributes: " ) . append ( attrs ( ) . toString ( ) ) . append ( CHttp . EOL ) . append ( " Text: " ) . append ( CHttp . EOL ) . append ( getText ( ) ) . append ( CHttp . EOL ) ; return aSB . toString ( ) ; }
public void onDestroy ( ) { mApp . oMPDAsyncHelper . removeAsyncExecListener ( this ) ; super . onDestroy ( ) ; }
public String toString ( ) { String retVal = new String ( ) ; retVal + = when + " \ n " ; for ( int s = 0 ; s < 2 ; s + + ) { for ( int v = 0 ; v < targets [ s ] . length ; v + + ) { if ( v ! = 0 ) retVal + = " , " ; retVal + = " " + targets [ s ] [ v ] ; } retVal + = " \ n " ; } return retVal ; }
static public boolean useAlbumArtist ( ) { return useAlbumArtist ; }
private static String _getTransferRate ( final long nBytesPerSecond ) { final StringBuilder aSB = new StringBuilder ( ) ; if ( nBytesPerSecond < CGlobal . BYTES_PER_KILOBYTE ) { aSB . append ( nBytesPerSecond ) . append ( "  Bps " ) ; } else { final long nKBytesPerSecond = nBytesPerSecond / CGlobal . BYTES_PER_KILOBYTE ; if ( nKBytesPerSecond < CGlobal . BYTES_PER_KILOBYTE ) { aSB . append ( nKBytesPerSecond ) . append ( '.' ) . append ( nBytesPerSecond % CGlobal . BYTES_PER_KILOBYTE ) . append ( "  KBps " ) ; } else { aSB . append ( nKBytesPerSecond / CGlobal . BYTES_PER_KILOBYTE ) . append ( '.' ) . append ( nKBytesPerSecond % CGlobal . BYTES_PER_KILOBYTE ) . append ( "  MBps " ) ; } } return aSB . toString ( ) ; }
public void testAppendWithoutCAS ( ) throws Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . append ( key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " testes " , client . get ( key ) ) ; }
public void close ( ) { } @Override public InputStream getContent ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } public long getContentLength ( ) { return - 1L ; } public boolean isStreaming ( ) { return true ; } @Override public void writeTo ( @Nonnull final OutputStream aOS ) throws IOException { try ( final OutputStream aDebugOS = aOutgoingDumper ! = null ? aOutgoingDumper . getDumpOS ( aOS ) : aOS ; final OutputStream aEncodedOS = eCTE ! = null ? AS2IOHelper . getContentTransferEncodingAwareOutputStream ( aDebugOS , eCTE . getID ( ) ) : aDebugOS ) { StreamHelper . copyByteStream ( ) . from ( aISToSend ) . closeFrom ( true ) . to ( aEncodedOS ) . closeTo ( false ) . build ( ) ; } catch ( final MessagingException ex ) { throw new IllegalStateException ( " Failed to encode OutputStream with CTE ' " + eCTE + " ' " , ex ) ; } } } ; final HttpEntity aEntity = aResHelper . createRepeatableHttpEntity ( aISE ) ; m_aRequestBuilder . setEntity ( aEntity ) ; final ClassicHttpRequest aHttpUriRequest = m_aRequestBuilder . build ( ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Performing HttpRequest to ' " + aHttpUriRequest . getRequestUri ( ) + " ' " ) ; m_aCloseableHttpResponse = m_aCloseableHttpClient . execute ( aHttpUriRequest ) ; return aCIS . getBytesRead ( ) ; } public InputStream getInputStream ( ) throws AS2Exception , IOException { if ( m_aCloseableHttpResponse = = null ) throw new AS2Exception ( " No response as message was yet sent " ) ; return m_aCloseableHttpResponse . getEntity ( ) . getContent ( ) ; } public int getResponseCode ( ) throws AS2Exception { if ( m_aCloseableHttpResponse = = null ) throw new AS2Exception ( " No response as message was yet sent " ) ; return m_aCloseableHttpResponse . getCode ( ) ; } public String getResponseMessage ( ) throws AS2Exception { if ( m_aCloseableHttpResponse = = null ) throw new AS2Exception ( " No response as message was yet sent " ) ; return m_aCloseableHttpResponse . getReasonPhrase ( ) ; } @Nonnull @ReturnsMutableCopy public HttpHeaderMap getResponseHeaderFields ( ) throws AS2Exception { if ( m_aCloseableHttpResponse = = null ) throw new AS2Exception ( " No response as message was yet sent " ) ; final HttpHeaderMap ret = new HttpHeaderMap ( ) ; final Header [ ] aHeaders = m_aCloseableHttpResponse . getHeaders ( ) ; if ( aHeaders ! = null ) for ( final Header aHeader : aHeaders ) ret . addHeader ( aHeader . getName ( ) , aHeader . getValue ( ) ) ; return ret ; } public void disconnect ( ) { try { if ( m_aCloseableHttpResponse ! = null ) m_aCloseableHttpResponse . close ( ) ; if ( m_aCloseableHttpClient ! = null ) m_aCloseableHttpClient . close ( ) ; } catch ( final Exception ex ) { if ( LOGGER . isErrorEnabled ( ) ) LOGGER . error ( " Exception while closing HttpClient connection:  " + this . toString ( ) , ex ) ; } } private static void _setProxyToRequestConfig ( @Nonnull final RequestConfig . Builder aConfBuilder , @Nullable final Proxy aProxy ) { try { if ( aProxy ! = null ) { final SocketAddress aSocketAddress = aProxy . address ( ) ; if ( aSocketAddress instanceof InetSocketAddress ) { final InetSocketAddress aISocketAdress = ( InetSocketAddress ) aSocketAddress ; final InetAddress aInetAddr = aISocketAdress . getAddress ( ) ; if ( aInetAddr ! = null ) { final HttpHost aHost = new HttpHost ( aInetAddr , aISocketAdress . getPort ( ) ) ; aConfBuilder . setProxy ( aHost ) ; } else { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " No address in proxy: " + aProxy . address ( ) + " - " + ( null ! = aProxy . type ( ) ? aProxy . type ( ) . name ( ) : " null " ) ) ; } } } } catch ( final RuntimeException ex ) { if ( LOGGER . isErrorEnabled ( ) ) LOGGER . error ( " Exception while setting proxy. Continue without proxy. aProxy: " + aProxy . address ( ) + " - " + ( null ! = aProxy . type ( ) ? aProxy . type ( ) . name ( ) : " null " ) , ex ) ; } } public static boolean isErrorResponseCode ( final int nResponseCode ) { return nResponseCode ! = CHttp . HTTP_OK & & nResponseCode ! = CHttp . HTTP_CREATED & & nResponseCode ! = CHttp . HTTP_ACCEPTED & & nResponseCode ! = CHttp . HTTP_NO_CONTENT & & nResponseCode ! = CHttp . HTTP_PARTIAL_CONTENT ; } }
private String resolveDelimiter ( String delimiterArg ) { if ( delimiterArg . startsWith ( " chars: " ) ) { String [ ] codePoints = delimiterArg . substring ( " chars: " . length ( ) ) . split ( " , " ) ;
public ProcessingItem connectInputShuffleStream ( Stream inputStream ) ; public ProcessingItem connectInputKeyStream ( Stream inputStream ) ; public ProcessingItem connectInputAllStream ( Stream inputStream ) ; public int getParallelism ( ) ; }
protected void intialDesire ( ) { nar . addInput ( " move(left)! :|: %1.00;0.65% " ) ; nar . addInput ( " move(right)! :|: %1.00;0.65% " ) ; }
@Override protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { { mario . keys [ Mario . KEY_LEFT ] = false ; mario . keys [ Mario . KEY_RIGHT ] = false ; mario . keys [ Mario . KEY_JUMP ] = false ; } return super . execute ( operation , args , memory ) ; }
public void init ( String [ ] args ) { if ( args . length > 0 & & CommandLineNARBuilder . isReallyFile ( args [ 0 ] ) ) { try { new TextInput ( nar , new File ( args [ 0 ] ) ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } CommandLineNARBuilder . decode ( args , nar ) ; }
public void trainOnInstance ( E example ) ; public double [ ] getVotesForInstance ( E example ) ; public Measurement [ ] getModelMeasurements ( ) ; public Learner [ ] getSublearners ( ) ; public MOAObject getModel ( ) ; public void setModelContext ( InstancesHeader ih ) ; public InstancesHeader getModelContext ( ) ; }
FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetlOperation getl ( String key , int exp , GetlOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; KeyedOperation touch ( String key , int expiration , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
public Object visit ( StmInPp p , LoanParser arg ) { Term t1 = ( Term ) p . term_1 . accept ( this , arg ) ; Term t2 = ( Term ) p . term_2 . accept ( this , arg ) ; return Statement . make ( Symbols . INSTANCE_PROPERTY_RELATION , t1 , t2 , memory ) ; }
private void logError ( final CommandResult result , final String baseCommand , final int retryCount ) { final StringBuilder stringBuilder = new StringBuilder ( 50 ) ; stringBuilder . append ( " Command  " ) ; stringBuilder . append ( baseCommand ) ; stringBuilder . append ( "  failed after  " ) ; stringBuilder . append ( retryCount + 1 ) ; if ( retryCount = = 0 ) { stringBuilder . append ( "  attempt. " ) ; } else { stringBuilder . append ( "  attempts. " ) ; } if ( result . isMPDException ( ) ) { Log . error ( mTag , stringBuilder . toString ( ) , result . getLastException ( ) ) ;
public void applyBulkMutations ( List < Tuple2 < MutationType , DataFrame > > planned ) throws Exception { KuduContext kc = new KuduContext ( config . getString ( CONNECTION_CONFIG_NAME ) ) ; for ( Tuple2 < MutationType , DataFrame > plan : planned ) { MutationType mutationType = plan . _1 ( ) ;
public void test_set_classpath ( ) throws PrologException , IOException { setPath ( true ) ; theory = " demo(Size) :- set_classpath([ " + paths + " ]),  \ n  " + " java_object('Counter', [], MyCounter),  \ n " + " java_object('Counter[]', [10], ArrayCounters),  \ n " + " java_array_length(ArrayCounters, Size). " ; engine . setTheory ( new Theory ( theory ) ) ; info = engine . solve ( " demo(Value). " ) ; assertEquals ( true , info . isSuccess ( ) ) ; nars . prolog . Number resultInt = ( nars . prolog . Number ) info . getVarValue ( " Value " ) ; assertEquals ( 10 , resultInt . intValue ( ) ) ; }
public void doStop ( ) throws AS2Exception { if ( m_aTimer ! = null ) {
public void putAll ( Map < ? extends K , ? extends V > map ) { int mapSize = map . size ( ) ; if ( size = = 0 & & mapSize ! = 0 & & map instanceof SortedMap ) { Comparator c = ( ( SortedMap ) map ) . comparator ( ) ; if ( c = = comparator | | ( c ! = null & & c . equals ( comparator ) ) ) { + + modCount ; try { buildFromSorted ( mapSize , map . entrySet ( ) . iterator ( ) , null , null ) ; } catch ( java . io . IOException cannotHappen ) { } catch ( ClassNotFoundException cannotHappen ) { } return ; } } super . putAll ( map ) ; }
R visit ( ImplicationAfter p , A arg ) ; R visit ( ImplicationBefore p , A arg ) ; R visit ( Inheritance p , A arg ) ; R visit ( Instance p , A arg ) ; R visit ( InstanceProperty p , A arg ) ; R visit ( IntersectionExt p , A arg ) ; R visit ( IntersectionInt p , A arg ) ; R visit ( Negation p , A arg ) ; R visit ( NumericLiteral p , A arg ) ; R visit ( Product p , A arg ) ; R visit ( Property p , A arg ) ; R visit ( SetExt p , A arg ) ; R visit ( SetInt p , A arg ) ; R visit ( Similarity p , A arg ) ; R visit ( TenseFuture p , A arg ) ; R visit ( TensePast p , A arg ) ; R visit ( TensePresent p , A arg ) ; R visit ( StringLiteral p , A arg ) ; R visit ( URIRef p , A arg ) ; R visit ( Variable p , A arg ) ; R visit ( Term p , A arg ) ; }
public boolean hasVisibleItems ( ) { return mNativeMenu . hasVisibleItems ( ) ; }
int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; }
public void particleGroupDestroyed ( ParticleGroup group ) { super . particleGroupDestroyed ( group ) ; if ( group = = m_lastGroup ) { m_lastGroup = null ;
public static ArrayList formulasToArrayLists ( List formulaList ) { ArrayList ans = new ArrayList ( ) ; try { if ( formulaList instanceof List ) { Iterator it = formulaList . iterator ( ) ; Formula f = null ; while ( it . hasNext ( ) ) { f = ( Formula ) it . next ( ) ; ans . add ( f . literalToArrayList ( ) ) ; } } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return ans ; }
public Rope padEnd ( final int toWidth ) { return padEnd ( toWidth , ' ' ) ; }
public void feedRelation2 ( Reasoner consumer , long objectId , long placeId , String relation , boolean isQuestion ) { String taskType = isQuestion ? " ? " : " . " ; consumer . addInput ( String . format ( " <(*, %d, %d)--> %s>%s :|: " , objectId , placeId , relation , taskType ) ) ; consumer . addInput ( String . format ( " <(*, {%d}, %d)--> %s>%s :|: " , objectId , placeId , relation , taskType ) ) ; consumer . addInput ( String . format ( " <(*, {%d}, {%d})--> %s>%s :|: " , objectId , placeId , relation , taskType ) ) ; consumer . addInput ( String . format ( " <(*, %d, {%d})--> %s>%s :|: " , objectId , placeId , relation , taskType ) ) ; consumer . addInput ( String . format ( " <(*, {%d, %d}, {%d})--> %s>%s :|: " , objectId , objectId + 500000 , placeId , relation , taskType ) ) ; consumer . addInput ( String . format ( " <(*, {%d, %d}, {%d})--> %s>%s :|: " , objectId , objectId , placeId , relation , taskType ) ) ; consumer . addInput ( String . format ( " <%d --> (/, %s, _, %d)>%s :|: " , placeId , relation , objectId , taskType ) ) ; consumer . addInput ( String . format ( " <%d --> (/, %s, %d, _)>%s :|: " , objectId , relation , placeId , taskType ) ) ; consumer . addInput ( String . format ( " <{%d} --> (/, %s, _, %d)>%s :|: " , placeId , relation , objectId , taskType ) ) ; consumer . addInput ( String . format ( " <%d --> (/, %s, {%d}, _)>%s :|: " , objectId , relation , placeId , taskType ) ) ; consumer . addInput ( String . format ( " <{%d} --> (/, %s, _, {%d})>%s :|: " , placeId , relation , objectId , taskType ) ) ; consumer . addInput ( String . format ( " <{%d} --> (/, %s, {%d}, _)>%s :|: " , objectId , relation , placeId , taskType ) ) ; consumer . addInput ( String . format ( " <{%d} --> (/, %s, _, {%d})>%s :|: " , placeId , relation , objectId , taskType ) ) ; consumer . addInput ( String . format ( " <{%d} --> (/, %s, {%d}, _)>%s :|: " , objectId , relation , placeId , taskType ) ) ; }
protected static CoverAsyncHelper getCoverHelper ( final AlbumCoverHolder holder , final int defaultSize ) { final CoverAsyncHelper coverHelper = new CoverAsyncHelper ( ) ; final int height = holder . mAlbumCover . getHeight ( ) ; if ( height = = 0 ) { coverHelper . setCoverMaxSize ( defaultSize ) ; } else { coverHelper . setCoverMaxSize ( height ) ; } loadPlaceholder ( coverHelper ) ; return coverHelper ; }
public void testStats ( ) { ( new StatsOperationImpl ( " dispatcher " , null ) ) . toString ( ) ; }
private static final < T extends KdTree . XYZPoint > void searchNode ( T value , KdNode node , int K , TreeSet < KdNode > results , Set < KdNode > examined ) { examined . add ( node ) ; KdNode lastNode = null ; Double lastDistance = Double . MAX_VALUE ; if ( results . size ( ) > 0 ) { lastNode = results . last ( ) ; lastDistance = lastNode . id . euclideanDistance ( value ) ; } Double nodeDistance = node . id . euclideanDistance ( value ) ; if ( nodeDistance . compareTo ( lastDistance ) < 0 ) { if ( results . size ( ) = = K & & lastNode ! = null ) results . remove ( lastNode ) ; results . add ( node ) ; } else if ( nodeDistance . equals ( lastDistance ) ) { results . add ( node ) ; } else if ( results . size ( ) < K ) { results . add ( node ) ; } lastNode = results . last ( ) ; lastDistance = lastNode . id . euclideanDistance ( value ) ; if ( node . lesser ! = null & & ! examined . contains ( node . lesser ) ) { KdNode lesser = node . lesser ; examined . add ( lesser ) ; int axis = lesser . depth % lesser . k ; boolean lineIntersectsRect = false ; Line line = null ; Rectangle rect = null ; if ( axis = = X_AXIS ) { line = new Line ( new Point ( value . x - lastDistance , value . y ) , new Point ( value . x + lastDistance , value . y ) ) ; Point ul = new Point ( Double . MIN_VALUE , Double . MIN_VALUE ) ; Point ur = new Point ( Double . MAX_VALUE , Double . MIN_VALUE ) ; Point lr = new Point ( Double . MAX_VALUE , node . id . y ) ; Point ll = new Point ( Double . MIN_VALUE , node . id . y ) ; rect = new Rectangle ( ul , ur , lr , ll ) ; lineIntersectsRect = rect . inserects ( line ) ; } else { line = new Line ( new Point ( value . x , value . y - lastDistance ) , new Point ( value . x , value . y + lastDistance ) ) ; Point ul = new Point ( Double . MIN_VALUE , Double . MIN_VALUE ) ; Point ur = new Point ( node . id . x , Double . MIN_VALUE ) ; Point lr = new Point ( node . id . x , Double . MAX_VALUE ) ; Point ll = new Point ( Double . MIN_VALUE , Double . MAX_VALUE ) ; rect = new Rectangle ( ul , ur , lr , ll ) ; lineIntersectsRect = rect . inserects ( line ) ; } if ( lineIntersectsRect ) { searchNode ( value , lesser , K , results , examined ) ; } } if ( node . greater ! = null & & ! examined . contains ( node . greater ) ) { KdNode greater = node . greater ;
public void actionPerformed ( ActionEvent e ) { SentenceTablePanel p = new SentenceTablePanel ( nar ) ; NWindow w = new NWindow ( " Sentence Table " , p ) ; w . setSize ( 500 , 300 ) ; w . setVisible ( true ) ; }
public static void main ( String args [ ] ) { NALNetwork nalnet = new NALNetwork ( ) ; nalnet . demoNALNet ( ) ; }
public ConfigWriter < Config > createWriter ( ) { throw new UnsupportedOperationException ( " In memory configurations aren't mean to be written. " ) ;
public Iterator < T > iterator ( ) { return ( new RedBlackTreeIterator < T > ( ( RedBlackTree < T > ) this . tree ) ) ; }
public < O > O toObject ( UnmodifiableConfig config , Supplier < O > destinationSupplier ) { O destination = destinationSupplier . get ( ) ; toObject ( config , destination ) ; return destination ; }
public static String verbPlural ( String verb ) { String word = verb ; String remainder = " " ; if ( verb . indexOf ( " _ " ) > 0 ) { word = verb . substring ( 0 , verb . indexOf ( " _ " ) ) ; remainder = verb . substring ( verb . indexOf ( " _ " ) , verb . length ( ) ) ; } if ( word . matches ( " .*y$ " ) & & ! isVowel ( word . charAt ( word . length ( ) - 2 ) ) ) word = WordNetUtilities . subst ( word , " y$ " , " ies " ) ; else { if ( word . matches ( " .*s$ " ) | | word . matches ( " .*x$ " ) | | word . matches ( " .*ch$ " ) | | word . matches ( " .*sh$ " ) | | word . matches ( " .*z$ " ) | | word . equals ( " go " ) ) word = word + " es " ; else if ( word . equals ( " be " ) ) word = " are " ; else word = word + " s " ; } return word + remainder ; }
public boolean push ( T value ) ; public T pop ( ) ; public T peek ( ) ; public T get ( int index ) ; public boolean contains ( T value ) ; public boolean remove ( T value ) ; public int size ( ) ; public boolean validate ( ) ; public java . util . Queue < T > asQueue ( ) ; public java . util . Collection < T > toCollection ( ) ; }
private void writeObject ( @Nonnull final ObjectOutputStream aOOS ) throws IOException { baseWriteObject ( aOOS ) ; final NonBlockingByteArrayOutputStream aBAOS = new NonBlockingByteArrayOutputStream ( ) ; try { if ( m_aData ! = null ) { aBAOS . write ( 1 ) ; m_aData . writeTo ( aBAOS ) ; } else { aBAOS . write ( 0 ) ; } } catch ( final MessagingException ex ) { throw new IOException ( " Messaging exception:  " + ex . getMessage ( ) ) ; } aOOS . write ( aBAOS . toByteArray ( ) ) ; aBAOS . close ( ) ; aOOS . writeObject ( m_aMDN ) ; aOOS . writeObject ( m_aHistory ) ; }
public void testAdd ( ) throws IOException { Path file = tmp . resolve ( " syncFileConfig.txt " ) ; Util . testLoadAdd ( newConfig ( file , ParsingMode . ADD , true ) ) ; Util . testLoadAdd ( newConfig ( file , ParsingMode . ADD , false ) ) ; }
public synchronized void output ( final Class channel , final Object o ) { if ( ( ! showErrors ) & & ( channel = = ERR . class ) ) return ; if ( ( outExp ! = null ) | | ( outExp2 ! = null ) ) { final String s = process ( channel , o ) ;
public List < String > listArtists ( final String genre ) throws IOException , MPDException { return listArtists ( genre , true ) ; }
private static final < N extends Number > List < List < N > > permute ( final N [ ] numbers , int currentElementIndex , List < List < N > > result ) { if ( currentElementIndex = = numbers . length - 1 ) return result ; for ( int i = currentElementIndex ; i < numbers . length ; + + i ) { N temp = numbers [ i ] ; numbers [ i ] = numbers [ currentElementIndex ] ; numbers [ currentElementIndex ] = temp ; permute ( numbers , currentElementIndex + 1 , result ) ; if ( i ! = currentElementIndex ) { LinkedList < N > nextPermutation = new LinkedList < N > ( ) ; for ( int j = 0 ; j < numbers . length ; j + + ) nextPermutation . add ( numbers [ j ] ) ; result . add ( nextPermutation ) ; } temp = numbers [ i ] ; numbers [ i ] = numbers [ currentElementIndex ] ; numbers [ currentElementIndex ] = temp ; } return result ; }
public List < ? extends DynamicNode > testParser ( ) throws IOException { var validTests = new ArrayList < DynamicTest > ( ) ; var invalidTests = new ArrayList < DynamicTest > ( ) ; for ( String testPath : Files . readAllLines ( TEST_LIST_1_0 ) ) { if ( testPath . startsWith ( " invalid/ " ) ) { var testFile = TOML_TEST_DIR . resolve ( testPath ) ; var testFileName = testFile . getFileName ( ) . toString ( ) ; var relativePath = TOML_TEST_DIR . relativize ( testFile ) ; if ( testFileName . endsWith ( " .toml " ) ) { invalidTests . add ( dynamicTest ( relativePath . toString ( ) , ( ) - > { TomlParser parser = new TomlParser ( ) ; assertThrows ( ParsingException . class , ( ) - > { parser . parse ( testFile , FileNotFoundAction . THROW_ERROR ) ; } , ( ) - > String . format ( " invalid file '%s' should have been rejected by the parser " , relativePath ) ) ; } ) ) ; } else if ( testFileName . endsWith ( " .multi " ) ) { invalidTests . add ( dynamicTest ( relativePath . toString ( ) , ( ) - > { TomlParser parser = new TomlParser ( ) ; for ( var line : Files . readAllLines ( testFile ) ) { if ( ! ( line . isBlank ( ) | | line . stripLeading ( ) . startsWith ( " # " ) ) ) { var key = line . substring ( 0 , line . indexOf ( '=' ) ) . strip ( ) ; var testName = relativePath + " ( " + key + " ) " ; System . out . println ( " testing  " + testName ) ; assertThrows ( ParsingException . class , ( ) - > { parser . parse ( line ) ; } , ( ) - > String . format ( " invalid test '%s' should have failed " , testName ) ) ; } } } ) ) ; } } else if ( testPath . startsWith ( " valid/ " ) ) { var testFile = TOML_TEST_DIR . resolve ( testPath ) ; var testFileName = testFile . getFileName ( ) . toString ( ) ; var relativePath = TOML_TEST_DIR . relativize ( testFile ) ; if ( testFileName . endsWith ( " .toml " ) ) { var expectFile = testFile . resolveSibling ( testFileName . replace ( " .toml " , " .json " ) ) ; validTests . add ( dynamicTest ( relativePath . toString ( ) , ( ) - > { TomlParser tomlParser = new TomlParser ( ) ; JsonParser jsonParser = new JsonParser ( ) ; try { CommentedConfig parsed = tomlParser . parse ( testFile , FileNotFoundAction . THROW_ERROR ) ; Config expected = jsonParser . parse ( expectFile , FileNotFoundAction . THROW_ERROR ) ; assertConfigMatchesJsonExpectation ( parsed , expected , relativePath . toString ( ) ) ; } catch ( Exception ex ) { fail ( " Exception occured in test  " + relativePath , ex ) ; } } ) ) ; } } } var allTests = Arrays . asList ( dynamicContainer ( " parser valid " , validTests ) , dynamicContainer ( " parser invalid " , invalidTests ) ) ; return allTests ; }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o instanceof com . googlecode . opennars . parser . loan . Loan . Absyn . StmProp ) { com . googlecode . opennars . parser . loan . Loan . Absyn . StmProp x = ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmProp ) o ; return this . term_1 . equals ( x . term_1 ) & & this . term_2 . equals ( x . term_2 ) ; } return false ; }
public void run ( ) { try { connMgr . execute ( ) ; } catch ( InterruptedIOException ex ) { getLogger ( ) . error ( " I/O reactor Interrupted " ) ; } catch ( IOException e ) { getLogger ( ) . error ( " I/O error:  " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } getLogger ( ) . info ( " Couchbase I/O reactor terminated " ) ; }
boolean containsAttribute ( @Nullable String sName ) ; @Nonnull @ReturnsMutableCopy ICommonsOrderedMap < String , String > getAllAttributes ( ) ; @Nullable String getAttributeAsString ( @Nullable String sName ) ; @Nullable String getAttributeAsString ( @Nullable String sName , @Nullable String sDefault ) ; int getAttributeAsInt ( @Nullable String sName ) ; int getAttributeAsInt ( @Nullable String sName , int nDefault ) ; long getAttributeAsLong ( @Nullable String sName ) ; long getAttributeAsLong ( @Nullable String sName , long nDefault ) ; double getAttributeAsDouble ( @Nullable String sName ) ; double getAttributeAsDouble ( @Nullable String sName , double dDefault ) ; boolean getAttributeAsBoolean ( @Nullable String sName ) ; boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; @Nonnull @ReturnsMutableCopy Enumeration < String > getAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy ICommonsOrderedSet < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy ICommonsList < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; }
public abstract Graph < V , E > getGraph ( ) ; abstract protected boolean hasUpdate ( ) ; public void updateGraph ( ) { if ( hasUpdate ( ) | | ( updateNext ) | | display . preUpdate ( this ) ) { updateNext = false ; { deadVertices . clear ( ) ; deadEdges . clear ( ) ; currentGraph = getGraph ( ) ; if ( currentGraph = = null ) { vertices . clear ( ) ; edges . clear ( ) ; return ; } deadVertices . addAll ( vertices . keySet ( ) ) ; deadEdges . addAll ( edges . keySet ( ) ) ; for ( final V v : currentGraph . vertexSet ( ) ) updateVertex ( v ) ; for ( final E e : currentGraph . edgeSet ( ) ) updateEdge ( e ) ; for ( final V v : deadVertices ) vertices . remove ( v ) ; for ( final E e : deadEdges ) edges . remove ( e ) ; } } } @Override public boolean draw ( PGraphics g ) { if ( currentGraph = = null ) { return true ; } { g . strokeCap ( SQUARE ) ; g . strokeJoin ( PROJECT ) ; int numEdges = currentGraph . edgeSet ( ) . size ( ) ; if ( numEdges < maxEdges ) { for ( final EdgeVis d : edges . values ( ) ) { d . draw ( this , g ) ; } } g . noStroke ( ) ; int numNodes = vertices . size ( ) ; if ( numNodes < maxNodes ) { for ( final VertexVis d : vertices . values ( ) ) { d . draw ( this , g ) ; } } } display . postUpdate ( this ) ; return true ; } public void resurrectVertex ( V v ) { deadVertices . remove ( v ) ; } void drawArrowAngle ( final PGraphics g , final float cx , final float cy , final float len , final float angle , float arrowHeadRadius ) { g . pushMatrix ( ) ; g . translate ( cx , cy ) ; g . rotate ( radians ( angle ) ) ; g . line ( 0 , 0 , len , 0 ) ; g . line ( len , 0 , len - arrowHeadRadius , - arrowHeadRadius / 2f ) ; g . line ( len , 0 , len - arrowHeadRadius , arrowHeadRadius / 2f ) ; g . popMatrix ( ) ; } void drawArrow ( final PGraphics g , final float x1 , final float y1 , final float x2 , final float y2 ) { float cx = ( x1 + x2 ) / 2f ; float cy = ( y1 + y2 ) / 2f ; float len = ( float ) Math . sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) ; float a = ( float ) ( Math . atan2 ( y2 - y1 , x2 - x1 ) * 180.0f / Math . PI ) ; drawArrowAngle ( g , x1 , y1 , len , a , len * arrowHeadScale ) ; } }
public void testInjectNextEventSuccess ( ) { entrancePi . setOutputStream ( outputStream ) ; new StrictExpectations ( ) { { entranceProcessor . hasNext ( ) ; result = true ; entranceProcessor . nextEvent ( ) ; result = event ; } } ; entrancePi . injectNextEvent ( ) ; new Verifications ( ) { {
public static void main ( String [ ] args ) { if ( args . length ! = 1 ) System . out . println ( " Pass exactly one prolog term! " ) ;
public void test_catch_3_5 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String theory = " p(0). p(1) :- throw(error). p(2). " ; engine . setTheory ( new Theory ( theory ) ) ; String goal = " catch(p(X), E, E == error). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; assertTrue ( info . hasOpenAlternatives ( ) ) ; info = engine . solveNext ( ) ; assertTrue ( info . isSuccess ( ) ) ; assertFalse ( info . hasOpenAlternatives ( ) ) ; }
static DataType convertType ( Descriptors . FieldDescriptor field ) { Descriptors . FieldDescriptor . JavaType type = field . getJavaType ( ) ; DataType dataType ; switch ( type ) { case BOOLEAN : dataType = DataTypes . BooleanType ; break ; case BYTE_STRING : dataType = DataTypes . BinaryType ; break ; case DOUBLE : dataType = DataTypes . DoubleType ; break ; case ENUM : dataType = DataTypes . StringType ; break ; case FLOAT : dataType = DataTypes . FloatType ; break ; case INT : dataType = DataTypes . IntegerType ; break ; case LONG : dataType = DataTypes . LongType ; break ; case MESSAGE : Descriptors . Descriptor msg = field . getMessageType ( ) ; if ( field . isMapField ( ) ) { dataType = DataTypes . createMapType ( convertType ( msg . findFieldByName ( KEY_TYPE ) ) , convertType ( msg . findFieldByName ( VALUE_TYPE ) ) , true ) ; } else { dataType = buildSchema ( field . getMessageType ( ) ) ; } break ; case STRING : dataType = DataTypes . StringType ; break ; default : throw new RuntimeException ( " Unknown type:  " + type . toString ( ) + "  for FieldDescriptor:  " + field . toString ( ) ) ; } if ( field . isRepeated ( ) & & ! field . isMapField ( ) ) { dataType = DataTypes . createArrayType ( dataType , true ) ; } LOG . trace ( " FieldDescriptor[{}] => {} " , field . getFullName ( ) , dataType ) ; return dataType ; }
public boolean onMenuItemClick ( final MenuItem item ) { final int groupId = item . getGroupId ( ) ; boolean result = true ; if ( groupId = = POPUP_COVER_BLACKLIST ) { final AlbumInfo albumInfo = new AlbumInfo ( mAlbum ) ; CoverManager . getInstance ( ) . markWrongCover ( albumInfo ) ; updateCover ( albumInfo ) ; updateNowPlayingSmallFragment ( albumInfo ) ; } else if ( groupId = = POPUP_COVER_SELECTIVE_CLEAN ) { final AlbumInfo albumInfo = new AlbumInfo ( mAlbum ) ; CoverManager . getInstance ( ) . clear ( albumInfo ) ; updateCover ( albumInfo ) ; updateNowPlayingSmallFragment ( albumInfo ) ; } else { result = false ; } return result ; }
public void removeNetworkMonitorListener ( final NetworkMonitorListener listener ) { mNetworkMonitorListeners . remove ( listener ) ; }
public void testSet ( ) { StructField field1 = DataTypes . createStructField ( " field1 " , DataTypes . StringType , true ) ; StructField field2 = DataTypes . createStructField ( " field2 " , DataTypes . IntegerType , true ) ; StructField field3 = DataTypes . createStructField ( " field3 " , DataTypes . FloatType , true ) ; StructType schema = DataTypes . createStructType ( Lists . newArrayList ( field1 , field2 , field3 ) ) ; Row row = new RowWithSchema ( schema , " hello " , 1 , 2.0 ) ; Row setRow = RowUtils . set ( row , " field2 " , 100 ) ; setRow = RowUtils . set ( setRow , " field1 " , " world " ) ; assertEquals ( setRow . length ( ) , 3 ) ; assertEquals ( setRow . getAs ( " field1 " ) , " world " ) ; assertEquals ( setRow . getAs ( " field2 " ) , 100 ) ; assertEquals ( setRow . getAs ( " field3 " ) , 2.0 ) ; }
abstract public boolean allow ( Sentence s ) ; abstract public boolean allow ( Statement st ) ; public void remove ( final Sentence s ) { removeEdge ( s ) ; } public void add ( final Sentence s ) { boolean include = false ; if ( s . content instanceof CompoundTerm ) { CompoundTerm cs = ( CompoundTerm ) s . content ; if ( cs instanceof Statement ) { Statement st = ( Statement ) cs ; if ( allow ( st ) ) { Term subject = st . getSubject ( ) ; Term predicate = st . getPredicate ( ) ; addVertex ( subject ) ; addVertex ( predicate ) ; addEdge ( subject , predicate , s ) ; } } } } }
public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { } @Override public void repeatChanged ( boolean repeating ) { } @Override public void randomChanged ( boolean random ) { } @Override public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } }
public Term visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmExSet p , A arg ) { ListTerm listterm_ = new ListTerm ( ) ; for ( Term x : p . listterm_ ) { listterm_ . add ( x . accept ( this , arg ) ) ; } return new com . googlecode . opennars . parser . loan . Loan . Absyn . TrmExSet ( listterm_ ) ; }
private void updateVertices ( final AbstractGraphVis c ) { elem1 = c . getVertexDisplay ( c . currentGraph . getEdgeSource ( edge ) ) ; elem2 = c . getVertexDisplay ( c . currentGraph . getEdgeTarget ( edge ) ) ; if ( ( elem1 = = null ) | | ( elem2 = = null ) | | ( elem1 = = elem2 ) ) { throw new RuntimeException ( this + "  has missing vertices " ) ;
private synchronized void sendShuffle ( MessageCollector collector , ContentEvent event ) { collector . send ( new OutgoingMessageEnvelope ( this . actualSystemStream , event ) ) ; }
public void observeAttributeClass ( double attVal , int classVal , double weight ) { if ( ! Utils . isMissingValue ( attVal ) ) { GaussianEstimator valDist = this . attValDistPerClass . get ( classVal ) ;
protected void initCertificateFactory ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2Session aSession ) throws AS2Exception { final StringMap aParams = new StringMap ( ) ; aParams . putIn ( CertificateFactory . ATTR_TYPE , aSettings . getKeyStoreType ( ) . getID ( ) ) ; final CertificateFactory aCertFactory = createCertificateFactory ( ) ; aCertFactory . initDynamicComponent ( aSession , aParams ) ; if ( aSettings . getKeyStoreFile ( ) ! = null ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Loading AS2 client keystore from file  " + aSettings . getKeyStoreFile ( ) ) ; aCertFactory . setFilename ( aSettings . getKeyStoreFile ( ) . getAbsolutePath ( ) ) ; aCertFactory . setPassword ( aSettings . getKeyStorePassword ( ) ) ; aCertFactory . setSaveChangesToFile ( aSettings . isSaveKeyStoreChangesToFile ( ) ) ; aCertFactory . load ( ) ; } else if ( aSettings . getKeyStoreBytes ( ) ! = null & & aSettings . getKeyStorePassword ( ) ! = null ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Loading AS2 client keystore from byte array. No changes will be stored. " ) ; aCertFactory . setSaveChangesToFile ( false ) ; try ( final NonBlockingByteArrayInputStream aBAIS = new NonBlockingByteArrayInputStream ( aSettings . getKeyStoreBytes ( ) ) ) { aCertFactory . load ( aBAIS , aSettings . getKeyStorePassword ( ) . toCharArray ( ) ) ; } } else { LOGGER . warn ( " No AS2 client keystore data was provided. Signing and encryption/decryption will most likely fail. " ) ; aCertFactory . setSaveChangesToFile ( false ) ; } if ( aSettings . getReceiverCertificate ( ) ! = null ) { try { aCertFactory . addCertificate ( aSettings . getReceiverKeyAlias ( ) , aSettings . getReceiverCertificate ( ) , false ) ; } catch ( final CertificateExistsException ex ) { } } aSession . setCertificateFactory ( aCertFactory ) ; }
public Set < Entry < K , V > > entrySet ( ) { Function < Entry < K , V > , ObservedEntry < K , V > > readT = e - > new ObservedEntry < > ( e , callback ) ; Function < ObservedEntry < K , V > , Entry < K , V > > writeT = oe - > oe . entry ; Function < Object , Object > searchT = o - > { if ( o instanceof ObservedEntry ) { ObservedEntry < ? , ? > observedEntry = ( ObservedEntry < ? , ? > ) o ; return observedEntry . entry ; } return o ; } ; TransformingSet < Entry < K , V > , ObservedEntry < K , V > > tSet = new TransformingSet < > ( map . entrySet ( ) , readT , writeT , searchT ) ; return new ObservedSet2 < > ( callback , tSet , mapEntry - > new ObservedEntry < > ( mapEntry , callback ) ) ; }
public void run ( ) { processUpdateInfo ( null ) ; }
static List < String [ ] > separatedQueueResults ( List < String > lines ) { List < String [ ] > result = new ArrayList < String [ ] > ( ) ; ArrayList < String > lineCache = new ArrayList < String > ( ) ; for ( String line : lines ) { if ( line . equals ( MPD_CMD_BULK_SEP ) ) { if ( lineCache . size ( ) ! = 0 ) { result . add ( lineCache . toArray ( new String [ lineCache . size ( ) ] ) ) ; lineCache . clear ( ) ; } } else lineCache . add ( line ) ; } if ( lineCache . size ( ) ! = 0 ) { result . add ( lineCache . toArray ( new String [ lineCache . size ( ) ] ) ) ; } return result ; }
public boolean removeIf ( Predicate < ? super Entry < String , Object > > filter ) { return wrapped . removeIf ( entry - > filter . test ( new UnwrappedEntry ( entry ) ) ) ; }
final void start ( final String mpdState ) { mIsActive = true ; mIsPlaying = MPDStatus . MPD_STATE_PLAYING . equals ( mpdState ) ; if ( ! mPreparingStreaming & & mIsPlaying ) { tryToStream ( ) ;
protected TreeSet < ParticlePlan > particlePlan ( final Term target , final double distance , final int particles ) { PostCondition targetPost = new PostCondition ( target ) ; if ( ! implication . containsVertex ( targetPost ) ) { System . out . println ( "   plan for  " + target + " : missing postCondition vertex " ) ; return null ; } ParticleActivation act = new ParticleActivation ( implication ) { @Override public boolean validVertex ( final Term x ) { return ! targetPost . equals ( x ) ; } } ; SortedSet < ParticlePath > roots = act . activate ( targetPost , false , particles , distance ) ; System . out . println ( "   plan:  " + act . getStatus ( ) ) ; if ( roots = = null ) { return null ; } TreeSet < ParticlePlan > plans = new TreeSet ( ) ; for ( final ParticlePath pp : roots ) { Sentence [ ] path = pp . path ; if ( path . length = = 0 ) throw new RuntimeException ( " ParticlePath empty:  " + pp ) ; int operations = 0 ; List < Term > seq = new ArrayList ( path . length ) ; Implication imp ; boolean nonIntervalAdded = false ; long accumulatedDelay = 0 ; for ( int i = path . length - 1 ; i > = 0 ; i - - ) { Sentence s = path [ i ] ; Term t = s . content ; if ( ! ( t instanceof Implication ) ) throw new RuntimeException ( " Unknown type:  " + t + "  in sequence generation of  " + this ) ; imp = ( Implication ) t ; Term subj = imp . getSubject ( ) ; if ( validPlanComponent ( subj ) ) { boolean isInterval = subj instanceof Interval ; if ( ! isInterval ) { nonIntervalAdded = true ; if ( accumulatedDelay > 0 ) { seq . add ( Interval . intervalTime ( accumulatedDelay , memory ) ) ; accumulatedDelay = 0 ; } seq . add ( subj ) ; } else { if ( nonIntervalAdded ) { Interval in = ( Interval ) subj ; long time = in . getTime ( memory ) ; accumulatedDelay + = time ; } } } else { if ( nonIntervalAdded ) { int temporal = ( s . content ) . getTemporalOrder ( ) ; if ( temporal = = TemporalRules . ORDER_FORWARD ) { accumulatedDelay + + ; } } } if ( subj instanceof Operation ) operations + + ; } if ( operations = = 0 ) continue ; if ( accumulatedDelay > 0 ) { seq . add ( Interval . intervalTime ( accumulatedDelay , memory ) ) ; } if ( seq . isEmpty ( ) ) continue ; ParticlePlan rp = new ParticlePlan ( memory , path , seq , pp . activation , pp . distance ) ; plans . add ( rp ) ; System . out . println ( "   plan  " + plans . size ( ) + " :  " + rp + "   " ) ; } return plans ; }
public int posToIndex ( final double p ) { final int s = size ( ) ; int x = ( int ) ( p * s ) ; if ( x = = s ) { x = s - 1 ; } return x ; }
public void bulkRead ( Consumer < ? super UnmodifiableConfig > action ) { config . bulkRead ( action ) ; }
protected void testNAL ( String path ) { int extraCycles = 0 ; final NAR n = new NAR ( ) ; final LinkedList < String > expressions = new LinkedList ( ) ; out . clear ( ) ; new TextOutput ( n ) { @Override public void output ( Class c , Object line ) { String s = line . toString ( ) ; s = s . trim ( ) ; if ( c = = ECHO . class ) { if ( s . startsWith ( " \" \ ' " ) ) { String expression = s . substring ( 2 , s . length ( ) - 1 ) ; expressions . add ( expression ) ; return ; } } if ( c = = OUT . class ) { out . add ( s ) ; } } } ; n . addInput ( getExample ( path ) ) ; n . finish ( extraCycles ) ; js . put ( " test " , this ) ; js . put ( " out " , out ) ; for ( String e : expressions ) { try { Object result = js . eval ( e ) ; if ( result instanceof Boolean ) { boolean r = ( Boolean ) result ; if ( ! r ) { System . out . println ( ) ; System . out . println ( path + "  FAILED @  " + n . getTime ( ) ) ; if ( out . size ( ) = = 0 ) System . out . println ( " (output empty) " ) ; for ( Object x : out ) System . out . println ( x ) ; System . out . println ( ) ; System . out . println ( ) ; } assertTrue ( path + " :  " + e , r ) ; } } catch ( Exception x ) { assertTrue ( x . toString ( ) + " <- " + path + " :  " + e , false ) ; System . err . println ( e ) ; System . err . println ( x ) ; x . printStackTrace ( ) ; } } if ( testPerformance ) { perfNAL ( path , 0 , performanceIterations , 1 ) ;
abstract public String getName ( ) ; @Override public int compareTo ( Item o ) { return getName ( ) . compareToIgnoreCase ( o . getName ( ) ) ; } @Override public String toString ( ) { return mainText ( ) ; } public String info ( ) { return toString ( ) ; } public static < T extends Item > List < T > merged ( List < T > aa_items , List < T > a_items ) { int j_start = aa_items . size ( ) - 1 ; for ( int i = a_items . size ( ) - 1 ; i > = 0 ; i - - ) { String a_name = a_items . get ( i ) . getName ( ) ; for ( int j = j_start ; j > = 0 ; j - - ) { if ( aa_items . get ( j ) . equals ( a_items . get ( i ) ) ) { j_start = j ; a_items . remove ( i ) ; break ; } } } List < T > result = a_items ; result . addAll ( aa_items ) ; Collections . sort ( result ) ; return result ; } }
public final int available ( ) { return capacity ( ) - size ( ) ; }
private static void createSequenceTaskByRange ( Conjunction sourceConjunction , int inclusiveStartIndex , int inclusiveEndIndex , DerivationContext nal ) { int subsequenceLength = inclusiveEndIndex - inclusiveStartIndex + 1 ; final Term [ ] subsequence = new Term [ subsequenceLength ] ; for ( int idxInSource = inclusiveStartIndex ; idxInSource < = inclusiveEndIndex ; idxInSource + + ) { int idxInSubsequence = idxInSource - inclusiveStartIndex ; subsequence [ idxInSubsequence ] = sourceConjunction . term [ idxInSource ] ; } final Term [ ] destination = new Term [ sourceConjunction . size ( ) - subsequenceLength + 1 ] ; int destinationIdx = 0 ; for ( int idx = 0 ; idx < inclusiveStartIndex ; idx + + ) { destination [ destinationIdx + + ] = sourceConjunction . term [ idx ] ; } assert destinationIdx = = inclusiveStartIndex ; destination [ destinationIdx + + ] = Conjunction . make ( subsequence , sourceConjunction . getTemporalOrder ( ) , sourceConjunction . getIsSpatial ( ) ) ; for ( int idxInSource = inclusiveEndIndex + 1 ; idxInSource < sourceConjunction . size ( ) ; idxInSource + + ) { destination [ destinationIdx + + ] = sourceConjunction . term [ idxInSource ] ; } assert destinationIdx = = destination . length ; createSequenceTask ( nal , sourceConjunction , destination ) ; }
public void testOneArrivingOneExistingWhereArrivingEarlierThanExisting ( ) { p = new BitemporalHistoryPlanner ( ) ; assertNoValidationFailures ( p , config ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , 1L , 253402214400000L , CURRENT_FLAG_DEFAULT_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 50L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 1 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . INSERT ) ; Long systemStart0 = planned . get ( 0 ) . getAs ( " systemstart " ) ; assertEquals ( planned . get ( 0 ) . getAs ( " value " ) , " world " ) ; assertEquals ( planned . get ( 0 ) . getAs ( " eventstart " ) , 50L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " eventend " ) , 99L ) ; assertTrue ( systemStart0 > = preplanSystemTime ) ; assertTrue ( systemStart0 < preplanSystemTime + 5000 ) ; assertEquals ( planned . get ( 0 ) . getAs ( " systemend " ) , 253402214400000L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; }
public void decisionMaking ( final Task task , final Concept concept ) { tasks . add ( task . clone ( ) ) ; plan ( task , task . getContent ( ) , searchDepth ) ;
public static boolean isRelation ( final String s ) { return opRelation ( s ) ! = null ; }
public Stream < E > sequential ( ) { return new UnwrappedStream < E > ( wrapped . sequential ( ) ) ; }
public static byte [ ] readHttpPayload ( @Nonnull final InputStream aIS , @Nonnull final IAS2HttpResponseHandler aResponseHandler , @Nonnull final IMessage aMsg ) throws IOException { ValueEnforcer . notNull ( aIS , " InputStream " ) ; ValueEnforcer . notNull ( aResponseHandler , " ResponseHandler " ) ; ValueEnforcer . notNull ( aMsg , " Msg " ) ; final DataInputStream aDataIS = new DataInputStream ( aIS ) ; byte [ ] aData = null ; final String sContentLength = aMsg . getHeader ( CHttpHeader . CONTENT_LENGTH ) ; if ( sContentLength = = null ) { final String sTransferEncoding = aMsg . getHeader ( CHttpHeader . TRANSFER_ENCODING ) ; if ( sTransferEncoding ! = null ) { if ( sTransferEncoding . replaceAll ( " \\ s+ " , " " ) . equalsIgnoreCase ( " chunked " ) ) { int nLength = 0 ; for ( ; ; ) { int nBlocklen = readChunkLen ( aDataIS ) ; if ( nBlocklen = = 0 ) break ; final int nNewlen = nLength + nBlocklen ; final byte [ ] aNewData = new byte [ nNewlen ] ; if ( nLength > 0 ) System . arraycopy ( aData , 0 , aNewData , 0 , nLength ) ; aDataIS . readFully ( aNewData , nLength , nBlocklen ) ; aData = aNewData ; nLength = nNewlen ; readTillNexLine ( aDataIS ) ; } aMsg . headers ( ) . setContentLength ( nLength ) ; } else { sendSimpleHTTPResponse ( aResponseHandler , HttpURLConnection . HTTP_LENGTH_REQUIRED ) ; throw new IOException ( " Transfer-Encoding unimplemented:  " + sTransferEncoding ) ; } } else { sendSimpleHTTPResponse ( aResponseHandler , HttpURLConnection . HTTP_LENGTH_REQUIRED ) ; throw new IOException ( " Content-Length missing " ) ; } } else { final int nContentSize = Integer . parseInt ( sContentLength ) ; aData = new byte [ nContentSize ] ; aDataIS . readFully ( aData ) ; } return aData ; }
public ConfigParser < CommentedConfig , Config > createParser ( ) { throw new UnsupportedOperationException ( " In memory configurations aren't mean to be  " + " parsed. " ) ;
public boolean collapseActionView ( ) { return mNativeItem . collapseActionView ( ) ; }
public int compareTo ( Number o ) { return ( new java . lang . Double ( value ) ) . compareTo ( o . doubleValue ( ) ) ; }
< T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
final void stop ( ) { if ( DEBUG ) { Log . d ( TAG , " StreamHandler.stop() " ) ; } mHandler . removeMessages ( PREPARE_ASYNC ) ; windDownResources ( REQUEST_NOTIFICATION_STOP ) ; mIsActive = false ; }
protected void onPostExecute ( Integer songIndex ) { if ( songIndex ! = null ) {
public boolean validate ( ) { if ( root = = null ) return true ; Node child = root ; if ( child instanceof KeyValueNode ) { KeyValueNode < V > kvChild = ( KeyValueNode < V > ) child ; if ( ! validate ( null , kvChild ) ) return false ; } else if ( child instanceof ArrayNode ) { ArrayNode arrayNode = ( ArrayNode ) child ; if ( ! validate ( null , arrayNode ) ) return false ; } else { return false ; } return true ; }
void setMessage ( IMessage aMessage ) ; IMessage getMessage ( ) ; void setMessageID ( String sMessageID ) ; String getMessageID ( ) ; void setPartnership ( Partnership aPartnership ) ; Partnership getPartnership ( ) ; void setText ( String sText ) ; String getText ( ) ; void addHeader ( String sKey , String sValue ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; }
public void trackPositionChanged ( MPDStatus status ) { mHelperHandler . obtainMessage ( MPDAsyncHelper . EVENT_TRACKPOSITION , Tools . toObjectArray ( status ) )
public void onDestroy ( ) { super . onDestroy ( ) ; Log . d ( TAG , " Removing connection lock " ) ; sApp . removeConnectionLock ( this ) ; sApp . oMPDAsyncHelper . removeStatusChangeListener ( this ) ; mDelayedPauseHandler . removeCallbacksAndMessages ( null ) ; windDownResources ( ) ; if ( mAlbumCover ! = null & & ! mAlbumCover . isRecycled ( ) ) { mAlbumCover . recycle ( ) ; } mRemoteControlClientHandler . onDestroy ( ) ; if ( mAudioManager ! = null ) { mAudioManager . abandonAudioFocus ( null ) ;
public int compareTo ( IntervalData < O > d ) { if ( this . end < d . end ) return - 1 ; if ( d . end < this . end ) return 1 ; return 0 ; }
private void buildMolecule ( ) { } }
public void addTrackPositionListener ( TrackPositionListener listener ) { trackPositionChangedListeners . add ( listener ) ; }
static TruthValue desireInd ( TruthValue v1 , TruthValue v2 ) { float f1 = v1 . getFrequency ( ) ; float f2 = v2 . getFrequency ( ) ; float c1 = v1 . getConfidence ( ) ; float c2 = v2 . getConfidence ( ) ; float w = and ( f2 , c1 , c2 ) ; float c = w2c ( w ) ; return new TruthValue ( f1 , c ) ; }
String getName ( ) ; @Nonnull ISession getSession ( ) ; void initDynamicComponent ( @Nonnull ISession aSession , @Nullable IStringMap aParameters ) throws OpenAS2Exception ; }
public Partnership getPartnershipByID ( @Nonnull final IStringMap aSenderIDs , @Nonnull final IStringMap aReceiverIDs ) { for ( final Partnership aPartnership : m_aMap . values ( ) ) { final IStringMap aCurrentSenderIDs = aPartnership . getAllSenderIDs ( ) ; if ( _arePartnerIDsPresent ( aSenderIDs , aCurrentSenderIDs ) ) { final IStringMap aCurrentReceiverIDs = aPartnership . getAllReceiverIDs ( ) ; if ( _arePartnerIDsPresent ( aReceiverIDs , aCurrentReceiverIDs ) ) return aPartnership ; } } return null ; }
public void testConvertToGetRowKeyColumns ( ) { Row filterRow = new RowWithSchema ( filterSchema1 , " GOOG " , 1_000_000_000L ) ; Get get = serde . convertToGet ( filterRow ) ; byte [ ] row = get . getRow ( ) ; assertEquals ( " Row Key should contain symbol and transacttime separated by : " , " GOOG: " + new String ( Bytes . toBytes ( 1_000_000_000L ) ) , new String ( row ) ) ; Set < byte [ ] > families = get . familySet ( ) ; assertEquals ( " Should be one column family " , 1 , families . size ( ) ) ; assertTrue ( " Column family should be cf1 " , families . contains ( " cf1 " . getBytes ( ) ) ) ; Filter filter = get . getFilter ( ) ; assertNull ( " No filters " , filter ) ; }
public final void connected ( ) { reconnectAttempt . set ( 0 ) ; continuousTimeout . set ( 0 ) ; }
public void onClick ( View v ) { Object tag = v . getTag ( ) ; if ( tag instanceof CharSequence ) { mSearchView . onQueryRefine ( ( CharSequence ) tag ) ;
public boolean add ( String subtype ) { if ( subtype = = null | | this . contains ( subtype ) ) { return false ; } _entrySet . add ( new SubTypeEntry ( subtype ) ) ; return true ; }
public boolean containsGlobal ( Component component , int i , int j ) { Point point = getLocationGlobal ( component ) ; Dimension dimension = component . size ( ) ; return i > = point . x & & i < point . x + dimension . width & & j > = point . y & & j < point . y + dimension . height ; }
public void reparse ( @Nonnull final AS2Message aMsg , @Nonnull final AS2HttpClient aHttpClient ) throws OpenAS2Exception { final IMessageMDN aMDN = new AS2MessageMDN ( aMsg ) ; aMDN . headers ( ) . addAllHeaders ( aHttpClient . getResponseHeaderFields ( ) ) ; NonBlockingByteArrayOutputStream aMDNStream = null ; try { final InputStream aIS = aHttpClient . getInputStream ( ) ; aMDNStream = new NonBlockingByteArrayOutputStream ( ) ; final long nContentLength = StringParser . parseLong ( aMDN . getHeader ( CHttpHeader . CONTENT_LENGTH ) , - 1 ) ; if ( nContentLength > = 0 ) StreamHelper . copyInputStreamToOutputStreamWithLimit ( aIS , aMDNStream , nContentLength ) ; else StreamHelper . copyInputStreamToOutputStream ( aIS , aMDNStream ) ; } catch ( final IOException ex ) { LOGGER . error ( " Error reparsing " , ex ) ; } finally { StreamHelper . close ( aMDNStream ) ; } final IHTTPIncomingDumper aIncomingDumper = HTTPHelper . getHTTPIncomingDumper ( ) ; if ( aIncomingDumper ! = null ) aIncomingDumper . dumpIncomingRequest ( aMDN . headers ( ) . getAllHeaderLines ( true ) , aMDNStream ! = null ? aMDNStream . toByteArray ( ) : ArrayHelper . EMPTY_BYTE_ARRAY , aMDN ) ; MimeBodyPart aPart = null ; if ( aMDNStream ! = null ) try { aPart = new MimeBodyPart ( AS2HttpHelper . getAsInternetHeaders ( aMDN . headers ( ) ) , aMDNStream . toByteArray ( ) ) ; } catch ( final MessagingException ex ) { LOGGER . error ( " Error creating MimeBodyPart " , ex ) ; } aMsg . getMDN ( ) . setData ( aPart ) ; aMDN . partnership ( ) . setSenderAS2ID ( aMDN . getHeader ( CHttpHeader . AS2_FROM ) ) ; aMDN . partnership ( ) . setReceiverAS2ID ( aMDN . getHeader ( CHttpHeader . AS2_TO ) ) ; }
static FileNotFoundAction copyData ( InputStream data ) { return ( f , c ) - > { Files . copy ( data , f . toPath ( ) ) ;
void save ( ) ; void load ( ) ; @Override void close ( ) ; @Override default FileConfig checked ( ) { return new CheckedFileConfig ( this ) ; } static FileConfig of ( File file , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return builder ( file , format ) . build ( ) ; } static FileConfig of ( File file ) { ConfigFormat format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getName ( ) ) ; } return of ( file , format ) ; } static FileConfig of ( String filePath , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return of ( new File ( filePath ) , format ) ; } static FileConfig of ( String filePath ) { return of ( new File ( filePath ) ) ; } static FileConfig ofConcurrent ( File file , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return builder ( file , format ) . concurrent ( ) . build ( ) ; } static FileConfig ofConcurrent ( File file ) { return builder ( file ) . concurrent ( ) . build ( ) ; } static FileConfig ofConcurrent ( String filePath , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return ofConcurrent ( new File ( filePath ) , format ) ; } static FileConfig ofConcurrent ( String filePath ) { return ofConcurrent ( new File ( filePath ) ) ; } static FileConfigBuilder < Config > builder ( File file , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new FileConfigBuilder < > ( file , format ) ; } static FileConfigBuilder < Config > builder ( File file ) { ConfigFormat format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getName ( ) ) ; } return builder ( file , format ) ; } static FileConfigBuilder < Config > builder ( String filePath , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return builder ( new File ( filePath ) , format ) ; } static FileConfigBuilder < Config > builder ( String filePath ) { return builder ( new File ( filePath ) ) ; } }
public static void debug ( final String tag , final String message , final Throwable tr ) { android . util . Log . d ( tag , message , tr ) ; }
public void handle ( final AbstractNetModule owner , final Socket s ) { s_aLogger . info ( " incoming connection " + "  [ " + getClientInfo ( s ) + " ] " ) ; final AS2Message msg = new AS2Message ( ) ; byte [ ] data = null ; try {
public void applyBulkMutations ( List < Tuple2 < MutationType , DataFrame > > planned ) throws Exception { KuduContext kc = new KuduContext ( config . getString ( CONNECTION_CONFIG_NAME ) ) ; for ( Tuple2 < MutationType , DataFrame > plan : planned ) { MutationType mutationType = plan . _1 ( ) ;
public boolean dispatchOnCreate ( ) { mMenu . stopDispatchingItemsChanged ( ) ; try { return mCallback . onCreateActionMode ( this , mMenu ) ;
private boolean isValid ( ) { if ( bits . length ! = offs . length ) return false ; if ( size > bits . length ) return false ; if ( size ! = 0 & & 0 < = offs [ 0 ] ) return false ; for ( int i = 1 ; i < size ; i + + ) if ( offs [ i ] < offs [ i - 1 ] ) return false ; return true ; }
public static List < Span > tokenize ( String text ) { List < Span > l = simpleTokenize ( squeezeWhitespace ( text ) ) ; Set < Span > hidden = new HashSet ( ) ; for ( Span a : l ) { if ( hidden . contains ( a ) ) continue ; for ( Span b : l ) { if ( hidden . contains ( b ) ) continue ; if ( a . contains ( b ) ) hidden . add ( b ) ; else if ( b . contains ( a ) ) { hidden . add ( a ) ; break ; } } } l . removeAll ( hidden ) ; return l ; }
protected void updatePerception ( ) { if ( hit = = null ) { if ( minDist > 0.5f ) { sight . set ( " < " + angleTerm + "  --> Empty>. :|: " ) ; } return ; } String dist = Rover2 . f ( minDist ) ; String material = hit . getUserData ( ) ! = null ? hit . getUserData ( ) . toString ( ) : " sth " ; float freq = 1f ; String ss = " <(&&, " + angleTerm + " , " + dist + " ) -->  " + material + " >. :|: % " + Texts . n1 ( freq ) + " ; " + Texts . n1 ( conf ) + " % " ; sight . set ( ss ) ; onTouch ( hit , minDist ) ; }
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public void onListItemClick ( ListView l , View v , int position , long id ) { Intent intent = new Intent ( getActivity ( ) , StoredPlaylistActivity . class ) ; intent . putExtra ( " playlist " , items . get ( position ) . getName ( ) ) ; startActivityForResult ( intent , - 1 ) ; }
public boolean equals ( final Object that ) { if ( that = = this ) return true ; if ( ! ( that instanceof Term ) ) return false ; return name ( ) . equals ( ( ( Term ) that ) . name ( ) ) ; }
public void repeatChanged ( boolean repeating ) { } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Log . d ( TAG , " StreamingService.stateChanged() " ) ; final String state = mpdStatus . getState ( ) ; if ( state ! = null & & ! state . equals ( prevMpdState ) ) { isPlaying = MPDStatus . MPD_STATE_PLAYING . equals ( state ) ; prevMpdState = state ; if ( isPlaying ) { beginStreaming ( ) ; } else { stopStreaming ( ) ; } } } private void stopStreaming ( ) { Log . d ( TAG , " StreamingService.stopStreaming() " ) ; if ( mediaPlayer ! = null & & mediaPlayer . isPlaying ( ) ) { mediaPlayer . stop ( ) ; } Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { } @Override public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } }
public int compare ( Concept o1 , Concept o2 ) { return o1 . name ( ) . toString ( ) . compareTo ( o2 . name ( ) . toString ( ) ) ; }
public boolean remove ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) { for ( int j = i + 1 ; j < size ; j + + ) { array [ j - 1 ] = array [ j ] ; } array [ - - size ] = null ; if ( array . length - size > = SHRINK_IN_CHUNK_SIZE ) { T [ ] temp = Arrays . copyOf ( array , size + GROW_IN_CHUNK_SIZE ) ; array = temp ; } return true ; } } return false ; }
static TypeConstraint extractCollectionValueType ( TypeConstraint t ) { return t . resolveTypeArgumentsFor ( Collection . class ) . map ( c - > c [ 0 ] ) . orElse ( null ) ; }
public void add ( IProcessingItem destinationPi , int type , int paralellism ) { this . listTypeStream . add ( type ) ; this . setParalellism ( paralellism ) ; this . listProcessingItem . add ( destinationPi ) ; / * IProcessingItem [ ] arrayPi = new IProcessingItem [ paralellism ] ;
public NARPrologMirror temporal ( boolean eternalJudgments , boolean presentJudgments ) { this . eternalJudgments = eternalJudgments ; this . presentJudgments = presentJudgments ; return this ; }
public void onStop ( ) { super . onStop ( ) ; mApp . updateTrackInfo . removeCallback ( this ) ; mApp . oMPDAsyncHelper . removeStatusChangeListener ( this ) ; mApp . oMPDAsyncHelper . removeTrackPositionListener ( this ) ; stopPosTimer ( ) ; mApp . unsetActivity ( this ) ; }
public abstract void doStop ( ) throws AS2Exception ; public void stop ( ) throws AS2Exception { _setRunning ( false ) ; doStop ( ) ; } @Override public boolean equals ( final Object o ) { return super . equals ( o ) ; } @Override public int hashCode ( ) { return super . hashCode ( ) ; } @Override public String toString ( ) { return ToStringGenerator . getDerived ( super . toString ( ) ) . append ( " running " , m_bRunning ) . getToString ( ) ; } }
static void initializeStaticCompatMethods ( ) { try { sMethodRegisterMediaButtonEventReceiver = AudioManager . class . getMethod ( " registerMediaButtonEventReceiver " , new Class [ ] { ComponentName . class } ) ;
public void directProcess ( final Task task , Memory mem ) { char type = task . sentence . punctuation ; switch ( type ) { case Symbols . JUDGMENT_MARK : mem . logic . JUDGMENT_PROCESS . commit ( ) ; processJudgment ( task ) ; break ; case Symbols . GOAL_MARK : mem . logic . GOAL_PROCESS . commit ( ) ; processGoal ( task ) ; break ; case Symbols . QUESTION_MARK : case Symbols . QUEST_MARK : mem . logic . QUESTION_PROCESS . commit ( ) ; processQuestion ( task ) ; break ; default : return ; } if ( task . aboveThreshold ( ) ) { mem . logic . LINK_TO_TASK . commit ( ) ; linkToTask ( task ) ; } if ( entityObserver . isActive ( ) ) { entityObserver . refresh ( displayContent ( ) ) ; } if ( mem . param . internalExperience . get ( ) ) { mem . rememberAction ( task ) ;
public void size ( ) throws Exception { MapConfig config = new SimpleConfig ( new SimpleConfig . SupportEverythingStrategy ( ) ) ; config . setString ( " a.b.c " , " value " ) ; config . setDouble ( " pi " , Math . PI ) ; Config subConfig = new SimpleConfig ( new SimpleConfig . SupportEverythingStrategy ( ) ) ; subConfig . setString ( " string " , " test! " ) ; config . setConfig ( " subConfig " , subConfig ) ; assert subConfig . size ( ) = = 1 : " Invalid subConfig size:  " + subConfig . size ( ) ; assert config . size ( ) = = 3 : " Invalid config size:  " + config . size ( ) ; }
public ConfigWriter createWriter ( ) { return new YamlWriter ( yaml ) ; }
public boolean nameEquals ( Item o ) { return getName ( ) . equals ( o . getName ( ) ) ; }
private ArrayList merge ( KIF kif , String pathname ) { ArrayList formulasPresent = new ArrayList ( ) ; try { terms . addAll ( kif . terms ) ; Set keys = kif . formulas . keySet ( ) ; for ( Object key1 : keys ) { StatsKey key = ( String ) key1 ; ArrayList newFormulas = new ArrayList ( ( Collection ) kif . formulas . get ( key ) ) ; if ( formulas . containsKey ( key ) ) { ArrayList oldFormulas = ( ArrayList ) formulas . get ( key ) ; for ( int i = 0 ; i < newFormulas . size ( ) ; i + + ) { Formula newFormula = ( Formula ) newFormulas . get ( i ) ; if ( pathname ! = null ) { newFormula . sourceFile = pathname ; } boolean found = false ; for ( int j = 0 ; j < oldFormulas . size ( ) ; j + + ) { Formula oldFormula = ( Formula ) oldFormulas . get ( j ) ; if ( newFormula . theFormula . equals ( oldFormula . theFormula ) ) { found = true ; formulasPresent . add ( oldFormula ) ; } } if ( ! found ) { oldFormulas . add ( newFormula ) ; formulaMap . put ( newFormula . theFormula . intern ( ) , newFormula ) ; } } } else { formulas . put ( key , newFormulas ) ; Iterator it2 = newFormulas . iterator ( ) ; Formula f ; while ( it2 . hasNext ( ) ) { f = ( Formula ) it2 . next ( ) ; if ( Formula . isNonEmptyString ( f . theFormula ) ) { formulaMap . put ( f . theFormula . intern ( ) , f ) ; } } } } } catch ( Exception ex ) { System . out . println ( ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; } return formulasPresent ; }
public void cycle ( final NAR inputs ) { event . emit ( Events . CycleStart . class ) ; for ( int i = 0 ; i < 1 & & isProcessingInput ( ) ; i + + ) { Item t = inputs . nextTask ( ) ; if ( t ! = null ) inputTask ( t ) ; } concepts . cycle ( ) ; event . emit ( Events . CycleEnd . class ) ; event . synch ( ) ; timePreviousCycle = time ( ) ; cycle + + ; timeRealNow = System . currentTimeMillis ( ) ; }
public String toString ( ) { return " Cmd:  " + Arrays . toString ( msg ) ; }
public Object clone ( ) { return new Equivalence ( getName ( ) , cloneTerms ( components ) , isConstant ( ) , complexity , temporalOrder ) ; }
public void configure ( Config config ) { LOG . debug ( " Configuring ProtobufTranslator " ) ; String descriptorFilePath = config . getString ( CONFIG_DESCRIPTOR_FILEPATH ) ; if ( config . hasPath ( CONFIG_DESCRIPTOR_MESSAGE ) ) { String descriptorMessage = config . getString ( CONFIG_DESCRIPTOR_MESSAGE ) ; this . descriptor = ProtobufUtils . buildDescriptor ( descriptorFilePath , descriptorMessage ) ; } else { this . descriptor = ProtobufUtils . buildDescriptor ( descriptorFilePath ) ; } this . schema = ProtobufUtils . buildSchema ( descriptor ) ; doesAppendRaw = TranslatorUtils . doesAppendRaw ( config ) ; if ( doesAppendRaw ) { List < StructField > rawFields = Lists . newArrayList (
public Iterator < Character > reverseIterator ( final int start ) { return null ; }
public String removeComment ( List < String > path ) { final int lastIndex = path . size ( ) - 1 ; final String lastKey = path . get ( lastIndex ) ; if ( lastIndex = = 0 ) { return commentMap . remove ( lastKey ) ; } Object parent = getRaw ( path . subList ( 0 , lastIndex ) ) ; if ( parent instanceof CommentedConfig ) { List < String > lastPath = Collections . singletonList ( lastKey ) ; return ( ( CommentedConfig ) parent ) . removeComment ( lastPath ) ; } return null ; }
public DebouncedRunnable andThen ( Runnable then ) { Runnable combined = ( ) - > { runnable . run ( ) ; then . run ( ) ; } ; return new DebouncedRunnable ( combined , debounceTimeNanos , scheduledTask ) ; }
protected void loadAttributes ( @Nonnull final IMicroElement aNode , @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { final String sNodeName = " attribute " ; final String sNodeKeyName = " name " ; final String sNodeValueName = " value " ; final Map < String , String > aAttributes = XMLHelper . mapAttributeNodes ( aNode , sNodeName , sNodeKeyName , sNodeValueName ) ; aPartnership . addAllAttributes ( aAttributes ) ; }
< R > R bulkUpdate ( Function < ? super Config , R > action ) ; default void bulkUpdate ( Consumer < ? super Config > action ) { bulkUpdate ( config - > { action . accept ( config ) ; return null ; } ) ; } static FileConfig of ( File file ) { return of ( file . toPath ( ) ) ; } static FileConfig of ( File file , ConfigFormat < ? extends Config > format ) { return of ( file . toPath ( ) , format ) ; } static FileConfig of ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return of ( file , format ) ; } static FileConfig of ( Path file , ConfigFormat < ? extends Config > format ) { return builder ( file , format ) . build ( ) ; } static FileConfig of ( String filePath ) { return of ( Paths . get ( filePath ) ) ; } static FileConfig of ( String filePath , ConfigFormat < ? > format ) { return of ( Paths . get ( filePath ) , format ) ; } static FileConfig ofConcurrent ( File file ) { return ofConcurrent ( file . toPath ( ) ) ; } static FileConfig ofConcurrent ( File file , ConfigFormat < ? > format ) { return ofConcurrent ( file . toPath ( ) , format ) ; } static FileConfig ofConcurrent ( Path file ) { return builder ( file ) . concurrent ( ) . build ( ) ; } static FileConfig ofConcurrent ( Path file , ConfigFormat < ? > format ) { return builder ( file , format ) . concurrent ( ) . build ( ) ; } static FileConfig ofConcurrent ( String filePath ) { return ofConcurrent ( Paths . get ( filePath ) ) ; } static FileConfig ofConcurrent ( String filePath , ConfigFormat < ? > format ) { return ofConcurrent ( Paths . get ( filePath ) , format ) ; } static FileConfigBuilder builder ( File file ) { return builder ( file . toPath ( ) ) ; } static FileConfigBuilder builder ( File file , ConfigFormat < ? > format ) { return builder ( file . toPath ( ) , format ) ; } static FileConfigBuilder builder ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return builder ( file , format ) ; } static FileConfigBuilder builder ( Path file , ConfigFormat < ? > format ) { return new FileConfigBuilder ( file , format ) ; } static FileConfigBuilder builder ( String filePath ) { return builder ( Paths . get ( filePath ) ) ; } static FileConfigBuilder builder ( String filePath , ConfigFormat < ? > format ) { return builder ( Paths . get ( filePath ) , format ) ; } }
public void addProcessingItem ( IProcessingItem procItem , int parallelism ) { super . addProcessingItem ( procItem , parallelism ) ; ISamzaProcessingItem samzaPi = ( ISamzaProcessingItem ) procItem ; samzaPi . setName ( this . getTopologyName ( ) + " - " + Integer . toString ( procItemCounter ) ) ; procItemCounter + + ; }
public abstract void closeLogFile ( ) ; public abstract boolean isLogging ( ) ; }
public void debouncing ( ) throws Exception { int n = 100 ; Path file = tmp . resolve ( " debouncing " ) ; Duration debounceTime = Duration . ofMillis ( 100 ) ; Duration debounceAndTolerance = debounceTime . plusMillis ( 11 ) ; FileWatcher watcher = new FileWatcher ( debounceTime , onWatcherException ) ; AtomicInteger callCounter = new AtomicInteger ( 0 ) ; watcher . addWatchFuture ( file , ( ) - > callCounter . getAndIncrement ( ) ) . get ( 10 , TimeUnit . MILLISECONDS ) ; Files . createFile ( file ) ; for ( int i = 0 ; i < n ; i + + ) { writeAndSync ( file , Arrays . asList ( " a " + i ) ) ; } assertEquals ( 0 , callCounter . get ( ) ) ; Thread . sleep ( debounceAndTolerance . toMillis ( ) ) ; assertEquals ( 1 , callCounter . get ( ) ) ; for ( int j = 0 ; j < n ; j + + ) { writeAndSync ( file , Arrays . asList ( " b " + j , " second line " ) ) ; } Thread . sleep ( debounceAndTolerance . toMillis ( ) ) ; assertEquals ( 2 , callCounter . get ( ) ) ; watcher . stopFuture ( ) . get ( 50 , TimeUnit . MILLISECONDS ) ; }
public T get ( int index ) { synchronized ( LOCK ) { final ListIterator < T > itr = this . listIterator ( index ) ;
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
default void write ( UnmodifiableConfig config , Path file , WritingMode writingMode , Charset charset ) { StandardOpenOption [ ] options ; if ( writingMode = = WritingMode . APPEND ) { options = new StandardOpenOption [ ] { WRITE , CREATE , APPEND } ; } else { options = new StandardOpenOption [ ] { WRITE , CREATE , TRUNCATE_EXISTING } ; } try ( OutputStream output = Files . newOutputStream ( file , options ) ) { write ( config , output , charset ) ;
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . SentPrefix p , A arg ) { p . nsprefix_ . accept ( new NSPrefixVisitor < R , A > ( ) , arg ) ; return null ; }
public void init ( TestbedState model ) { this . model = model ; Vec2 gravity = new Vec2 ( 0 , - 10 f ) ; m_world = model . getWorldCreator ( ) . createWorld ( gravity ) ; m_world . setParticleGravityScale ( 0.4f ) ; m_world . setParticleDensity ( 1.2f ) ; bomb = null ; mouseJoint = null ; mouseTracing = false ; mouseTracerPosition . setZero ( ) ; mouseTracerVelocity . setZero ( ) ; BodyDef bodyDef = new BodyDef ( ) ; groundBody = m_world . createBody ( bodyDef ) ; init ( m_world , false ) ; }
protected boolean partOfThis ( char c , int idx ) { if ( string ! = null & & idx < string . length & & string [ idx ] = = c ) return true ; return false ; }
public void test2 ( ) { NAR n = new DefaultNARBuilder ( ) . build ( ) ; InferenceTracer tracer = new InferenceTracer ( ) ; n . memory . setRecorder ( tracer ) ; n . addInput ( " <a --> b>. " ) ; n . step ( 1 ) ; n . addInput ( " <a <-> b>. " ) ; n . step ( 1 ) ; n . addInput ( " <b --> c>. " ) ; n . step ( 1 ) ; n . addInput ( " <(*,a,b) --> d>. " ) ; n . step ( 1 ) ; assert ( tracer . time . size ( ) = = 5 ) ;
public void optimize ( ) { if ( writeQ . peek ( ) instanceof GetOperation ) { getOp = ( GetOperation ) writeQ . remove ( ) ;
public double d ( String fieldName ) ; public long i ( String fieldName ) ; default public double sum ( ) { return d ( " sum " ) ; } default public double max ( ) { return d ( " max " ) ; } default public double min ( ) { return d ( " min " ) ; } default public long hits ( ) { return i ( " hits " ) ; } default public double median ( ) { return ( max ( ) + min ( ) ) / 2.0 ; } default public double mean ( ) { long h = hits ( ) ; if ( h = = 0 ) return 0 ; return ( sum ( ) / h ) ; } default public void put ( String id , double value ) { put ( id , new Double ( value ) ) ; } }
public void addAll ( final Iterable < Music > collection ) throws IOException , MPDException { addAllCommand ( collection ) . send ( mConnection ) ; }
public static com . cloudera . labs . envelope . input . translate . ProtobufMultipleMessage . OtherExample parseDelimitedFrom ( java . io . InputStream input ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input ) ;
public void seekByIndex ( int index , long position ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; mpdConnection . sendCommand ( MPDCommand . MPD_CMD_SEEK , Integer . toString ( index ) , Long . toString ( position ) ) ;
public abstract boolean contains ( T value ) ; public abstract int size ( ) ; public static < T > Queue < T > createQueue ( QueueType type ) { switch ( type ) { case ArrayQueue : return new ArrayQueue < T > ( ) ; default : return new LinkedQueue < T > ( ) ; } } public static class LinkedQueue < T > extends Queue < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; public LinkedQueue ( ) { head = null ; tail = null ; size = 0 ; } @Override public void enqueue ( T value ) { enqueue ( new Node < T > ( value ) ) ; } private void enqueue ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > oldHead = head ; head = node ; node . next = oldHead ; oldHead . prev = node ; } size + + ; } @Override public T dequeue ( ) { T result = null ; if ( tail ! = null ) { result = tail . value ; Node < T > prev = tail . prev ; if ( prev ! = null ) { prev . next = null ; tail = prev ; } else { head = null ; tail = null ; } size - - ; } return result ; } @Override public boolean contains ( T value ) { if ( head = = null ) return false ; Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . next ; } return false ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . next ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > prev = null ; private Node < T > next = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( prev ! = null ) ? prev . value : " NULL " ) + "  next= " + ( ( next ! = null ) ? next . value : " NULL " ) ; } } } public static class ArrayQueue < T > extends Queue < T > { private static final int GROW_IN_CHUNK_SIZE = 50 ; private static final int SHRINK_IN_CHUNK_SIZE = 50 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int nextIndex = 0 ; private int firstIndex = 0 ; @Override public void enqueue ( T value ) { if ( ( nextIndex - firstIndex ) > = array . length ) { T [ ] temp = Arrays . copyOfRange ( array , firstIndex , nextIndex + GROW_IN_CHUNK_SIZE ) ; temp [ nextIndex + + ] = value ; array = temp ; firstIndex = 0 ; } else { array [ nextIndex + + ] = value ; } } @Override public T dequeue ( ) { if ( ( nextIndex - firstIndex ) < 0 ) return null ; T t = array [ firstIndex ] ; array [ firstIndex + + ] = null ; if ( ( nextIndex - firstIndex ) = = 0 ) { firstIndex = 0 ; nextIndex = 0 ; } else if ( array . length - ( nextIndex - firstIndex ) > = SHRINK_IN_CHUNK_SIZE ) { T [ ] temp = Arrays . copyOfRange ( array , firstIndex , nextIndex ) ; array = temp ; nextIndex = nextIndex - firstIndex ; firstIndex = 0 ; } return t ; } @Override public boolean contains ( T value ) { for ( int i = firstIndex ; i < nextIndex ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public int size ( ) { return nextIndex - firstIndex ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = nextIndex - 1 ; i > = firstIndex ; i - - ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } }
static void decomposeStatement ( CompoundTerm compound , Term component , boolean compoundTask , Memory memory ) { Task task = memory . getCurrentTask ( ) ; Sentence sentence = task . getSentence ( ) ; Sentence belief = memory . getCurrentBelief ( ) ; Term content = CompoundTerm . reduceComponents ( compound , component , memory ) ; if ( content = = null ) { return ; } TruthValue truth = null ; BudgetValue budget ; if ( sentence . isQuestion ( ) ) { budget = BudgetFunctions . compoundBackward ( content , memory ) ;
public void purgeTimer ( ) ; public void purgeStateTimer ( ) ; public void cancelTimer ( ) ; public void cancelStateTimer ( ) ; public void startProber ( ) ; public void startAnnouncer ( ) ; public void startRenewer ( ) ; public void startCanceler ( ) ; public void startReaper ( ) ; public void startServiceInfoResolver ( ServiceInfoImpl info ) ; public void startTypeResolver ( ) ; public void startServiceResolver ( String type ) ; public void startResponder ( DNSIncoming in , int port ) ; }
public String toString ( ) { return realized ? " OK:  " + exact : getFailureReason ( ) ; }
public void adjustHappy ( float newValue , float weight , NAL nal ) { happy + = newValue * weight ; happy / = 1.0f + weight ; if ( lasthappy ! = - 1 ) { float frequency = - 1 ; if ( happy > Parameters . HAPPY_EVENT_HIGHER_THRESHOLD & & lasthappy < = Parameters . HAPPY_EVENT_HIGHER_THRESHOLD ) { frequency = 1.0f ; } if ( happy < Parameters . HAPPY_EVENT_LOWER_THRESHOLD & & lasthappy > = Parameters . HAPPY_EVENT_LOWER_THRESHOLD ) { frequency = 0.0f ; } if ( frequency ! = - 1 ) { Term predicate = SetInt . make ( new Term ( " satisfied " ) ) ; Term subject = new Term ( " SELF " ) ; Inheritance inh = Inheritance . make ( subject , predicate ) ; TruthValue truth = new TruthValue ( 1.0f , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) ; Sentence s = new Sentence ( inh , Symbols . JUDGMENT_MARK , truth , new Stamp ( nal . memory ) ) ; s . stamp . setOccurrenceTime ( nal . memory . time ( ) ) ; Task t = new Task ( s , new BudgetValue ( Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY , BudgetFunctions . truthToQuality ( truth ) ) ) ; nal . addTask ( t , " emotion " ) ; if ( Parameters . REFLECT_META_HAPPY_GOAL ) { TruthValue truth2 = new TruthValue ( 1.0f , Parameters . DEFAULT_GOAL_CONFIDENCE ) ; Sentence s2 = new Sentence ( inh , Symbols . GOAL_MARK , truth2 , new Stamp ( nal . memory ) ) ; s2 . stamp . setOccurrenceTime ( nal . memory . time ( ) ) ; Task t2 = new Task ( s2 , new BudgetValue ( Parameters . DEFAULT_GOAL_PRIORITY , Parameters . DEFAULT_GOAL_DURABILITY , BudgetFunctions . truthToQuality ( truth2 ) ) ) ; nal . addTask ( t2 , " metagoal " ) ; Operator consider = nal . memory . getOperator ( " ^consider " ) ; Operator remind = nal . memory . getOperator ( " ^remind " ) ; Term [ ] arg = new Term [ 1 ] ; arg [ 0 ] = inh ; if ( InternalExperience . enabled & & Parameters . CONSIDER_REMIND ) { Operation op_consider = Operation . make ( consider , arg , true ) ; Operation op_remind = Operation . make ( remind , arg , true ) ; Operation [ ] op = new Operation [ 2 ] ; op [ 0 ] = op_remind ; op [ 1 ] = op_consider ; for ( Operation o : op ) { TruthValue truth3 = new TruthValue ( 1.0f , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) ; Sentence s3 = new Sentence ( o , Symbols . JUDGMENT_MARK , truth3 , new Stamp ( nal . memory ) ) ; s3 . stamp . setOccurrenceTime ( nal . memory . time ( ) ) ; BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY , BudgetFunctions . truthToQuality ( truth3 ) ) ; budget . setPriority ( budget . getPriority ( ) * InternalExperience . INTERNAL_EXPERIENCE_PRIORITY_MUL ) ; budget . setDurability ( budget . getPriority ( ) * InternalExperience . INTERNAL_EXPERIENCE_DURABILITY_MUL ) ; Task t3 = new Task ( s3 , budget ) ; nal . addTask ( t3 , " internal experience for consider and remind " ) ; } } } } } lasthappy = happy ;
private double func ( double n , double min , double max , double slope ) { return max / ( 1 + Math . exp ( - slope * ( n - min ) ) ) ; }
void setAttributes ( @Nullable IStringMap aAttributes ) ; @Nullable String getHeader ( @Nonnull String sKey ) ; @Nullable String getHeader ( @Nonnull String sKey , @Nullable String sDelimiter ) ; @Nonnull @ReturnsMutableObject ( " design " ) InternetHeaders getHeaders ( ) ; @Nonnull @Nonempty String getHeadersDebugFormatted ( ) ; void setHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void addHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void setHeaders ( @Nullable InternetHeaders aHeaders ) ; @Nullable String getMessageID ( ) ; void setMessageID ( @Nullable String sMessageID ) ; @Nonnull String generateMessageID ( ) ; void updateMessageID ( ) ; @Nonnull @ReturnsMutableObject ( " Design " ) Partnership getPartnership ( ) ; void setPartnership ( @Nonnull Partnership aPartnership ) ; @Nonnull @Nonempty String getAsString ( ) ; }
public boolean onMenuItemClick ( final MenuItem item ) { final int itemId = item . getItemId ( ) ; if ( itemId = = GOTO_ARTIST ) { final Intent intent = new Intent ( getActivity ( ) , SimpleLibraryActivity . class ) ; intent . putExtra ( " artist " , mAlbum . getArtist ( ) ) ; startActivityForResult ( intent , - 1 ) ; } else { mApp . oMPDAsyncHelper . execAsync ( new Runnable ( ) { @Override public void run ( ) { boolean replace = false ; boolean play = false ; switch ( itemId ) { case ADD_REPLACE_PLAY : replace = true ; play = true ; break ; case ADD_REPLACE : replace = true ; break ; case ADD_PLAY : play = true ; break ; default : break ; } try { mApp . oMPDAsyncHelper . oMPD . add ( mAlbum , replace , play ) ; Tools . notifyUser ( R . string . albumAdded , mAlbum ) ; } catch ( final IOException | MPDException e ) { Log . e ( TAG , " Failed to add, replace, play. " , e ) ; } } } ) ; } return true ; }
protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { Term content = args [ 1 ] ; TruthValue truth = new TruthValue ( 1 , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) ; Sentence sentence = new Sentence ( content , Symbols . JUDGMENT_MARK , truth , new Stamp ( memory ) ) ; float quality = BudgetFunctions . truthToQuality ( truth ) ; BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY , quality ) ; return Lists . newArrayList ( new Task ( sentence , budget ) ) ;
public boolean condition ( Class channel , Object signal ) { if ( channel = = OUT . class ) { CharSequence o = TextOutput . getOutputString ( channel , signal , false , false , nar ) ; if ( o . toString ( ) . contains ( containing ) ) return true ; if ( saveSimilar ) { int dist = Texts . levenshteinDistance ( o , containing ) ; almost . put ( " similar( " + dist + " ):  " + TextOutput . getOutputString ( channel , signal , false , false , nar ) , dist ) ; } } if ( channel = = ERR . class ) { assertTrue ( signal . toString ( ) , false ) ; } return false ; }
public void testNullFactoryConstructor ( ) throws Exception { try { client = new MemcachedClient ( null ,
public int locateIndex ( int index ) { int min = 0 ; int max = this . indexValues . length - 1 ; if ( max = = - 1 ) { return - 1 ; } while ( ( this . indexValues [ min ] < = index ) & & ( this . indexValues [ max ] > = index ) ) { int current = ( max + min ) / 2 ; if ( this . indexValues [ current ] > index ) { max = current - 1 ; } else if ( this . indexValues [ current ] < index ) { min = current + 1 ; } else { return current ; } } if ( this . indexValues [ max ] < index ) { return max ;
public boolean prefersCondensedTitle ( ) ; public boolean showsIcon ( ) ; } }
private void checkConcurrentModification ( ) { if ( this . expectedModCount ! = WeakLinkedList . this . modcount ) throw new ConcurrentModificationException (
private List < String > innerSyncedWriteAsyncRead ( MPDCommand command ) throws MPDServerException { ArrayList < String > result = new ArrayList < String > ( ) ; try { writeToServer ( command ) ; } catch ( IOException e ) { throw new MPDConnectionException ( e ) ; } boolean dataReaded = false ; while ( ! dataReaded ) { try { result = readFromServer ( ) ; dataReaded = true ; } catch ( SocketTimeoutException e ) { w ( MPDConnection . class . getSimpleName ( ) , " Socket timeout while reading server response :  " + e ) ; } catch ( IOException e ) { throw new MPDConnectionException ( e ) ; } } return result ; }
void setPartnership ( Partnership aPartnership ) ; Partnership getPartnership ( ) ; void setText ( String sText ) ; String getText ( ) ; void addHeader ( String sKey , String sValue ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; }
public Spliterator < Entry < String , Object > > trySplit ( ) { return new CheckedEntrySpliterator ( wrapped . trySplit ( ) ) ; }
EChange removePartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nonnull Partnership getPartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nullable Partnership getPartnershipByName ( @Nullable String sName ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllPartnershipNames ( ) ; @Nonnull @ReturnsMutableCopy List < Partnership > getAllPartnerships ( ) ; void updatePartnership ( @Nonnull IMessage aMsg , boolean bOverwrite ) throws OpenAS2Exception ; void updatePartnership ( @Nonnull IMessageMDN aMdn , boolean bOverwrite ) throws OpenAS2Exception ; }
public HttpFuture < View > asyncGetView ( String designDocumentName , final String viewName ) { designDocumentName = MODE_PREFIX + designDocumentName ; String uri = " / " + bucketName + " /_design/ " + designDocumentName ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < View > crv = new HttpFuture < View > ( couchLatch , operationTimeout ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ViewOperationImpl ( request , bucketName , designDocumentName , viewName , new ViewCallback ( ) { View view = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( view , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( View v ) { view = v ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }
public String getSecurityProviderName ( ) { return m_sSecurityProviderName ; }
Map < String , String > commentMap ( ) ; @Override Set < ? extends Entry > entrySet ( ) ; interface Entry extends Config . Entry , UnmodifiableCommentedConfig . Entry { String setComment ( String comment ) ; String removeComment ( ) ; } @Override CommentedConfig createSubConfig ( ) ; static CommentedConfig of ( ConfigFormat < ? extends CommentedConfig > format ) { return new SimpleCommentedConfig ( format , false ) ; } static CommentedConfig of ( Supplier < Map < String , Object > > mapCreator , ConfigFormat < ? extends CommentedConfig > format ) { return new SimpleCommentedConfig ( mapCreator , format ) ; } @Deprecated static CommentedConfig ofConcurrent ( ConfigFormat < ? extends CommentedConfig > format ) { return new SimpleCommentedConfig ( format , false ) ; } static CommentedConfig inMemory ( ) { return InMemoryCommentedFormat . defaultInstance ( ) . createConfig ( ) ; } @Deprecated static CommentedConfig inMemoryConcurrent ( ) { return InMemoryCommentedFormat . defaultInstance ( ) . createConcurrentConfig ( ) ; } static CommentedConfig wrap ( Map < String , Object > map , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( map , format ) ; } static CommentedConfig copy ( UnmodifiableConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , false ) ; } static CommentedConfig copy ( UnmodifiableConfig config , Supplier < Map < String , Object > > mapCreator ) { return new SimpleCommentedConfig ( config , mapCreator , config . configFormat ( ) ) ; } static CommentedConfig copy ( UnmodifiableConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , false ) ; } static CommentedConfig copy ( UnmodifiableConfig config , Supplier < Map < String , Object > > mapCreator , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , mapCreator , format ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , false ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config , Supplier < Map < String , Object > > mapCreator ) { return new SimpleCommentedConfig ( config , mapCreator , config . configFormat ( ) ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , false ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config , Supplier < Map < String , Object > > mapCreator , ConfigFormat < ? extends CommentedConfig > format ) { return new SimpleCommentedConfig ( config , mapCreator , format ) ; } @Deprecated static CommentedConfig concurrentCopy ( UnmodifiableConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , true ) ; } @Deprecated static CommentedConfig concurrentCopy ( UnmodifiableConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , true ) ; } @Deprecated static CommentedConfig concurrentCopy ( UnmodifiableCommentedConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , true ) ; } @Deprecated static CommentedConfig concurrentCopy ( UnmodifiableCommentedConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , true ) ; } static CommentedConfig fake ( Config config ) { if ( config instanceof CommentedConfig ) { return ( CommentedConfig ) config ; } return new FakeCommentedConfig ( config ) ; } }
private boolean remove ( int index ) { if ( index ! = - - size ) { System . arraycopy ( array , index + 1 , array , index , size - index ) ; } array [ size ] = null ; if ( size > = MINIMUM_SIZE & & size < array . length / 2 ) { System . arraycopy ( array , 0 , array , 0 , size ) ; } return true ; }
public static List < Music > getMusicFromList ( final Collection < String > response , final boolean sort ) { final List < Music > result = new ArrayList < > ( response . size ( ) ) ; final List < String > lineCache = new ArrayList < > ( MUSIC_ATTRIBUTES ) ; for ( final String line : response ) { if ( line . startsWith ( " file:  " ) ) { if ( ! lineCache . isEmpty ( ) ) { result . add ( new Music ( lineCache ) ) ; lineCache . clear ( ) ; } } lineCache . add ( line ) ; } if ( ! lineCache . isEmpty ( ) ) { result . add ( new Music ( lineCache ) ) ; } if ( sort ) { Collections . sort ( result ) ; } return result ; }
public void playlistChanged ( MPDStatus mpdStatus , int oldPlaylistVersion ) { } @Override public void randomChanged ( boolean random ) { } @Override public void repeatChanged ( boolean repeating ) { } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Log . d ( TAG , " StreamingService.stateChanged() " ) ; final String state = mpdStatus . getState ( ) ; if ( state = = null | | state . equals ( prevMpdState ) ) { return ; } isPlaying = MPDStatus . MPD_STATE_PLAYING . equals ( state ) ; prevMpdState = state ; if ( isPlaying ) { beginStreaming ( ) ; } else { stopStreaming ( ) ; } } private void stopStreaming ( ) { Log . d ( TAG , " StreamingService.stopStreaming() " ) ; if ( mediaPlayer ! = null & & mediaPlayer . isPlaying ( ) ) { mediaPlayer . stop ( ) ; } Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { prevMpdState = " " ; } @Override public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } }
public void step_start ( ) { termid + + ; Term V = new Term ( subj + termid ) ; float [ ] [ ] cpy = new float [ height ] [ width ] ; for ( int i = 0 ; i < height ; i + + ) { for ( int j = 0 ; j < width ; j + + ) { cpy [ height ] [ width ] = cpy [ height ] [ width ] ; } } VisualSpace vspace = new VisualSpace ( nar , cpy , py , px , height , width ) ; V . imagination = vspace ; Sentence s = new Sentence ( Inheritance . make ( V , this . label ) , Symbols . JUDGMENT_MARK , new TruthValue ( 1.0f , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) , new Stamp ( nar . memory ) ) ; Task T = new Task ( s , new BudgetValue ( Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY , BudgetFunctions . truthToQuality ( s . truth ) ) , true ) ; this . results . add ( T ) ; this . step_finished ( ) ; }
public void randomChanged ( boolean random ) { } @Override public void repeatChanged ( boolean repeating ) { } @Override final public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Log . d ( TAG , " StreamingService.stateChanged() " ) ; final String state = mpdStatus . getState ( ) ; if ( state ! = null ) { switch ( state ) { case MPDStatus . MPD_STATE_PLAYING : isPlaying = true ; beginStreaming ( ) ; break ; case MPDStatus . MPD_STATE_STOPPED : case MPDStatus . MPD_STATE_PAUSED : isPlaying = false ; stopStreaming ( ) ; break ; } prevMpdState = state ; } } private void stopStreaming ( ) { Log . d ( TAG , " StreamingService.stopStreaming() " ) ; if ( mediaPlayer ! = null & & mediaPlayer . isPlaying ( ) ) { mediaPlayer . stop ( ) ; } Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { } @Override public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } }
public void testReadWrite ( ) { Config config = Config . inMemory ( ) ; config . set ( " null " , null ) ; config . set ( " nullObject " , NULL_OBJECT ) ; config . set ( " string " , " this is a string " ) ; config . set ( " sub.null " , null ) ; config . set ( " sub.nullObject " , NULL_OBJECT ) ; System . out . println ( " Config:  " + config ) ; System . out . println ( " classOf[sub] =  " + config . get ( " sub " ) . getClass ( ) ) ; System . out . println ( " sub.null =  " + config . get ( " sub.null " ) ) ; System . out . println ( " sub.nullObject =  " + config . get ( " sub.nullObject " ) ) ; YamlFormat yamlFormat = YamlFormat . defaultInstance ( ) ; yamlFormat . createWriter ( ) . write ( config , file , WritingMode . REPLACE ) ; Config parsed = yamlFormat . createConcurrentConfig ( ) ; yamlFormat . createParser ( ) . parse ( file , parsed , ParsingMode . REPLACE , THROW_ERROR ) ; System . out . println ( " \ nParsed:  " + parsed ) ; System . out . println ( " classOf[sub] =  " + parsed . get ( " sub " ) . getClass ( ) ) ; assertNull ( parsed . get ( " sub.null " ) ) ; assertNull ( parsed . get ( " sub.nullObject " ) ) ; assertSame ( NULL_OBJECT , parsed . valueMap ( ) . get ( " null " ) ) ; assertSame ( NULL_OBJECT , parsed . valueMap ( ) . get ( " nullObject " ) ) ; Assertions . assertEquals ( config , parsed , " Error: written != parsed " ) ; }
abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; @Override public abstract Iterator < E > iterator ( ) ; }
protected void updateInputValues ( ) { updateSOM ( ) ; for ( int i = 0 ; i < encoded . length ; i + + ) setNextValue ( encoded [ i ] ) ;
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { MemcachedConnection . opTimedOut ( op ) ; if ( op ! = null ) { op . timeOut ( ) ; } throw new CheckedOperationTimeoutException ( " Timed out waiting for operation " , op ) ; } else { MemcachedConnection . opSucceeded ( op ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { throw new ExecutionException ( new CheckedOperationTimeoutException ( " Operation timed out. " , op ) ) ; } return objRef . get ( ) ; }
public Builder addBeginningRange ( final double end ) { return addBeginningRange ( end , null ) ; }
public void insert ( float x , float y ) { XYPoint xyPoint = new XYPoint ( x , y ) ; root . insert ( ( P ) xyPoint ) ; }
private static boolean runTests ( ) { testIndex = 0 ; testNumber + + ; System . out . println ( " Generating data. " ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Array= " ) ; unsorted = new Integer [ ARRAY_SIZE ] ; java . util . Set < Integer > set = new java . util . HashSet < Integer > ( ) ; for ( int i = 0 ; i < ARRAY_SIZE ; i + + ) { Integer j = RANDOM . nextInt ( RANDOM_SIZE ) ; boolean found = true ; while ( found ) { if ( set . contains ( j ) ) { j = RANDOM . nextInt ( RANDOM_SIZE ) ; } else { unsorted [ i ] = j ; set . add ( j ) ; found = false ; } } unsorted [ i ] = j ; builder . append ( j ) . append ( ',' ) ; } builder . append ( '\n' ) ; string = builder . toString ( ) ; if ( debug > 1 ) System . out . println ( string ) ; sorted = Arrays . copyOf ( unsorted , unsorted . length ) ; Arrays . sort ( sorted ) ; System . out . println ( " Generated data. " ) ; boolean passed = true ; passed = testAVLTree ( ) ; if ( ! passed ) { System . err . println ( " AVL Tree failed. " ) ; return false ; } passed = testBTree ( ) ; if ( ! passed ) { System . err . println ( " B-Tree failed. " ) ; return false ; } passed = testBST ( ) ; if ( ! passed ) { System . err . println ( " BST failed. " ) ; return false ; } passed = testHeap ( ) ; if ( ! passed ) { System . err . println ( " Heap failed. " ) ; return false ; } passed = testHashMap ( ) ; if ( ! passed ) { System . err . println ( " Hash Map failed. " ) ; return false ; } passed = testList ( ) ; if ( ! passed ) { System . err . println ( " List failed. " ) ; return false ; } passed = testPatriciaTrie ( ) ; if ( ! passed ) { System . err . println ( " Patricia Trie failed. " ) ; return false ; } passed = testQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } passed = testRadixTrie ( ) ; if ( ! passed ) { System . err . println ( " Radix Trie failed. " ) ; return false ; } passed = testRedBlackTree ( ) ; if ( ! passed ) { System . err . println ( " Red-Black Tree failed. " ) ; return false ; } passed = testSkipList ( ) ; if ( ! passed ) { System . err . println ( " Skip List failed. " ) ; return false ; } passed = testSplayTree ( ) ; if ( ! passed ) { System . err . println ( " Splay Tree failed. " ) ; return false ; } passed = testStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } passed = testTreap ( ) ; if ( ! passed ) { System . err . println ( " Treap failed. " ) ; return false ; } passed = testTreeMap ( ) ; if ( ! passed ) { System . err . println ( " Tree Map failed. " ) ; return false ; } passed = testTrie ( ) ; if ( ! passed ) { System . err . println ( " Trie failed. " ) ; return false ; } passed = testTrieMap ( ) ; if ( ! passed ) { System . err . println ( " Trie Map failed. " ) ; return false ; } passed = testJavaHeap ( ) ; if ( ! passed ) { System . err . println ( " Java Heap failed. " ) ; return false ; } passed = testJavaHashMap ( ) ; if ( ! passed ) { System . err . println ( " Java Hash Map failed. " ) ; return false ; } passed = testJavaList ( ) ; if ( ! passed ) { System . err . println ( " Java List failed. " ) ; return false ; } passed = testJavaQueue ( ) ; if ( ! passed ) { System . err . println ( " Java Queue failed. " ) ; return false ; } passed = testJavaRedBlackTree ( ) ; if ( ! passed ) { System . err . println ( " Java Red-Black failed. " ) ; return false ; } passed = testJavaStack ( ) ; if ( ! passed ) { System . err . println ( " Java Stack failed. " ) ; return false ; } passed = testJavaTreeMap ( ) ; if ( ! passed ) { System . err . println ( " Java Tree Map failed. " ) ; return false ; } if ( debugTime & & debugMemory ) { String results = getTestResults ( testNumber , testNames , testResults ) ; System . out . println ( results ) ; } passed = testCompactSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Compact Suffix Trie failed. " ) ; return false ; } passed = testGraph ( ) ; if ( ! passed ) { System . err . println ( " Graph failed. " ) ; return false ; } passed = testIntervalTree ( ) ; if ( ! passed ) { System . err . println ( " Interval Tree failed. " ) ; return false ; } passed = testKdTree ( ) ; if ( ! passed ) { System . err . println ( " k-d Tree Tree failed. " ) ; return false ; } passed = testMatrix ( ) ; if ( ! passed ) { System . err . println ( " Matrix failed. " ) ; return false ; } passed = testQuadTree ( ) ; if ( ! passed ) { System . err . println ( " QuadTree failed. " ) ; return false ; } passed = testSegmentTree ( ) ; if ( ! passed ) { System . err . println ( " Segment Tree failed. " ) ; return false ; } passed = testSuffixTree ( ) ; if ( ! passed ) { System . err . println ( " Suffix Tree failed. " ) ; return false ; } passed = testSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Suffix Trie failed. " ) ; return false ; } return true ; }
public boolean hasOp ( ) { return ! ( getOp = = null & & opq . isEmpty ( ) ) ; }
public void before ( Body b , DrawPhy2D d ) { switch ( this ) { case Food :
public void testSupportAll ( ) throws Exception { ObjectConverter converter = new ObjectConverter ( null , null ) ; Config config = new SimpleConfig ( SimpleConfig . STRATEGY_SUPPORT_ALL ) ; MyObject object = new MyObject ( ) ; converter . toConfig ( object , config ) ; System . out . println ( " MyObject mapped to a SimpleConfig with support_all strategy: " ) ; System . out . println ( config ) ; assert config . < Integer > getValue ( " integer " ) = = object . integer ; assert config . < Double > getValue ( " decimal " ) = = object . decimal ; assert config . < String > getValue ( " string " ) = = object . string ; assert config . < List < String > > getValue ( " stringList " ) = = object . stringList ; assert config . < Config > getValue ( " config " ) = = object . config ; assert config . getValue ( " subObject " ) = = object . subObject ; }
public static void main ( String [ ] args ) { int repeats = 2 ; int warmups = 1 ; int maxConcepts = 2000 ; int extraCycles = 2048 ; int randomExtraCycles = 512 ; NAR n = new NAR ( new Plugins ( ) ) ; Collection c = NALTest . params ( ) ; while ( true ) { for ( Object o : c ) {
abstract public void update ( Effect nextEffect ) ; @Override public void draw ( ) { cx = ( cx * ( 1.0f - animationLerpRate ) ) + ( x * animationLerpRate ) ; cy = ( cy * ( 1.0f - animationLerpRate ) ) + ( y * animationLerpRate ) ; cheading = ( cheading * ( 1.0f - animationLerpRate / 2.0f ) ) + ( heading * animationLerpRate / 2.0f ) ; float scale = ( float ) Math . sin ( space . getTime ( ) / 7f ) * 0.05f + 1.0f ; space . pushMatrix ( ) ; space . translate ( cx , cy ) ; space . scale ( scale * 0.8f ) ; if ( ! ( nar . memory . executive . next . isEmpty ( ) ) ) { space . fill ( Color . RED . getRGB ( ) , 255 ) ; } else { space . fill ( Color . ORANGE . getRGB ( ) , 255 ) ; } space . ellipse ( 0 , 0 , 1 , 1 ) ; space . fill ( Color . BLUE . getRGB ( ) , 255 ) ; space . rotate ( ( float ) ( Math . PI / 180 f * cheading ) ) ; space . translate ( - 0.15f , 0.4f ) ; space . ellipse ( 0 , 0 , 0.2f , 0.2f ) ; space . translate ( 0.3f , 0.0f ) ; space . ellipse ( 0 , 0 , 0.2f , 0.2f ) ; space . popMatrix ( ) ; } }
public void containsValue ( ) throws Exception { MapConfig config = new SimpleConfig ( SimpleConfig . STRATEGY_SUPPORT_ALL ) ; config . setValue ( " a.b.c " , " value " ) ; assert config . containsValue ( " a " ) ; assert ! config . containsValue ( " b " ) ; assert config . containsValue ( " a.b " ) ; assert ! config . containsValue ( " c " ) ; assert config . containsValue ( " a.b.c " ) ; config . setValue ( " int " , 12 ) ; assert config . containsValue ( " int " ) ; }
Set < ? extends Entry > entrySet ( ) ; interface Entry extends Config . Entry , UnmodifiableCommentedConfig . Entry { String setComment ( String comment ) ; String removeComment ( ) ; } @Override CommentedConfig createSubConfig ( ) ; static CommentedConfig of ( ConfigFormat < ? extends CommentedConfig > format ) { return new SimpleCommentedConfig ( format , false ) ; } static CommentedConfig of ( Supplier < Map < String , Object > > mapCreator , ConfigFormat < ? extends CommentedConfig > format ) { return new SimpleCommentedConfig ( mapCreator , format ) ; } static CommentedConfig ofConcurrent ( ConfigFormat < ? extends CommentedConfig > format ) { return new SimpleCommentedConfig ( format , false ) ; } static CommentedConfig inMemory ( ) { return InMemoryCommentedFormat . defaultInstance ( ) . createConfig ( ) ; } static CommentedConfig inMemoryConcurrent ( ) { return InMemoryCommentedFormat . defaultInstance ( ) . createConcurrentConfig ( ) ; } static CommentedConfig wrap ( Map < String , Object > map , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( map , format ) ; } static CommentedConfig copy ( UnmodifiableConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , false ) ; } static CommentedConfig copy ( UnmodifiableConfig config , Supplier < Map < String , Object > > mapCreator ) { return new SimpleCommentedConfig ( config , mapCreator , config . configFormat ( ) ) ; } static CommentedConfig copy ( UnmodifiableConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , false ) ; } static CommentedConfig copy ( UnmodifiableConfig config , Supplier < Map < String , Object > > mapCreator , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , mapCreator , format ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , false ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config , Supplier < Map < String , Object > > mapCreator ) { return new SimpleCommentedConfig ( config , mapCreator , config . configFormat ( ) ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , false ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config , Supplier < Map < String , Object > > mapCreator , ConfigFormat < ? extends CommentedConfig > format ) { return new SimpleCommentedConfig ( config , mapCreator , format ) ; } static CommentedConfig concurrentCopy ( UnmodifiableConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , true ) ; } static CommentedConfig concurrentCopy ( UnmodifiableConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , true ) ; } static CommentedConfig concurrentCopy ( UnmodifiableCommentedConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , true ) ; } static CommentedConfig concurrentCopy ( UnmodifiableCommentedConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , true ) ; } static CommentedConfig fake ( Config config ) { if ( config instanceof CommentedConfig ) { return ( CommentedConfig ) config ; } return new FakeCommentedConfig ( config ) ; } }
public List < T > getAll ( ) ; public List < T > getAll ( List < Long > idList ) ; public int getItemCount ( ) ; public boolean isInDatabase ( long id ) ; public int truncate ( ) ; }
Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }
public K lastKey ( ) { throw new InternalError ( ) ; }
public static DNSOperationCode operationCodeForFlags ( int flags ) { int maskedIndex = ( flags & OpCode_MASK ) > > 11 ; for ( DNSOperationCode aCode : DNSOperationCode . values ( ) ) { if ( aCode . _index = = maskedIndex ) return aCode ; } return Unassigned ; }
public static final String reverseWithSwaps ( String string ) { char [ ] array = string . toCharArray ( ) ; int length = array . length - 1 ; int half = ( int ) Math . floor ( array . length / 2 ) ; char c ; for ( int i = length ; i > = half ; i - - ) { c = array [ length - i ] ; array [ length - i ] = array [ i ] ; array [ i ] = c ; } return String . valueOf ( array ) ; }
public void cycle ( ) { long now = memory . time ( ) ; if ( now - lastExecution < ( memory . param . duration . get ( ) / maxExecutionsPerDuration ) ) { return ; } lastExecution = now ; updateTasks ( ) ; updateSensors ( ) ; if ( tasks . isEmpty ( ) ) { return ; } if ( memory . emitting ( TaskExecution . class ) ) { if ( tasks . size ( ) > 1 ) { for ( TaskExecution tcc : tasks ) { memory . emit ( Executive . class , memory . time ( ) , tcc ) ; } } else { memory . emit ( Executive . class , memory . time ( ) , tasks . first ( ) ) ; } } TaskExecution topExecution = tasks . first ( ) ; Task top = topExecution . t ; Term term = top . getContent ( ) ; if ( term instanceof Operation ) { execute ( ( Operation ) term , top ) ;
protected static String makeSetName ( final char opener , final Term [ ] arg , final char closer ) { final int sizeEstimate = 12 * arg . length + 2 ; StringBuilder name = new StringBuilder ( sizeEstimate ) . append ( opener ) ; if ( arg . length = = 0 ) { } else { name . append ( arg [ 0 ] . name ( ) ) ; for ( int i = 1 ; i < arg . length ; i + + ) { name . append ( Symbols . ARGUMENT_SEPARATOR ) ; name . append ( arg [ i ] . name ( ) ) ; } } name . append ( closer ) ; return name . toString ( ) ; }
final Collection < Music > subList ( final int fromIndex , final int toIndex ) { return mList . subList ( fromIndex , toIndex ) ; }
public static final String toBinaryUsingShiftsAndModulus ( long longNumber ) { StringBuilder builder = new StringBuilder ( ) ; long temp = 0 l ; while ( longNumber > 0 ) { temp = longNumber ; longNumber = ( temp > > 1 ) ; builder . append ( temp % 2 ) ; } return builder . reverse ( ) . toString ( ) ; }
public static final TruthValue reduceDisjunction ( final TruthValue v1 , final TruthValue v2 , Parameters narParameters ) { final TruthValue v0 = intersection ( v1 , negation ( v2 , narParameters ) , narParameters ) ; return deduction ( v0 , 1f , narParameters ) ; }
private static boolean runTests ( ) { test = 0 ; System . out . println ( " Generating data. " ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Array= " ) ; unsorted = new Integer [ ARRAY_SIZE ] ; for ( int i = 0 ; i < unsorted . length ; i + + ) { Integer j = RANDOM . nextInt ( unsorted . length * 10 ) ; boolean found = true ; while ( found ) { found = false ; for ( int k = 0 ; k < i ; k + + ) { int l = unsorted [ k ] ; if ( j = = l ) { found = true ; j = RANDOM . nextInt ( unsorted . length * 10 ) ; break ; } } } unsorted [ i ] = j ; builder . append ( j ) . append ( ',' ) ; } builder . append ( '\n' ) ; string = builder . toString ( ) ; if ( debug > 1 ) System . out . println ( string ) ; System . out . println ( " Generated data. " ) ; boolean passed = true ; passed = testAVLTree ( ) ; if ( ! passed ) { System . err . println ( " AVL Tree failed. " ) ; return false ; } passed = testBST ( ) ; if ( ! passed ) { System . err . println ( " BST failed. " ) ; return false ; } passed = testHeap ( ) ; if ( ! passed ) { System . err . println ( " Heap failed. " ) ; return false ; } passed = testHashMap ( ) ; if ( ! passed ) { System . err . println ( " Hash Map failed. " ) ; return false ; } passed = testLinkedList ( ) ; if ( ! passed ) { System . err . println ( " Linked List failed. " ) ; return false ; } passed = testPatriciaTrie ( ) ; if ( ! passed ) { System . err . println ( " Patricia Trie failed. " ) ; return false ; } passed = testQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } passed = testRadixTree ( ) ; if ( ! passed ) { System . err . println ( " Radix Tree failed. " ) ; return false ; } passed = testSkipList ( ) ; if ( ! passed ) { System . err . println ( " Skip List failed. " ) ; return false ; } passed = testSplayTree ( ) ; if ( ! passed ) { System . err . println ( " Splay Tree failed. " ) ; return false ; } passed = testStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } passed = testTreap ( ) ; if ( ! passed ) { System . err . println ( " Treap failed. " ) ; return false ; } passed = testTrie ( ) ; if ( ! passed ) { System . err . println ( " Trie failed. " ) ; return false ; } passed = testTrieMap ( ) ; if ( ! passed ) { System . err . println ( " Trie Map failed. " ) ; return false ; } if ( debugTime & & debugMemory ) { String results = getTestResults ( testNames , testResults ) ; System . out . println ( results ) ; } passed = testGraph ( ) ; if ( ! passed ) { System . err . println ( " Graph failed. " ) ; return false ; } passed = testMatrix ( ) ; if ( ! passed ) { System . err . println ( " Matrix failed. " ) ; return false ; } passed = testSegmentTree ( ) ; if ( ! passed ) { System . err . println ( " Segment Tree failed. " ) ; return false ; } passed = testSuffixTree ( ) ; if ( ! passed ) { System . err . println ( " Suffix Tree failed. " ) ; return false ; } passed = testSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Suffix Trie failed. " ) ; return false ; } return true ; }
abstract protected Term function ( Memory memory , Term [ ] x ) ; @Deprecated abstract protected Term getRange ( ) ; @Override protected List < Task > execute ( Operation operation , final Term [ ] args , final Memory m ) { final int numArgs = args . length - 1 ; if ( numArgs < 1 ) { throw new IllegalStateException ( " Requires at least 1 arguments " ) ; } if ( numArgs < 2 ) { throw new IllegalStateException ( " Requires at least 2 arguments " ) ; } final Term lastTerm = args [ numArgs ] ; final boolean variable = lastTerm instanceof Variable ; if ( ! variable ) { throw new IllegalStateException ( " output can not be specified " ) ; } final int numParam = numArgs - 1 ; final Term [ ] x = new Term [ numParam ] ; System . arraycopy ( args , 1 , x , 0 , numParam ) ; final Term y ; y = function ( m , x ) ; if ( y = = null ) { return null ; } final Variable var = new Variable ( " $1 " ) ; operation = ( Operation ) operation . setComponent ( 0 , ( ( CompoundTerm ) operation . getSubject ( ) ) . setComponent ( numArgs , y , m ) , m ) ; final float confidence = Parameters . DEFAULT_JUDGMENT_CONFIDENCE ; if ( variable ) { final Sentence s = new Sentence ( operation , Symbols . JUDGMENT_MARK , new TruthValue ( 1.0f , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) , new Stamp ( m ) ) ; return Lists . newArrayList ( new Task ( s , new BudgetValue ( Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_FEEDBACK_DURABILITY , truthToQuality ( s . getTruth ( ) ) ) , true ) ) ; } else { return null ; } } public float equals ( final Term a , final Term b ) { return a . equals ( b ) ? 1.0f : 0.0f ; } }
public static String unbackQuoteChars ( String string ) { int index ; StringBuffer newStringBuffer ; String charsFind [ ] = { " \\ \\ " , " \\ ' " , " \\ t " , " \\ n " , " \\ r " , " \\ \" " , " \\ % " , " \\ u001E " } ; char charsReplace [ ] = { '\\' , '\'' , '\t' , '\n' , '\r' , '"' , '%' , '\u001E' } ; int pos [ ] = new int [ charsFind . length ] ; int curPos ; String str = new String ( string ) ; newStringBuffer = new StringBuffer ( ) ; while ( str . length ( ) > 0 ) { curPos = str . length ( ) ; index = - 1 ; for ( int i = 0 ; i < pos . length ; i + + ) { pos [ i ] = str . indexOf ( charsFind [ i ] ) ; if ( ( pos [ i ] > - 1 ) & & ( pos [ i ] < curPos ) ) { index = i ; curPos = pos [ i ] ; } } if ( index = = - 1 ) { newStringBuffer . append ( str ) ; str = " " ; } else { newStringBuffer . append ( str . substring ( 0 , pos [ index ] ) ) ; newStringBuffer . append ( charsReplace [ index ] ) ; str = str . substring ( pos [ index ] + charsFind [ index ] . length ( ) ) ; } } return newStringBuffer . toString ( ) ; }
protected boolean cycleInput ( ) { boolean inputPerceived = false ; if ( ( inputting ) & & ( ! inputChannels . isEmpty ( ) ) ) { for ( int j = 0 ; j < inputChannels . size ( ) ; j + + ) { final Input i = inputChannels . get ( j ) ; if ( i . finished ( false ) ) { deadInputs . add ( i ) ; } else { Object o = i . next ( ) ; if ( o ! = null ) { perceive ( i , o ) ; inputPerceived = true ; } } } inputChannels . removeAll ( deadInputs ) ; deadInputs . clear ( ) ; } return inputPerceived ; }
void checkSelect ( ) { } } class Hamlib { void Init ( ) { noStroke ( ) ; hnav . Init ( ) ; hsim . Init ( ) ; } void mousePressed ( ) { hnav . mousePressed ( ) ; hsim . mousePressed ( ) ; } void mouseDragged ( ) { hnav . mouseDragged ( ) ; hsim . mouseDragged ( ) ; } void mouseReleased ( ) { hnav . mouseReleased ( ) ; hsim . mouseReleased ( ) ; } public void mouseMoved ( ) { } void keyPressed ( ) { hnav . keyPressed ( ) ; } void mouseScrolled ( ) { hnav . mouseScrolled ( ) ; } void Camera ( ) { } } } public class TestChamber extends Window { TestChamber_applet app = null ; public TestChamber ( NAR n ) { super ( " TestChamber " ) ; app = new TestChamber_applet ( ) ; app . init ( ) ; app . nar = n ; this . setSize ( 1000 , 860 ) ; this . setVisible ( true ) ; Container content = getContentPane ( ) ; content . setLayout ( new BorderLayout ( ) ) ; JPanel menu = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; content . add ( menu , BorderLayout . NORTH ) ; content . add ( app , BorderLayout . CENTER ) ; } @Override protected void close ( ) { app . stop ( ) ; app . destroy ( ) ; getContentPane ( ) . removeAll ( ) ; app = null ; } public static void main ( String [ ] arg ) { NAR n = new NAR ( ) ; new TestChamber ( n ) ; } }
public Collection < Music > search ( String type , String string ) throws MPDServerException { return genericSearch ( MPDCommand . MPD_CMD_SEARCH , type , string ) ; }
public static void run ( Config config ) throws Exception { validateConfigurations ( config ) ; Set < Step > steps = extractSteps ( config , true , true ) ; ExecutionMode mode = getExecutionMode ( steps ) ; Contexts . initialize ( config , mode ) ; initializeSecurity ( config , steps ) ; initializeEventHandlers ( config ) ; initializeAccumulators ( steps ) ; initializeUDFs ( config ) ; initializeThreadPool ( config ) ; notifyPipelineStarted ( ) ; try { if ( mode = = ExecutionMode . STREAMING ) { runStreaming ( steps ) ; } else { runBatch ( steps ) ; } } catch ( Exception e ) { notifyPipelineException ( e ) ; throw e ; } finally { shutdownThreadPool ( ) ; shutdownSecurity ( ) ; } notifyPipelineFinished ( ) ; }
public < R > R bulkCommentedUpdate ( Function < ? super CommentedConfig , R > action ) { long stamp = commentsLock . writeLock ( ) ; try { return bulkUpdate ( ( Function < ? super Config , R > ) action ) ;
private Term parseCompoundTerm ( final String s0 ) throws InvalidInputException { String s = s0 . trim ( ) ; if ( s . isEmpty ( ) ) { throw new InvalidInputException ( " Empty compound term:  " + s ) ; } int firstSeparator = s . indexOf ( ARGUMENT_SEPARATOR ) ; if ( firstSeparator = = - 1 ) { throw new InvalidInputException ( " Invalid compound term (missing ARGUMENT_SEPARATOR):  " + s ) ; } String op = ( firstSeparator < 0 ) ? s : s . substring ( 0 , firstSeparator ) . trim ( ) ; NativeOperator oNative = getOperator ( op ) ; Operator oRegistered = memory . getOperator ( op ) ; if ( ( oRegistered = = null ) & & ( oNative = = null ) ) { throw new InvalidInputException ( " Unknown operator:  " + op ) ; } ArrayList < Term > arg = ( firstSeparator < 0 ) ? new ArrayList < > ( 0 ) : parseArguments ( s . substring ( firstSeparator + 1 ) + ARGUMENT_SEPARATOR ) ; Term [ ] argA = arg . toArray ( new Term [ arg . size ( ) ] ) ; Term t ; if ( oNative ! = null ) { t = Terms . term ( oNative , argA ) ; } else if ( oRegistered ! = null ) { t = make ( oRegistered , argA , true ) ; } else { throw new InvalidInputException ( " Invalid compound term " ) ; } return t ; }
public void removeMeter ( String name ) { metrics . remove ( name ) ; }
public void add ( Music music ) { if ( getById ( music . getSongId ( ) ) ! = null ) throw new IllegalArgumentException ( " Music is already on list " ) ; map . put ( Integer . valueOf ( music . getSongId ( ) ) , music ) ; while ( list . size ( ) < ( music . getPos ( ) + 1 ) ) list . add ( null ) ; list . set ( music . getPos ( ) , music ) ; }
private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > tc ) { CachedData co = tc . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }
protected List < Task > execute ( final Operation operation , final Term [ ] args , final Memory memory , final Timable time ) { if ( Debug . DEBUG ) { memory . emit ( getClass ( ) , args ) ; } return null ; }
public void testReadBrokenChunk1 ( ) throws Exception { try ( final InputStream empty = new NonBlockingByteArrayInputStream ( " bla foo fasel \ n " . getBytes ( ) ) ; final ChunkedInputStream cIS = new ChunkedInputStream ( empty ) )
public Coordinates convertToField ( String value ) { List < String > parts = StringUtils . split ( value , ',' ) ; int x = Integer . parseInt ( parts . get ( 0 ) . trim ( ) ) ; int y = Integer . parseInt ( parts . get ( 1 ) . trim ( ) ) ; int z = Integer . parseInt ( parts . get ( 2 ) . trim ( ) ) ; return new Coordinates ( x , y , z ) ; }
protected File getConfigurationFile ( @Nonnull final ICommonsMap < String , String > aInitParams ) throws ServletException { final String sConfigurationFilename = aInitParams . get ( SERVLET_INIT_PARAM_AS2_SERVLET_CONFIG_FILENAME ) ; if ( StringHelper . hasNoText ( sConfigurationFilename ) ) throw new ServletException ( " Servlet Init-Parameter ' " + SERVLET_INIT_PARAM_AS2_SERVLET_CONFIG_FILENAME + " ' is missing or empty! " ) ; try {
MimeBodyPart sign ( MimeBodyPart aPart , Certificate aCert , Key key , String sAlgorithm ) throws Exception ; MimeBodyPart verify ( MimeBodyPart aPart , Certificate aCert ) throws Exception ; }
public void event ( Class event , Object [ ] arguments ) { Task t = ( Task ) arguments [ 0 ] ; Sentence newSolution = ( Sentence ) arguments [ 1 ] ; System . out . println ( " solution:  " + newSolution ) ; onBelief ( newSolution ) ; }
public void testReadContentTransferEncodingBase64 ( ) throws MessagingException , IOException { final String sHTTP = " Content-Type: text/plain " + HTTPHelper . EOL + " Content-Transfer-Encoding: base64 " + HTTPHelper . EOL + " x-custom: junit " + HTTPHelper . EOL + " Content-Length: 44 " + HTTPHelper . EOL + HTTPHelper . EOL + " VGVzdCBtZXNzYWdlCkxpbmUgMgoKTGluZSA0CkVPRg== " + HTTPHelper . EOL ; InputStream aIS = new StringInputStream ( sHTTP , StandardCharsets . ISO_8859_1 ) ; final InternetHeaders aHeaders = new InternetHeaders ( aIS ) ; final String sCTE = aHeaders . getHeader ( CHttpHeader . CONTENT_TRANSFER_ENCODING ) [ 0 ] ; if ( StringHelper . hasText ( sCTE ) ) aIS = MimeUtility . decode ( aIS , sCTE ) ; final byte [ ] aData = StreamHelper . getAllBytes ( aIS ) ; final ContentType aReceivedContentType = new ContentType ( aHeaders . getHeader ( CHttpHeader . CONTENT_TYPE ) [ 0 ] ) ; final String sReceivedContentType = aReceivedContentType . toString ( ) ; final MimeBodyPart aReceivedPart = new MimeBodyPart ( ) ; aReceivedPart . setDataHandler ( new ByteArrayDataSource ( aData , sReceivedContentType , null ) . getAsDataHandler ( ) ) ; aReceivedPart . setHeader ( " x-received " , " true " ) ; final NonBlockingByteArrayOutputStream aBAOS = new NonBlockingByteArrayOutputStream ( ) ; aReceivedPart . writeTo ( aBAOS ) ; StreamHelper . close ( aBAOS ) ; final String sMsgPart = aBAOS . getAsString ( StandardCharsets . ISO_8859_1 ) ; if ( true ) s_aLogger . info ( sMsgPart ) ;
public void onDestroy ( ) { super . onDestroy ( ) ; Log . d ( TAG , " Removing connection lock " ) ; sApp . removeConnectionLock ( this ) ; sApp . oMPDAsyncHelper . removeStatusChangeListener ( this ) ; mHandler . removeCallbacksAndMessages ( this ) ; windDownResources ( ) ; if ( mNotificationHandler ! = null ) { mNotificationHandler . onDestroy ( ) ; } mAlbumCoverHandler . onDestroy ( ) ; mRemoteControlClientHandler . onDestroy ( ) ; if ( mAudioManager ! = null ) { mAudioManager . abandonAudioFocus ( null ) ;
private static Term make ( final Term [ ] termSet , final Memory memory ) { final String name = makeSetName ( SET_EXT_OPENER . ch , termSet , SET_EXT_CLOSER . ch ) ; final Term t = memory . conceptTerm ( name ) ; return ( t ! = null ) ? t : new SetExt ( name , termSet ) ; }
Map < String , IDynamicComponent > getAllComponents ( ) ; @Nonnull ICertificateFactory getCertificateFactory ( ) throws ComponentNotFoundException ; @Nonnull IPartnershipFactory getPartnershipFactory ( ) throws ComponentNotFoundException ; @Nonnull IMessageProcessor getMessageProcessor ( ) throws ComponentNotFoundException ; boolean isCryptoVerifyUseCertificateInBodyPart ( ) ; void setCryptoVerifyUseCertificateInBodyPart ( boolean bCryptoVerifyUseCertificateInBodyPart ) ; @Nullable Proxy getHttpProxy ( ) ; void setHttpProxy ( @Nullable Proxy aHttpProxy ) ; }
public void onListItemClick ( final ListView l , View v , final int position , long id ) { final int song = ( ( AbstractPlaylistMusic ) l . getAdapter ( ) . getItem ( position ) ) . getSongId ( ) ; PlaylistControl . run ( PlaylistControl . SKIP_TO_ID , song ) ; }
NoopOperation noop ( OperationCallback cb ) ; DeleteOperation delete ( String key , OperationCallback operationCallback ) ; FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }
public AbstractBag < E > newBag ( ) ; } public static double compare ( String label , BagBuilder b , final int iterations , final int randomAccesses , final float insertRatio , int repeats , int warmups ) { Performance p = new Performance ( label , repeats , warmups ) { @Override public void init ( ) { } @Override public void run ( boolean warmup ) { AbstractBag bag = b . newBag ( ) ; randomBagIO ( bag , randomAccesses , insertRatio ) ; for ( int i = 0 ; i < iterations ; i + + ) iterate ( bag ) ; } } ; return p . getCycleTimeMS ( ) ; } public BagPerf ( ) { for ( int capacity = 8 ; capacity < 40000 ; capacity * = capacity ) { randomAccesses = capacity * 64 ; for ( int i = 5 ; i < 200 ; i + = 5 ) { testBag ( false , i , capacity , forgetRate ) ; testBag ( true , i , capacity , forgetRate ) ; } } } public static void main ( String [ ] args ) { int capacityPerLevel = 10 ; int repeats = 3 ; int warmups = 1 ; double totalDiff = 0 ; double totalTimeA = 0 , totalTimeB = 0 ; final int iterations = 1 ; for ( float insertRatio = 0.1f ; insertRatio < = 1.0f ; insertRatio + = 0.2f ) { for ( int levels = 1 ; levels < = 500 ; levels + = 10 ) { final int bagCapacity = levels * capacityPerLevel ; int randomAccesses = 64 * bagCapacity ; final int _levels = levels ; double a = 0 , b = 0 ; a = compare ( " A " , new BagBuilder ( ) { @Override public AbstractBag newBag ( ) { return new ContinuousBag2 < Item > ( bagCapacity , forgetRate , new ContinuousBag2 . DefaultBagCurve ( ) , true ) ; } } , iterations , randomAccesses , insertRatio , repeats , warmups ) ; b = compare ( " B " , new BagBuilder ( ) { @Override public AbstractBag newBag ( ) { return new ContinuousBag < Item > ( bagCapacity , forgetRate , true ) ; } } , iterations , randomAccesses , insertRatio , repeats , warmups ) ; System . out . print ( insertRatio + " ,  " + levels + " ,  " + bagCapacity + " ,  " ) ; System . out . println ( ( a - b ) / ( ( a + b ) / 2.0 ) ) ; totalDiff + = ( a - b ) ; totalTimeA + = a ; totalTimeB + = b ; } } if ( totalDiff > 0 ) System . out . print ( " B faster:  " ) ; else System . out . print ( " A faster:  " ) ; System . out . println ( " total difference (ms):  " + totalDiff ) ; System . out . println ( "   A time= " + totalTimeA ) ; System . out . println ( "   B time= " + totalTimeB ) ; } }
public int hashCode ( ) { synchronized ( rootMonitor ) { return config . hashCode ( ) ;
public boolean hasMoreInstances ( ) { return this . stream . hasMoreInstances ( ) ; }
public void test ( ) { ConfigSpec spec = new ConfigSpec ( ) ; spec . defineInRange ( " a.i " , 0 , - 20 , 20 ) ; spec . defineInRange ( " a.l " , 0 , - 20 , 20 ) ; spec . defineInRange ( " a.f " , 0.1f , - 0.2f , 0.2f ) ; spec . defineInRange ( " a.d " , 0.1 , - 0.1 , 0.2 ) ; spec . defineInList ( " a.s " , " default " , Arrays . asList ( " a " , " b " , " c " , " d " , " e " , " f " , " default " ) ) ; spec . defineList ( " a.list " , Arrays . asList ( " 1 " , " 2 " ) , element - > element instanceof String ) ; { Config config = new SimpleConfig ( ) ; config . set ( " a.i " , 256 ) ; config . set ( " a.l " , 1234567890 ) ; config . set ( " a.f " , 12 f ) ; config . set ( " a.d " , 123 d ) ; config . set ( " a.s " , " value " ) ; config . set ( " a.list " , Arrays . asList ( " hey " , null , false , 1 ) ) ; assert ! spec . isCorrect ( config ) ; System . out . println ( " Before correction:  " + configToString ( config ) ) ; spec . correct ( config ) ; System . out . println ( " After correction:  " + configToString ( config ) ) ; assert spec . isCorrect ( config ) : " Config was not corrected correctly! " ; } { Config config = new SimpleConfig ( ) ;
Set < String > getAllPartnershipNames ( ) ; @Nonnull @ReturnsMutableCopy List < Partnership > getAllPartnerships ( ) ; @Nonnull IPartnershipMap getPartnershipMap ( ) ; void updatePartnership ( @Nonnull IMessage aMsg , boolean bOverwrite ) throws OpenAS2Exception ; void updatePartnership ( @Nonnull IMessageMDN aMdn , boolean bOverwrite ) throws OpenAS2Exception ; }
public int hashCode ( ) { return new HashCodeGenerator ( this ) . append ( m_aAttrs ) . getHashCode ( ) ; }
public void testFinalize ( ) throws Exception { for ( int i = 0 ; i < 10000 ; i + + ) { String inData = " 123456 " ;
public void testClearComments ( ) { CommentedConfig config = CommentedConfig . inMemory ( ) ; config . set ( " a " , " a " ) ; config . setComment ( " a " , " commentA " ) ; CommentedConfig sub = CommentedConfig . inMemory ( ) ; sub . set ( " b " , " b " ) ; sub . setComment ( " b " , " commentB " ) ; config . set ( " sub " , sub ) ; config . setComment ( " sub " , " commentSub " ) ; assertEquals ( config . getComment ( " a " ) , " commentA " ) ; assertEquals ( config . getComment ( " sub.b " ) , " commentB " ) ; assertEquals ( config . getComment ( " sub " ) , " commentSub " ) ; assertEquals ( sub . getComment ( " b " ) , " commentB " ) ; for ( CommentedConfig . Entry entry : config . entrySet ( ) ) { assertNotNull ( entry . getComment ( ) ) ; } config . clearComments ( ) ; assertNull ( config . getComment ( " a " ) ) ; assertNull ( config . getComment ( " sub.b " ) ) ; assertNull ( config . getComment ( " sub " ) ) ; assertNull ( sub . getComment ( " b " ) ) ; for ( CommentedConfig . Entry entry : config . entrySet ( ) ) { assertNull ( entry . getComment ( ) ) ;
public static void revision ( final Sentence newBelief , final Sentence oldBelief , final boolean feedbackToLinks , final Memory memory ) { TruthValue newTruth = newBelief . truth ; TruthValue oldTruth = oldBelief . truth ; TruthValue truth = TruthFunctions . revision ( newTruth , oldTruth ) ; BudgetValue budget = BudgetFunctions . revise ( newTruth , oldTruth , truth , feedbackToLinks , memory ) ; Term content = newBelief . content ; memory . logic . BELIEF_REVISION . commit ( ) ; memory . doublePremiseTaskRevised ( content , truth , budget ) ; }
public boolean isRFC3851Algorithm ( ) { return this = = DIGEST_MD5 | | this = = DIGEST_SHA1 | |
public void testBadTRansferEncodingMessageStream ( ) throws Exception { final IAS2HttpResponseHandler mockedResponseHandler = ( nHttpResponseCode , aHeaders , aData ) - > { } ; final NonBlockingByteArrayInputStream is = new NonBlockingByteArrayInputStream ( m_sBadTransferEncodingMessage . getBytes ( StandardCharsets . UTF_8 ) ) ; final AS2Message aMsg = new AS2Message ( ) ; aMsg . attrs ( ) . putIn ( ATTR_LARGE_FILE_SUPPORT_ON , true ) ; final IAS2InputStreamProvider mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; HTTPHelper . readHttpRequest ( mockStreamProvider , mockedResponseHandler , aMsg ) ; }
public void repeatChanged ( boolean repeating ) { } @Override public void randomChanged ( boolean random ) { } @Override public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } @Override public void onBackPressed ( ) { super . onBackPressed ( ) ; } }
public synchronized static CoverManager getInstance ( MPDApplication app , SharedPreferences settings ) { if ( instance = = null ) { instance = new CoverManager ( app , settings ) ; } return instance ; }
void update ( Sensor tracker , long now ) ; void clear ( ) ; void setEventManager ( EventManager e ) ; }
private void saveNow ( ) { UnmodifiableConfig copy = config . newAccumulatorCopy ( ) ; synchronized ( this ) { if ( writingMode = = WritingMode . REPLACE_ATOMIC ) { Path tmp = nioPath . resolveSibling ( IoUtils . tempConfigFileName ( nioPath ) ) ; try ( BufferedWriter writer = Files . newBufferedWriter ( tmp , charset , WRITE , CREATE , TRUNCATE_EXISTING ) ) { configWriter . write ( copy , writer ) ; } catch ( IOException e ) { String msg = String . format ( " Failed to write (%s) the config to: %s " , writingMode . toString ( ) , tmp . toString ( ) ) ; throw new WritingException ( msg , e ) ; } try { IoUtils . retryIfAccessDenied ( " move " , ( ) - > { Files . move ( tmp , nioPath , StandardCopyOption . ATOMIC_MOVE ) ; } ) ; } catch ( AtomicMoveNotSupportedException e ) { String msg = String . format ( " Failed to atomically move the config from '%s' to '%s': WritingMode.REPLACE_ATOMIC is not supported for this path, use WritingMode.REPLACE instead. \ n%s " , tmp . toString ( ) , nioPath . toString ( ) , " Note: you may see *.new.tmp files after this error, they contain the  \" new version \"  of your configurations and can be safely removed. " + " If you want, you can manually copy their content into your regular configuration files (replacing the old config). " ) ; throw new WritingException ( msg , e ) ; } catch ( IOException e ) { String msg = String . format ( " Failed to atomically write (%s) the config to: %s " , writingMode . toString ( ) , tmp . toString ( ) ) ; throw new WritingException ( msg , e ) ; } } else { BufferedWriter fileWriter ; OpenOption lastOption = ( writingMode = = WritingMode . APPEND ) ? APPEND : TRUNCATE_EXISTING ; try { fileWriter = Files . newBufferedWriter ( nioPath , charset , WRITE , CREATE , lastOption ) ; } catch ( IOException e ) { throw new WritingException ( " Failed to open a BufferedWriter on:  " + nioPath , e ) ; } configWriter . write ( copy , fileWriter ) ; try { if ( closed ) { fileWriter . close ( ) ; } else { fileWriter . flush ( ) ; } } catch ( IOException e ) { String op = closed ? " close " : " flush " ; String msg = String . format ( " Buffer %s failed while saving asynchronous FileConfig. " , op ) ; throw new WritingException ( msg , e ) ; } } } saveListener . run ( ) ; }
public String buildCoverUrl ( String serverName , String musicPath , String path , String fileName ) { if ( musicPath . startsWith ( URL_PREFIX ) ) { int hostPortEnd = musicPath . indexOf ( URL_PREFIX . length ( ) , '/' ) ; if ( hostPortEnd = = - 1 ) { hostPortEnd = musicPath . length ( ) ; } serverName = musicPath . substring ( URL_PREFIX . length ( ) , hostPortEnd ) ; musicPath = musicPath . substring ( hostPortEnd ) ; } Uri . Builder b = Uri . parse ( URL_PREFIX + serverName ) . buildUpon ( ) ; Uri uri = b . appendPath ( musicPath ) . appendPath ( path ) . appendPath ( fileName ) . build ( ) ; return uri . toString ( ) ; }
public void connectionStateChanged ( final boolean connected , final boolean connectionLost ) { super . connectionStateChanged ( connected , connectionLost ) ; if ( connected ) { try {
public AS2ClientResponse sendSynchronous ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2ClientRequest aRequest ) { ValueEnforcer . notNull ( aSettings , " ClientSettings " ) ; ValueEnforcer . notNull ( aRequest , " ClientRequest " ) ; final AS2ClientResponse aResponse = createResponse ( ) ; IMessage aMsg = null ; final StopWatch aSW = StopWatch . createdStarted ( ) ; try { final Partnership aPartnership = buildPartnership ( aSettings ) ; aMsg = createMessage ( aPartnership , aRequest ) ; aResponse . setOriginalMessageID ( aMsg . getMessageID ( ) ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " MessageID to send:  " + aMsg . getMessageID ( ) ) ; final boolean bHasRetries = aSettings . getRetryCount ( ) > 0 ; final AS2Session aSession = createSession ( ) ; initCertificateFactory ( aSettings , aSession ) ; initPartnershipFactory ( aSession ) ; initMessageProcessor ( aSession ) ; if ( bHasRetries ) { final IProcessorResenderModule aResender = new ImmediateResenderModule ( ) ; aResender . initDynamicComponent ( aSession , null ) ; aSession . getMessageProcessor ( ) . addModule ( aResender ) ; } aSession . getMessageProcessor ( ) . startActiveModules ( ) ; try { beforeSend ( aSettings , aSession , aMsg ) ; final ICommonsMap < String , Object > aHandleOptions = new CommonsHashMap < > ( ) ; if ( bHasRetries ) aHandleOptions . put ( IProcessorResenderModule . OPTION_RETRIES , Integer . toString ( aSettings . getRetryCount ( ) ) ) ; aPartnership . setContentTransferEncodingSend ( aRequest . getContentTransferEncoding ( ) ) ; aPartnership . setContentTransferEncodingReceive ( aRequest . getContentTransferEncoding ( ) ) ; final AS2SenderModule aSender = m_aAS2SenderModuleFactory . get ( ) ; aSender . initDynamicComponent ( aSession , null ) ; aSender . putIn ( AbstractHttpSenderModule . ATTR_CONNECT_TIMEOUT , aSettings . getConnectTimeoutMS ( ) ) ; aSender . putIn ( AbstractHttpSenderModule . ATTR_READ_TIMEOUT , aSettings . getReadTimeoutMS ( ) ) ; aMsg . headers ( ) . setAllHeaders ( aSettings . customHeaders ( ) ) ; aSession . getMessageProcessor ( ) . addModule ( aSender ) ; aSender . handle ( IProcessorSenderModule . DO_SEND , aMsg , aHandleOptions ) ; } finally { aSession . getMessageProcessor ( ) . stopActiveModules ( ) ; } } catch ( final Throwable t ) { LOGGER . error ( " Error sending AS2 message " , t ) ; aResponse . setException ( t ) ; } finally { if ( aMsg ! = null & & aMsg . getMDN ( ) ! = null ) { aResponse . setMDN ( aMsg . getMDN ( ) ) ; } } if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Response retrieved:  " + aResponse . getAsString ( ) ) ; aResponse . setExecutionDuration ( aSW . stopAndGetDuration ( ) ) ; return aResponse ; }
public BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , transcoder ) ; }
public void onChange ( float v ) { minPriority = ( float ) ( 1.0 - v ) ; setUpdateNext ( ) ; }
public void setExecutionDuration ( @Nonnull final Duration aExecutionDuration ) { ValueEnforcer . notNull ( aExecutionDuration , " ExecutionDuration " ) ; m_aExecutionDuration = aExecutionDuration ; }
public boolean get_data_2 ( Term key , Term res ) { Term result = dict . get ( key . toString ( ) ) ; return unify ( res , result ) ; }
void save ( String filename , char [ ] password ) throws OpenAS2Exception ; void save ( OutputStream out , char [ ] password ) throws OpenAS2Exception ; }
private static boolean testBST ( ) { { System . out . println ( " Binary search tree with first HashNode. " ) ; BinarySearchTree < Integer > bst = new BinarySearchTree < Integer > ( BinarySearchTree . TYPE . FIRST ) ; for ( int i : unsorted ) { bst . add ( i ) ; boolean exists = bst . contains ( i ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + i + "  doesn't exists. " ) ; handleError ( bst ) ; return false ; } } System . out . println ( bst . toString ( ) ) ; int next = RANDOM . nextInt ( unsorted . length * 100 ) ; System . out . println ( " Adding a new HashNode  " + next ) ; bst . add ( next ) ; System . out . println ( bst . toString ( ) ) ; System . out . println ( " Removing a HashNode  " + next ) ; bst . remove ( next ) ; System . out . println ( bst . toString ( ) ) ; next = RANDOM . nextInt ( unsorted . length ) ; boolean contains = bst . contains ( unsorted [ next ] ) ; System . out . println ( " Does  " + unsorted [ next ] + "  exist in the BST?  " + contains ) ; System . out . println ( " Removing a previously added HashNode  " + unsorted [ next ] ) ; bst . remove ( unsorted [ next ] ) ; System . out . println ( bst . toString ( ) ) ; for ( int i : unsorted ) { bst . remove ( i ) ; boolean exists = bst . contains ( i ) ; if ( exists ) { handleError ( bst ) ; return false ; } } System . out . println ( ) ; } { System . out . println ( " Binary search tree with middle HashNode. " ) ; BinarySearchTree < Integer > bst = new BinarySearchTree < Integer > ( BinarySearchTree . TYPE . MIDDLE ) ; for ( int i : unsorted ) { bst . add ( i ) ; boolean exists = bst . contains ( i ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + i + "  doesn't exists. " ) ; handleError ( bst ) ; return false ; } } System . out . println ( bst . toString ( ) ) ; int next = RANDOM . nextInt ( unsorted . length * 100 ) ; System . out . println ( " Adding a new HashNode  " + next ) ; bst . add ( next ) ; System . out . println ( bst . toString ( ) ) ; System . out . println ( " Removing a HashNode  " + next ) ; bst . remove ( next ) ; System . out . println ( bst . toString ( ) ) ; next = RANDOM . nextInt ( unsorted . length ) ; boolean contains = bst . contains ( unsorted [ next ] ) ; System . out . println ( " Does  " + unsorted [ next ] + "  exist in the BST?  " + contains ) ; System . out . println ( " Removing a previously added HashNode  " + unsorted [ next ] ) ; bst . remove ( unsorted [ next ] ) ; System . out . println ( bst . toString ( ) ) ; for ( int i : unsorted ) { bst . remove ( i ) ; boolean exists = bst . contains ( i ) ; if ( exists ) { System . err . println ( " YIKES!!  " + i + "  still exists. " ) ; handleError ( bst ) ; return false ; } } System . out . println ( ) ; } { System . out . println ( " Binary search tree using random HashNode. " ) ; BinarySearchTree < Integer > bst = new BinarySearchTree < Integer > ( BinarySearchTree . TYPE . RANDOM ) ; for ( int i : unsorted ) { bst . add ( i ) ; boolean exists = bst . contains ( i ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + i + "  doesn't exists. " ) ; handleError ( bst ) ; return false ; } } System . out . println ( bst . toString ( ) ) ; int next = RANDOM . nextInt ( unsorted . length * 100 ) ; System . out . println ( " Adding a new HashNode  " + next ) ; bst . add ( next ) ; System . out . println ( bst . toString ( ) ) ; System . out . println ( " Removing a HashNode  " + next ) ; bst . remove ( next ) ; System . out . println ( bst . toString ( ) ) ; next = RANDOM . nextInt ( unsorted . length ) ; boolean contains = bst . contains ( unsorted [ next ] ) ; System . out . println ( " Does  " + unsorted [ next ] + "  exist in the BST?  " + contains ) ; System . out . println ( " Removing a previously added HashNode  " + unsorted [ next ] ) ; bst . remove ( unsorted [ next ] ) ; System . out . println ( bst . toString ( ) ) ; for ( int i : unsorted ) { bst . remove ( i ) ; boolean exists = bst . contains ( i ) ; if ( exists ) { System . err . println ( " YIKES!!  " + i + "  still exists. " ) ; handleError ( bst ) ; return false ; } } System . out . println ( ) ; } return true ; }
public Object get ( int arg0 ) { return internalRow . get ( arg0 ) ; }
private static KdNode createNode ( List < XYZPoint > list , int k , int depth ) { if ( list = = null | | list . size ( ) = = 0 ) return null ; int axis = depth % k ; if ( axis = = X_AXIS ) Collections . sort ( list , X_COMPARATOR ) ; else if ( axis = = Y_AXIS ) Collections . sort ( list , Y_COMPARATOR ) ; else if ( axis = = Z_AXIS ) Collections . sort ( list , Z_COMPARATOR ) ; int mediaIndex = list . size ( ) / 2 ; KdNode node = new KdNode ( k , depth , list . get ( mediaIndex ) ) ; if ( list . size ( ) > 0 ) { if ( ( mediaIndex - 1 ) > = 0 ) { List < XYZPoint > less = list . subList ( 0 , mediaIndex ) ; if ( less . size ( ) > 0 ) { node . lesser = createNode ( less , k , depth + 1 ) ; node . lesser . parent = node ; } } if ( ( mediaIndex + 1 ) < = ( list . size ( ) - 1 ) ) { List < XYZPoint > more = list . subList ( mediaIndex + 1 , list . size ( ) ) ; if ( more . size ( ) > 0 ) { node . greater = createNode ( more , k , depth + 1 ) ; node . greater . parent = node ; } } } return node ; }
public boolean equals ( final Object obj ) { return ( obj instanceof RangeList ) & & equals ( ( RangeList ) obj ) ; }
public BagObserver < Concept > createBagObserver ( ) { return new BagWindow < Concept > ( ) ; }
public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperation op = new DeleteOperationImpl ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }
public void initDynamicComponent ( @Nonnull final IAS2Session aSession , @Nullable final IStringMap aOptions ) throws OpenAS2Exception { super . initDynamicComponent ( aSession , aOptions ) ; getAttributeAsStringRequired ( ATTR_POLLING_INTERVAL ) ; }
public static double kthSmallestValue ( int [ ] array , int k ) { int [ ] index = new int [ array . length ] ; for ( int i = 0 ; i < index . length ; i + + ) { index [ i ] = i ; } return array [ index [ select ( array , index , 0 , array . length - 1 , k ) ] ] ; }
public void receivedStatus ( OperationStatus s ) { } } ) ; } } , false ) ; try { return blatch . await ( timeout , unit ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for queues " , e ) ; } } public boolean addObserver ( ConnectionObserver obs ) { return conn . addObserver ( obs ) ; } public boolean removeObserver ( ConnectionObserver obs ) { return conn . removeObserver ( obs ) ; } }
public void testCreateTopology ( ) { Topology topology = factory . createTopology ( topoName ) ; assertNotNull ( " Topology created is null. " , topology ) ; assertEquals ( " Topology created is not a SimpleTopology. " , SimpleTopology . class , topology . getClass ( ) ) ; }
public void onReceive ( Context context , Intent intent ) { final Bundle bundle = intent . getBundleExtra ( LocaleConstants . EXTRA_BUNDLE ) ; if ( bundle = = null ) { return ; } final String action = bundle . getString ( EditActivity . BUNDLE_ACTION_STRING ) ; switch ( action ) { case NotificationService . ACTION_OPEN_NOTIFICATION :
public void onCreate ( final Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; if ( savedInstanceState ! = null ) { init ( savedInstanceState . getString ( EXTRA_PLAYLIST_NAME ) ) ;
private boolean findConnection ( int width , int height ) { for ( int x = 0 ; x < width ; x + + ) { for ( int y = 0 ; y < height ; y + + ) { if ( level [ x ] [ y ] = = TILE_LEVEL & & data [ x ] [ y ] = = - 1 ) { connect ( x , y , width , height ) ; return true ; } } } return false ; }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o instanceof com . googlecode . opennars . parser . loan . Loan . Absyn . LitQVarAn ) { return true ; } return false ; }
protected void onCreate ( final Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . library_tabs ) ; final LayoutInflater inflater = ( LayoutInflater ) getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; mTitleView = ( TextView ) inflater . inflate ( R . layout . actionbar_title , null ) ; mTitleView . setFocusable ( true ) ; mTitleView . setFocusableInTouchMode ( true ) ; mTitleView . setSelected ( true ) ; mTitleView . requestFocus ( ) ; final ActionBar actionBar = getActionBar ( ) ; if ( actionBar ! = null ) { actionBar . setCustomView ( mTitleView ) ; actionBar . setDisplayShowTitleEnabled ( false ) ; actionBar . setDisplayShowCustomEnabled ( true ) ; } if ( savedInstanceState = = null ) { final Fragment rootFragment = getRootFragment ( ) ; if ( rootFragment ! = null ) { if ( rootFragment instanceof BrowseFragment ) { setTitle ( ( ( BrowseFragment ) rootFragment ) . getTitle ( ) ) ; } final FragmentTransaction ft = getSupportFragmentManager ( ) . beginTransaction ( ) ; ft . setTransition ( FragmentTransaction . TRANSIT_FRAGMENT_OPEN ) ; ft . replace ( R . id . root_frame , rootFragment ) ; ft . commit ( ) ; } else { throw new RuntimeException ( " Error : SimpleLibraryActivity root fragment is null " ) ; } } else { refreshTitleFromCurrentFragment ( ) ; } getSupportFragmentManager ( ) . addOnBackStackChangedListener ( this ) ; }
synchronized List sendCommandQueue ( ) throws MPDServerException { String command = MPD_CMD_START_BULK + " \ n " + commandQueue . toString ( ) + MPD_CMD_END_BULK + " \ n " ; this . commandQueue = new StringBuffer ( ) ; return sendRawCommand ( command ) ; }
public long latest ( ) { long v = list [ 0 ] ; for ( int i = 1 ; i < length ( ) ; i + + ) if ( list [ i ] > v ) v = list [ i ] ; return v ; }
public static Result unban ( String artist , String track , Session session ) { return Caller . getInstance ( ) . call ( " track.unban " , session , " artist " , artist , " track " , track ) ; }
public void init ( ) { setSpeed ( 0 ) ; setSpeed ( 0 ) ; updateGUI ( ) ; nar . memory . event . on ( CycleEnd . class , this ) ; }
private int updateWeight ( Entry < K , V > e ) { int weight = 1 ; if ( e . left ! = null ) { weight + = updateWeight ( e . left ) ; } if ( e . right ! = null ) { weight + = updateWeight ( e . right ) ; } e . weight = weight ; return weight ; }
public void handle ( final String sAaction , final IMessage aMsg , final Map < String , Object > aOptions ) throws OpenAS2Exception { throw new UnsupportedException ( " Active modules don't handle anything by default " ) ; }
public void playlistChanged ( MPDPlaylistChangedEvent event ) { } @Override public void randomChanged ( MPDRandomChangedEvent event ) { pRandom . setChecked ( event . isRandom ( ) ) ; } @Override public void repeatChanged ( MPDRepeatChangedEvent event ) { pRepeat . setChecked ( event . isRepeat ( ) ) ; } @Override public void stateChanged ( MPDStateChangedEvent event ) { } @Override public void trackChanged ( MPDTrackChangedEvent event ) { } @Override public void updateStateChanged ( MPDUpdateStateChangedEvent event ) { } @Override public void volumeChanged ( MPDVolumeChangedEvent event ) { } }
public String makeName ( ) { return makeImageName ( Symbols . IMAGE_INT_OPERATOR , components , relationIndex ) ; }
HttpFuture < View > asyncGetView ( final String designDocumentName , final String viewName ) ; HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) ; ViewResponse query ( View view , Query query ) ; }
private boolean fileExists ( String file ) { File theFile = new File ( file ) ; return theFile . exists ( ) ; }
public void clear ( ) ; public Concept concept ( Term term ) ; public Concept conceptualize ( BudgetValue budget , Term term , boolean createIfMissing ) ; public void activate ( Concept c , BudgetValue b , Activating mode ) ; public Concept sampleNextConcept ( ) ; public void init ( Memory m ) ; public void conceptRemoved ( Concept c ) ; }
public byte nextTick ( ) { if ( tickCount = = - 99999999 ) { try { tickCount = dis . readInt ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } if ( tickCount = = 0 ) { try { tick = ( byte ) dis . read ( ) ; tickCount = dis . readInt ( ) ; } catch ( IOException e ) { } } if ( tickCount > 0 ) { tickCount - - ; } return tick ; }
protected void decodePayload ( byte [ ] pl ) { ErrorCode ec = ErrorCode . getErrorCode ( ( byte ) errorCode ) ; getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) , ec ) ) ; }
private void enqueue ( Node node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node oldHead = head ; head = node ; node . nextNode = oldHead ; oldHead . previousNode = node ; } size + + ; }
OperationImpl removeCurrentReadOp ( ) ; OperationImpl getCurrentWriteOp ( ) ; OperationImpl removeCurrentWriteOp ( ) ; boolean hasReadOp ( ) ; boolean hasWriteOp ( ) ; void addOp ( OperationImpl op ) ; int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; }
public void testGetStatsCacheDump ( ) throws Exception { client . set ( " dumpinitializer " , 0 , " hi " ) ; Map < SocketAddress , Map < String , String > > stats = client . getStats ( " cachedump 1 10000 " ) ; System . out . println ( " Stats cachedump:   " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; String val = oneStat . get ( " dumpinitializer " ) ; assertTrue ( val + " doesn't match " , val . matches ( " \\ [2 b;  \\ d+ s \\ ] " ) ) ; }
public boolean isSingleValued ( ) { return true ; }
private static boolean runTests ( ) { testIndex = 0 ; testNumber + + ; System . out . println ( " Generating data. " ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Array= " ) ; unsorted = new Integer [ ARRAY_SIZE ] ; java . util . Set < Integer > set = new java . util . HashSet < Integer > ( ) ; for ( int i = 0 ; i < ARRAY_SIZE ; i + + ) { Integer j = RANDOM . nextInt ( RANDOM_SIZE ) ; boolean found = true ; while ( found ) { if ( set . contains ( j ) ) { j = RANDOM . nextInt ( RANDOM_SIZE ) ; } else { unsorted [ i ] = j ; set . add ( j ) ; found = false ; } } unsorted [ i ] = j ; builder . append ( j ) . append ( ',' ) ; } builder . append ( '\n' ) ; string = builder . toString ( ) ; if ( debug > 1 ) System . out . println ( string ) ; sorted = Arrays . copyOf ( unsorted , unsorted . length ) ; Arrays . sort ( sorted ) ; System . out . println ( " Generated data. " ) ; boolean passed = true ; passed = testAVLTree ( ) ; if ( ! passed ) { System . err . println ( " AVL Tree failed. " ) ; return false ; } passed = testBTree ( ) ; if ( ! passed ) { System . err . println ( " B-Tree failed. " ) ; return false ; } passed = testBST ( ) ; if ( ! passed ) { System . err . println ( " BST failed. " ) ; return false ; } passed = testHeap ( ) ; if ( ! passed ) { System . err . println ( " Heap failed. " ) ; return false ; } passed = testHashMap ( ) ; if ( ! passed ) { System . err . println ( " Hash Map failed. " ) ; return false ; } passed = testList ( ) ; if ( ! passed ) { System . err . println ( " List failed. " ) ; return false ; } passed = testPatriciaTrie ( ) ; if ( ! passed ) { System . err . println ( " Patricia Trie failed. " ) ; return false ; } passed = testQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } passed = testRadixTrie ( ) ; if ( ! passed ) { System . err . println ( " Radix Trie failed. " ) ; return false ; } passed = testRedBlackTree ( ) ; if ( ! passed ) { System . err . println ( " Red-Black Tree failed. " ) ; return false ; } passed = testSkipList ( ) ; if ( ! passed ) { System . err . println ( " Skip List failed. " ) ; return false ; } passed = testSplayTree ( ) ; if ( ! passed ) { System . err . println ( " Splay Tree failed. " ) ; return false ; } passed = testStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } passed = testTreap ( ) ; if ( ! passed ) { System . err . println ( " Treap failed. " ) ; return false ; } passed = testTreeMap ( ) ; if ( ! passed ) { System . err . println ( " Tree Map failed. " ) ; return false ; } passed = testTrie ( ) ; if ( ! passed ) { System . err . println ( " Trie failed. " ) ; return false ; } passed = testTrieMap ( ) ; if ( ! passed ) { System . err . println ( " Trie Map failed. " ) ; return false ; } passed = testJavaHeap ( ) ; if ( ! passed ) { System . err . println ( " Java Heap failed. " ) ; return false ; } passed = testJavaHashMap ( ) ; if ( ! passed ) { System . err . println ( " Java Hash Map failed. " ) ; return false ; } passed = testJavaList ( ) ; if ( ! passed ) { System . err . println ( " Java List failed. " ) ; return false ; } passed = testJavaQueue ( ) ; if ( ! passed ) { System . err . println ( " Java Queue failed. " ) ; return false ; } passed = testJavaRedBlackTree ( ) ; if ( ! passed ) { System . err . println ( " Java Red-Black failed. " ) ; return false ; } passed = testJavaStack ( ) ; if ( ! passed ) { System . err . println ( " Java Stack failed. " ) ; return false ; } passed = testJavaTreeMap ( ) ; if ( ! passed ) { System . err . println ( " Java Tree Map failed. " ) ; return false ; } if ( debugTime & & debugMemory ) { String results = getTestResults ( testNumber , testNames , testResults ) ; System . out . println ( results ) ; } passed = testCompactSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Compact Suffix Trie failed. " ) ; return false ; } passed = testGraph ( ) ; if ( ! passed ) { System . err . println ( " Graph failed. " ) ; return false ; } passed = testIntervalTree ( ) ; if ( ! passed ) { System . err . println ( " Interval Tree failed. " ) ; return false ; } passed = testKdTree ( ) ; if ( ! passed ) { System . err . println ( " k-d Tree Tree failed. " ) ; return false ; } passed = testMatrix ( ) ; if ( ! passed ) { System . err . println ( " Matrix failed. " ) ; return false ; } passed = testSegmentTree ( ) ; if ( ! passed ) { System . err . println ( " Segment Tree failed. " ) ; return false ; } passed = testSuffixTree ( ) ; if ( ! passed ) { System . err . println ( " Suffix Tree failed. " ) ; return false ; } passed = testSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Suffix Trie failed. " ) ; return false ; } return true ; }
public void emit ( final Class eventClass , final Object . . . params ) { if ( events . get ( eventClass ) = = null ) return ; List < Observer > observers = events . get ( eventClass ) ; if ( observers = = null ) return ; if ( observers . size ( ) = = 0 ) return ; int n = observers . size ( ) ; for ( int i = 0 ; i < n ; i + + ) { final Observer m = observers . get ( i ) ;
protected Partnership buildPartnership ( @Nonnull final AS2ClientSettings aSettings ) { final Partnership aPartnership = new Partnership ( aSettings . getPartnershipName ( ) ) ; aPartnership . setSenderAS2ID ( aSettings . getSenderAS2ID ( ) ) ; aPartnership . setSenderX509Alias ( aSettings . getSenderKeyAlias ( ) ) ; aPartnership . setSenderEmail ( aSettings . getSenderEmailAddress ( ) ) ; aPartnership . setReceiverAS2ID ( aSettings . getReceiverAS2ID ( ) ) ; aPartnership . setReceiverX509Alias ( aSettings . getReceiverKeyAlias ( ) ) ; aPartnership . setAttribute ( CPartnershipIDs . PA_AS2_URL , aSettings . getDestinationAS2URL ( ) ) ; aPartnership . setAttribute ( CPartnershipIDs . PA_ENCRYPT , aSettings . getCryptAlgoID ( ) ) ; aPartnership . setAttribute ( CPartnershipIDs . PA_SIGN , aSettings . getSignAlgoID ( ) ) ; aPartnership . setAttribute ( CPartnershipIDs . PA_PROTOCOL , AS2Message . PROTOCOL_AS2 ) ; aPartnership . setAttribute ( CPartnershipIDs . PA_MESSAGEID_FORMAT , aSettings . getMessageIDFormat ( ) ) ; aPartnership . setAttribute ( CPartnershipIDs . PA_AS2_MDN_OPTIONS , aSettings . getMDNOptions ( ) ) ; if ( false ) aPartnership . setAttribute ( CPartnershipIDs . PA_AS2_MDN_TO , " http://localhost:10080 " ) ; aPartnership . setAttribute ( CPartnershipIDs . PA_AS2_RECEIPT_OPTION , null ) ; if ( aSettings . getCompressionType ( ) ! = null ) { aPartnership . setAttribute ( CPartnershipIDs . PA_COMPRESSION_TYPE , aSettings . getCompressionType ( ) . getID ( ) ) ; aPartnership . setAttribute ( CPartnershipIDs . PA_COMPRESSION_MODE , aSettings . isCompressBeforeSigning ( ) ? CPartnershipIDs . COMPRESS_BEFORE_SIGNING : CPartnershipIDs . COMPRESS_AFTER_SIGNING ) ; } return aPartnership ; }
public void testGraphPlan ( String input , String expected ) throws IOException { NAR n = new DefaultNARBuilder ( ) . build ( ) ; AtomicBoolean success = new AtomicBoolean ( true ) ; n . addOutput ( new Output ( ) { @Override public void output ( Class channel , Object o ) { System . out . println ( o ) ; if ( o . toString ( ) . contains ( expected ) ) success . set ( true ) ; } } ) ; n . addInput ( input ) ; new NARSwing ( n ) ; new NWindow ( " Implication Graph " , new ProcessingGraphPanel ( n ,
public boolean hasNext ( ) { return this . currentRopePos > 0 | | ! this . toTraverse . isEmpty ( ) ; }
private void assertDouble ( double d ) { assertEquals ( d , tc . decode ( tc . encode ( d ) ) ) ; }
void hrend_DrawEnd ( ) { } public void hrend_DrawGUI ( ) { } @Override public void setup ( ) { frameRate ( FrameRate ) ; } int calcevery = 100 ; int calci = 0 ; float rendersize = 100 ; public void drawit ( ) { calci + + ; if ( calci % 100 = = 0 ) { A . Exec ( ) ; } strokeCap ( SQUARE ) ; strokeJoin ( PROJECT ) ; fill ( 255 ) ; for ( int i = 0 ; i < A . n ; i + + ) { for ( int j = 0 ; j < A . n ; j + + ) { fill ( 255 ) ; if ( i = = 0 | | i = = A . n - 1 | | j = = 0 | | j = = A . n - 1 ) { fill ( 0 , 0 , 255 ) ; rect ( i * rendersize , j * rendersize , rendersize , rendersize ) ; } else if ( A . readCells [ i ] [ j ] . state = = 0 ) { fill ( 255 ) ; rect ( i * 100 , j * rendersize , rendersize , rendersize ) ; } else { fill ( 128 ) ; rect ( i * rendersize , j * rendersize , rendersize , rendersize ) ; } } } } class ProcessingJs { ProcessingJs ( ) { addMouseWheelListener ( new java . awt . event . MouseWheelListener ( ) { public void mouseWheelMoved ( java . awt . event . MouseWheelEvent evt ) { mouseScroll = - evt . getWheelRotation ( ) ; mouseScrolled ( ) ; } } ) ; } } class Hnav { private float savepx = 0 ; private float savepy = 0 ; private int selID = 0 ; private float zoom = 1.0f ; private float difx = 0 ; private float dify = 0 ; private int lastscr = 0 ; private boolean EnableZooming = true ; private float scrollcamspeed = 1.1f ; float MouseToWorldCoordX ( int x ) { return 1 / zoom * ( x - difx - width / 2 ) ; } float MouseToWorldCoordY ( int y ) { return 1 / zoom * ( y - dify - height / 2 ) ; } private boolean md = false ; void mousePressed ( ) { md = true ; if ( mouseButton = = RIGHT ) { savepx = mouseX ; savepy = mouseY ; } drawn = false ; } void mouseReleased ( ) { md = false ; } void mouseDragged ( ) { if ( mouseButton = = RIGHT ) { difx + = ( mouseX - savepx ) ; dify + = ( mouseY - savepy ) ; savepx = mouseX ; savepy = mouseY ; } drawn = false ; } private float camspeed = 20.0f ; private float scrollcammult = 0.92f ; boolean keyToo = true ; void keyPressed ( ) { if ( ( keyToo & & key = = 'w' ) | | keyCode = = UP ) { dify + = ( camspeed ) ; } if ( ( keyToo & & key = = 's' ) | | keyCode = = DOWN ) { dify + = ( - camspeed ) ; } if ( ( keyToo & & key = = 'a' ) | | keyCode = = LEFT ) { difx + = ( camspeed ) ; } if ( ( keyToo & & key = = 'd' ) | | keyCode = = RIGHT ) { difx + = ( - camspeed ) ; } if ( ! EnableZooming ) { return ; } if ( key = = '-' | | key = = '#' ) { float zoomBefore = zoom ; zoom * = scrollcammult ; difx = ( difx ) * ( zoom / zoomBefore ) ; dify = ( dify ) * ( zoom / zoomBefore ) ; } if ( key = = '+' ) { float zoomBefore = zoom ; zoom / = scrollcammult ; difx = ( difx ) * ( zoom / zoomBefore ) ; dify = ( dify ) * ( zoom / zoomBefore ) ; } drawn = false ; } void Init ( ) { difx = - width / 2 ; dify = - height / 2 ; } void mouseScrolled ( ) { if ( ! EnableZooming ) { return ; } float zoomBefore = zoom ; if ( mouseScroll > 0 ) { zoom * = scrollcamspeed ; } else { zoom / = scrollcamspeed ; } difx = ( difx ) * ( zoom / zoomBefore ) ; dify = ( dify ) * ( zoom / zoomBefore ) ; drawn = false ; } void Transform ( ) { translate ( difx + 0.5f * width , dify + 0.5f * height ) ; scale ( zoom , zoom ) ; } } class Hsim { ArrayList obj = new ArrayList ( ) ; void Init ( ) { smooth ( ) ; } void mousePressed ( ) { if ( mouseButton = = LEFT ) { checkSelect ( ) ; float x = hnav . MouseToWorldCoordX ( mouseX ) ; float y = hnav . MouseToWorldCoordY ( mouseY ) ; automataclicked ( x , y ) ; } } boolean dragged = false ; void mouseDragged ( ) { if ( mouseButton = = LEFT ) { dragged = true ; dragElems ( ) ; } } void mouseReleased ( ) { dragged = false ; } void dragElems ( ) { } void checkSelect ( ) { } } class Hamlib { void Init ( ) { noStroke ( ) ; hnav . Init ( ) ; hsim . Init ( ) ; } void mousePressed ( ) { hnav . mousePressed ( ) ; hsim . mousePressed ( ) ; } void mouseDragged ( ) { hnav . mouseDragged ( ) ; hsim . mouseDragged ( ) ; } void mouseReleased ( ) { hnav . mouseReleased ( ) ; hsim . mouseReleased ( ) ; } public void mouseMoved ( ) { } void keyPressed ( ) { hnav . keyPressed ( ) ; } void mouseScrolled ( ) { hnav . mouseScrolled ( ) ; } void Camera ( ) { } } } public class TestChamber extends Window { TestChamber_applet app = null ; public TestChamber ( NAR n ) { super ( " TestChamber " ) ; app = new TestChamber_applet ( ) ; app . init ( ) ; app . nar = n ; this . setSize ( 1000 , 860 ) ; this . setVisible ( true ) ; Container content = getContentPane ( ) ; content . setLayout ( new BorderLayout ( ) ) ; JPanel menu = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; content . add ( menu , BorderLayout . NORTH ) ; content . add ( app , BorderLayout . CENTER ) ; } @Override protected void close ( ) { app . stop ( ) ; app . destroy ( ) ; getContentPane ( ) . removeAll ( ) ; app = null ; } public static void main ( String [ ] arg ) { NAR n = new NAR ( ) ; new TestChamber ( n ) ; } }
final void close ( boolean allMenusAreClosing ) { if ( mIsClosing ) return ; mIsClosing = true ; for ( WeakReference < MenuPresenter > ref : mPresenters ) { final MenuPresenter presenter = ref . get ( ) ; if ( presenter = = null ) { mPresenters . remove ( ref ) ; } else { presenter . onCloseMenu ( this , allMenusAreClosing ) ; } } mIsClosing = false ; }
public void identifyFunctor ( Term term ) { identify ( term , PrimitiveInfo . FUNCTOR ) ; }
public void testKdTree ( ) { List < XYZPoint > points = new ArrayList < XYZPoint > ( ) ; XYZPoint p1 = new XYZPoint ( 2 , 3 ) ; points . add ( p1 ) ; XYZPoint p2 = new XYZPoint ( 5 , 4 ) ; points . add ( p2 ) ; XYZPoint p3 = new XYZPoint ( 9 , 6 ) ; points . add ( p3 ) ; XYZPoint p4 = new XYZPoint ( 4 , 7 ) ; points . add ( p4 ) ; XYZPoint p5 = new XYZPoint ( 8 , 1 ) ; points . add ( p5 ) ; XYZPoint p6 = new XYZPoint ( 7 , 2 ) ; points . add ( p6 ) ; KdTree < XYZPoint > kdTree = new KdTree < XYZPoint > ( points ) ; Collection < XYZPoint > result = kdTree . nearestNeighbourSearch ( 1 , p3 ) ; assertTrue ( " K-D Tree query error. query=(k=1, p=(9, 6)) returned= " + result , result . contains ( p3 ) ) ; XYZPoint search = new XYZPoint ( 1 , 4 ) ; result = kdTree . nearestNeighbourSearch ( 4 , search ) ; assertTrue ( " K-D Tree query error. query=(k=4, p=(1, 4)) returned= " + result , ( result . contains ( p1 ) & & result . contains ( p2 ) & & result . contains ( p4 ) & & result . contains ( p6 ) ) ) ; kdTree . remove ( p6 ) ; kdTree . remove ( p4 ) ; kdTree . remove ( p3 ) ; kdTree . remove ( p5 ) ; kdTree . remove ( p1 ) ; kdTree . remove ( p2 ) ; }
public int hashCode ( ) { final int code = this . value . hashCode ( ) + this . weight + this . edges . size ( ) ; return 31 * code ; }
public AbstractViewHolder findInnerViews ( View targetView ) { SongViewHolder viewHolder = new SongViewHolder ( ) ; viewHolder . mTrackTitle = ( TextView ) targetView . findViewById ( R . id . track_title ) ; viewHolder . mTrackNumber = ( TextView ) targetView . findViewById ( R . id . track_number ) ; viewHolder . mTrackDuration = ( TextView ) targetView . findViewById ( R . id . track_duration ) ; viewHolder . mTrackArtist = ( TextView ) targetView . findViewById ( R . id . track_artist ) ; return viewHolder ; }
protected void connect ( ) throws Exception { client = new KuduClient . KuduClientBuilder ( this . connection ) . build ( ) ; table = client . openTable ( getTableName ( ) ) ; session = client . newSession ( ) ; session . setIgnoreAllDuplicateRows ( false ) ; session . setFlushMode ( FlushMode . MANUAL_FLUSH ) ; }
public boolean isSigned ( @Nonnull final MimeBodyPart aPart ) throws MessagingException { final ContentType aContentType = new ContentType ( aPart . getContentType ( ) ) ; final String sBaseType = aContentType . getBaseType ( ) . toLowerCase ( Locale . US ) ; return sBaseType . equals ( " multipart/signed " ) ; }
public void applySubstitute ( final HashMap < Term , Term > subs ) { int i = 0 ; for ( final Term t1 : components ) { if ( subs . containsKey ( t1 ) ) { Term t2 = subs . get ( t1 ) ; while ( subs . containsKey ( t2 ) ) { t2 = subs . get ( t2 ) ; } components . set ( i , ( Term ) t2 . clone ( ) ) ; } else if ( t1 instanceof CompoundTerm ) { ( ( CompoundTerm ) t1 ) . applySubstitute ( subs ) ; } i + + ; } if ( this . isCommutative ( ) ) { Collections . sort ( components ) ; } name = makeName ( ) ; }
public void update ( NARGraphDisplay style , GraphDisplay layout ) { this . style = style ; this . layout = layout ; displays . sequence . clear ( ) ; displays . sequence . add ( style ) ; displays . sequence . add ( layout ) ; }
protected static CharSequence makeSetName ( final char opener , final Term [ ] arg , final char closer ) { int size = 1 + 1 - 1 ; for ( final Term t : arg ) size + = 1 + t . name ( ) . length ( ) ; final CharBuffer n = CharBuffer . allocate ( size ) ; n . append ( opener ) ; for ( int i = 0 ; i < arg . length ; i + + ) { if ( i ! = 0 ) n . append ( Symbols . ARGUMENT_SEPARATOR ) ; n . append ( arg [ i ] . name ( ) ) ; } n . append ( closer ) ; return n . compact ( ) ; }
public static void main ( String [ ] args ) { NAR nar = new DefaultNARBuilder ( ) . build ( ) ; new NARPhysics < Rover > ( nar , new Rover ( ) ) { } ; nar . start ( 50 , 1 ) ;
boolean isCancelled ( ) ; boolean hasErrored ( ) ; OperationException getException ( ) ; OperationCallback getCallback ( ) ; void cancel ( ) ; OperationState getState ( ) ; ByteBuffer getBuffer ( ) ; void writeComplete ( ) ; void initialize ( ) ; void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; }
public void testKnownPaths ( ) { Validation v = new IfPathExistsValidation ( " hello " , Validations . single ( ) . allowedValues ( " world " , 2 ) ) ; assertEquals ( Sets . newHashSet ( " hello " , " world " ) , v . getKnownPaths ( ) ) ; }
public void save ( ) { if ( closed ) { throw new IllegalStateException ( " This FileConfig is closed, cannot save(). " ) ; } config . bulkCommentedRead ( config - > { writer . write ( config , nioPath , writingMode , charset ) ;
public static ServiceInfo create ( final String type , final String name , final String subtype , final int port , final int weight , final int priority , final boolean persistent , final String text ) { return new ServiceInfoImpl ( type , name , subtype , port , weight , priority , persistent , text ) ; }
public static float rankBelief ( Sentence judg ) { float confidence = judg . getTruth ( ) . getConfidence ( ) ; float originality = 1.0f / ( judg . getStamp ( ) . length ( ) + 1 ) ; return or ( confidence , originality ) ; }
MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt , @Nonnull AS2ResourceHelper aResHelper ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs , boolean bRemoveCmsAlgorithmProtect , @Nonnull EContentTransferEncoding eCTE ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify , @Nullable Consumer < X509Certificate > aEffectiveCertificateConsumer , @Nonnull AS2ResourceHelper aResHelper ) throws Exception ; }
public void shouldFailValidationWithAsciiSpace ( ) { StringUtils . validateKey ( " key baz " , false ) ; }
void handle ( @Nonnull AbstractNetModule aOwner , @Nonnull Socket aSocket ) ; }
Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public void gotoObj ( String name ) { Hauto cells = space . cells ; goal = name ; for ( int i = 0 ; i < cells . w ; i + + ) { for ( int j = 0 ; j < cells . h ; j + + ) {
public int compareTo ( final AbstractTerm that ) { if ( this = = that ) return 0 ; final int superCmp = super . compareTo ( that ) ; if ( superCmp ! = 0 ) return superCmp ; if ( Parameters . TERM_ELEMENT_EQUIVALENCY ) { throw new NotImplementedException ( ) ; } if ( ! ( that instanceof Variable ) ) return 0 ; final Variable thatVar = ( Variable ) that ; final int nameCmp = String . valueOf ( this . name ( ) ) . compareTo ( String . valueOf ( thatVar . name ) ) ; if ( nameCmp ! = 0 ) return nameCmp ; if ( this . getScope ( ) = = this & & thatVar . getScope ( ) ! = thatVar ) return 1 ; if ( this . getScope ( ) ! = this & & thatVar . getScope ( ) = = thatVar ) return - 1 ; return String . valueOf ( this . getScope ( ) . name ) . compareTo ( String . valueOf ( thatVar . getScope ( ) . name ) ) ; }
private static boolean testMinHeap ( ) { String aNameMin = " Min-Heap [array] " ; BinaryHeap . BinaryHeapArray < Integer > aHeapMin = new BinaryHeap . BinaryHeapArray < Integer > ( BinaryHeap . Type . MIN ) ; Collection < Integer > aCollectionMin = aHeapMin . toCollection ( ) ; if ( ( validateStructure | | validateContents ) & & ! testHeap ( aHeapMin , aNameMin , BinaryHeap . Type . MIN ) ) return false ; if ( ! testJavaCollection ( aCollectionMin , Type . Integer , aNameMin ) ) return false ; String tNameMin = " Min-Heap [tree] " ; BinaryHeap . BinaryHeapTree < Integer > tHeapMin = new BinaryHeap . BinaryHeapTree < Integer > ( BinaryHeap . Type . MIN ) ; Collection < Integer > tCollectionMin = tHeapMin . toCollection ( ) ; if ( ( validateStructure | | validateContents ) & & ! testHeap ( tHeapMin , tNameMin , BinaryHeap . Type . MIN ) ) return false ; if ( ! testJavaCollection ( tCollectionMin , Type . Integer , tNameMin ) ) return false ; return true ; }
private byte [ ] download ( String textUrl ) { URL url = buildURLForConnection ( textUrl ) ; HttpURLConnection connection = getHttpConnection ( url ) ; BufferedInputStream bis = null ; ByteArrayOutputStream baos = null ; byte [ ] buffer = null ; int len ; if ( ! urlExists ( connection ) ) { return null ; } try { bis = new BufferedInputStream ( connection . getInputStream ( ) , 8192 ) ; baos = new ByteArrayOutputStream ( ) ; buffer = new byte [ 1024 ] ; while ( ( len = bis . read ( buffer ) ) > - 1 ) { baos . write ( buffer , 0 , len ) ; } baos . flush ( ) ; buffer = baos . toByteArray ( ) ; } catch ( final Exception e ) { if ( DEBUG ) { Log . e ( TAG , " Failed to download cover. " , e ) ; } } finally { if ( bis ! = null ) { try { bis . close ( ) ; } catch ( final IOException e ) { Log . e ( TAG , " Failed to close the BufferedInputStream. " , e ) ; } } if ( baos ! = null ) { try { baos . close ( ) ; } catch ( final IOException e ) { Log . e ( TAG , " Failed to close the BufferedArrayOutputStream. " , e ) ; } } if ( connection ! = null ) { connection . disconnect ( ) ; } } return buffer ; }
public CompoundTerm cloneDeepVariables ( ) { return clone ( cloneVariableTermsDeep ( ) ) ; }
Set < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Collection < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; @Nonnull Iterator < Entry < String , String > > iterator ( ) ; }
public void configure ( Config config ) { stepName = config . getString ( STEP_NAME_CONFIG ) ; entityKeyFieldNames = config . getStringList ( ENTITY_KEY_FIELD_NAMES_CONFIG ) ; pivotKeyFieldName = config . getString ( PIVOT_KEY_FIELD_NAME_CONFIG ) ; pivotValueFieldName = config . getString ( PIVOT_VALUE_FIELD_NAME_CONFIG ) ; if ( config . hasPath ( PIVOT_KEYS_SOURCE_CONFIG ) ) { pivotKeysSource = config . getString ( PIVOT_KEYS_SOURCE_CONFIG ) ;
public void run ( ) { try { final ArrayList < Music > songs = new ArrayList < Music > ( getSongs ( artist , album ) ) ;
public static void main ( String [ ] args ) { { String string = " ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz " ; System . out . println ( " Reversing a string using concatination. " ) ; long before = System . nanoTime ( ) ; String result = StringFunctions . reverseWithStringConcat ( string ) ; long after = System . nanoTime ( ) ; System . out . println ( " before= " + string + "  after= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Reversing a string with a StringBuilder. " ) ; before = System . nanoTime ( ) ; result = StringFunctions . reverseWithStringBuilder ( string ) ; after = System . nanoTime ( ) ; System . out . println ( " before= " + string + "  after= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Reversing a string with StringBuilder built-in reverse method. " ) ; before = System . nanoTime ( ) ; result = StringFunctions . reverseWithStringBuilderBuiltinMethod ( string ) ; after = System . nanoTime ( ) ; System . out . println ( " before= " + string + "  after= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Reversing a string with swaps. " ) ; before = System . nanoTime ( ) ; result = StringFunctions . reverseWithSwaps ( string ) ; after = System . nanoTime ( ) ; System . out . println ( " before= " + string + "  after= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Reversing a string with XOR. " ) ; before = System . nanoTime ( ) ; result = StringFunctions . reverseWithXOR ( string ) ; after = System . nanoTime ( ) ; System . out . println ( " before= " + string + "  after= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . out . println ( ) ; System . gc ( ) ; } { String string = " Could you pretty please reverse this sentence " ; System . out . println ( " Reversing a string using additional array. " ) ; long before = System . nanoTime ( ) ; String result = StringFunctions . reverseWordsByCharWithAdditionalStorage ( string ) ; long after = System . nanoTime ( ) ; System . out . println ( " before= " + string + "  after= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Reversing a string using StringTokenizer with additional storage. " ) ; before = System . nanoTime ( ) ; result = StringFunctions . reverseWordsUsingStringTokenizerWithAdditionalStorage ( string ) ; after = System . nanoTime ( ) ; System . out . println ( " before= " + string + "  after= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Reversing a string using split with additional storage. " ) ; before = System . nanoTime ( ) ; result = StringFunctions . reverseWordsUsingStringTokenizerWithAdditionalStorage ( string ) ; after = System . nanoTime ( ) ; System . out . println ( " before= " + string + "  after= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Reversing a string in-place. " ) ; before = System . nanoTime ( ) ; result = StringFunctions . reverseWordsInPlace ( string ) ; after = System . nanoTime ( ) ; System . out . println ( " before= " + string + "  after= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . out . println ( ) ; System . gc ( ) ; } { String string = " ABCDEFGHIJKLMNOPQRSTUVWXYZ " ; System . out . println ( " Is Palindrome with additional storage? " ) ; long before = System . nanoTime ( ) ; boolean result = StringFunctions . isPalindromeWithAdditionalStorage ( string ) ; long after = System . nanoTime ( ) ; System . out . println ( " string= " + string + "  isPalindrome= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Is Palindrome in-place? " ) ; before = System . nanoTime ( ) ; result = StringFunctions . isPalindromeInPlace ( string ) ; after = System . nanoTime ( ) ; System . out . println ( " string= " + string + "  isPalindrome= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; string = " ABCDEFGHIJKLMNOPQRSTUVWXYZZYXWVUTSRQPONMLKJIHGFEDCBA " ; System . out . println ( " Is Palindrome with additional storage? " ) ; before = System . nanoTime ( ) ; result = StringFunctions . isPalindromeWithAdditionalStorage ( string ) ; after = System . nanoTime ( ) ; System . out . println ( " string= " + string + "  isPalindrome= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Is Palindrome in-place? " ) ; before = System . nanoTime ( ) ; result = StringFunctions . isPalindromeInPlace ( string ) ; after = System . nanoTime ( ) ; System . out . println ( " string= " + string + "  isPalindrome= " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . out . println ( ) ; System . gc ( ) ; } { String string = " abc " ; System . out . println ( " All possible subsets. " ) ; long before = System . nanoTime ( ) ; String [ ] result = StringFunctions . generateSubsets ( string ) ; long after = System . nanoTime ( ) ; System . out . println ( " string= " + string + "  subsets= " + result . length ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . out . println ( ) ; System . gc ( ) ; } { String string1 = " kitten " ;
public MenuItem setOnMenuItemClickListener ( MenuItem . OnMenuItemClickListener menuItemClickListener ) ; public ContextMenuInfo getMenuInfo ( ) ; public void setShowAsAction ( int actionEnum ) ; public MenuItem setShowAsActionFlags ( int actionEnum ) ; public MenuItem setActionView ( View view ) ; public MenuItem setActionView ( int resId ) ; public View getActionView ( ) ; public MenuItem setActionProvider ( ActionProvider actionProvider ) ; public ActionProvider getActionProvider ( ) ; public boolean expandActionView ( ) ; public boolean collapseActionView ( ) ; public boolean isActionViewExpanded ( ) ; public MenuItem setOnActionExpandListener ( OnActionExpandListener listener ) ; }
private void init ( Context context , List < ? extends Item > items ) { if ( ! ( items instanceof ArrayList < ? > ) ) throw new RuntimeException ( " Items must be contained in an ArrayList<Item> " ) ; inflater = ( LayoutInflater ) context . getSystemService ( Context . LAYOUT_INFLATER_SERVICE ) ; this . context = context ; this . items = ( List < Item > ) items ; alphaIndexer = new HashMap < String , Integer > ( ) ; int size = items . size ( ) ; for ( int i = size - 1 ; i > = 0 ; i - - ) { Item element = items . get ( i ) ; alphaIndexer . put ( element . sort ( ) . substring ( 0 , 1 ) . toUpperCase ( ) , i ) ; } Set < String > keys = alphaIndexer . keySet ( ) ; Iterator < String > it = keys . iterator ( ) ; ArrayList < String > keyList = new ArrayList < String > ( ) ; while ( it . hasNext ( ) ) { String key = it . next ( ) ; keyList . add ( key ) ; } Collections . sort ( keyList ) ; sections = new String [ keyList . size ( ) ] ; keyList . toArray ( sections ) ; }
protected E removeItem ( final int index ) { final E selected = items . get ( ( int ) index ) ; if ( selected ! = null ) { nameTable . remove ( selected . name ( ) ) ; mass - = selected . budget . getPriority ( ) ; } return selected ; }
public void test_java_catch_3_5 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " java_catch(java_object('java.util.ArrayList', [], l), [(E, true)], (X is 2+3, Y is 3+5)). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Term e = info . getTerm ( " E " ) ; assertTrue ( e instanceof Var ) ; Int x = ( Int ) info . getTerm ( " X " ) ; assertTrue ( x . intValue ( ) = = 5 ) ; Int y = ( Int ) info . getTerm ( " Y " ) ; assertTrue ( y . intValue ( ) = = 8 ) ; }
public void multipleFiles ( ) throws Exception { int nDirs = 10 ; int nFiles = 10 ; FileWatcher watcher = new FileWatcher ( Duration . ZERO , Duration . ZERO , onWatcherException ) ; CountDownLatch latch = new CountDownLatch ( nDirs * nFiles ) ; for ( int i = 0 ; i < nDirs ; i + + ) { Path dir = tmp . resolve ( " sub- " + i ) ; Files . createDirectory ( dir ) ; for ( int j = 0 ; j < nFiles ; j + + ) { Path file = dir . resolve ( " multipleFilesNotifications- " + j ) ; watcher . addWatch ( file , latch : : countDown ) ; } } Thread . sleep ( 10 ) ; for ( int i = 0 ; i < nDirs ; i + + ) { for ( int j = 0 ; j < nFiles ; j + + ) { Path dir = tmp . resolve ( " sub- " + i ) ; Path file = dir . resolve ( " multipleFilesNotifications- " + j ) ; writeAndSync ( file , Arrays . asList ( " test " ) ) ; assertTrue ( Files . exists ( file ) ) ; } } assertTrue ( latch . await ( 200 , TimeUnit . MILLISECONDS ) ) ; watcher . stop ( ) ; }
public void testPostOrderDFS ( ) { final Integer [ ] inOrder = testBST . getDFS ( DepthFirstSearchOrder . postOrder ) ; final Integer [ ] expectation = new Integer [ ] { 1 , 3 , 2 , 5 , 4 } ; for ( int i = 0 ; i < inOrder . length ; i + + ) { Assert . assertTrue ( inOrder [ i ] = = expectation [ i ] ) ;
public String toString ( ) { return ( _dns ! = null ? " DNS:  " + _dns . getName ( ) : " NO DNS " ) + "  state:  " + _state + "  task:  " + _task ; }
X509Certificate getCertificate ( String sAlias ) throws AS2Exception ; ICommonsMap < String , Certificate > getCertificates ( ) throws AS2Exception ; void addCertificate ( @Nonnull @Nonempty String sAlias , @Nonnull X509Certificate aCert , boolean bOverwrite ) throws AS2Exception ; void addPrivateKey ( @Nonnull @Nonempty String sAlias , @Nonnull Key aKey , @Nonnull String sPassword ) throws AS2Exception ; void clearCertificates ( ) throws AS2Exception ; void removeCertificate ( @Nonnull X509Certificate aCert ) throws AS2Exception ; void removeCertificate ( String sAlias ) throws AS2Exception ; }
Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " origin_node= " ) . append ( originNode ) . append ( " \ n " ) ; builder . append ( " first_char_index= " ) . append ( firstCharIndex ) . append ( " \ n " ) ; builder . append ( " last_char_index= " ) . append ( lastCharIndex ) . append ( " \ n " ) ; if ( isImplicit ( ) ) { String string = SuffixTree . string . substring ( firstCharIndex , lastCharIndex + 1 ) ; builder . append ( " string= " ) . append ( string ) . append ( " \ n " ) ; } return builder . toString ( ) ; }
public void init ( Memory m ) { throw new UnsupportedOperationException ( " Not supported yet. " ) ; }
public InputStream getNonUpwardClosingInputStream ( ) throws IOException { return StreamHelper . getBuffered ( new NonClosingInputStream ( m_aSocket . getInputStream ( ) ) ) ; }
default UnmodifiableCommentedConfig unmodifiable ( ) { return new UnmodifiableCommentedConfig ( ) { @Override
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( WifiManager . WIFI_STATE_CHANGED_ACTION ) ) { System . out . println ( " WIFI-STATE: " + intent . getAction ( ) ) ;
@Override public void actionPerformed ( ActionEvent e ) { rover . thrust ( 0 , - 10.0f ) ; }
final public boolean levelEmpty ( final int l ) { final Deque < E > level = itemTable [ l ] ; return ( level = = null ) | | ( level . isEmpty ( ) ) ; }
public static int order ( final long a , final long b , final int durationCycles ) { return order ( b - a , durationCycles ) ; }
public D query ( long start , long end ) { D result = null ; if ( start = = this . start & & end = = this . end ) { for ( Segment < D > s : this . range ) { D temp = ( D ) s . data . query ( start , end ) ; if ( temp ! = null ) { if ( result = = null ) result = ( D ) temp . copy ( ) ; else result . combined ( temp ) ; } } } else if ( ! this . hasChildren ( ) ) { if ( end < this . start | | start > this . end ) { } else { for ( Segment < D > s : this . range ) { if ( end < s . start | | start > s . end ) { } else { D temp = ( D ) s . data . query ( start , end ) ; if ( temp ! = null ) { if ( result = = null ) result = ( D ) temp . copy ( ) ; else result . combined ( temp ) ; } } } } } else { long middle = this . start + this . half ; D temp = null ; if ( start < middle & & end > = middle ) { temp = this . getLeftChild ( ) . query ( start , middle - 1 ) ; D temp2 = this . getRightChild ( ) . query ( middle , end ) ; if ( temp2 ! = null ) { if ( temp = = null ) temp = ( D ) temp2 . copy ( ) ; else temp . combined ( temp2 ) ; } } else if ( end < middle ) { temp = this . getLeftChild ( ) . query ( start , end ) ; } else if ( start > = middle ) { temp = this . getRightChild ( ) . query ( start , end ) ; } if ( temp ! = null ) result = ( D ) temp . copy ( ) ; } return result ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmStm p , A arg ) { p . stm_ . accept ( new StmVisitor < R , A > ( ) , arg ) ; return null ; }
void requestDistributedSuggestions ( long splitId , ModelAggregatorProcessor modelAggrProc ) { this . isSplitting = true ; this . suggestionCtr = 0 ; this . thrownAwayInstance = 0 ; ComputeContentEvent cce = new ComputeContentEvent ( splitId , this . id , this . getObservedClassDistribution ( ) ) ; modelAggrProc . sendToControlStream ( cce ) ; }
public boolean remove ( Object key , Object value ) { throw new RuntimeException ( " Not implemented " ) ; }
public void testMultipleOperation ( ) { Collection < Operation > ops = new ArrayList < Operation > ( ) ; ops . add ( buildOp ( 11211 ) ) ; ops . add ( buildOp ( 11212 ) ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes: localhost:11211, localhost:11212 " ,
public void withDefaultSerializer ( ) { defaultSerializer = ( value , ctx ) - > { ConfigFormat < ? > format = ctx . configFormat ( ) ;
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; }
protected void rotateLeft ( Node < T > node ) { Position parentPosition = null ; Node < T > parent = node . parent ; if ( parent ! = null ) { if ( node . equals ( parent . lesser ) ) { parentPosition = Position . LEFT ; } else { parentPosition = Position . RIGHT ; } } Node < T > greater = node . greater ; node . greater = null ; Node < T > lesser = greater . lesser ; greater . lesser = node ; node . parent = greater ; node . greater = lesser ; if ( lesser ! = null ) lesser . parent = node ; if ( parentPosition ! = null ) { if ( parentPosition = = Position . LEFT ) {
public List < V > get ( K key ) { return mInternalMap . get ( key ) ; }
public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { super . onCreateOptionsMenu ( menu , inflater ) ; inflater . inflate ( R . menu . mpd_storedplaylistmenu , menu ) ; }
public double Total ( int k ) { return bucketTotal [ k ] ; }
public Operation clone ( ) { return new Operation ( term ) ; }
public LinkedList < String > listAlbums ( String artist , boolean sortInsensitive ) throws MPDServerException { if ( mpdConnection = = null ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } String [ ] args = null ; if ( artist = = null ) { args = new String [ 1 ] ; } else { args = new String [ 2 ] ; args [ 1 ] = artist ; } args [ 0 ] = MPD_TAG_ALBUM ; List < String > list = mpdConnection . sendCommand ( MPD_CMD_LIST_TAG , args ) ; LinkedList < String > result = new LinkedList < String > ( ) ; for ( String line : list ) { String arr = line . substring ( 7 ) ; System . out . println ( " >  " + line ) ; if ( arr . length ( ) > 1 ) result . add ( arr ) ; } if ( sortInsensitive ) { Collections . sort ( result , String . CASE_INSENSITIVE_ORDER ) ; } else { Collections . sort ( result ) ; } return result ; }
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { System . out . println ( " Executed:  " + this ) ; for ( Term t : args ) { System . out . println ( "  ---  " + t ) ; chamb . gotoObj ( t . toString ( ) ) ; } return null ; }
public void run ( ) { final long elapsedSinceTimerStart = new Date ( ) . getTime ( ) - timerStartTime ; elapsedTime = startTrackTime + elapsedSinceTimerStart / DateUtils . SECOND_IN_MILLIS ; updateTrackProgress ( elapsedTime , totalTrackTime ) ; }
boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; @Nonnull KeyStore getKeyStore ( ) throws Exception ; @Nonnull KeyStore loadKeyStore ( @Nonnull InputStream aIS , @Nonnull char [ ] aPassword ) throws Exception ; @Nonnull KeyStore loadKeyStore ( @Nonnull String sFilename , @Nonnull char [ ] aPassword ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull String sDigest , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull Certificate aCert , @Nonnull Key aKey ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull Certificate aCert , @Nonnull String sAlgorithm ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull Certificate aCert , @Nonnull Key key , @Nonnull String sAlgorithm ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nonnull Certificate aCert ) throws Exception ; }
C parseConfig ( Reader reader ) ; void parseConfig ( Reader reader , D destination ) ; default C parseConfig ( InputStream input ) { Reader reader = new BufferedReader ( new InputStreamReader ( input , StandardCharsets . UTF_8 ) ) ; return parseConfig ( reader ) ; } default void parseConfig ( InputStream input , D destination ) { Reader reader = new BufferedReader ( new InputStreamReader ( input , StandardCharsets . UTF_8 ) ) ; parseConfig ( reader , destination ) ; } default C parseConfig ( File file ) { try ( Reader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , StandardCharsets . UTF_8 ) ) ) { return parseConfig ( reader ) ; } catch ( IOException e ) { throw new WritingException ( " An I/O error occured " , e ) ; } } default void parseConfig ( File file , D destination ) { try ( Reader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , StandardCharsets . UTF_8 ) ) ) { parseConfig ( reader , destination ) ; } catch ( IOException e ) { throw new WritingException ( " An I/O error occured " , e ) ; } } default C parseConfig ( URL url ) { URLConnection connection ; try { connection = url . openConnection ( ) ; } catch ( IOException e ) { throw new WritingException ( " Unable to connect to the URL " , e ) ; } String encoding = connection . getContentEncoding ( ) ; Charset charset = ( encoding = = null ) ? StandardCharsets . UTF_8 : Charset . forName ( encoding ) ; try ( Reader reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) , charset ) ) ) { return parseConfig ( reader ) ; } catch ( IOException e ) { throw new WritingException ( " An I/O error occured " , e ) ; } } default void parseConfig ( URL url , D destination ) { URLConnection connection ; try { connection = url . openConnection ( ) ; } catch ( IOException e ) { throw new WritingException ( " Unable to connect to the URL " , e ) ; } String encoding = connection . getContentEncoding ( ) ; Charset charset = ( encoding = = null ) ? StandardCharsets . UTF_8 : Charset . forName ( encoding ) ; try ( Reader reader = new BufferedReader ( new InputStreamReader ( url . openStream ( ) , charset ) ) ) { parseConfig ( reader , destination ) ; } catch ( IOException e ) { throw new WritingException ( " An I/O error occured " , e ) ; } } }
public void startStatusMonitor ( ) { mWorkerHandler . sendEmptyMessage ( MPDAsyncWorker . EVENT_STARTMONITOR ) ; }
public synchronized boolean defineFlag ( String name , Struct valueList , Term defValue , boolean modifiable , String libName ) { flags . add ( new Flag ( name , valueList , defValue , modifiable , libName ) ) ; return true ; }
public void setSingle ( final boolean single ) throws MPDServerException { mConnection . sendCommand ( MPDCommand . MPD_CMD_SINGLE , single ? " 1 " : " 0 " ) ; }
public final int compare ( final TaskConcept a , final TaskConcept b ) { float bp = b . getMotivation ( ) ; float ap = a . getMotivation ( ) ; if ( bp ! = ap ) { return Float . compare ( bp , ap ) ;
public void libraryStateChanged ( final boolean updating , final boolean dbChanged ) { mHelperHandler . obtainMessage ( MPDAsyncHelper . EVENT_UPDATE_STATE , Tools . toObjectArray ( updating , dbChanged ) ) . sendToTarget ( ) ;
public void receivedStatus ( String s ) { rv . put ( sa , s ) ; }
public void onClick ( DialogInterface dialog , int which ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; new CachedCover ( app ) . clear ( ) ; pCacheUsage1 . setSummary ( " 0.00B " ) ; pCacheUsage2 . setSummary ( " 0.00B " ) ; }
public boolean onQueryTextChange ( final String newText ) { mFilter = newText ; if ( newText ! = null & & newText . isEmpty ( ) ) { mFilter = null ; } if ( mFilter ! = null ) { mFilter = mFilter . toLowerCase ( ) ; } mList . setDragEnabled ( mFilter = = null ) ; update ( false ) ; return false ; }
public void testIntervalTree ( ) { final String stravinsky = " Stravinsky " ; final String schoenberg = " Schoenberg " ; final String grieg = " Grieg " ; final String schubert = " Schubert " ; final String mozart = " Mozart " ; final String schuetz = " Schuetz " ; java . util . List < IntervalTree . IntervalData < String > > intervals = new ArrayList < IntervalTree . IntervalData < String > > ( ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 1888 , 1971 , stravinsky ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 1874 , 1951 , schoenberg ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 1843 , 1907 , grieg ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 1779 , 1828 , schubert ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 1756 , 1791 , mozart ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 1585 , 1672 , schuetz ) ) ) ; IntervalTree < String > tree = new IntervalTree < String > ( intervals ) ; IntervalTree . IntervalData < String > query = tree . query ( 1890 ) ; assertTrue ( " Interval Tree query error. query=1890 returned= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( stravinsky , schoenberg , grieg ) ) ) ; query = tree . query ( 1909 ) ; assertTrue ( " Interval Tree query error. query=1909 returned= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( stravinsky , schoenberg ) ) ) ; query = tree . query ( 1792 , 1903 ) ; assertTrue ( " Interval Tree query error. query=1792->1903 returned= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( stravinsky , schoenberg , grieg , schubert ) ) ) ; query = tree . query ( 1776 , 1799 ) ; assertTrue ( " Interval Tree query error. query=1776->1799 returned= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( schubert , mozart ) ) ) ; }
public void moveTo ( float px , float py ) { moveTo ( px , py , G4P . control_mode ) ; }
public void testSetupWorkers ( ) { new Expectations ( ) { { for ( int i = 0 ; i < parallelism ; i + + ) { processor . newProcessor ( processor ) ; result = processor ; processor . onCreate ( anyInt ) ; } } } ; pi . setupWorkers ( ) ; List < ThreadsWorkerProcessingItem > workers = pi . getWorkerProcessingItems ( ) ; assertNotNull ( " List of workers is null. " , workers ) ; assertEquals ( " Number of workers does not match parallelism. " , parallelism , workers . size ( ) , 0 ) ; for ( int i = 0 ; i < workers . size ( ) ; i + + ) { assertNotNull ( " Worker  " + i + "  is null. " , workers . get ( i ) ) ;
protected void markAsChanged ( ) throws OpenAS2Exception { } protected final void setPartners ( @Nonnull final PartnerMap aPartners ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { m_aPartners . setPartners ( aPartners ) ; markAsChanged ( ) ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } public void addPartner ( @Nonnull final StringMap aNewPartner ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { m_aPartners . addPartner ( aNewPartner ) ; markAsChanged ( ) ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } @Nonnull public EChange removePartner ( @Nullable final String sPartnerName ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { if ( m_aPartners . removePartner ( sPartnerName ) . isUnchanged ( ) ) return EChange . UNCHANGED ; markAsChanged ( ) ; return EChange . CHANGED ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } @Nullable public StringMap getPartnerOfName ( @Nullable final String sPartnerName ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartners . getPartnerOfName ( sPartnerName ) ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nonnull @ReturnsMutableCopy public Set < String > getAllPartnerNames ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartners . getAllPartnerNames ( ) ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nonnull @ReturnsMutableCopy public List < StringMap > getAllPartners ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartners . getAllPartners ( ) ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nonnull public IPartnerMap getPartnerMap ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartners ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nonnull @OverridingMethodsMustInvokeSuper public Partnership getPartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { ValueEnforcer . notNull ( aPartnership , " Partnership " ) ; m_aRWLock . readLock ( ) . lock ( ) ; try { Partnership aRealPartnership = m_aPartnerships . getPartnershipByName ( aPartnership . getName ( ) ) ; if ( aRealPartnership = = null ) { aRealPartnership = m_aPartnerships . getPartnershipByID ( aPartnership . getAllSenderIDs ( ) , aPartnership . getAllReceiverIDs ( ) ) ; } if ( aRealPartnership = = null ) throw new PartnershipNotFoundException ( " Partnership not found:  " + aPartnership ) ; return aRealPartnership ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nullable public Partnership getPartnershipByName ( @Nullable final String sName ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartnerships . getPartnershipByName ( sName ) ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nonnull @ReturnsMutableCopy public Set < String > getAllPartnershipNames ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartnerships . getAllPartnershipNames ( ) ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nonnull @ReturnsMutableCopy public List < Partnership > getAllPartnerships ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartnerships . getAllPartnerships ( ) ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nonnull public IPartnershipMap getPartnershipMap ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartnerships ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } protected final void setPartnerships ( @Nonnull final PartnershipMap aPartnerships ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { m_aPartnerships . setPartnerships ( aPartnerships ) ; markAsChanged ( ) ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } public final void addPartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { m_aPartnerships . addPartnership ( aPartnership ) ; markAsChanged ( ) ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } @Nonnull public final EChange removePartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { if ( m_aPartnerships . removePartnership ( aPartnership ) . isUnchanged ( ) ) return EChange . UNCHANGED ; markAsChanged ( ) ; return EChange . CHANGED ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } public final void updatePartnership ( @Nonnull final IMessage aMsg , final boolean bOverwrite ) throws OpenAS2Exception { ValueEnforcer . notNull ( aMsg , " Message " ) ; final Partnership aPartnership = getPartnership ( aMsg . getPartnership ( ) ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Updating partnership  " + aPartnership ) ; aMsg . getPartnership ( ) . copyFrom ( aPartnership ) ; if ( bOverwrite ) { final String sSubject = aPartnership . getAttribute ( CPartnershipIDs . PA_SUBJECT ) ; if ( sSubject ! = null ) { aMsg . setSubject ( new MessageParameters ( aMsg ) . format ( sSubject ) ) ; } } } public final void updatePartnership ( @Nonnull final IMessageMDN aMdn , final boolean bOverwrite ) throws OpenAS2Exception { ValueEnforcer . notNull ( aMdn , " MessageMDN " ) ; final Partnership aPartnership = getPartnership ( aMdn . getPartnership ( ) ) ; aMdn . getPartnership ( ) . copyFrom ( aPartnership ) ; } }
< T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
public void setData ( Dataset < Row > batchDF ) throws Exception { this . data = batchDF ; if ( doesCache ( ) ) { cache ( ) ; } if ( usesSmallHint ( ) ) { applySmallHint ( ) ; } if ( doesPrintSchema ( ) ) { printSchema ( ) ; } if ( doesPrintData ( ) ) { printData ( ) ; } registerStep ( ) ; if ( hasOutput ( ) ) { writeOutput ( ) ;
private boolean refactorExpressLanes ( int expressLanes ) { if ( expressLanes ! = lanes . size ( ) ) return true ; int length = size ; for ( int i = 0 ; i < expressLanes ; i + + ) { List < ExpressNode < T > > expressLane = lanes . get ( i ) ; if ( expressLane . size ( ) ! = length ) return true ; length = length / 2 ; } return false ; }
public void testBasic ( ) throws Exception { assertTrue ( ! CAS2Info . VERSION . equals ( " undefined " ) ) ; }
< T > T set ( List < String > path , Object value ) ; boolean add ( List < String > path , Object value ) ; default boolean add ( String path , Object value ) { return add ( split ( path , '.' ) , value ) ; } default void putAll ( UnmodifiableConfig config ) { valueMap ( ) . putAll ( config . valueMap ( ) ) ; } default < T > T remove ( String path ) { return remove ( split ( path , '.' ) ) ; } < T > T remove ( List < String > path ) ; void clear ( ) ; default UnmodifiableConfig unmodifiable ( ) { return new UnmodifiableConfig ( ) { @Override public < T > T get ( List < String > path ) { return Config . this . get ( path ) ; } @Override public boolean contains ( List < String > path ) { return Config . this . contains ( path ) ; } @Override public int size ( ) { return Config . this . size ( ) ; } @Override public Map < String , Object > valueMap ( ) { return Collections . unmodifiableMap ( Config . this . valueMap ( ) ) ; } @Override public Set < ? extends Entry > entrySet ( ) { return Config . this . entrySet ( ) ; } @Override public ConfigFormat < ? , ? , ? > configFormat ( ) { return Config . this . configFormat ( ) ; } } ; } default Config checked ( ) { return new CheckedConfig ( this ) ; } Map < String , Object > valueMap ( ) ; @Override Set < ? extends Entry > entrySet ( ) ; interface Entry extends UnmodifiableConfig . Entry { < T > T setValue ( Object value ) ; } Config createSubConfig ( ) ; static Config of ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format , false ) ; } static Config ofConcurrent ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format , true ) ; } static Config inMemory ( ) { return InMemoryFormat . defaultInstance ( ) . createConfig ( ) ; } static Config inMemoryConcurrent ( ) { return InMemoryFormat . defaultInstance ( ) . createConcurrentConfig ( ) ; } static Config wrap ( Map < String , Object > map , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( map , format ) ; } static Config copy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) , false ) ; } static Config copy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( config , format , false ) ; } static Config concurrentCopy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) , true ) ; } static Config concurrentCopy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( config , format , true ) ; } }
protected boolean isMembase ( ) { if ( membase ! = null ) { return membase . booleanValue ( ) ; } Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; for ( Map < String , String > node : stats . values ( ) ) { if ( node . get ( " ep_version " ) ! = null ) { membase = true ; System . err . println ( " Found membase " ) ; break ; } else { membase = false ; System . err . println ( " Found memcached " ) ; } } return membase . booleanValue ( ) ; }
public final boolean call ( final Operation operation , final Term [ ] args , final Memory memory , final Timable time ) { List < Task > feedback = null ; try { feedback = execute ( operation , args , memory , time ) ; } catch ( Exception ex ) { if ( Debug . SHOW_EXECUTION_ERRORS ) { memory . event . emit ( ERR . class , ex ) ; } if ( ! Debug . EXECUTION_ERRORS_CONTINUE ) { throw new IllegalStateException ( " Execution error: \ n " , ex ) ; } else { return false ; } } float executionConfidence = memory . narParameters . DEFAULT_JUDGMENT_CONFIDENCE ; if ( feedback = = null | | feedback . isEmpty ( ) ) { memory . executedTask ( time , operation , new TruthValue ( 1f , executionConfidence , memory . narParameters ) ) ; } reportExecution ( operation , args , feedback , memory ) ; if ( feedback ! = null ) { for ( final Task t : feedback ) { memory . inputTask ( time , t ) ; } } return true ; }
public boolean isDamage ( ) { return hiX > loX & & hiY > loY ; }
public void setRating ( int rating ) throws MPDServerException { setRating ( null , rating ) ; }
public void testNullMissing ( ) { String delimited = " val1 2 34 " ; Config config = ConfigFactory . empty ( ) . withValue ( DelimitedTranslator . SCHEMA_CONFIG + " . " + ComponentFactory . TYPE_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( " flat " ) ) . withValue ( DelimitedTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_NAMES_CONFIG , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " field1 " , " field2 " , " field3 " , " field4 " , " field5 " ) ) ) . withValue ( DelimitedTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_TYPES_CONFIG , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " string " , " integer " , " long " , " integer " , " boolean " ) ) ) . withValue ( DelimitedTranslator . DELIMITER_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( "   " ) ) ; DelimitedTranslator t = new DelimitedTranslator ( ) ; assertNoValidationFailures ( t , config ) ; t . configure ( config ) ; Row raw = TestingMessageFactory . get ( " testkey " , DataTypes . StringType , delimited , DataTypes . StringType ) ; Row r = t . translate ( raw ) . iterator ( ) . next ( ) ; assertEquals ( r . length ( ) , 5 ) ; assertEquals ( r . get ( 0 ) , " val1 " ) ; assertEquals ( r . get ( 1 ) , 2 ) ; assertEquals ( r . get ( 2 ) , 34L ) ; assertEquals ( r . get ( 3 ) , null ) ; assertEquals ( r . get ( 4 ) , null ) ; }
public Set < K > keySet ( ) { return nameTable . keySet ( ) ; }
private static boolean testSegmentTree ( ) { { if ( debug > 1 ) System . out . println ( " Segment Tree. " ) ; SegmentTree . Segment [ ] segments = new SegmentTree . Segment [ 4 ] ; segments [ 0 ] = new SegmentTree . Segment ( 0 , new SegmentTree . Data ( 1 , 0 , 0 , 0 ) ) ; segments [ 1 ] = new SegmentTree . Segment ( 1 , new SegmentTree . Data ( 0 , 1 , 0 , 0 ) ) ; segments [ 2 ] = new SegmentTree . Segment ( 2 , new SegmentTree . Data ( 0 , 0 , 1 , 0 ) ) ; segments [ 3 ] = new SegmentTree . Segment ( 3 , new SegmentTree . Data ( 0 , 0 , 0 , 1 ) ) ; SegmentTree tree = new SegmentTree ( segments ) ; SegmentTree . Data query = tree . query ( 0 , 3 ) ; if ( debug > 1 ) System . out . println ( query . quad1 + "   " + query . quad2 + "   " + query . quad3 + "   " + query . quad4 ) ; tree . update ( 1 , new SegmentTree . Data ( 0 , - 1 , 1 , 0 ) ) ; tree . update ( 2 , new SegmentTree . Data ( 0 , 1 , - 1 , 0 ) ) ; tree . update ( 3 , new SegmentTree . Data ( 1 , 0 , 0 , - 1 ) ) ; query = tree . query ( 2 , 3 ) ; if ( debug > 1 ) System . out . println ( query . quad1 + "   " + query . quad2 + "   " + query . quad3 + "   " + query . quad4 ) ; tree . update ( 0 , new SegmentTree . Data ( - 1 , 1 , 0 , 0 ) ) ; tree . update ( 1 , new SegmentTree . Data ( 0 , 0 , - 1 , 1 ) ) ; query = tree . query ( 0 , 2 ) ; if ( debug > 1 ) System . out . println ( query . quad1 + "   " + query . quad2 + "   " + query . quad3 + "   " + query . quad4 ) ; if ( debug > 1 ) System . out . println ( ) ; } return true ; }
public Task parseNarsese ( StringBuilder buffer ) throws InvalidInputException { long time = memory . getTime ( ) ; int i = buffer . indexOf ( valueOf ( PREFIX_MARK ) ) ; if ( i > 0 ) { String prefix = buffer . substring ( 0 , i ) . trim ( ) ; if ( prefix . equals ( INPUT_LINE_PREFIX ) ) { buffer . delete ( 0 , i + 1 ) ; } else if ( prefix . equals ( OUTPUT_LINE_PREFIX ) ) { return null ; } } char c = buffer . charAt ( buffer . length ( ) - 1 ) ; if ( c = = STAMP_CLOSER ) { int j = buffer . lastIndexOf ( valueOf ( STAMP_OPENER ) ) ; buffer . delete ( j - 1 , buffer . length ( ) ) ; } return parseTask ( buffer . toString ( ) . trim ( ) , time ) ; }
public void volumeChanged ( final MPDStatus mpdStatus , final int oldVolume ) { } }
void receivedStatus ( OperationStatus status ) ; void complete ( ) ; }
public static boolean baseOverlap ( final Stamp a , final Stamp b ) { final BaseEntry [ ] base1 = a . evidentialBase ; final BaseEntry [ ] base2 = b . evidentialBase ; final Set < BaseEntry > task_base = new LinkedHashSet < > ( base1 . length + base2 . length ) ; for ( final BaseEntry aBase1 : base1 ) { if ( task_base . contains ( aBase1 ) ) { return true ; } task_base . add ( aBase1 ) ; } for ( final BaseEntry aBase2 : base2 ) { if ( task_base . contains ( aBase2 ) ) { return true ; } task_base . add ( aBase2 ) ; } return false ; }
@Override protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { { mario . keys [ Mario . KEY_LEFT ] = false ; mario . keys [ Mario . KEY_RIGHT ] = true ; } return super . execute ( operation , args , memory ) ; }
public Operation tapBackfill ( final String id , final long date , final int runTime , final TimeUnit timeunit ) throws IOException , ConfigurationException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . opFact . tapBackfill ( id , date , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { tapAck ( conn , opcode , opaque , this ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; if ( runTime > 0 ) { Runnable r = new Runnable ( ) { @Override public void run ( ) { try { Thread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , timeunit ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } conn . shutdown ( ) ; synchronized ( omap ) { omap . remove ( op ) ; } } } ; new Thread ( r ) . start ( ) ; } return op ; }
public void configure ( Config config ) { this . intoDependency = config . getString ( NEST_INTO_CONFIG_NAME ) ; this . fromDependency = config . getString ( NEST_FROM_CONFIG_NAME ) ; this . keyFieldNames = config . getStringList ( KEY_FIELD_NAMES_CONFIG_NAME ) ; this . nestedFieldName = config . getString ( NESTED_FIELD_NAME_CONFIG_NAME ) ; }
DataHistory getHistory ( ) ; String getMessageID ( ) ; void setMessageID ( String sMessageID ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; @Nonnull Partnership getPartnership ( ) ; void setPartnership ( @Nullable Partnership aPartnership ) ; }
public abstract String getPlayListMainLine ( ) ; public abstract String getPlaylistSubLine ( ) ; }
public void onClick ( DialogInterface dialogInterface , int i ) { final String progress = Integer . toString ( seekBar . getProgress ( ) ) ; finishWithAction ( item , progress , item . mLabel + "  :  " + progress ) ; }
public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; app = ( MPDApplication ) getActivity ( ) . getApplication ( ) ; playlistName = getActivity ( ) . getIntent ( ) . getStringExtra ( " playlist " ) ; }
public abstract String getParameter ( @Nonnull String sKey ) throws InvalidParameterException ; public void setParameters ( @Nonnull final String sEncodedParams ) throws InvalidParameterException { final StringTokenizer aParams = new StringTokenizer ( sEncodedParams , " =, " , false ) ; while ( aParams . hasMoreTokens ( ) ) { final String sKey = aParams . nextToken ( ) . trim ( ) ; if ( ! aParams . hasMoreTokens ( ) ) throw new InvalidParameterException ( " Invalid value " , this , sKey , null ) ; final String sValue = aParams . nextToken ( ) ; setParameter ( sKey , sValue ) ; } } public void setParameters ( @Nullable final String sFormat , @Nullable final String sDelimiters , @Nonnull final String sValue ) throws OpenAS2Exception { final List < String > aKeys = StringHelper . getExploded ( ',' , sFormat ) ; final StringTokenizer aValueTokens = new StringTokenizer ( sValue , sDelimiters , false ) ; for ( final String sKey : aKeys ) { if ( ! aValueTokens . hasMoreTokens ( ) ) throw new OpenAS2Exception ( " Invalid value: Format= " + sFormat + " , value= " + sValue ) ; if ( sKey . length ( ) > 0 ) setParameter ( sKey , aValueTokens . nextToken ( ) ) ; } } @Nonnull public String format ( @Nonnull final String sFormat ) throws InvalidParameterException { if ( s_aLogger . isTraceEnabled ( ) ) s_aLogger . trace ( " Formatting ' " + sFormat + " ' " ) ; final StringBuilder aSB = new StringBuilder ( ) ; for ( int nNext = 0 ; nNext < sFormat . length ( ) ; + + nNext ) { int nPrev = nNext ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) { aSB . append ( sFormat . substring ( nPrev , sFormat . length ( ) ) ) ; break ; } if ( nNext > nPrev ) { aSB . append ( sFormat . substring ( nPrev , nNext ) ) ; } nPrev = nNext + 1 ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) throw new InvalidParameterException ( " Invalid key (missing closing $) " ) ; if ( nNext = = nPrev ) aSB . append ( '$' ) ; else { final String sParameterName = sFormat . substring ( nPrev , nNext ) ; aSB . append ( getParameter ( sParameterName ) ) ; } } if ( s_aLogger . isTraceEnabled ( ) ) s_aLogger . trace ( " Formatted value is now ' " + aSB . toString ( ) + " ' " ) ; return aSB . toString ( ) ; } @Override public String toString ( ) { return new ToStringGenerator ( this ) . toString ( ) ; } }
public static void main ( String [ ] args ) throws Exception { int cycles = 1000 ; NAR nar = new Default ( ) . build ( ) ; NARTrace t = new NARTrace ( nar ) ; nar . addInput ( " <a --> b>. " ) ; nar . addInput ( " <b --> c>. " ) ; nar . addInput ( " <(^pick,x) = \\ > a>. " ) ; nar . addInput ( " <(*, b, c) <-> x>. " ) ; nar . addInput ( " a! " ) ; Timeline2DCanvas tc = new Timeline2DCanvas ( new BarChart ( new FirstOrderDifferenceTimeSeries ( " d(concepts) " , t . charts . get ( " concept.count " ) ) ) , new StackedPercentageChart ( t . getCharts ( " concept.priority.hist.0 " , " concept.priority.hist.1 " , " concept.priority.hist.2 " , " concept.priority.hist.3 " ) ) . height ( 2 ) , new LineChart ( new ConceptBagTreeMLData ( nar , nar . memory . concepts , cycles , Mode . ConceptPriorityTotal ) ) . height ( 4 ) , new LineChart ( new ConceptBagTreeMLData ( nar , nar . memory . concepts , cycles , Mode . TermLinkPriorityMean ) , new ConceptBagTreeMLData ( nar , nar . memory . concepts , cycles , Mode . TaskLinkPriorityMean ) ) . height ( 4 ) , new LineChart ( t . getCharts ( " task.novel.add " , " task.immediate_processed " ) ) . height ( 3 ) , new LineChart ( t . getCharts ( " task.goal.process " , " task.question.process " , " task.judgment.process " ) ) . height ( 3 ) , new LineChart ( t . getCharts ( " emotion.busy " ) ) . height ( 1 ) , new EventChart ( t , false , false , true ) . height ( 3 ) ) ; nar . finish ( cycles ) ; new NWindow ( " _ " , tc ) . show ( 800 , 800 , true ) ;
public void close ( ) { } @Override public InputStream getContent ( ) throws IOException { throw new UnsupportedOperationException ( ) ; } public long getContentLength ( ) { return - 1L ; } public boolean isStreaming ( ) { return true ; } @Override public void writeTo ( @Nonnull final OutputStream aOS ) throws IOException { try ( final OutputStream aDebugOS = aOutgoingDumper ! = null ? aOutgoingDumper . getDumpOS ( aOS ) : aOS ; final OutputStream aEncodedOS = eCTE ! = null ? AS2IOHelper . getContentTransferEncodingAwareOutputStream ( aDebugOS , eCTE . getID ( ) ) : aDebugOS ) { StreamHelper . copyByteStream ( ) . from ( aCIS ) . closeFrom ( true ) . to ( aEncodedOS ) . closeTo ( false ) . build ( ) ; } catch ( final MessagingException ex ) { throw new IllegalStateException ( " Failed to encode OutputStream with CTE ' " + eCTE + " ' " , ex ) ; } } } ; final HttpEntity aEntity = aResHelper . createRepeatableHttpEntity ( aISE ) ; m_aRequestBuilder . setEntity ( aEntity ) ; final ClassicHttpRequest aHttpUriRequest = m_aRequestBuilder . build ( ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Performing HttpRequest to ' " + aHttpUriRequest . toString ( ) + " ' " ) ; m_aCloseableHttpResponse = m_aCloseableHttpClient . execute ( aHttpUriRequest ) ; return aCIS . getBytesRead ( ) ; } } public InputStream getInputStream ( ) throws AS2Exception , IOException { if ( m_aCloseableHttpResponse = = null ) throw new AS2Exception ( " No response as message was yet sent " ) ; return m_aCloseableHttpResponse . getEntity ( ) . getContent ( ) ; } public int getResponseCode ( ) throws AS2Exception { if ( m_aCloseableHttpResponse = = null ) throw new AS2Exception ( " No response as message was yet sent " ) ; return m_aCloseableHttpResponse . getCode ( ) ; } public String getResponseMessage ( ) throws AS2Exception { if ( m_aCloseableHttpResponse = = null ) throw new AS2Exception ( " No response as message was yet sent " ) ; return m_aCloseableHttpResponse . getReasonPhrase ( ) ; } @Nonnull @ReturnsMutableCopy public HttpHeaderMap getResponseHeaderFields ( ) throws AS2Exception { if ( m_aCloseableHttpResponse = = null ) throw new AS2Exception ( " No response as message was yet sent " ) ; final HttpHeaderMap ret = new HttpHeaderMap ( ) ; final Header [ ] aHeaders = m_aCloseableHttpResponse . getHeaders ( ) ; if ( aHeaders ! = null ) for ( final Header aHeader : aHeaders ) ret . addHeader ( aHeader . getName ( ) , aHeader . getValue ( ) ) ; return ret ; } public void disconnect ( ) { try { if ( m_aCloseableHttpResponse ! = null ) m_aCloseableHttpResponse . close ( ) ; if ( m_aCloseableHttpClient ! = null ) m_aCloseableHttpClient . close ( ) ; } catch ( final Exception ex ) { LOGGER . error ( " Exception while closing HttpClient connection:  " + this . toString ( ) , ex ) ; } } private static void _setProxyToRequestConfig ( @Nonnull final RequestConfig . Builder aConfBuilder , @Nullable final Proxy aProxy ) { try { if ( aProxy ! = null ) { final SocketAddress aSocketAddress = aProxy . address ( ) ; if ( aSocketAddress instanceof InetSocketAddress ) { final InetSocketAddress aISocketAdress = ( InetSocketAddress ) aSocketAddress ; final InetAddress aInetAddr = aISocketAdress . getAddress ( ) ; if ( aInetAddr ! = null ) { final HttpHost aHost = new HttpHost ( aInetAddr , aISocketAdress . getPort ( ) ) ; aConfBuilder . setProxy ( aHost ) ; } else { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " No address in proxy: " + aProxy . address ( ) + " - " + ( null ! = aProxy . type ( ) ? aProxy . type ( ) . name ( ) : " null " ) ) ; } } } } catch ( final RuntimeException ex ) { LOGGER . error ( " Exception while setting proxy. Continue without proxy. Proxy:  " + aProxy . address ( ) + " - " + ( null ! = aProxy . type ( ) ? aProxy . type ( ) . name ( ) : " null " ) , ex ) ; } } public static boolean isErrorResponseCode ( final int nResponseCode ) { return nResponseCode ! = CHttp . HTTP_OK & & nResponseCode ! = CHttp . HTTP_CREATED & & nResponseCode ! = CHttp . HTTP_ACCEPTED & & nResponseCode ! = CHttp . HTTP_NO_CONTENT & & nResponseCode ! = CHttp . HTTP_PARTIAL_CONTENT ; } }
public static void main ( final String [ ] args ) { final Nar nd = new Nar ( ) ; test ( nd ) ;
public void divideTest ( ) { assertEquals ( 1 , Modular . divide ( 7 , 7 , 125 ) ) ; assertEquals ( 97 , Modular . divide ( Modular . multiply ( 97 , 25 , 1023 ) , 25 , 1023 ) ) ; assertEquals ( Long . MAX_VALUE - 11 , Modular . divide ( Modular . multiply ( Long . MAX_VALUE - 11 , Long . MAX_VALUE - 12 , Long . MAX_VALUE ) , Long . MAX_VALUE - 12 , Long . MAX_VALUE ) ) ; boolean exception = true ; try { Modular . divide ( 11 , 6 , 120 ) ; } catch ( IllegalArgumentException e ) { } assertTrue ( " Exception expected " , exception ) ; exception = true ; try { Modular . divide ( 2 , 2 , 0 ) ; } catch ( ArithmeticException e ) { } assertTrue ( " Exception expected " , exception ) ; }
public abstract Nar addInput ( final Task t ) ; public void step_start ( ) { } public void step_finished ( ) { for ( final SensoryChannel ch : reportResultsTo ) { for ( final Task t : results ) { ch . addInput ( t ) ; } } results . clear ( ) ; } public double topDownPriority ( final Term t ) { double prioritysum = 0.0f ; int k = 0 ; for ( final SensoryChannel chan : reportResultsTo ) { prioritysum + = chan . priority ( t ) ; k + + ; } return prioritysum / ( double ) reportResultsTo . size ( ) ; } public double priority ( final Term t ) { if ( this instanceof Nar ) { final Concept c = ( ( Nar ) this ) . memory . concept ( t ) ; if ( c ! = null ) { return c . getPriority ( ) ; } } return 0.0 ; } }
public String toString ( ) { return "          id:  " + id + " \ n " + "      currentGoal:   " + currentGoal + " \ n " +
public void set ( final FilesystemTreeEntry entry , final String sticker , final String value ) throws IOException , MPDException { if ( ! ( entry instanceof Music ) ) { throw new IllegalArgumentException ( NOT_SUPPORTED ) ; } if ( isAvailable ( ) ) { mConnection . sendCommand ( CMD_ACTION_SET , CMD_STICKER_TYPE_SONG , entry . getFullPath ( ) ,
public boolean isNullAt ( int arg0 ) { return internalRow . isNullAt ( arg0 ) ; }
public boolean isCompound ( ) { Term t = getTerm ( ) ; if ( t = = this ) { return false ;
private static void serviceWoundDown ( final boolean value ) { serviceWoundDown = value ; }
public void testPut ( ) { expectGetAndReturn ( " blaha " , " olda " ) ; clientMock . expects ( once ( ) ) . method ( " set " ) . with ( eq ( " blaha " ) , eq ( EXP ) , eq ( " newa " ) ) ; assertEquals ( " olda " , cacheMap . put ( " a " , " newa " ) ) ; }
public final boolean isCompressBeforeSigning ( ) { return m_bCompressBeforeSigning ; }
protected final void executeAction ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) throws AS2Exception { final ICommonsList < Throwable > aCauses = new CommonsArrayList < > ( ) ; final ICommonsList < IProcessorModule > aModulesFound = new CommonsArrayList < > ( ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( "   handling action ' " + sAction + " ' on message ' " + aMsg . getMessageID ( ) + " ' with options  " + aOptions ) ; final ICommonsList < IProcessorModule > aAllModules = getAllModules ( ) ; for ( final IProcessorModule aModule : aAllModules ) if ( aModule . canHandle ( sAction , aMsg , aOptions ) ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( "   handling action ' " + sAction + " ' with module  " + aModule ) ; try { aModulesFound . add ( aModule ) ; aModule . handle ( sAction , aMsg , aOptions ) ; } catch ( final AS2Exception ex ) { aCauses . add ( ex ) ; } } else { if ( LOGGER . isTraceEnabled ( ) ) LOGGER . trace ( "   Not handling action ' " + sAction + " ' with module  " + aModule ) ; } if ( aCauses . isNotEmpty ( ) ) throw new AS2ProcessorException ( this , aCauses ) ; if ( aModulesFound . isEmpty ( ) ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( "   no modules found for ' " + sAction + " '; modules are:  " + aAllModules ) ; throw new AS2NoModuleException ( sAction , aMsg , aOptions ) ; } if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( "   action ' " + sAction + " ' was handled by modules  " + aModulesFound ) ;
public boolean isMissingSparse ( int indexAttribute ) { return Double . isNaN ( this . value ( indexAttribute ) ) ; }
public boolean allow ( final Sentence s ) { float conf = s . truth . getConfidence ( ) ; float freq = s . truth . getFrequency ( ) ; if ( ( conf > minConfidence ) & & ( freq > minFreq ) ) return true ; return false ; }
public int compare ( final Album lhs , final Album rhs ) { int compare = 0 ; if ( lhs . mYear < rhs . mYear ) { compare = - 1 ; } else if ( lhs . mYear > rhs . mYear ) { compare = 1 ; } if ( compare = = 0 ) { compare = lhs . compareTo ( rhs ) ; } return compare ; }
static BudgetValue revise ( final TruthValue tTruth , final TruthValue bTruth , final TruthValue truth , final boolean feedbackToLinks , final Memory memory ) { final float difT = truth . getExpDifAbs ( tTruth ) ; final Task task = memory . currentTask ; task . decPriority ( 1 - difT ) ; task . decDurability ( 1 - difT ) ; if ( feedbackToLinks ) { TaskLink tLink = memory . currentTaskLink ; tLink . decPriority ( 1 - difT ) ; tLink . decDurability ( 1 - difT ) ; TermLink bLink = memory . currentBeliefLink ; final float difB = truth . getExpDifAbs ( bTruth ) ; bLink . decPriority ( 1 - difB ) ; bLink . decDurability ( 1 - difB ) ; } final float dif = truth . getConfidence ( ) - Math . max ( tTruth . getConfidence ( ) , bTruth . getConfidence ( ) ) ; final float priority = or ( dif , task . getPriority ( ) ) ; final float durability = aveAri ( dif , task . getDurability ( ) ) ; final float quality = truthToQuality ( truth ) ; return new BudgetValue ( priority , durability , quality ) ; }
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; app = ( MPDApplication ) getApplication ( ) ; setContentView ( app . isTabletUiEnabled ( ) ? R . layout . main_activity_nagvigation_tablet : R . layout . main_activity_nagvigation ) ; nowPlayingDualPane = findViewById ( R . id . nowplaying_dual_pane ) ; nowPlayingPager = ( ViewPager ) findViewById ( R . id . pager ) ; libraryRootFrame = findViewById ( R . id . library_root_frame ) ; isDualPaneMode = ( nowPlayingDualPane ! = null ) ; switchMode ( DisplayMode . MODE_NOWPLAYING ) ; exitCounterReset = new Handler ( ) ; StrictMode . ThreadPolicy policy = new StrictMode . ThreadPolicy . Builder ( ) . permitAll ( ) . build ( ) ; StrictMode . setThreadPolicy ( policy ) ; final ActionBar actionBar = getActionBar ( ) ; actionBar . setDisplayHomeAsUpEnabled ( true ) ; actionBar . setHomeButtonEnabled ( true ) ; mDrawerItems = new ArrayList < DrawerItem > ( ) ; mDrawerItems . add ( new DrawerItem ( getString ( R . string . nowPlaying ) , DrawerItem . Action . ACTION_NOWPLAYING ) ) ; mDrawerItems . add ( new DrawerItem ( getString ( R . string . libraryTabActivity ) , DrawerItem . Action . ACTION_LIBRARY ) ) ; mDrawerItems . add ( new DrawerItem ( getString ( R . string . outputs ) , DrawerItem . Action . ACTION_OUTPUTS ) ) ; mDrawerLayout = ( DrawerLayout ) findViewById ( R . id . drawer_layout ) ; mDrawerList = ( ListView ) findViewById ( R . id . left_drawer ) ; mDrawerToggle = new ActionBarDrawerToggle ( this , mDrawerLayout , R . drawable . ic_drawer , R . string . drawer_open , R . string . drawer_close ) { public void onDrawerClosed ( View view ) { refreshActionBarTitle ( ) ; } public void onDrawerOpened ( View drawerView ) { actionBar . setNavigationMode ( ActionBar . NAVIGATION_MODE_STANDARD ) ; actionBar . setDisplayShowTitleEnabled ( true ) ; actionBar . setTitle ( R . string . app_name ) ; } } ; mDrawerLayout . setDrawerListener ( mDrawerToggle ) ; mDrawerList . setAdapter ( new ArrayAdapter < DrawerItem > ( this , R . layout . drawer_list_item , mDrawerItems ) ) ; oldDrawerPosition = 0 ; mDrawerList . setItemChecked ( oldDrawerPosition , true ) ; mDrawerList . setOnItemClickListener ( new DrawerItemClickListener ( ) ) ; fragmentManager = getSupportFragmentManager ( ) ; fragmentManager . addOnBackStackChangedListener ( this ) ; mTabList = LibraryTabsUtil . getCurrentLibraryTabs ( this . getApplicationContext ( ) ) ; ArrayAdapter < CharSequence > actionBarAdapter = new ArrayAdapter < CharSequence > ( actionBar . getThemedContext ( ) , android . R . layout . simple_spinner_item ) ; for ( int i = 0 ; i < mTabList . size ( ) ; i + + ) { actionBarAdapter . add ( getText ( LibraryTabsUtil . getTabTitleResId ( mTabList . get ( i ) ) ) ) ; } actionBarAdapter . setDropDownViewResource ( android . R . layout . simple_spinner_dropdown_item ) ; actionBar . setListNavigationCallbacks ( actionBarAdapter , this ) ; libraryFragment = ( LibraryFragment ) fragmentManager . findFragmentByTag ( FRAGMENT_TAG_LIBRARY ) ; if ( libraryFragment = = null ) { libraryFragment = new LibraryFragment ( ) ; final FragmentTransaction ft = getSupportFragmentManager ( ) . beginTransaction ( ) ; ft . setTransition ( FragmentTransaction . TRANSIT_FRAGMENT_OPEN ) ; ft . replace ( R . id . library_root_frame , libraryFragment , FRAGMENT_TAG_LIBRARY ) ; ft . commit ( ) ; } nowPlayingPager . setAdapter ( new MainMenuPagerAdapter ( ) ) ; nowPlayingPager . setOnPageChangeListener ( new ViewPager . SimpleOnPageChangeListener ( ) {
public V get ( K key ) { PatriciaTrie . Node node = trie . getNode ( key ) ; if ( node instanceof RadixNode ) { RadixNode < V > radixNode = ( RadixNode < V > ) node ; return radixNode . value ; } return null ; }
public V get ( K key ) { Trie . Node node = trie . getNode ( key ) ; if ( node ! = null & & node instanceof TrieMapNode ) { TrieMapNode < V > mapNode = ( TrieMapNode < V > ) node ; return mapNode . value ; } return null ; }
public void writeConfig ( Config config , Writer writer ) throws IOException { currentIndentLevel = - 1 ; TableWriter . writeSmartly ( config , new ArrayList < > ( ) , new WriterOutput ( writer ) , this ) ; }
public void end ( ) { } public void error ( ) { become ( " end " ) ; } }
public List < FilesystemTreeEntry > getDir ( String path ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; List < String > response = mpdConnection . sendCommand ( MPDCommand . MPD_CMD_LSDIR , path ) ; LinkedList < String > lineCache = new LinkedList < String > ( ) ; LinkedList < FilesystemTreeEntry > result = new LinkedList < FilesystemTreeEntry > ( ) ; for ( String line : response ) { if ( line . startsWith ( " file:  " ) & & lineCache . size ( ) > 0 ) { result . add ( new Music ( lineCache ) ) ; lineCache . clear ( ) ; } if ( line . startsWith ( " playlist:  " ) ) { lineCache . clear ( ) ; line = line . substring ( " playlist:  " . length ( ) ) ; result . add ( new PlaylistFile ( line ) ) ; } else if ( line . startsWith ( " directory:  " ) ) { lineCache . clear ( ) ; line = line . substring ( " directory:  " . length ( ) ) ; result . add ( rootDirectory . makeDirectory ( line ) ) ; } else { lineCache . add ( line ) ; } } if ( lineCache . size ( ) > 0 ) { for ( String line : lineCache ) { if ( line . startsWith ( " file:  " ) ) { result . add ( new Music ( lineCache ) ) ; break ; } } } return result ; }
protected abstract byte [ ] buildResponse ( SaslClient sc ) throws SaslException ; @Override protected void decodePayload ( byte [ ] pl ) { getLogger ( ) . debug ( " Auth response:  %s " , new String ( pl ) ) ; } @Override protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) , StatusCode . SUCCESS ) ) ; transitionState ( OperationState . COMPLETE ) ; } else if ( errorCode = = 0 ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , " " , StatusCode . SUCCESS ) ) ; transitionState ( OperationState . COMPLETE ) ; } else { super . finishedPayload ( pl ) ; } } @Override public String toString ( ) { return " SASL base operation " ; } }
public static < T extends Comparable < T > > void printNode ( Node < T > root ) { System . out . println ( ) ; print ( root , " " , true ) ; System . out . println ( ) ; }
static CommentedConfig parseNormal ( CommentedConfig parentConfig , CharacterInput input , TomlParser parser ) { return parseNormal ( input , parser , parentConfig . createSubConfig ( ) ) ; }
protected void onDetachedFromWindow ( ) { super . onDetachedFromWindow ( ) ; ActivityChooserModel dataModel = mAdapter . getDataModel ( ) ; if ( dataModel ! = null ) { dataModel . unregisterObserver ( mModelDataSetOberver ) ; } ViewTreeObserver viewTreeObserver = getViewTreeObserver ( ) ; if ( viewTreeObserver . isAlive ( ) ) { viewTreeObserver . removeGlobalOnLayoutListener ( mOnGlobalLayoutListener ) ; } mIsAttachedToWindow = false ; }
public void testAsyncGetBulkVarargWithTranscoder ( ) throws Exception { Transcoder < String > t = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( t , " test1 " , " test2 " , " test3 " ) . size ( ) ) ; client . set ( " test1 " , 5 , " val1 " , t ) ; client . set ( " test2 " , 5 , " val2 " , t ) ; BulkFuture < Map < String , String > > vals = client . asyncGetBulk ( t , " test1 " , " test2 " , " test3 " ) ; assert vals . getStatus ( ) . isSuccess ( ) ; assertEquals ( 2 , vals . get ( ) . size ( ) ) ; assertEquals ( " val1 " , vals . get ( ) . get ( " test1 " ) ) ; assertEquals ( " val2 " , vals . get ( ) . get ( " test2 " ) ) ; }
static void writeLiteralMultiline ( String str , CharacterOutput output ) { output . write ( " ''' \ n " ) ; output . write ( str ) ; output . write ( " '''' " ) ; }
public List < Music > search ( final String type , final String locatorString ) throws IOException , MPDException { return genericSearch ( MPDCommand . MPD_CMD_SEARCH , type , locatorString ) ; }
public List < String > listAlbumArtists ( final Genre genre , final boolean sortInsensitive ) throws IOException , MPDException { final List < String > response = mConnection . sendCommand ( MPDCommand . MPD_CMD_LIST_TAG , MPDCommand . MPD_TAG_ALBUM_ARTIST , MPDCommand . MPD_TAG_GENRE , genre . getName ( ) ) ; return Tools . parseResponse ( response , " AlbumArtist " , sortInsensitive ) ; }
public String toString ( ) { return key ( ) + concepts . toString ( ) ; }
public void before ( Body b , DrawPhy2D d ) { d . setFillColor ( null ) ; d . setStroke ( null ) ; }
public abstract int size ( ) ; public static < T > List < T > createList ( ListType type ) { switch ( type ) { case ArrayList : return new ArrayList < T > ( ) ; default : return new LinkedList < T > ( ) ; } } public static class ArrayList < T > extends List < T > { private static final int GROW_IN_CHUNK_SIZE = 1000 ; private static final int SHRINK_IN_CHUNK_SIZE = 1000 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int size = 0 ; @Override public void add ( T value ) { if ( size > = array . length ) { array = Arrays . copyOf ( array , size + GROW_IN_CHUNK_SIZE ) ; } array [ size + + ] = value ; } @Override public boolean remove ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) { for ( int j = i + 1 ; j < size ; j + + ) { array [ j - 1 ] = array [ j ] ; } array [ - - size ] = null ; if ( array . length - size > = SHRINK_IN_CHUNK_SIZE ) { array = Arrays . copyOf ( array , size ) ; } return true ; } } return false ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public T get ( int index ) { if ( index > = size ) return null ; return array [ index ] ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i + + ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } public static class LinkedList < T > extends List < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; @Override public void add ( T value ) { add ( new Node < T > ( value ) ) ; } private void add ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > prev = tail ; prev . nextNode = node ; node . previousNode = prev ; tail = node ; } size + + ; } @Override public boolean remove ( T value ) { Node < T > node = head ; while ( node ! = null & & ( ! node . value . equals ( value ) ) ) { node = node . nextNode ; } if ( node = = null ) return false ; if ( node . equals ( tail ) ) tail = node . previousNode ; Node < T > prev = node . previousNode ; Node < T > next = node . nextNode ; if ( prev ! = null & & next ! = null ) { prev . nextNode = next ; next . previousNode = prev ; } else if ( prev ! = null & & next = = null ) { prev . nextNode = null ; } else if ( prev = = null & & next ! = null ) { next . previousNode = null ; head = next ; } else { head = null ; } size - - ; return true ; } @Override public boolean contains ( T value ) { Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . nextNode ; } return false ; } @Override public T get ( int index ) { T result = null ; Node < T > node = head ; int i = 0 ; while ( node ! = null & & i < index ) { node = node . nextNode ; i + + ; } if ( node ! = null ) result = node . value ; return result ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . nextNode ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > previousNode = null ; private Node < T > nextNode = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( previousNode ! = null ) ? previousNode . value : " NULL " ) + "  next= " + ( ( nextNode ! = null ) ? nextNode . value : " NULL " ) ; } } } }
public static com . cloudera . labs . envelope . input . translate . ProtobufSingleMessage . SingleExample parseDelimitedFrom ( java . io . InputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input , extensionRegistry ) ;
public void testKMRarray ( ) { String string = " aasfaasdsadasdfasdasdasdasfdasfassdfas " ; SuffixArray suffixArrayBuilder = new SuffixArray ( string ) ; ArrayList < Integer > suffixArray = suffixArrayBuilder . getSuffixArray ( ) ; ArrayList < Integer > KMRarray = suffixArrayBuilder . getKMRarray ( ) ; int length = string . length ( ) ; for ( int i = 0 ; i < length ; i + + ) { assertTrue ( suffixArray . get ( KMRarray . get ( i ) ) = = i ) ;
public ResponseStatus nowPlaying ( String artist , String track ) throws IOException { return nowPlaying ( artist , track , null , - 1 , - 1 ) ; }
public boolean checkAsyncMDN ( final AS2Message aMsg ) { try { final String sReturnMIC = aMsg . getMDN ( ) . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_MIC ) ; final String sOrigMessageID = aMsg . getMDN ( ) . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_ORIG_MESSAGEID ) ; final String sPendingInfoFile = getModule ( ) . getSession ( ) . getMessageProcessor ( ) . attrs ( ) . getAsString ( ATTR_PENDINGMDNINFO ) + " / " + AS2IOHelper . getFilenameFromMessageID ( sOrigMessageID ) ; String sOriginalMIC ; File aPendingFile ; try ( final NonBlockingBufferedReader aPendingInfoReader = new NonBlockingBufferedReader ( new FileReader ( sPendingInfoFile ) ) ) { sOriginalMIC = aPendingInfoReader . readLine ( ) ; aPendingFile = new File ( aPendingInfoReader . readLine ( ) ) ; } final String sDisposition = aMsg . getMDN ( ) . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_DISPOSITION ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " received MDN [ " + sDisposition + " ] " + aMsg . getLoggingText ( ) ) ; if ( sOriginalMIC = = null | | ! sReturnMIC . replaceAll ( " \\ s+ " , " " ) . equals ( sOriginalMIC . replaceAll ( " \\ s+ " , " " ) ) ) { if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " MIC IS NOT MATCHED, original mic:  " + sOriginalMIC + "  return mic:  " + sReturnMIC + aMsg . getLoggingText ( ) ) ; return false ; } if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " mic is matched, mic:  " + sReturnMIC + aMsg . getLoggingText ( ) ) ; final File aPendingInfoFile = new File ( sPendingInfoFile ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " delete pendinginfo file :  " + aPendingInfoFile . getName ( ) + "  from pending folder :  " + getModule ( ) . getSession ( ) . getMessageProcessor ( ) . attrs ( ) . getAsString ( ATTR_PENDINGMDN ) + aMsg . getLoggingText ( ) ) ; if ( ! aPendingInfoFile . delete ( ) ) { if ( LOGGER . isErrorEnabled ( ) ) LOGGER . error ( " Error delete pendinginfo file  " + aPendingFile ) ; } if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " delete pending file :  " + aPendingFile . getName ( ) + "  from pending folder :  " + aPendingFile . getParent ( ) + aMsg . getLoggingText ( ) ) ; if ( ! aPendingFile . delete ( ) ) { if ( LOGGER . isErrorEnabled ( ) ) LOGGER . error ( " Error delete pending file  " + aPendingFile ) ; } } catch ( final IOException | ComponentNotFoundException ex ) { LOGGER . error ( " Error checking async MDN " , ex ) ; return false ; } return true ; }
static void transformProductImage ( Inheritance inh , CompoundTerm oldContent , short [ ] indices , NAL nal ) { final Memory memory = nal . mem ( ) ; Term subject = inh . getSubject ( ) ; Term predicate = inh . getPredicate ( ) ; if ( inh . equals ( oldContent ) ) { if ( subject instanceof CompoundTerm ) { transformSubjectPI ( ( CompoundTerm ) subject , predicate , nal ) ; } if ( predicate instanceof CompoundTerm ) { transformPredicatePI ( subject , ( CompoundTerm ) predicate , nal ) ; } return ; } short index = indices [ indices . length - 1 ] ; short side = indices [ indices . length - 2 ] ; Term compT = inh . term [ side ] ; if ( ! ( compT instanceof CompoundTerm ) ) return ; CompoundTerm comp = ( CompoundTerm ) compT ; if ( comp instanceof Product ) { if ( side = = 0 ) { subject = comp . term [ index ] ; predicate = ImageExt . make ( ( Product ) comp , inh . getPredicate ( ) , index ) ; } else { subject = ImageInt . make ( ( Product ) comp , inh . getSubject ( ) , index ) ; predicate = comp . term [ index ] ; } } else if ( ( comp instanceof ImageExt ) & & ( side = = 1 ) ) { if ( index = = ( ( ImageExt ) comp ) . relationIndex ) { subject = Product . make ( comp , inh . getSubject ( ) , index ) ; predicate = comp . term [ index ] ; } else { subject = comp . term [ index ] ; predicate = ImageExt . make ( ( ImageExt ) comp , inh . getSubject ( ) , index ) ; } } else if ( ( comp instanceof ImageInt ) & & ( side = = 0 ) ) { if ( index = = ( ( ImageInt ) comp ) . relationIndex ) { subject = comp . term [ index ] ; predicate = Product . make ( comp , inh . getPredicate ( ) , index ) ; } else { subject = ImageInt . make ( ( ImageInt ) comp , inh . getPredicate ( ) , index ) ; predicate = comp . term [ index ] ; } } else { return ; } Inheritance newInh = Inheritance . make ( subject , predicate ) ; if ( newInh = = null ) return ; CompoundTerm content = null ; if ( indices . length = = 2 ) { content = newInh ; } else if ( ( oldContent instanceof Statement ) & & ( indices [ 0 ] = = 1 ) ) { content = Statement . make ( ( Statement ) oldContent , oldContent . term [ 0 ] , newInh , oldContent . getTemporalOrder ( ) ) ; } else { Term [ ] componentList ; Term condition = oldContent . term [ 0 ] ; if ( ( ( oldContent instanceof Implication ) | | ( oldContent instanceof Equivalence ) ) & & ( condition instanceof Conjunction ) ) { componentList = ( ( CompoundTerm ) condition ) . cloneTerms ( ) ; componentList [ indices [ 1 ] ] = newInh ; Term newCond = memory . term ( ( CompoundTerm ) condition , componentList ) ; content = Statement . make ( ( Statement ) oldContent , newCond , ( ( Statement ) oldContent ) . getPredicate ( ) , oldContent . getTemporalOrder ( ) ) ; } else { componentList = oldContent . cloneTerms ( ) ; componentList [ indices [ 0 ] ] = newInh ; if ( oldContent instanceof Conjunction ) { Term newContent = memory . term ( oldContent , componentList ) ; if ( ! ( newContent instanceof CompoundTerm ) ) return ; content = ( CompoundTerm ) newContent ; } else if ( ( oldContent instanceof Implication ) | | ( oldContent instanceof Equivalence ) ) { content = Statement . make ( ( Statement ) oldContent , componentList [ 0 ] , componentList [ 1 ] , oldContent . getTemporalOrder ( ) ) ; } } } if ( content = = null ) return ; Sentence sentence = nal . getCurrentTask ( ) . sentence ; TruthValue truth = sentence . truth ; BudgetValue budget ; if ( sentence . isQuestion ( ) ) { budget = BudgetFunctions . compoundBackward ( content , nal ) ; } else { budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; } nal . singlePremiseTask ( content , truth , budget ) ; }
String getKey ( ) ; < T > T getValue ( ) ; } ConfigFormat < ? , ? , ? > configFormat ( ) ; }
public void onAnimationEnd ( Animator animation ) { if ( mRule = = Dependency . AFTER ) { startIfReady ( animation ) ;
protected ArrayRealVector newNodeCoordinates ( Object node ) { newNode . set ( true ) ; return super . newNodeCoordinates ( node ) ; }
public static Term make ( TreeSet < Term > set , Memory memory ) { if ( set . isEmpty ( ) ) { return null ; } ArrayList < Term > argument = new ArrayList < Term > ( set ) ; String name = makeSetName ( Symbols . SET_INT_OPENER , argument , Symbols . SET_INT_CLOSER ) ; Term t = memory . nameToTerm ( name ) ; return ( t ! = null ) ? t : new SetInt ( argument ) ; }
public void testMultipleArrivingOneExistingWhereAllArrivingLaterThanExisting ( ) { p = new BitemporalHistoryPlanner ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , FAR_FUTURE_MILLIS , 1L , FAR_FUTURE_MILLIS , CURRENT_FLAG_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 200L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world! " , 300L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world? " , 400L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 5 ) ; Long systemStart1 = ( Long ) RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemstart " ) ; Long systemStart2 = ( Long ) RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " systemstart " ) ; Long systemStart3 = ( Long ) RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " systemstart " ) ; Long systemStart4 = ( Long ) RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " systemstart " ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . UPDATE ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemstart " ) , 1L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemend " ) , RowUtils . precedingTimestamp ( systemStart1 ) ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( planned . get ( 1 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventend " ) , 199L ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( planned . get ( 2 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " eventstart " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " eventend " ) , 299L ) ; assertTrue ( systemStart2 > = preplanSystemTime ) ; assertTrue ( systemStart2 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( planned . get ( 3 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " value " ) , " world! " ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " eventstart " ) , 300L ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " eventend " ) , 399L ) ; assertTrue ( systemStart3 > = preplanSystemTime ) ; assertTrue ( systemStart3 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( planned . get ( 4 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " value " ) , " world? " ) ; assertEquals ( RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " eventstart " ) , 400L ) ; assertEquals ( RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertTrue ( systemStart4 > = preplanSystemTime ) ; assertTrue ( systemStart4 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_YES ) ; }
public void testTranslation ( ) throws Exception { String delimited = " hello%$-100.1%$1000.5%$99%$888%$%$false%$2018-03-03T20:23:33.897+04:00 " ; Config config = ConfigFactory . empty ( ) . withValue ( DelimitedTranslator . FIELD_NAMES_CONFIG_NAME , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " field1 " , " field2 " , " field3 " , " field4 " , " field5 " , " field6 " , " field7 " , " field8 " ) ) ) . withValue ( DelimitedTranslator . FIELD_TYPES_CONFIG_NAME , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " string " , " float " , " double " , " int " , " long " , " int " , " boolean " , " timestamp " ) ) ) . withValue ( DelimitedTranslator . DELIMITER_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( " %$ " ) ) ; Translator < String , String > t = new DelimitedTranslator ( ) ; t . configure ( config ) ; Row r = t . translate ( null , delimited ) . iterator ( ) . next ( ) ; assertEquals ( r . length ( ) , 8 ) ; assertEquals ( r . get ( 0 ) , " hello " ) ; assertEquals ( r . get ( 1 ) , - 100.1f ) ; assertEquals ( r . get ( 2 ) , 1000.5d ) ; assertEquals ( r . get ( 3 ) , 99 ) ; assertEquals ( r . get ( 4 ) , 888L ) ; assertEquals ( r . get ( 5 ) , null ) ; assertEquals ( r . get ( 6 ) , false ) ; assertEquals ( r . get ( 7 ) . toString ( ) , " 2018-03-03 11:23:33.897 " ) ; }
public void textValueUpdated ( ServiceInfo target , byte [ ] value ) { synchronized ( _services ) { for ( JmDNS mDNS : _knownMDNS . values ( ) ) {
public SortedMap < K , V > subMap ( K fromKey , K toKey ) { throw new InternalError ( ) ; }
public Iterator propertyIterator ( ) { return model . propertyIterator ( ) ; }
public synchronized void addExceptionListener ( ExceptionListener l ) { exceptionListeners . add ( l ) ; }
public ImaginationSpace ConstructSpace ( Conjunction program ) ; public ImaginationSpace ProgressSpace ( Operation op , ImaginationSpace B ) ; public boolean IsOperationInSpace ( Operation oper ) ; }
public Dataset < Row > read ( ) throws Exception { String url = config . getString ( JDBC_CONFIG_URL ) ; String tablename = config . getString ( JDBC_CONFIG_TABLENAME ) ; String username = config . getString ( JDBC_CONFIG_USERNAME ) ; String password = config . getString ( JDBC_CONFIG_PASSWORD ) ; Properties properties = new Properties ( ) ; properties . put ( " user " , username ) ; properties . put ( " password " , password ) ; return Contexts . getSparkSession ( ) . read ( ) . jdbc ( url , tablename , properties ) ; }
private static boolean testKdTree ( String name , int testRound , int testNum , int [ ] [ ] unsorteds ) { if ( testRound ! = 0 ) { testNames [ testNum ] = name ; if ( testResults [ testNum ] = = null ) testResults [ testNum ] = new long [ 5 ] ; } int test = 0 ; List < KdTree . XYZPoint > points = new ArrayList < KdTree . XYZPoint > ( ARRAY_SIZE ) ; for ( int i = 0 ; i < ARRAY_SIZE ; i + + ) { KdTree . XYZPoint p = new KdTree . XYZPoint ( unsorteds [ i ] [ 0 ] , unsorteds [ i ] [ 1 ] ) ; points . add ( p ) ; } long beforeMemory = DataStructuresTiming . getMemoryUse ( ) ; long beforeAddTime = System . nanoTime ( ) ; KdTree < KdTree . XYZPoint > tree = new KdTree < KdTree . XYZPoint > ( points , 2 ) ; long afterAddTime = System . nanoTime ( ) ; long afterMemory = DataStructuresTiming . getMemoryUse ( ) ; long memory = afterMemory - beforeMemory ; if ( testRound ! = 0 ) testResults [ testNum ] [ test + + ] + = memory ; System . out . println ( name + "  memory use =  " + ( memory / ARRAY_SIZE ) + "  bytes " ) ; long addTime = afterAddTime - beforeAddTime ; if ( testRound ! = 0 ) testResults [ testNum ] [ test + + ] + = addTime ; System . out . println ( name + "  add time =  " + ( addTime / ARRAY_SIZE ) + "  ns " ) ; long beforeContainsTime = System . nanoTime ( ) ; for ( KdTree . XYZPoint p : points ) { boolean r = tree . contains ( p ) ; assertTrue ( " Point not found. " , p , tree , r = = true ) ; } long afterContainsTime = System . nanoTime ( ) ; long containsTime = afterContainsTime - beforeContainsTime ; if ( testRound ! = 0 ) testResults [ testNum ] [ test + + ] + = containsTime ; System . out . println ( name + "  contains time =  " + ( containsTime / ARRAY_SIZE ) + "  ns " ) ; long beforeNnTime = System . nanoTime ( ) ; for ( KdTree . XYZPoint p : points ) { Collection < KdTree . XYZPoint > c = tree . nearestNeighbourSearch ( 4 , p ) ; assertTrue ( " nearest neighbor didn't find anyone. " , p , tree , c . size ( ) > 0 ) ; } long afterNnTime = System . nanoTime ( ) ; long nnTime = afterNnTime - beforeNnTime ; if ( testRound ! = 0 ) testResults [ testNum ] [ test + + ] + = nnTime ; System . out . println ( name + "  nearest neighbor time =  " + ( nnTime / ARRAY_SIZE ) + "  ns " ) ; long beforeRemovesTime = System . nanoTime ( ) ; for ( KdTree . XYZPoint p : points ) { boolean r = tree . remove ( p ) ; assertTrue ( " Point not removed. " , p , tree , r = = true ) ; } long afterRemovesTime = System . nanoTime ( ) ; long removesTime = afterRemovesTime - beforeRemovesTime ; if ( testRound ! = 0 ) testResults [ testNum ] [ test + + ] + = removesTime ; System . out . println ( name + "  removes time =  " + ( removesTime / ARRAY_SIZE ) + "  ns " ) ; return true ; }
public List < String > waitForChanges ( ) throws MPDServerException { while ( mpdIdleConnection ! = null & & mpdIdleConnection . isConnected ( ) ) { List < String > data = mpdIdleConnection . sendAsyncCommand ( MPDCommand . MPD_CMD_IDLE ) ; if ( data . isEmpty ( ) ) { continue ; } return data ; } throw new MPDConnectionException ( " IDLE connection lost " ) ; }
public < R > R bulkCommentedRead ( Function < ? super UnmodifiableCommentedConfig , R > action ) { return config . bulkCommentedRead ( action ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmInSet p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmProd p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmLit p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmStm p , A arg ) ; } }
static Point [ ] RotateToZero ( Point [ ] points ) { Point c = Centroid ( points ) ; float theta = atan2 ( c . Y - points [ 0 ] . Y , c . X - points [ 0 ] . X ) ; return RotateBy ( points , - theta ) ; }
void drawArrowAngle ( final float cx , final float cy , final float len , final float angle ) { pushMatrix ( ) ; translate ( cx , cy ) ; rotate ( radians ( angle ) ) ; line ( 0 , 0 , len , 0 ) ; line ( len , 0 , len - 8 , - 8 ) ; line ( len , 0 , len - 8 , 8 ) ; popMatrix ( ) ; }
public void testSpanMeters ( ) throws Exception { CompositeSpanTracker cst = new CompositeSpanTracker ( new NanoTimeDurationTracker ( " NanoTimeDurationExample " , new Range ( 0 , 10 ) , new Range ( 10 , 50 ) , new Range ( 50 , 150 ) ) , new HitPeriodTracker ( " HitFrequencyExample " ) , new ThreadCPUTimeTracker ( " ThreadCPUExample " ) , new MemoryUseTracker ( " MemoryUseExample " ) ) ; for ( int i = 0 ; i < 2 ; i + + ) { cst . track ( ) ; { NAR n = new Default ( ) . build ( ) ; } cst . commit ( ) ; } for ( Sensor x : cst . trackers ) { } assertTrue ( true ) ;
public void multiplication ( ) { int a = nextRandomInt ( MIN , MAX ) ; int b = nextRandomInt ( MIN , MAX ) ; String resultString ; long result = Multiplication . multiplyUsingLoop ( a , b ) ; long check = Multiplication . multiplication ( a , b ) ; assertTrue ( " Multiplication using a loop. a= " + a + "  b= " + b + "  result= " + result + "  check= " + check , ( result = = check ) ) ; result = Multiplication . multiplyUsingRecursion ( a , b ) ; check = Multiplication . multiplication ( a , b ) ; assertTrue ( " Multiplication using recursion. a= " + a + "  b= " + b + "  result= " + result + "  check= " + check , ( result = = check ) ) ; result = Multiplication . multiplyUsingShift ( a , b ) ; check = Multiplication . multiplication ( a , b ) ; assertTrue ( " Multiplication using shifts. a= " + a + "  b= " + b + "  result= " + result + "  check= " + check , ( result = = check ) ) ; result = Multiplication . multiplyUsingLogs ( a , b ) ; check = Multiplication . multiplication ( a , b ) ; assertTrue ( " Multiplication using logs. a= " + a + "  b= " + b + "  result= " + result + "  check= " + check , ( result = = check ) ) ; result = Integer . parseInt ( Multiplication . multiplyUsingFFT ( Integer . toString ( a ) , Integer . toString ( b ) ) ) ; check = Multiplication . multiplication ( a , b ) ; assertTrue ( " Multiplication using FFT. a= " + a + "  b= " + b + "  result= " + result + "  check= " + check , ( result = = check ) ) ; }
static CommentedConfig concurrentCopy ( UnmodifiableConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , true ) ; }
public void run ( ) { String filename = JOptionPane . showInputDialog ( " What is the name of the level?:  " ) + " .lvl " ; / * todo
public boolean equals ( Object o ) { return ( o instanceof Artist ) & & ( ( Artist ) o ) . name . equals ( name ) ; }
public ListIterator < ExternalV > listIterator ( ) { return new TransformingListIterator < > ( ( ( List < InternalV > ) internalCollection ) . listIterator ( ) , readTransformation , writeTransformation ) ; }
private void fireCleared ( ) { eventManager . fireEvent ( EventType . SESSION_CLEARED , key , this ) ; }
static CommentedConfig copy ( UnmodifiableConfig config , Supplier < Map < String , Object > > mapCreator , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , mapCreator , format ) ; }
public void onClick ( DialogInterface dialog , int whichButton ) { if ( streamUrlToAdd ! = null ) { getActivity ( ) . finish ( ) ;
public static Interval interval ( final String i ) { return intervalMagnitude ( Integer . parseInt ( i . substring ( 1 ) ) - 1 ) ; }
public AS2ClientRequest setData ( @Nonnull final InputStream aIS ) { ValueEnforcer . notNull ( aIS , " InputStream " ) ; return setData ( StreamUtils . getAllBytes ( aIS ) ) ; }
public static void main ( String [ ] args ) throws Exception { NAR nar = new DefaultNARBuilder ( ) . build ( ) ; new TextOutput ( nar , System . out ) ; NARProlog prolog = new NARProlog ( nar ) ; new NARPrologMirror ( nar , prolog ) ; nar . addInput ( " <a --> b>. " ) ; nar . finish ( 3 ) ; prolog . solve ( " inheritance(X,b). " ) ;
public void testTranslation ( ) { Config config = ConfigFactory . empty ( ) . withValue ( JSONTranslator . SCHEMA_CONFIG + " . " + SchemaFactory . TYPE_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( new AvroSchema ( ) . getAlias ( ) ) ) . withValue ( JSONTranslator . SCHEMA_CONFIG + " . " + AvroSchema . AVRO_FILE_CONFIG , ConfigValueFactory . fromAnyRef ( getClass ( ) . getResource ( " /translator/json-translator-schema.avsc " ) . getFile ( ) ) ) ; JSONTranslator translator = new JSONTranslator ( ) ; ValidationAssert . assertNoValidationFailures ( translator , config ) ; translator . configure ( config ) ; String json = " { \ n " + "    \" f1 \" :  \" hello \" , \ n " + "    \" f2 \" : 1.2, \ n " + "    \" f3 \" : true, \ n " + "    \" f4 \" : { \ n " + "      \" f41 \" :  \" world \" \ n " + "   }, \ n " + "    \" f5 \" : [ \ n " + "      \" v5 \" \ n " + "   ], \ n " + "    \" f6 \" : [ \ n " + "     { \ n " + "        \" f611 \" : [false, false] \ n " + "     } \ n " + "   ] \ n " + " } " ; Row message = new RowWithSchema ( SchemaUtils . stringValueSchema ( ) , json ) ; Iterable < Row > rows = translator . translate ( message ) ; assertEquals ( 1 , Lists . newArrayList ( rows ) . size ( ) ) ; Row row = rows . iterator ( ) . next ( ) ; assertEquals ( " hello " , row . getAs ( " f1 " ) ) ; assertEquals ( 1.2f , row . getAs ( " f2 " ) ) ; assertEquals ( true , row . getAs ( " f3 " ) ) ; assertEquals ( " world " , row . getStruct ( row . fieldIndex ( " f4 " ) ) . getAs ( " f41 " ) ) ; assertEquals ( " v5 " , row . getList ( row . fieldIndex ( " f5 " ) ) . get ( 0 ) ) ; assertEquals ( false , ( ( Row ) row . getList ( row . fieldIndex ( " f6 " ) ) . get ( 0 ) ) . getList ( 0 ) . get ( 0 ) ) ; assertEquals ( false , ( ( Row ) row . getList ( row . fieldIndex ( " f6 " ) ) . get ( 0 ) ) . getList ( 0 ) . get ( 1 ) ) ; }
protected void onAttachedToWindow ( ) { super . onAttachedToWindow ( ) ; for ( View_OnAttachStateChangeListener listener : mListeners ) { listener . onViewAttachedToWindow ( this ) ;
private E takeOutIndex ( final int index , boolean removeFromNameTable ) { final E selected = items . remove ( index ) ; if ( removeFromNameTable ) nameTable . remove ( selected . getKey ( ) ) ; addToMass ( - ( selected . budget . getPriority ( ) ) ) ; return selected ; }
public void readToStampedConfig ( ) { File f = new File ( " test.yml " ) ; StampedConfig config = new StampedConfig ( InMemoryCommentedFormat . defaultInstance ( ) , HashMap : : new ) ; new YamlParser ( ) . parse ( f , config , ParsingMode . REPLACE , FileNotFoundAction . THROW_ERROR ) ; Util . checkExample ( config ) ; }
public List < Artist > getArtists ( final boolean useAlbumArtist ) throws MPDServerException { final List < String > artistNames = useAlbumArtist ? listAlbumArtists ( ) : listArtists ( true ) ; final List < Artist > artists = new ArrayList < > ( artistNames . size ( ) ) ; if ( null ! = artistNames & & ! artistNames . isEmpty ( ) ) { for ( final String artist : artistNames ) { artists . add ( new Artist ( artist ) ) ; } } Collections . sort ( artists ) ; return artists ; }
public void pre ( ) { if ( keepCursorInView ) { boolean horzScroll = false , vertScroll = false ;
public FileConfig wrapRead ( FileConfig config ) { return new ConvertedFileConfig ( config , this : : convert , v - > v , config . configFormat ( ) : : supportsType ) ;
public Object clone ( ) { return new Disjunction ( name , ( ArrayList < Term > ) cloneList ( components ) , isConstant ( ) , complexity ) ; }
public boolean put ( T key , T value ) { int hashedKey = hashingFunction ( key ) ; List < T > list = map [ hashedKey ] ; for ( int i = 0 ; i < list . size ( ) ; i + + ) { T v = list . get ( i ) ; if ( v = = value ) return false ; } list . add ( value ) ; size + + ; return true ; }
public void testJsonObject ( ) { String json = " { \" aaaaaaaaaaaaaaaaaaaaaaaaa \" : " + " \" aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \" } " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = tc . encode ( json ) ; assertFalse ( " Flags shows JSON was compressed " , ( cd . getFlags ( ) & ( 1L < < WhalinTranscoder . COMPRESSED ) ) ! = 0 ) ; assertTrue ( " JSON was incorrectly encoded " , Arrays . equals ( json . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( " JSON was harmed, should not have been " , json , tc . decode ( cd ) ) ; }
public static String encode ( String s ) { if ( s = = null ) return null ; try { return URLEncoder . encode ( s , " UTF-8 " ) ; } catch ( UnsupportedEncodingException e ) { } return null ; }
public void testStringEnumsCaseInsensitive ( ) { Map < String , Object > configMap = new HashMap < > ( ) ; configMap . put ( " fields " , Lists . newArrayList ( " name " , " nickname " ) ) ; configMap . put ( " fieldtype " , " string " ) ; configMap . put ( " values " , Lists . newArrayList ( " Ian " , " Jeremy " , " Webster " ) ) ; configMap . put ( " case-sensitive " , false ) ; Config config = ConfigFactory . parseMap ( configMap ) ; EnumRowRule rule = new EnumRowRule ( ) ; assertNoValidationFailures ( rule , config ) ; rule . configure ( " namecheck " , config ) ; Row row1 = new RowWithSchema ( SCHEMA , " Ian " , " ian " , 34 , new BigDecimal ( " 0.00 " ) ) ; assertTrue ( " Row should pass rule " , rule . check ( row1 ) ) ; Row row2 = new RowWithSchema ( SCHEMA , " Webster " , " Websta " , 110 , new BigDecimal ( " 450.10 " ) ) ; assertFalse ( " Row should not pass rule " , rule . check ( row2 ) ) ; }
public void shutdown ( ) throws MPDServerException { if ( ! isConnected ( ) ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } mpdConnection . sendCommand ( MPDCommand . MPD_CMD_KILL ) ; }
public final boolean isDebugLogEnabled ( ) { return m_aRWLock . readLockedBoolean ( ( ) - > m_bDebugLog ) ; }
public int cardinality ( ) { int sum = 0 ; for ( int i = 0 ; i < _length ; i + + ) { sum + = MathLib . bitCount ( bits [ i ] ) ; } return sum ; }
public boolean parse ( NAR nar , String input , TextInputParser lastHandler ) { if ( ! nar . isWorking ( ) ) { if ( input . equals ( Symbols . STOP_COMMAND ) ) { nar . output ( Output . OUT . class , " stopping. " ) ; nar . setWorking ( false ) ; return true ; } } return false ; }
String getFilename ( ) ; default void setPassword ( @Nonnull final char [ ] aPassword ) { setPassword ( new String ( aPassword ) ) ; } void setPassword ( @Nullable String sPassword ) ; @Nullable char [ ] getPassword ( ) ; void setSaveChangesToFile ( boolean bSaveChangesToFile ) ; boolean isSaveChangesToFile ( ) ; default void load ( ) throws OpenAS2Exception { load ( getFilename ( ) , getPassword ( ) ) ; } default void load ( @Nonnull final String sFilename , @Nonnull final char [ ] aPassword ) throws OpenAS2Exception { InputStream aFIS = null ; try { aFIS = KeyStoreHelper . getResourceProvider ( ) . getInputStream ( sFilename ) ; if ( aFIS = = null ) throw new OpenAS2Exception ( " Failed to to open input stream from ' " + sFilename + " ' " ) ; } catch ( final RuntimeException ex ) { throw new OpenAS2Exception ( " Failed to to open input stream from ' " + sFilename + " ' " , ex ) ; } load ( aFIS , aPassword ) ; } void load ( @Nonnull InputStream aIS , @Nonnull char [ ] aPassword ) throws OpenAS2Exception ; default void save ( ) throws OpenAS2Exception { save ( getFilename ( ) , getPassword ( ) ) ; } default void save ( @Nonnull final String sFilename , @Nonnull final char [ ] aPassword ) throws OpenAS2Exception { final OutputStream fOut = FileHelper . getOutputStream ( new File ( sFilename ) , EAppend . TRUNCATE ) ; if ( fOut = = null ) throw new OpenAS2Exception ( " Failed to to open output stream to ' " + sFilename + " ' " ) ; save ( fOut , aPassword ) ; } void save ( @Nonnull OutputStream aOS , @Nonnull char [ ] aPassword ) throws OpenAS2Exception ; }
public void clear ( ) ; public Concept concept ( CharSequence name ) ; public Concept addConcept ( Term term , Memory memory ) ; public void conceptActivate ( Concept c , BudgetValue b ) ; public Concept sampleNextConcept ( ) ; }
private static < T extends Comparable < T > > int add ( int length , T element , T [ ] unsorted ) { int i = length ; unsorted [ length + + ] = element ; T e = unsorted [ i ] ; int parentIndex = ( ( i - 1 ) / 2 ) ; T parent = unsorted [ parentIndex ] ; while ( e . compareTo ( parent ) > 0 ) { swap ( parentIndex , i , unsorted ) ; i = parentIndex ; e = unsorted [ i ] ; parentIndex = ( ( i - 1 ) / 2 ) ; parent = unsorted [ parentIndex ] ; } return length ; }
void dispatchOnPanelAnchored ( View panel ) { if ( mPanelSlideListener ! = null ) { mPanelSlideListener . onPanelAnchored ( panel ) ; } sendAccessibilityEvent ( AccessibilityEvent . TYPE_WINDOW_STATE_CHANGED ) ; }
protected void keyPressedProcess ( int keyCode , char keyChar , boolean shiftDown , boolean ctrlDown ) { boolean validKeyCombo = true ; switch ( keyCode ) { case LEFT : moveCaretLeft ( endTLHI ) ; break ; case RIGHT : moveCaretRight ( endTLHI ) ; break ; case GConstants . HOME : moveCaretStartOfLine ( endTLHI ) ; break ; case GConstants . END : moveCaretEndOfLine ( endTLHI ) ; break ; case 'A' : if ( ctrlDown ) { moveCaretStartOfLine ( startTLHI ) ; moveCaretEndOfLine ( endTLHI ) ; shiftDown = true ; } break ; case 'C' : if ( ctrlDown ) GClip . copy ( getSelectedText ( ) ) ; validKeyCombo = false ; break ; case 'V' : if ( ctrlDown ) { String p = GClip . paste ( ) ; p . replaceAll ( " \ n " , " " ) ; if ( p . length ( ) > 0 ) { if ( hasSelection ( ) ) stext . deleteCharacters ( pos , nbr ) ; stext . insertCharacters ( p , pos ) ; adjust = p . length ( ) ; textChanged = true ; } } break ; default : validKeyCombo = false ; } calculateCaretPos ( endTLHI ) ; if ( validKeyCombo ) { if ( ! shiftDown )
public boolean isEnabled ( int position , List < ? extends Object > items , Object item ) ; public void onDataBind ( Context context , View targetView , List < ? extends Object > items , Object item , int position ) ; }
Set < MutationType > getSupportedRandomMutationTypes ( ) ; void applyRandomMutations ( List < PlannedRow > planned ) throws Exception ; Iterable < Row > getExistingForFilters ( Iterable < Row > filters ) throws Exception ; }
private < T > T newInstance ( String className , Class < ? > [ ] constructorSignature , Object [ ] arguments ) { try { Class < ? > clazz = mContext . getClassLoader ( ) . loadClass ( className ) ; Constructor < ? > constructor = clazz . getConstructor ( constructorSignature ) ; return ( T ) constructor . newInstance ( arguments ) ; } catch ( Exception e ) { Log . w ( LOG_TAG , " Cannot instantiate class:  " + className , e ) ; } return null ; }
public void testQuerySetDescending ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setDescending ( true ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }
public void reset ( ) { event . emit ( ResetStart . class ) ; synchronized ( concepts ) { concepts . clear ( ) ; } synchronized ( tasksMutex ) { novelTasks . clear ( ) ; } synchronized ( this . seq_current ) { this . seq_current . clear ( ) ; } if ( emotion ! = null ) { emotion . resetEmotions ( ) ; } recent_operations . clear ( ) ; this . lastDecision = null ; randomNumber . setSeed ( randomSeed ) ; event . emit ( ResetEnd . class ) ; }
public String toString ( ) { return " Track[name= " + name + " ,artist= " + artist + " , album= " + album + " , position= " + position + " , duration= " + duration + " , location= " + location + " , nowPlaying= " + nowPlaying + " , fullTrackAvailable= " + fullTrackAvailable + " , playedWhen= "
public void defineInList ( String path , Supplier < ? > defaultValueSupplier , Collection < ? > acceptableValues ) { defineInList ( split ( path , '.' ) , defaultValueSupplier , acceptableValues ) ; }
public void testCompactSuffixTrie ( ) { String bookkeeper = " bookkeeper " ; CompactSuffixTrie < String > trie = new CompactSuffixTrie < String > ( bookkeeper ) ; boolean exists = trie . doesSubStringExist ( bookkeeper ) ; assertTrue ( " YIKES!!  " + bookkeeper + "  doesn't exists. " , exists ) ; String failed = " booker " ; exists = trie . doesSubStringExist ( failed ) ; assertFalse ( " YIKES!!  " + failed + "  exists. " , exists ) ; String pass = " kkee " ; exists = trie . doesSubStringExist ( pass ) ; assertTrue ( " YIKES!!  " + pass + "  doesn't exists. " , exists ) ; }
private String buildStringWithEndChar ( CharSequence sequence ) { STRING_BUILDER . setLength ( 0 ) ; STRING_BUILDER . append ( sequence ) ; if ( STRING_BUILDER . indexOf ( String . valueOf ( endSeqChar ) ) < 0 ) STRING_BUILDER . append ( endSeqChar ) ; return STRING_BUILDER . toString ( ) ; }
public void init ( ScrollingTabContainerView parent , ActionBar . Tab tab , boolean forList ) { mParent = parent ; mTab = tab ; if ( forList ) { setGravity ( Gravity . LEFT | Gravity . CENTER_VERTICAL ) ; } update ( ) ; }
public boolean isList ( ) { Term t = getTerm ( ) ; if ( t = = this ) { return false ;
public List < Album > listAllAlbumsGrouped ( final boolean useAlbumArtist , final boolean includeUnknownAlbum ) throws IOException , MPDException { final String albumResponse = " Album " ; final String artistResponse ; final List < String > response = mConnection . sendCommand ( listAllAlbumsGroupedCommand ( useAlbumArtist ) ) ; final List < Album > result = new ArrayList < > ( response . size ( ) / 2 ) ; Album currentAlbum = null ; if ( useAlbumArtist ) { artistResponse = " AlbumArtist " ; } else { artistResponse = " Artist " ; } for ( final String [ ] pair : Tools . splitResponse ( response ) ) { if ( artistResponse . equals ( pair [ KEY ] ) ) { if ( currentAlbum ! = null ) { final Album newAlbum = currentAlbum . setAlbumArtist ( new Artist ( pair [ VALUE ] ) ) ; result . add ( newAlbum ) ; } } else if ( albumResponse . equals ( pair [ KEY ] ) ) { if ( ! pair [ VALUE ] . isEmpty ( ) | | includeUnknownAlbum ) { currentAlbum = new Album ( pair [ VALUE ] , null ) ; currentAlbum . setHasAlbumArtist ( useAlbumArtist ) ; } else { currentAlbum = null ; } } } Collections . sort ( result ) ; return result ; }
private boolean removeChild ( Node child ) { boolean found = false ; if ( childrenSize = = 0 ) return found ; for ( int i = 0 ; i < childrenSize ; i + + ) { if ( children [ i ] . equals ( child ) ) { found = true ; } else if ( found ) { System . arraycopy ( children , i , children , i - 1 , childrenSize - i ) ; break ; } } if ( found ) childrenSize - - ; return found ; }
public void Test1 ( ) { int A = 0 , B = 1 , C = 2 , D = 3 , E = 4 , F = 5 , G = 6 ; EdmondsKarp ek = new EdmondsKarp ( 7 , 11 ) ; ek . AddEdge ( A , D , 3 ) ; ek . AddEdge ( D , F , 6 ) ; ek . AddEdge ( A , B , 3 ) ; ek . AddEdge ( E , B , 1 ) ; ek . AddEdge ( E , G , 1 ) ; ek . AddEdge ( F , G , 9 ) ; ek . AddEdge ( D , E , 2 ) ; ek . AddEdge ( B , C , 4 ) ; ek . AddEdge ( C , A , 3 ) ; ek . AddEdge ( C , D , 1 ) ; ek . AddEdge ( C , E , 2 ) ; assertTrue ( ek . GetMaxFlow ( A , G ) = = 5 ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; if ( isWord = = true ) builder . append ( " Node= " ) . append ( isWord ) . append ( " \ n " ) ; for ( int i = 0 ; i < childrenSize ; i + + ) { Node c = children [ i ] ; builder . append ( c . toString ( ) ) ; } return builder . toString ( ) ; }
private static void _checkImportance ( @Nullable final String sImportance ) { if ( sImportance ! = null & & ! sImportance . equals ( " required " ) & & ! sImportance . equals ( " optional " ) ) s_aLogger . warn ( " Non-standard importance value ' " + sImportance + " ' used! " ) ;
protected static String makeCompoundName ( final NativeOperator op , final Term [ ] arg ) { final int sizeEstimate = 12 * arg . length ; final StringBuilder nameBuilder = new StringBuilder ( sizeEstimate ) . append ( COMPOUND_TERM_OPENER . ch ) . append ( op . toString ( ) ) ; for ( final Term t : arg ) { nameBuilder . append ( Symbols . ARGUMENT_SEPARATOR ) ; if ( t instanceof CompoundTerm ) { t . setName ( ( ( CompoundTerm ) t ) . makeName ( ) ) ; } nameBuilder . append ( t . getName ( ) ) ; } nameBuilder . append ( COMPOUND_TERM_CLOSER . ch ) ; return nameBuilder . toString ( ) ; }
public void correctNewlinesSub ( ) { Config conf = TomlFormat . instance ( ) . createConfig ( ) ; Config sub = conf . createSubConfig ( ) ; conf . set ( " table " , sub ) ; sub . set ( " key " , " value " ) ; TomlWriter tWriter = new TomlWriter ( ) ; String written = tWriter . writeToString ( conf ) ; System . out . println ( written ) ; assertLinesMatch ( Arrays . asList ( " [table] " , " \ tkey =  \" value \" " , " " ) , StringUtils . splitLines ( written ) ) ;
public void reparse ( @Nonnull final AS2Message aMsg , @Nonnull final AS2HttpClient aHttpClient , @Nullable final IHTTPIncomingDumper aIncomingDumper ) throws AS2Exception { final IMessageMDN aMDN = new AS2MessageMDN ( aMsg ) ; aMDN . headers ( ) . addAllHeaders ( aHttpClient . getResponseHeaderFields ( ) ) ; NonBlockingByteArrayOutputStream aMDNStream = null ; try { final InputStream aIS = aHttpClient . getInputStream ( ) ; aMDNStream = new NonBlockingByteArrayOutputStream ( ) ; final CopyByteStreamBuilder aBuilder = StreamHelper . copyByteStream ( ) . from ( aIS ) . closeFrom ( true ) . to ( aMDNStream ) . closeTo ( false ) ; final long nContentLength = StringParser . parseLong ( aMDN . getHeader ( CHttpHeader . CONTENT_LENGTH ) , - 1 ) ; if ( nContentLength > = 0 ) aBuilder . limit ( nContentLength ) ; aBuilder . build ( ) ; } catch ( final IOException ex ) { LOGGER . error ( " Error reparsing " , ex ) ; } finally { StreamHelper . close ( aMDNStream ) ; } if ( aIncomingDumper ! = null ) aIncomingDumper . dumpIncomingRequest ( aMDN . headers ( ) . getAllHeaderLines ( true ) , aMDNStream ! = null ? aMDNStream . toByteArray ( ) : ArrayHelper . EMPTY_BYTE_ARRAY , aMDN ) ; MimeBodyPart aPart = null ; if ( aMDNStream ! = null ) try { aPart = new MimeBodyPart ( AS2HttpHelper . getAsInternetHeaders ( aMDN . headers ( ) ) , aMDNStream . toByteArray ( ) ) ; } catch ( final MessagingException ex ) { LOGGER . error ( " Error creating MimeBodyPart " , ex ) ; } aMDN . setData ( aPart ) ; aMDN . partnership ( ) . setSenderAS2ID ( aMDN . getHeader ( CHttpHeader . AS2_FROM ) ) ; aMDN . partnership ( ) . setReceiverAS2ID ( aMDN . getHeader ( CHttpHeader . AS2_TO ) ) ; }
public void initDynamicComponent ( @Nonnull final IAS2Session aSession , @Nullable final IStringMap aOptions ) throws AS2Exception { debugLog ( ( ) - > " initDynamicComponent ( " + aSession + " ,  " + aOptions + " ) " ) ; super . initDynamicComponent ( aSession , aOptions ) ; reinitKeyStore ( ) ; debugLog ( ( ) - > " initDynamicComponent -> done " ) ; }
public void testEmpty ( ) { OperationException oe = new OperationException ( ) ; assertSame ( Operation . ErrorType . GENERAL , oe . getType ( ) ) ; assertEquals ( " OperationException: GENERAL " , String . valueOf ( oe ) ) ; }
public static RadioStation library ( String user ) { return new RadioStation ( " lastfm://user/ " + user + " /library " ) ; }
public static Sentence make ( Sentence oldS , Term term , TruthValue truth , Base base , Memory memory ) { if ( term instanceof CompoundTerm ) ( ( CompoundTerm ) term ) . renameVariables ( ) ; if ( oldS instanceof Question ) return new Question ( term , Symbols . QUESTION_MARK , memory ) ; if ( oldS instanceof Goal ) return new Goal ( term , Symbols . GOAL_MARK , truth , base , memory ) ; return new Judgement ( term , Symbols . JUDGMENT_MARK , truth , base , memory ) ; }
public List < Partnership > getPartnerships ( ) { if ( m_aPartnerships = = null ) m_aPartnerships = new ArrayList < Partnership > ( ) ; return m_aPartnerships ; }
private static void inavlidControlType ( Object [ ] info ) { String groupClassName = info [ 0 ] . getClass ( ) . getSimpleName ( ) ; String className = info [ 1 ] . getClass ( ) . getSimpleName ( ) ; System . out . println ( " Controls of type  " + className + "  cannot be added to a control group ( " + groupClassName + " \ n " ) ; }
public void playlistChanged ( MPDPlaylistChangedEvent event ) { } @Override public void randomChanged ( MPDRandomChangedEvent event ) { } @Override public void repeatChanged ( MPDRepeatChangedEvent event ) { } @Override public void stateChanged ( MPDStateChangedEvent event ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = oldStatus ) return ; if ( state = = MPDStatus . MPD_STATE_PLAYING ) { isPaused = false ; resumeStreaming ( ) ; isPlaying = true ; } else { oldStatus = state ; isPlaying = false ; stopStreaming ( ) ; } } } } @Override public void updateStateChanged ( MPDUpdateStateChangedEvent event ) { } @Override public void volumeChanged ( MPDVolumeChangedEvent event ) { } @Override public void onPrepared ( MediaPlayer mp ) { buffering = false ; isPlaying = true ; oldStatus = " " ; showNotification ( ) ; mediaPlayer . start ( ) ; } @Override public void onCompletion ( MediaPlayer mp ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = MPDStatus . MPD_STATE_PLAYING ) { resumeStreaming ( ) ; } else { oldStatus = state ; die ( ) ; } } } } @Override public void onBufferingUpdate ( MediaPlayer mp , int percent ) { } @Override public boolean onError ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public boolean onInfo ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public void connectionFailed ( String message ) { Toast . makeText ( this , " Connection Failed ! " , Toast . LENGTH_SHORT ) . show ( ) ; } @Override public void connectionSucceeded ( String message ) { } }
public abstract View onLayoutInflation ( Context context , View targetView , List < ? extends Item > items ) ; @Override public abstract void onDataBind ( Context context , View targetView , AbstractViewHolder viewHolder , List < ? extends Item > items , Object item , int position ) ; @Override public abstract AbstractViewHolder findInnerViews ( View targetView ) ; @Override public abstract boolean isEnabled ( int position , List < ? extends Item > items , Object item ) ; @Override public abstract int getLayoutId ( ) ; protected void loadPlaceholder ( CoverAsyncHelper coverHelper ) { coverHelper . obtainMessage ( CoverAsyncHelper . EVENT_COVER_NOT_FOUND ) . sendToTarget ( ) ; } protected void loadArtwork ( CoverAsyncHelper coverHelper , AlbumInfo albumInfo ) { coverHelper . downloadCover ( albumInfo ) ; } }
@Override public Chart newChart ( ) { return new Timeline2DCanvas . LineChart ( trace , " concept.priority.mean " ) . height ( 1 ) ; }
public < T > T remove ( List < String > path ) { synchronized ( rootMonitor ) { return config . remove ( path ) ;
public < T > void addItemFactory ( Class < T > itemClass , ItemFactory < T > factory ) { factories . put ( itemClass , factory ) ; }
public void onChange ( float v ) { } } ; blur . setPrefix ( " Blur:  " ) ; blur . setPreferredSize ( new Dimension ( 60 , 25 ) ) ; menu . add ( blur ) ; return menu ; } @Override public boolean preUpdate ( AbstractGraphVis < V , E > g ) { return true ; } @Override public boolean postUpdate ( AbstractGraphVis < V , E > g ) { return true ; } }
public D query ( long startOfQuery , long endOfQuery ) { D result = null ; if ( startOfQuery = = this . start & & endOfQuery = = this . end ) { for ( Segment < D > s : this . range ) { final D temp = ( D ) s . data . query ( startOfQuery , endOfQuery ) ; if ( temp ! = null ) { if ( result = = null ) result = ( D ) temp . copy ( ) ; else result . combined ( temp ) ; } } } else if ( ! this . hasChildren ( ) ) { if ( endOfQuery < this . start | | startOfQuery > this . end ) { } else { for ( Segment < D > s : this . range ) { if ( endOfQuery < s . start | | startOfQuery > s . end ) { } else { final D temp = ( D ) s . data . query ( startOfQuery , endOfQuery ) ; if ( temp ! = null ) { if ( result = = null ) result = ( D ) temp . copy ( ) ; else result . combined ( temp ) ; } } } } } else { final long middle = this . start + this . half ; D temp = null ; if ( startOfQuery < middle & & endOfQuery > = middle ) { temp = this . getLeftChild ( ) . query ( startOfQuery , middle - 1 ) ; D temp2 = this . getRightChild ( ) . query ( middle , endOfQuery ) ; if ( temp2 ! = null ) { if ( temp = = null ) temp = ( D ) temp2 . copy ( ) ; else temp . combined ( temp2 ) ; } } else if ( endOfQuery < middle ) { temp = this . getLeftChild ( ) . query ( startOfQuery , endOfQuery ) ; } else if ( startOfQuery > = middle ) { temp = this . getRightChild ( ) . query ( startOfQuery , endOfQuery ) ; } if ( temp ! = null ) result = ( D ) temp . copy ( ) ; } return result ; }
public void parseJsonObject ( CharacterInput input , JsonConfig destination ) { char firstChar = input . readCharAndSkip ( SPACES ) ; if ( firstChar ! = '{' ) { throw new ParsingException ( " Invalid first character for a json object:  " + firstChar ) ; } parseObject ( input , destination ) ; }
public void forEach ( Consumer < ? super LazyEntry > action ) { long stamp = StampedConfig . this . lock . tryWriteLock ( ) ; if ( stamp = = 0 ) { StampedConfig . this . checkStateForNormalOp ( ) ; stamp = StampedConfig . this . lock . writeLock ( ) ; } try { StampedConfig . this . state . set ( ThreadConfigState . IN_ITER_OP ) ;
public boolean equals ( Object other ) { if ( ! ( other instanceof FastConcatenationRope ) ) return false ; FastConcatenationRope o = ( FastConcatenationRope ) other ; if ( other = = this ) return true ; if ( hashCode ( ) ! = o . hashCode ( ) ) return false ; if ( length ( ) ! = o . length ( ) ) return false ; if ( ! left . equals ( o . left ) ) return false ; return right . equals ( o . right ) ; }
public Set < Step > refactor ( Set < Step > steps ) { Set < Step > decisionDependentSteps = StepUtils . getImmediateDependentSteps ( this , steps ) ; Set < Step > pruneSteps = getPruneSteps ( decisionDependentSteps , steps ) ; steps . removeAll ( pruneSteps ) ; this . setState ( StepState . FINISHED ) ; return steps ; }
Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }
public void conversionSuccess ( ) throws Exception { Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( MorphlineTranslator . ENCODING_KEY , " UTF-8 " ) ; configMap . put ( MorphlineTranslator . ENCODING_MSG , " UTF-8 " ) ; configMap . put ( MorphlineTranslator . MORPHLINE , getResourcePath ( MORPHLINE_FILE ) ) ; configMap . put ( MorphlineTranslator . MORPHLINE_ID , " default " ) ; configMap . put ( MorphlineTranslator . SCHEMA_CONFIG + " . " + ComponentFactory . TYPE_CONFIG_NAME , " flat " ) ; configMap . put ( MorphlineTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_NAMES_CONFIG , Lists . newArrayList ( " int " , " str " , " float " ) ) ; configMap . put ( MorphlineTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_TYPES_CONFIG , Lists . newArrayList ( " int " , " string " , " float " ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; translator . configure ( config ) ; Row raw = TestingMessageFactory . get ( " The Key " . getBytes ( ) , DataTypes . BinaryType , " The Message " . getBytes ( ) , DataTypes . BinaryType ) ; Iterable < Row > result = translator . translate ( raw ) ; Row row = result . iterator ( ) . next ( ) ; Assert . assertNotNull ( " Row is null " , result ) ; Assert . assertEquals ( " Invalid number of fields " , 3 , row . length ( ) ) ; Assert . assertEquals ( " Invalid field value " , 123 , row . get ( 0 ) ) ; Assert . assertEquals ( " Invalid field value " , " The Message " , row . get ( 1 ) ) ; Assert . assertEquals ( " Invalid field value " , 234 F , row . get ( 2 ) ) ; }
public void missingDatasets ( ) throws Exception { Map < String , Object > paramMap = new HashMap < > ( ) ; config = ConfigFactory . parseMap ( paramMap ) ; ExcludeDeriver excludeDeriver = new ExcludeDeriver ( ) ; excludeDeriver . configure ( config ) ; }
public abstract ServiceInfo getInfo ( ) ; @Override public ServiceEvent clone ( ) { try { return ( ServiceEvent ) super . clone ( ) ; } catch ( CloneNotSupportedException exception ) { return null ; } } }
protected void enableSolutionCommands ( boolean flag ) { bNext . setEnabled ( flag ) ; bAccept . setEnabled ( flag ) ; }
private void stopStreaming ( ) { Log . d ( TAG , " StreamingService.stopStreaming() " ) ; if ( mediaPlayer ! = null & & mediaPlayer . isPlaying ( ) ) { mediaPlayer . stop ( ) ; } sendIntent ( ACTION_STREAMING_STOP , NotificationService . class ) ; setupServiceControlHandlers ( ) ; }
void onDestroy ( ) { sApp . oMPDAsyncHelper . removeTrackPositionListener ( this ) ; mRemoteControlClient . setOnGetPlaybackPositionListener ( null ) ; mRemoteControlClient . setPlaybackPositionUpdateListener ( null ) ; }
public void addDockContent ( DockingContent content ) ; public DockingChild getDockingChild ( DockingPathRecord subpath ) ; public void restore ( DockingContent content , DockingPathRecord subpath ) ; public DockingPickRecord pickContainer ( Point containerPoint ) ; public void closeAll ( ) ; }
private boolean compareFormulaSets ( String s ) { ArrayList thisList = parseList ( this . theFormula . substring ( 1 , this . theFormula . length ( ) - 1 ) ) ; ArrayList sList = parseList ( s . substring ( 1 , s . length ( ) - 1 ) ) ; if ( thisList . size ( ) ! = sList . size ( ) ) { return false ; } for ( int i = 0 ; i < thisList . size ( ) ; i + + ) { for ( int j = 0 ; j < sList . size ( ) ; j + + ) { if ( ( ( Formula ) thisList . get ( i ) ) . logicallyEquals ( ( ( Formula ) sList . get ( j ) ) . theFormula ) ) { sList . remove ( j ) ; j = sList . size ( ) ; } } } return sList . size ( ) = = 0 ; }
public boolean isSortingCategories ( ) { return model . isSortingCategories ( ) ; }
public void testProcessEvent ( ) { new Expectations ( ) { { for ( int i = 0 ; i < parallelism ; i + + ) { processor . newProcessor ( processor ) ; result = processor ; processor . onCreate ( anyInt ) ; } processor . process ( event ) ; } } ; pi . processEvent ( event , counter ) ;
private void remove ( ) { int i = hash ( startNode , SuffixTree . characters [ firstCharIndex ] ) ; while ( EDGES [ i ] . startNode ! = startNode | | EDGES [ i ] . firstCharIndex ! = firstCharIndex ) i = + + i % HASH_TABLE_SIZE ; while ( true ) { EDGES [ i ] . startNode = - 1 ;
public void run ( ) { Bitmap [ ] covers = null ; if ( fillEmptyArtist ( ) ) { for ( ICoverRetriever coverRetriever : coverRetrievers ) { covers = getBitmapForRetriever ( coverRetriever ) ; if ( covers ! = null & & covers [ 0 ] ! = null ) { if ( DEBUG ) Log . i ( MPDApplication . TAG , " Found cover art using retriever :  " + coverRetriever . getName ( ) ) ; if ( cacheWritable & & ! ( coverRetriever instanceof CachedCover ) ) { for ( ICoverRetriever coverRetriever1 : coverRetrievers ) { if ( coverRetriever1 instanceof CachedCover ) { if ( DEBUG ) Log . i ( MPDApplication . TAG , " Saving cover art to cache " ) ; ( ( CachedCover ) coverRetriever1 ) . save ( info . sArtist , info . sAlbum , covers [ 1 ] ) ; if ( covers [ 0 ] ! = covers [ 1 ] ) { covers [ 1 ] . recycle ( ) ; covers [ 1 ] = null ; } } } } CoverAsyncHelper . this . obtainMessage ( EVENT_COVERDOWNLOADED , covers [ 0 ] ) . sendToTarget ( ) ; break ; } } } if ( covers = = null ) { if ( DEBUG )
public static StormTopology argsToTopology ( String [ ] args ) { StringBuilder cliString = new StringBuilder ( ) ; for ( int i = 0 ; i < args . length ; i + + ) { cliString . append ( "   " ) . append ( args [ i ] ) ; } logger . debug ( " Command line string = {} " , cliString . toString ( ) ) ; Task task = getTask ( cliString . toString ( ) ) ; task . setFactory ( new StormComponentFactory ( ) ) ; task . init ( ) ; StormTopology stormTopo = ( StormTopology ) task . getTopology ( ) ; return stormTopo ; }
public boolean equalsByTerm ( final Object that ) { if ( ! ( that instanceof CompoundTerm ) ) return false ; final CompoundTerm t = ( CompoundTerm ) that ; if ( operator ( ) ! = t . operator ( ) ) return false ; if ( getComplexity ( ) ! = t . getComplexity ( ) ) return false ; if ( getTemporalOrder ( ) ! = t . getTemporalOrder ( ) ) return false ; if ( ! equals2 ( t ) ) return false ; if ( term . length ! = t . term . length ) return false ; for ( int i = 0 ; i < term . length ; i + + ) { if ( ! term [ i ] . equals ( t . term [ i ] ) ) return false ; } return true ; }
public void testFNV1A64 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( "   " , 0x8601817fL ) ; exp . put ( " hello world! " , 0xcd5a2672L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xbec309a8L ) ; exp . put ( " wd:com.google " , 0x097b3f26L ) ; exp . put ( " wd:com.google  " , 0x1c6c1732L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . FNV1A_64_HASH , me . getKey ( ) ,
FoundNode filterInstanceToLeaf ( Instance inst , SplitNode parent , int parentBranch ) { int childIndex = instanceChildIndex ( inst ) ; if ( childIndex > = 0 ) { Node child = getChild ( childIndex ) ; if ( child ! = null ) { return child . filterInstanceToLeaf ( inst , this , childIndex ) ; } return new FoundNode ( null , this , childIndex ) ; } return new FoundNode ( this , parent , parentBranch ) ; }
public void onDestroy ( ) { mediaPlayer . stop ( ) ; mediaPlayer . release ( ) ; mediaPlayer = null ; super . onDestroy ( ) ; }
private static boolean isCloser ( String s , int i ) { char c = s . charAt ( i ) ; boolean b = ( Symbols . getCloser ( c ) ! = null ) ; if ( ! b ) return false ; return i < 2 | | ! Symbols . isRelation ( s . substring ( i - 2 , i + 1 ) ) ; }
public IntervalData < O > query ( long index ) { return root . query ( index ) ; }
public static int compareNatural ( final Collator collator , final String s , final String t ) { return compareNatural ( s , t , true , collator ) ; }
public boolean equals ( final Object obj ) { if ( obj = = this ) return true ; if ( hashCode ( ) ! = obj . hashCode ( ) ) return false ; if ( obj instanceof TermLink ) { TermLink t = ( TermLink ) obj ; if ( type ! = t . type ) return false ; if ( ! Arrays . equals ( t . index , index ) ) return false ; final Term tt = t . target ; if ( target = = null ) { if ( tt ! = null ) return false ; } else if ( tt = = null ) { if ( target ! = null ) return false ; } else if ( ! target . equals ( t . target ) ) return false ; return true ; } return false ; }
private void canonize ( ) { Edge < C > edge = Edge . find ( this , currentNode , characters [ firstCharIndex ] ) ; int edgeSpan = edge . lastCharIndex - edge . firstCharIndex ; while ( edgeSpan < = ( lastCharIndex - firstCharIndex ) ) { if ( DEBUG ) System . out . printf ( " Canonizing " ) ;
boolean hasErrored ( ) ; OperationException getException ( ) ; OperationCallback getCallback ( ) ; void cancel ( ) ; OperationState getState ( ) ; ByteBuffer getBuffer ( ) ; void writeComplete ( ) ; void initialize ( ) ; void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; }
public void add ( T value ) { if ( root = = null ) { root = new Node < T > ( null , maxKeySize , maxChildrenSize ) ; root . addKey ( value ) ; } else { Node < T > node = root ; while ( node ! = null ) { if ( node . children . size ( ) = = 0 ) { node . addKey ( value ) ; if ( node . keys . size ( ) < = maxKeySize ) { break ; } else { split ( node ) ; break ; } } else { T lesser = node . keys . get ( 0 ) ; if ( value . compareTo ( lesser ) < 0 ) { node = node . children . get ( 0 ) ; continue ; } int size = node . keys . size ( ) ; int last = size - 1 ; T greater = node . keys . get ( last ) ; if ( value . compareTo ( greater ) > 0 ) { node = node . children . get ( size ) ; continue ; } for ( int i = 1 ; i < node . keys . size ( ) ; i + + ) { T prev = node . keys . get ( i - 1 ) ; T next = node . keys . get ( i ) ; if ( value . compareTo ( prev ) > 0 & & value . compareTo ( next ) < 0 ) { node = node . children . get ( i ) ; break ; } } } } } size + + ; }
private static void notifyExecutionMode ( ExecutionMode mode ) { Map < String , Object > metadata = Maps . newHashMap ( ) ; metadata . put ( CoreEventMetadataKeys . EXECUTION_MODE_DETERMINED_MODE , mode ) ; EventManager . notify ( new Event ( CoreEventTypes . EXECUTION_MODE_DETERMINED ,
public boolean startsWith ( CharSequence prefix , int offset ) ; public boolean endsWith ( CharSequence suffix ) ; public boolean endsWith ( CharSequence suffix , int offset ) ; public static final long [ ] FIBONACCI = { 0 l , 1l , 1l , 2l , 3l , 5l , 8l , 13l , 21l , 34l , 55l , 89l , 144l , 233l , 377l , 610l , 987l , 1597l , 2584l , 4181l , 6765l , 10946l , 17711l , 28657l , 46368l , 75025l , 121393l , 196418l , 317811l , 514229l , 832040l , 1346269l , 2178309l , 3524578l , 5702887l , 9227465l , 14930352l , 24157817l , 39088169l , 63245986l , 102334155l , 165580141l , 267914296l , 433494437l , 701408733l , 1134903170l , 1836311903l , 2971215073l , 4807526976l , 7778742049l , 12586269025l , 20365011074l , 32951280099l , 53316291173l , 86267571272l , 139583862445l , 225851433717l , 365435296162l , 591286729879l , 956722026041l , 1548008755920l , 2504730781961l , 4052739537881l , 6557470319842l , 10610209857723l , 17167680177565l , 27777890035288l , 44945570212853l , 72723460248141l , 117669030460994l , 190392490709135l , 308061521170129l , 498454011879264l , 806515533049393l , 1304969544928657l , 2111485077978050l , 3416454622906707l , 5527939700884757l , 8944394323791464l , 14472334024676221l , 23416728348467685l , 37889062373143906l , 61305790721611591l , 99194853094755497l , 160500643816367088l , 259695496911122585l , 420196140727489673l , 679891637638612258l , 1100087778366101931l , 1779979416004714189l , 2880067194370816120l , 4660046610375530309l , 7540113804746346429l } ; public static final short MAX_ROPE_DEPTH = 96 ; public static final String SPACES = "                                                                                                                                                                                                          " ; public static Rope autoRebalance ( final Rope r ) { if ( r instanceof AbstractRope & & ( ( AbstractRope ) r ) . depth ( ) > MAX_ROPE_DEPTH ) { return rebalance ( r ) ; } else { return r ; } } public static Rope cat ( final CharSequence . . . c ) { Rope r = null ; for ( CharSequence a : c ) { if ( a = = null ) continue ; if ( ! ( a instanceof Rope ) ) a = Rope . build ( a ) ; r = ( r = = null ) ? ( Rope ) a : new ConcatenationRope ( r , ( Rope ) a ) ; } return r ; } public static Rope catFast ( final CharSequence . . . c ) { Rope r = null ; for ( CharSequence a : c ) { if ( a = = null ) a = new CharArrayRope ( new char [ ] { } ) ; if ( ! ( a instanceof Rope ) ) a = Rope . buildFast ( a ) ; r = ( r = = null ) ? ( Rope ) a : new FastConcatenationRope ( r , ( Rope ) a ) ; } return r ; } public static Rope cat ( final Rope left , final Rope right ) { if ( left . length ( ) = = 0 ) return right ; if ( right . length ( ) = = 0 ) return left ; if ( ( long ) left . length ( ) + right . length ( ) > Integer . MAX_VALUE ) throw new IllegalArgumentException ( " Left length= " + left . length ( ) + " , right length= " + right . length ( ) + " . Concatenation would overflow length field. " ) ; final int combineLength = 17 ; if ( left . length ( ) + right . length ( ) < combineLength ) { return new FlatCharSequenceRope ( left . toString ( ) + right . toString ( ) ) ; } if ( ! ( left instanceof ConcatenationRope ) ) { if ( right instanceof ConcatenationRope ) { final ConcatenationRope cRight = ( ConcatenationRope ) right ; if ( left . length ( ) + cRight . getLeft ( ) . length ( ) < combineLength ) return autoRebalance ( new ConcatenationRope ( new FlatCharSequenceRope ( left . toString ( ) + cRight . getLeft ( ) . toString ( ) ) , cRight . getRight ( ) ) ) ; } } if ( ! ( right instanceof ConcatenationRope ) ) { if ( left instanceof ConcatenationRope ) { final ConcatenationRope cLeft = ( ConcatenationRope ) left ; if ( right . length ( ) + cLeft . getRight ( ) . length ( ) < combineLength ) return autoRebalance ( new ConcatenationRope ( cLeft . getLeft ( ) , new FlatCharSequenceRope ( cLeft . getRight ( ) . toString ( ) + right . toString ( ) ) ) ) ; } } return autoRebalance ( new ConcatenationRope ( left , right ) ) ; } public static byte depth ( final Rope r ) { if ( r instanceof AbstractRope ) { return ( ( AbstractRope ) r ) . depth ( ) ; } else { return 0 ; } } public static boolean isBalanced ( final Rope r ) { final byte depth = depth ( r ) ; if ( depth > = FIBONACCI . length - 2 ) return false ; return ( FIBONACCI [ depth + 2 ] < = r . length ( ) ) ; } public static Rope rebalance ( final Rope r ) { final ArrayList < Rope > leafNodes = new ArrayList < Rope > ( ) ; final ArrayDeque < Rope > toExamine = new ArrayDeque < Rope > ( ) ; toExamine . add ( r ) ; while ( toExamine . size ( ) > 0 ) { final Rope x = toExamine . pop ( ) ; if ( x instanceof ConcatenationRope ) { toExamine . push ( ( ( ConcatenationRope ) x ) . getRight ( ) ) ; toExamine . push ( ( ( ConcatenationRope ) x ) . getLeft ( ) ) ; } else { leafNodes . add ( x ) ; } } Rope result = merge ( leafNodes , 0 , leafNodes . size ( ) ) ; return result ; } public static Rope merge ( ArrayList < Rope > leafNodes , int start , int end ) { int range = end - start ; switch ( range ) { case 1 : return leafNodes . get ( start ) ; case 2 : return new ConcatenationRope ( leafNodes . get ( start ) , leafNodes . get ( start + 1 ) ) ; default : int middle = start + ( range / 2 ) ; return new ConcatenationRope ( merge ( leafNodes , start , middle ) , merge ( leafNodes , middle , end ) ) ; } } public static void visualize ( final Rope r , final PrintStream out ) { visualize ( r , out , 0 ) ; } public static void visualize ( final Rope r , final PrintStream out , final int depth ) { if ( r instanceof FlatCharSequenceRope ) { out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; CharSequence seq = ( ( FlatCharSequenceRope ) r ) . sequence ; out . println ( " \" " + seq + " \"   " + System . identityHashCode ( seq ) ) ; } else if ( r instanceof FlatRope ) { out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; out . println ( " \" " + r + " \" " ) ; } if ( r instanceof SubstringRope ) { out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; out . println ( " substring  " + r . length ( ) + "   \" " + r + " \" " ) ; } if ( r instanceof ConcatenationRope ) { out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; out . println ( " concat[left] " ) ; visualize ( ( ( ConcatenationRope ) r ) . getLeft ( ) , out , depth + 1 ) ; out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; out . println ( " concat[right] " ) ; visualize ( ( ( ConcatenationRope ) r ) . getRight ( ) , out , depth + 1 ) ; } if ( r instanceof PrePostCharRope ) { PrePostCharRope p = ( PrePostCharRope ) r ; out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; out . println ( " \ ' " + p . pre + " \ ' " ) ; Rope . visualize ( p . content , out , depth + 1 ) ; out . println ( " \ ' " + p . post + " \ ' " ) ; } } public static void stats ( final Rope r , final PrintStream out ) { int nonLeaf = 0 ; final ArrayList < Rope > leafNodes = new ArrayList < Rope > ( ) ; final ArrayDeque < Rope > toExamine = new ArrayDeque < Rope > ( ) ; toExamine . add ( r ) ; while ( toExamine . size ( ) > 0 ) { final Rope x = toExamine . pop ( ) ; if ( x instanceof ConcatenationRope ) { + + nonLeaf ; toExamine . push ( ( ( ConcatenationRope ) x ) . getRight ( ) ) ; toExamine . push ( ( ( ConcatenationRope ) x ) . getLeft ( ) ) ; } else { leafNodes . add ( x ) ; } } out . println ( " rope(length= " + r . length ( ) + " , leaf nodes= " + leafNodes . size ( ) + " , non-leaf nodes= " + nonLeaf + " , depth= " + depth ( r ) + " ) " ) ; } }
protected static < D extends Data > OverlappingSegment < D > createFromList ( List < Segment < D > > segments ) { OverlappingSegment < D > segment = new OverlappingSegment < D > ( ) ; segment . length = segments . size ( ) ; segment . startIndex = segments . get ( 0 ) . startIndex ; segment . endIndex = segments . get ( segment . length - 1 ) . endIndex ; segment . data = null ; for ( Segment < D > s : segments ) { if ( segment . data = = null ) segment . data = ( ( D ) s . data . copy ( ) ) ; else segment . data . combined ( s . data ) ; } if ( segment . length > = 2 ) { segment . half = segment . length / 2 ; if ( segment . length > 1 & & segment . length % 2 ! = 0 ) segment . half + + ; List < Segment < D > > s1 = new ArrayList < Segment < D > > ( ) ; List < Segment < D > > s2 = new ArrayList < Segment < D > > ( ) ; for ( int i = 0 ; i < segment . length ; i + + ) { Segment < D > s = segments . get ( i ) ; if ( s . startIndex < segment . startIndex + segment . half ) s1 . add ( s ) ; else s2 . add ( s ) ; } OverlappingSegment < D > sub1 = createFromList ( s1 ) ; OverlappingSegment < D > sub2 = createFromList ( s2 ) ; segment . segments = new OverlappingSegment [ ] { sub1 , sub2 } ; } else { segment . segments = new OverlappingSegment [ ] { segment } ; } return segment ; }
public void run ( ) { wu . run ( ) ; s . nar . addInput ( " <(^go-to,$1) =/> <$1 --> at>>. " ) ; TestChamber . needpizza = true ; }
public void testFNV132 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x811c9dc5L ) ; exp . put ( "   " , 0x050c5d3fL ) ; exp . put ( " hello world! " , 0x8a01b99cL ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0x9277524aL ) ; exp . put ( " wd:com.google " , 0x455e0df8L ) ; exp . put ( " wd:com.google  " , 0x2b0ffd48L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1_32_HASH , me . getKey ( ) ,
Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public void storePartnership ( ) throws OpenAS2Exception { final String sFilename = getFilename ( ) ; if ( ! containsKey ( ATTR_DISABLE_BACKUP ) ) { final File aBackupFile = _getUniqueBackupFile ( sFilename ) ; if ( LOGGER . isWarnEnabled ( ) ) LOGGER . info ( " backing up  " + sFilename + "  to  " + aBackupFile . getName ( ) ) ; final File aSourceFile = new File ( sFilename ) ; AS2IOHelper . getFileOperationManager ( ) . renameFile ( aSourceFile , aBackupFile ) ; } final IMicroDocument aDoc = new MicroDocument ( ) ; final IMicroElement eRoot = aDoc . appendElement ( " partnerships " ) ; for ( final IPartner aPartner : getAllPartners ( ) ) { final IMicroElement ePartner = eRoot . appendElement ( " partner " ) ; for ( final Map . Entry < String , String > aAttr : aPartner ) ePartner . setAttribute ( aAttr . getKey ( ) , aAttr . getValue ( ) ) ; } for ( final Partnership aPartnership : getAllPartnerships ( ) ) { final IMicroElement ePartnership = eRoot . appendElement ( " partnership " ) ; ePartnership . setAttribute ( PARTNERSHIP_NAME , aPartnership . getName ( ) ) ; final IMicroElement eSender = ePartnership . appendElement ( " sender " ) ; for ( final Map . Entry < String , String > aAttr : aPartnership . getAllSenderIDs ( ) . entrySet ( ) ) eSender . setAttribute ( aAttr . getKey ( ) , aAttr . getValue ( ) ) ; final IMicroElement eReceiver = ePartnership . appendElement ( " receiver " ) ; for ( final Map . Entry < String , String > aAttr : aPartnership . getAllReceiverIDs ( ) . entrySet ( ) ) eReceiver . setAttribute ( aAttr . getKey ( ) , aAttr . getValue ( ) ) ; for ( final Map . Entry < String , String > aAttr : aPartnership . getAllAttributes ( ) . entrySet ( ) ) ePartnership . appendElement ( " attribute " ) . setAttribute ( " name " , aAttr . getKey ( ) ) . setAttribute ( " value " , aAttr . getValue ( ) ) ; } if ( MicroWriter . writeToFile ( aDoc , new File ( sFilename ) ) . isFailure ( ) ) throw new OpenAS2Exception ( " Failed to write to file  " + sFilename ) ;
protected FileConfig buildAutosave ( CommentedFileConfig chain ) { return new AutosaveFileConfig < > ( chain ) ; }
public final String getAttribute ( @Nullable final String sKey ) { return m_aAttributes . getAsString ( sKey ) ; }
static void abdIndCom ( final Term term1 , final Term term2 , final Sentence sentence1 , final Sentence sentence2 , final int figure , final NAL nal ) { if ( Statement . invalidStatement ( term1 , term2 ) | | Statement . invalidPair ( term1 . name ( ) , term2 . name ( ) ) ) { return ; } int order1 = sentence1 . content . getTemporalOrder ( ) ; int order2 = sentence2 . content . getTemporalOrder ( ) ; int order = abdIndComOrder ( order1 , order2 ) ; if ( order = = ORDER_INVALID ) { return ; } Statement taskContent = ( Statement ) sentence1 . content ; TruthValue truth1 = null ; TruthValue truth2 = null ; TruthValue truth3 = null ; BudgetValue budget1 , budget2 , budget3 ; TruthValue value1 = sentence1 . truth ; TruthValue value2 = sentence2 . truth ; if ( sentence1 . isQuestion ( ) ) { budget1 = BudgetFunctions . backward ( value2 , nal ) ; budget2 = BudgetFunctions . backwardWeak ( value2 , nal ) ; budget3 = BudgetFunctions . backward ( value2 , nal ) ; } else if ( sentence1 . isQuest ( ) ) { budget1 = BudgetFunctions . backwardWeak ( value2 , nal ) ; budget2 = BudgetFunctions . backward ( value2 , nal ) ; budget3 = BudgetFunctions . backwardWeak ( value2 , nal ) ; } else { if ( sentence1 . isGoal ( ) ) { truth1 = TruthFunctions . desireStrong ( value1 , value2 ) ; truth2 = TruthFunctions . desireWeak ( value2 , value1 ) ; truth3 = TruthFunctions . desireStrong ( value1 , value2 ) ; } else { truth1 = TruthFunctions . abduction ( value1 , value2 ) ; truth2 = TruthFunctions . abduction ( value2 , value1 ) ; truth3 = TruthFunctions . comparison ( value1 , value2 ) ; } budget1 = BudgetFunctions . forward ( truth1 , nal ) ; budget2 = BudgetFunctions . forward ( truth2 , nal ) ; budget3 = BudgetFunctions . forward ( truth3 , nal ) ; } nal . doublePremiseTask ( Statement . make ( taskContent , term1 , term2 , order ) , truth1 , budget1 , false ) ; nal . doublePremiseTask ( Statement . make ( taskContent , term2 , term1 , reverseOrder ( order ) ) , truth2 , budget2 , false ) ; nal . doublePremiseTask ( Statement . makeSym ( taskContent , term1 , term2 , order ) ,
public CharsWrapper readCharsUntil ( char [ ] stop ) { CharsWrapper . Builder builder = new CharsWrapper . Builder ( 10 ) ; char c = readChar ( ) ; while ( ! Utils . arrayContains ( stop , c ) ) { builder . append ( c ) ; c = readChar ( ) ; } deque . addFirst ( c ) ; return builder . build ( ) ; }
public List < Music > getSongs ( Album album ) throws MPDServerException { List < Music > songs = Music . getMusicFromList ( mpdConnection . sendCommand ( getSongsCommand ( album ) ) , true ) ; if ( album . hasAlbumArtist ( ) ) { String artistname = album . getArtist ( ) . getName ( ) ; for ( int i = songs . size ( ) - 1 ; i > = 0 ; i - - ) { final String albumartist = songs . get ( i ) . getAlbumArtist ( ) ; if ( albumartist ! = null & & ! albumartist . isEmpty ( ) & & ! ( artistname . equals ( albumartist ) ) ) { songs . remove ( i ) ; } } } if ( null ! = songs ) { Collections . sort ( songs ) ; } return songs ; }
public void testGraphPlan ( ) { NAR n = new DefaultNARBuilder ( ) . build ( ) ; new TextOutput ( n , System . out ) ; n . addInput ( input ) ; for ( int i = 0 ; i < 10 ; i + + ) { n . step ( 1 ) ; } new Window ( " Implications " , new JGraphXGraphPanel ( n . memory . executive . graph . implication ) ) . show ( 500 , 500 ) ; }
protected synchronized boolean load ( ) { final File file = new File ( mFilesDir , getFilename ( ) + ( GZIP ? " .gz " : " " ) ) ; if ( ! file . exists ( ) ) { return false ; } Log . d ( TAG , " Loading  " + file ) ; final ObjectInputStream restore ; boolean loaded_ok = false ; try { if ( GZIP ) { restore = new ObjectInputStream ( new GZIPInputStream ( new FileInputStream ( file ) ) ) ; } else { restore = new ObjectInputStream ( new FileInputStream ( file ) ) ; } mLastUpdate = ( Date ) restore . readObject ( ) ; mAlbumDetails = ( HashMap < String , AlbumDetails > ) restore . readObject ( ) ; mAlbumSet = ( Set < List < String > > ) restore . readObject ( ) ; restore . close ( ) ; makeUniqueAlbumSet ( ) ; loaded_ok = true ; } catch ( final FileNotFoundException ignored ) { } catch ( final Exception e ) { Log . e ( TAG , " Exception. " , e ) ; } if ( loaded_ok ) { Log . d ( TAG , cacheInfo ( ) ) ; } else { Log . d ( TAG , " Error on load " ) ; } return loaded_ok ; }
public void testQuerySetInclusiveEnd ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setInclusiveEnd ( true ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }
public java . util . Queue < T > toQueue ( ) { return ( new JavaCompatibleArrayQueue < T > ( this ) ) ; }
public abstract T dequeue ( ) ; public abstract boolean contains ( T value ) ; public abstract int size ( ) ; public static < T > Queue < T > createQueue ( QueueType type ) { switch ( type ) { case ArrayQueue : return new ArrayQueue < T > ( ) ; default : return new LinkedQueue < T > ( ) ; } } public static class ArrayQueue < T > extends Queue < T > { private static final int MINIMUM_SIZE = 10 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ MINIMUM_SIZE ] ; private int lastIndex = 0 ; private int firstIndex = 0 ; @Override public void enqueue ( T value ) { int length = lastIndex - firstIndex ; if ( length > = array . length ) { array = Arrays . copyOfRange ( array , firstIndex , ( ( lastIndex * 3 ) / 2 ) + 1 ) ; lastIndex = lastIndex - firstIndex ; firstIndex = 0 ; } array [ lastIndex + + ] = value ; } @Override public T dequeue ( ) { int length = lastIndex - firstIndex ; if ( length < 0 ) return null ; T t = array [ firstIndex ] ; array [ firstIndex + + ] = null ; length = lastIndex - firstIndex ; if ( length = = 0 ) { lastIndex = 0 ; firstIndex = 0 ; } if ( length > = MINIMUM_SIZE & & ( array . length - length ) > = length ) { array = Arrays . copyOfRange ( array , firstIndex , lastIndex ) ; lastIndex = length ; firstIndex = 0 ; } return t ; } @Override public boolean contains ( T value ) { for ( int i = firstIndex ; i < lastIndex ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public int size ( ) { return lastIndex - firstIndex ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = lastIndex - 1 ; i > = firstIndex ; i - - ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } @Override public Iterator < T > iterator ( ) { return ( new ArrayQueueIterator < T > ( this ) ) ; } private static class ArrayQueueIterator < T > implements Iterator < T > { private ArrayQueue < T > queue = null ; private int index = 0 ; private ArrayQueueIterator ( ArrayQueue < T > queue ) { this . queue = queue ; } @Override public boolean hasNext ( ) { return ( ( queue . firstIndex + index ) < queue . lastIndex ) ; } @Override public T next ( ) { if ( queue . firstIndex + index < queue . lastIndex ) { return queue . array [ queue . firstIndex + index + + ] ; } return null ; } @Override public void remove ( ) { System . err . println ( " OperationNotSupported " ) ; } } } public static class LinkedQueue < T > extends Queue < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; public LinkedQueue ( ) { head = null ; tail = null ; size = 0 ; } @Override public void enqueue ( T value ) { enqueue ( new Node < T > ( value ) ) ; } private void enqueue ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > oldHead = head ; head = node ; node . next = oldHead ; oldHead . prev = node ; } size + + ; } @Override public T dequeue ( ) { T result = null ; if ( tail ! = null ) { result = tail . value ; Node < T > prev = tail . prev ; if ( prev ! = null ) { prev . next = null ; tail = prev ; } else { head = null ; tail = null ; } size - - ; } return result ; } @Override public boolean contains ( T value ) { if ( head = = null ) return false ; Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . next ; } return false ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . next ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > prev = null ; private Node < T > next = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( prev ! = null ) ? prev . value : " NULL " ) + "  next= " + ( ( next ! = null ) ? next . value : " NULL " ) ; } } @Override public Iterator < T > iterator ( ) { return ( new LinkedQueueIterator < T > ( this . tail ) ) ; } private static class LinkedQueueIterator < T > implements Iterator < T > { private Node < T > nextNode = null ; private LinkedQueueIterator ( Node < T > tail ) { this . nextNode = tail ; } @Override public boolean hasNext ( ) { return ( nextNode ! = null ) ; } @Override public T next ( ) { Node < T > current = nextNode ; if ( current ! = null ) { nextNode = current . prev ; return current . value ; } return null ; } @Override public void remove ( ) { System . err . println ( " OperationNotSupported " ) ; } } } }
protected void print ( Color c , float size , String text , boolean bold ) { StyleContext sc = StyleContext . getDefaultStyleContext ( ) ; MutableAttributeSet aset = ioText . getInputAttributes ( ) ; Font f = ioText . getFont ( ) ; StyleConstants . setForeground ( aset , c ) ; StyleConstants . setBold ( aset , bold ) ; try { doc . insertString ( doc . getLength ( ) , text , null ) ;
String getName ( ) ; Map < String , String > getParameters ( ) ; @Nullable String getParameterNotRequired ( @Nullable String sKey ) ; ISession getSession ( ) ; void initDynamicComponent ( ISession aSession , Map < String , String > aParameters ) throws OpenAS2Exception ; }
public void run ( ) { try { MPDApplication app = ( MPDApplication ) getApplication ( ) ;
public void testConjunctionTreeSet ( ) { NAR n = new NAR ( ) ; try {
public Set < IProcessingItem > getNonEntranceProcessingItems ( ) throws Exception { Set < IProcessingItem > copiedSet = new HashSet < IProcessingItem > ( ) ; copiedSet . addAll ( this . getProcessingItems ( ) ) ; boolean result = copiedSet . removeAll ( this . getEntranceProcessingItems ( ) ) ; if ( ! result ) { throw new Exception ( " Failed extracting the set of non-entrance processing items " ) ; } return copiedSet ; }
public View onCreateActionView ( ) { ActivityChooserModel dataModel = ActivityChooserModel . get ( mContext , mShareHistoryFileName ) ; ActivityChooserView activityChooserView = new ActivityChooserView ( mContext ) ; activityChooserView . setActivityChooserModel ( dataModel ) ; TypedValue outTypedValue = new TypedValue ( ) ; mContext . getTheme ( ) . resolveAttribute ( R . attr . actionModeShareDrawable , outTypedValue , true ) ; Drawable drawable = mContext . getResources ( ) . getDrawable ( outTypedValue . resourceId ) ; activityChooserView . setExpandActivityOverflowButtonDrawable ( drawable ) ; activityChooserView . setProvider ( this ) ; activityChooserView . setDefaultActionButtonContentDescription ( R . string . abs__shareactionprovider_share_with_application ) ; activityChooserView . setExpandActivityOverflowButtonContentDescription ( R . string . abs__shareactionprovider_share_with ) ; return activityChooserView ; }
public void addPlugin ( final Plugin p ) { if ( p instanceof SensoryChannel ) { this . addSensoryChannel ( ( ( SensoryChannel ) p ) . getName ( ) , ( SensoryChannel ) p ) ; } if ( p instanceof Operator ) { memory . addOperator ( ( Operator ) p ) ; } final PluginState ps = new PluginState ( p ) ; plugins . add ( ps ) ; emit ( Events . PluginsChange . class , p , null ) ; }
public String toString ( ) { return " MyObjectFinal{ " + " integer= "
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmExDif p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmInDif p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmExImg p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmInImg p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmExSet p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmInSet p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmProd p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmLit p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmStm p , A arg ) ; } }
public double run ( ) throws IOException , InstantiationException , InvocationTargetException , NoSuchMethodException , ParserConfigurationException , IllegalAccessException , SAXException , ClassNotFoundException , ParseException { return testNAL ( scriptPath ) ; }
boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; @Nonnull Iterator < Entry < String , String > > iterator ( ) ; }
public static Variable makeCommonVariable ( final Term v1 , final Term v2 ) { return new Variable ( v1 . toString ( ) + v2 . toString ( ) + '$' ) ; }
protected void advance ( ) throws java . io . IOException { next_char = instream . read ( ) ; }
public abstract INetModuleHandler createHandler ( ) ; public void handleError ( @Nonnull final IMessage aMsg , @Nonnull final OpenAS2Exception aSrcEx ) { aSrcEx . addSource ( OpenAS2Exception . SOURCE_MESSAGE , aMsg ) ; aSrcEx . terminate ( ) ; try { final CompositeParameters aParams = new CompositeParameters ( false ) . add ( " date " , new DateParameters ( ) ) . add ( " msg " , new MessageParameters ( aMsg ) ) ; final String sErrorFilename = aParams . format ( getAttributeAsString ( ATTR_ERROR_FORMAT , DEFAULT_ERROR_FORMAT ) ) ; final String sErrorDirectory = getAttributeAsStringRequired ( ATTR_ERROR_DIRECTORY ) ; final File aMsgErrorFile = IOUtil . getUniqueFile ( IOUtil . getDirectoryFile ( sErrorDirectory ) , FilenameHelper . getAsSecureValidFilename ( sErrorFilename ) ) ; final OutputStream aFOS = FileHelper . getOutputStream ( aMsgErrorFile ) ; try { final String sMsgText = aMsg . getAsString ( ) ; aFOS . write ( sMsgText . getBytes ( ) ) ; if ( false ) StreamHelper . copyInputStreamToOutputStream ( aMsg . getData ( ) . getInputStream ( ) , aFOS ) ; } finally { StreamHelper . close ( aFOS ) ; } final InvalidMessageException im = new InvalidMessageException ( " Stored invalid message to  " + aMsgErrorFile . getAbsolutePath ( ) ) ; im . terminate ( ) ; } catch ( final Exception ex ) { final OpenAS2Exception we = WrappedOpenAS2Exception . wrap ( ex ) ; we . addSource ( OpenAS2Exception . SOURCE_MESSAGE , aMsg ) ; we . terminate ( ) ; } } protected static final class ConnectionThread extends Thread { private static final Logger s_aLogger = LoggerFactory . getLogger ( ConnectionThread . class ) ; private final AbstractNetModule m_aOwner ; private final Socket m_aSocket ; public ConnectionThread ( @Nonnull final AbstractNetModule aOwner , @Nonnull @WillClose final Socket aSocket ) { super ( " AS2ConnectionThread- " + ClassHelper . getClassLocalName ( aOwner ) ) ; m_aOwner = aOwner ; m_aSocket = aSocket ; } @Override public void run ( ) { s_aLogger . info ( " AS2ConnectionThread: run " ) ; m_aOwner . createHandler ( ) . handle ( m_aOwner , m_aSocket ) ; try { m_aSocket . close ( ) ; } catch ( final IOException ex ) { WrappedOpenAS2Exception . wrap ( ex ) . terminate ( ) ; } finally { s_aLogger . info ( " AS2ConnectionThread: done running " ) ; } } } protected static final class MainThread extends Thread { private static final Logger s_aLogger = LoggerFactory . getLogger ( MainThread . class ) ; private final AbstractNetModule m_aOwner ; private final ServerSocket m_aServerSocket ; private volatile boolean m_bTerminated ; public MainThread ( @Nonnull final AbstractNetModule aOwner , @Nullable final String sAddress , @Nonnegative final int nPort ) throws IOException { super ( " AS2MainThread- " + ClassHelper . getClassLocalName ( aOwner ) ) ; m_aOwner = aOwner ; m_aServerSocket = new ServerSocket ( ) ; final InetSocketAddress aAddr = sAddress = = null ? new InetSocketAddress ( nPort ) : new InetSocketAddress ( sAddress , nPort ) ; m_aServerSocket . bind ( aAddr ) ; s_aLogger . info ( " Inited  " + getName ( ) + "  at  " + aAddr ) ; } @OverrideOnDemand protected Socket createAcceptSocket ( ) throws IOException { final Socket aSocket = m_aServerSocket . accept ( ) ; aSocket . setSoLinger ( true , 60 ) ; return aSocket ; } @Override public void run ( ) { s_aLogger . info ( " AS2MainThread: run " ) ; while ( ! m_bTerminated & & ! isInterrupted ( ) ) { try { final Socket aSocket = createAcceptSocket ( ) ; new ConnectionThread ( m_aOwner , aSocket ) . start ( ) ; } catch ( final Exception ex ) { if ( ! m_bTerminated ) m_aOwner . forceStop ( ex ) ; } } s_aLogger . info ( " AS2MainThread: done running " ) ; } public void terminate ( ) { if ( ! m_bTerminated ) { m_bTerminated = true ; if ( m_aServerSocket ! = null ) try { m_aServerSocket . close ( ) ; } catch ( final IOException ex ) { m_aOwner . forceStop ( ex ) ; } } } } }
public String mkString ( ) { return internalRow . mkString ( ) ; }
protected String getFilename ( @Nonnull final IMessage aMsg , @Nullable final String sFileParam ) throws AS2InvalidParameterException { final CompositeParameters aCompParams = new CompositeParameters ( false ) . add ( " date " , new DateParameters ( ) ) . add ( " msg " , new MessageParameters ( aMsg ) ) ; return aCompParams . format ( sFileParam ) ; }
public void receivedStatus ( String line ) { latch . countDown ( ) ; }
public boolean doesSubStringExist ( C sequence ) { char [ ] chars = sequence . toString ( ) . toCharArray ( ) ; int length = chars . length ; Trie . Node current = tree . root ; for ( int i = 0 ; i < length ; i + + ) { int idx = current . childIndex ( chars [ i ] ) ; if ( idx < 0 ) return false ; current = current . getChild ( idx ) ; } return true ; }
public boolean equals ( Object obj ) { if ( this = = obj ) return true ; if ( obj instanceof TaskLink ) { TaskLink t = ( TaskLink ) obj ; return t . targetTask . equals ( targetTask ) ; } return false ; }
final boolean inRange ( Object key , boolean inclusive ) { return inclusive ? inRange ( key ) : inClosedRange ( key ) ; }
public MimeBodyPart sign ( @Nonnull final MimeBodyPart aPart , @Nonnull final X509Certificate aX509Cert , @Nonnull final PrivateKey aPrivateKey , @Nonnull final ECryptoAlgorithmSign eAlgorithm , final boolean bIncludeCertificateInSignedContent , final boolean bUseOldRFC3851MicAlgs , final boolean bRemoveCmsAlgorithmProtect , @Nonnull final EContentTransferEncoding eCTE ) throws GeneralSecurityException , SMIMEException , MessagingException , OperatorCreationException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( aX509Cert , " X509Cert " ) ; ValueEnforcer . notNull ( aPrivateKey , " PrivateKey " ) ; ValueEnforcer . notNull ( eAlgorithm , " Algorithm " ) ; ValueEnforcer . notNull ( eCTE , " ContentTransferEncoding " ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " BCCryptoHelper.sign; X509 subject= " + aX509Cert . getSubjectX500Principal ( ) . getName ( ) + " ; algorithm= " + eAlgorithm + " ; includeCertificateInSignedContent= " + bIncludeCertificateInSignedContent + " ; CTE= " + eCTE ) ; aX509Cert . checkValidity ( ) ; final ICommonsList < X509Certificate > aCertList = new CommonsArrayList < > ( aX509Cert ) ; final JcaCertStore aCertStore = new JcaCertStore ( aCertList ) ; final ASN1EncodableVector aSignedAttrs = new ASN1EncodableVector ( ) ; final SMIMECapabilityVector aCapabilities = new SMIMECapabilityVector ( ) ; aCapabilities . addCapability ( eAlgorithm . getOID ( ) ) ; aSignedAttrs . add ( new SMIMECapabilitiesAttribute ( aCapabilities ) ) ; final SMIMESignedGenerator aSGen = new SMIMESignedGenerator ( bUseOldRFC3851MicAlgs ? SMIMESignedGenerator . RFC3851_MICALGS : SMIMESignedGenerator . RFC5751_MICALGS ) ; aSGen . setContentTransferEncoding ( eCTE . getID ( ) ) ; { SignerInfoGenerator aSigInfoGen = new JcaSimpleSignerInfoGeneratorBuilder ( ) . setProvider ( m_sSecurityProviderName ) . setSignedAttributeGenerator ( new AttributeTable ( aSignedAttrs ) ) . build ( eAlgorithm . getSignAlgorithmName ( ) , aPrivateKey , aX509Cert ) ; if ( bRemoveCmsAlgorithmProtect ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Removing CMS AlgorithmProtect attribute, if it is present " ) ; final CMSAttributeTableGenerator sAttrGen = aSigInfoGen . getSignedAttributeTableGenerator ( ) ; aSigInfoGen = new SignerInfoGenerator ( aSigInfoGen , new DefaultSignedAttributeTableGenerator ( ) { @Override public AttributeTable getAttributes ( final Map parameters ) { final AttributeTable ret = sAttrGen . getAttributes ( parameters ) ; return ret . remove ( CMSAttributes . cmsAlgorithmProtect ) ; } } , aSigInfoGen . getUnsignedAttributeTableGenerator ( ) ) ; } aSGen . addSignerInfoGenerator ( aSigInfoGen ) ; } if ( bIncludeCertificateInSignedContent ) { aSGen . addCertificates ( aCertStore ) ; } final MimeMultipart aSignedData = aSGen . generate ( aPart ) ; final MimeBodyPart aSignedPart = new MimeBodyPart ( ) ; aSignedPart . setContent ( aSignedData ) ; aSignedPart . setHeader ( CHttpHeader . CONTENT_TYPE , aSignedData . getContentType ( ) ) ; return aSignedPart ; }
int getCurrentLine ( ) ; int getCurrentOffset ( ) ; int [ ] offsetToRowColumn ( int offset ) ; }
public static Implication make ( Term subject , Term predicate , Memory memory ) { if ( invalidStatement ( subject , predicate ) ) return null ; String name = makeStatementName ( subject , Symbols . IMPLICATION_RELATION , predicate ) ; Term t = memory . nameToListedTerm ( name ) ; if ( t ! = null ) return ( Implication ) t ; if ( predicate instanceof Implication ) { Term oldCondition = ( ( Implication ) predicate ) . getSubject ( ) ;
protected void asyncUpdate ( ) { try { MPDApplication app = ( MPDApplication ) getApplication ( ) ; musicList = app . oMPDAsyncHelper . oMPD . listAlbums ( ) ; } catch ( MPDServerException e ) { } searchKeywords = searchKeywords . toLowerCase ( ) . trim ( ) ; for ( String music : musicList ) { if ( music . toLowerCase ( ) . contains ( searchKeywords ) )
void drawArrowAngle ( final float cx , final float cy , final float len , final float angle ) { pushMatrix ( ) ; translate ( cx , cy ) ; rotate ( radians ( angle ) ) ; line ( 0 , 0 , len , 0 ) ; line ( len , 0 , len - 8 * 2 , - 8 ) ; line ( len , 0 , len - 8 * 2 , 8 ) ; popMatrix ( ) ; }
@Override public void actionPerformed ( ActionEvent e ) { cells . click ( syntaxEnable2 . getLabel ( ) ) ; }
public abstract void stop ( ) ; public boolean isActive ( ) ; public void append ( String s ) ; public void onConceptNew ( Concept concept ) ; public void preCycle ( long clock ) ; public void postCycle ( long clock ) ; public void onTaskAdd ( Task task , String reason ) ; public void onTaskRemove ( Task task , String reason ) ; }
public String getAlias ( @Nonnull final Certificate cert ) throws CertificateException { try {
public static void main ( String [ ] arg ) { NAR nar = new Default ( ) . simulationTime ( ) . setConceptBagSize ( 500 ) . build ( ) ; ( nar . param ) . duration . set ( memoryCyclesPerFrame ) ; ( nar . param ) . noiseLevel . set ( 0 ) ; ( nar . param ) . decisionThreshold . set ( 0 ) ; float fps = 50 f ; gameRate = 1.0f / fps ; NARSwing sw = new NARSwing ( nar ) ; nar . start ( ( ( long ) ( 1000 f / fps ) ) ) ; NARio nario = new NARio ( nar ) ; sw . controls . setSpeed ( 0.95f ) ; }
public void run ( ScheduledExecutorService executor ) { if ( scheduledTask ! = null ) { scheduledTask . cancel ( false ) ; } scheduledTask = executor . schedule ( runnable , debounceTimeNanos , TimeUnit . NANOSECONDS ) ; }
public void checkApplyBulkMutations_Exception_MutationTypeNotSupported ( ) throws Exception { JdbcOutput jdbcOutput = new JdbcOutput ( ) ; jdbcOutput . configure ( ConfigUtils . configFromPath ( JdbcInput . class . getResource ( JDBC_PROPERTIES_TABLE_USER_PATH ) . getPath ( ) ) ) ; ArrayList < Tuple2 < MutationType , DataFrame > > planned = new ArrayList < > ( ) ; SQLContext sqlContext = Contexts . getSQLContext ( ) ; DataFrame o = sqlContext . read ( ) . json ( JdbcInput . class . getResource ( SAMPLE_DATA_PATH ) . getPath ( ) ) ; Tuple2 < MutationType , DataFrame > input = new Tuple2 < > ( MutationType . OVERWRITE , o ) ; planned . add ( input ) ; jdbcOutput . applyBulkMutations ( planned ) ;
public final Sentence clone ( final Term t ) { return new Sentence ( t , punctuation , truth ! = null ? new TruthValue ( truth ) : null ,
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; app = ( MPDApplication ) activity . getApplication ( ) ; lightTheme = app . isLightThemeSelected ( ) ; handler = new Handler ( ) ; setHasOptionsMenu ( false ) ; activity . setTitle ( activity . getResources ( ) . getString ( R . string . nowPlaying ) ) ; activity . registerReceiver ( MPDConnectionHandler . getInstance ( ) , new IntentFilter ( WifiManager . NETWORK_STATE_CHANGED_ACTION ) ) ; }
public double uniform ( final double min , final double max ) { return rng . nextDouble ( ) * ( max - min ) + min ; }
public java . util . Collection < T > toCollection ( ) { return ( new JavaCompatibleBinaryHeapArray < T > ( this ) ) ; }
public static void transformNegation ( final CompoundTerm content , final DerivationContext nal ) { final Task task = nal . getCurrentTask ( ) ; final Sentence sentence = task . sentence ; TruthValue truth = sentence . truth ; final BudgetValue budget ; if ( sentence . isJudgment ( ) | | sentence . isGoal ( ) ) { truth = TruthFunctions . negation ( truth ) ; budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; } else { budget = BudgetFunctions . compoundBackward ( content , nal ) ; } nal . singlePremiseTask ( content , truth , budget ) ; }
public int getResendItemCount ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try {
public void handle ( @Nonnull final String sAction , @Nonnull final IMessage aBaseMsg , @Nullable final Map < String , Object > aOptions ) throws AS2Exception { try ( final AS2ResourceHelper aResHelper = new AS2ResourceHelper ( ) ) {
default void parse ( InputStream input , D destination ) { Reader reader = new BufferedReader ( new InputStreamReader ( input , StandardCharsets . UTF_8 ) ) ; parse ( reader , destination ) ; }
public void onChange ( double v ) { app . nodeSpeed = ( float ) v ; app . drawn = false ; }
public void handleMessage ( Message msg ) { if ( ! isPlaying ) { windDownResources ( ) ;
void testCharAt ( ) { char result = charsWrapper . charAt ( 0 ) ; assertEquals ( 'a' , result ) ; }
public static Boolean isLocalNetworkConnected ( ) { ConnectivityManager cm = ( ConnectivityManager ) app . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; if ( cm = = null ) { return false ; } NetworkInfo netWorkinfo = cm . getActiveNetworkInfo ( ) ; return ( netWorkinfo ! = null & & ( netWorkinfo . getType ( ) = = ConnectivityManager . TYPE_WIFI | | netWorkinfo
protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { Term content = args [ 1 ] ; Sentence sentence = new Sentence ( content , Symbols . QUEST_MARK , null , new Stamp ( memory ) ) ; BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_QUEST_PRIORITY , Parameters . DEFAULT_QUESTION_DURABILITY , 1 ) ; return Lists . newArrayList ( new Task ( sentence , budget , true ) ) ;
boolean isCompressed ( @Nonnull String sContentType ) throws OpenAS2Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm , @Nonnull EContentTransferEncoding eCTE ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt , boolean bLargeFileOn ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs , @Nonnull EContentTransferEncoding eCTE ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
String getHeader ( @Nonnull String sKey ) ; @Nullable String getHeader ( @Nonnull String sKey , @Nullable String sDelimiter ) ; @Nonnull @ReturnsMutableObject ( " design " ) InternetHeaders getHeaders ( ) ; @Nonnull @Nonempty String getHeadersDebugFormatted ( ) ; void setHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void addHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void setHeaders ( @Nullable InternetHeaders aHeaders ) ; @Nullable String getMessageID ( ) ; void setMessageID ( @Nullable String sMessageID ) ; @Nonnull String generateMessageID ( ) ; void updateMessageID ( ) ; @Nonnull @ReturnsMutableObject ( " Design " ) Partnership getPartnership ( ) ; void setPartnership ( @Nonnull Partnership aPartnership ) ; }
public E peekNext ( ) { if ( size ( ) = = 0 ) return null ; return items . get ( nextRemovalIndex ( ) ) ; }
static void populateTest ( CommentedConfig config ) { Config subConfig = config . createSubConfig ( ) ; subConfig . set ( " string " , " test " ) ; subConfig . set ( " enum " , BasicTestEnum . C ) ; subConfig . set ( " sub " , config . createSubConfig ( ) ) ; List < Config > configList = Arrays . asList ( subConfig , subConfig , subConfig ) ; config . set ( " string " , " \" value \" " ) ; config . set ( " integer " , 2 ) ; config . set ( " long " , 123456789L ) ; config . set ( " double " , 3.1415926535 ) ; config . set ( " bool_array " , Arrays . asList ( true , false , true , false ) ) ; config . set ( " config " , subConfig ) ; config . set ( " config_list " , configList ) ; config . setComment ( " string " , "  Comment 1 \ n Comment 2 \ n Comment 3 " ) ; config . set ( " enum " , TestEnum . A ) ; }
public static Inheritance make ( final Term subject , final Term predicate ) { return Inheritance . make ( new SetExt ( subject ) , predicate ) ; }
public int hashCode ( ) { synchronized ( rootMonitor ) { return dataHolder . hashCode ( ) ;
public void handleIO ( ) throws IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long then = reconnectQueue . firstKey ( ) ; delay = Math . max ( then - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; if ( selectedKeys . isEmpty ( ) & & ! shutDown ) { getLogger ( ) . debug ( " No selectors ready, interrupted:  " + Thread . interrupted ( ) ) ; if ( + + emptySelects > DOUBLE_CHECK_EMPTY ) { for ( SelectionKey sk : selector . keys ( ) ) { getLogger ( ) . debug ( " %s has %s, interested in %s " , sk , sk . readyOps ( ) , sk . interestOps ( ) ) ; if ( sk . readyOps ( ) ! = 0 ) { getLogger ( ) . debug ( " %s has a ready op, handling IO " , sk ) ; handleIO ( sk ) ; } else { lostConnection ( ( MemcachedNode ) sk . attachment ( ) ) ; } } assert emptySelects < EXCESSIVE_EMPTY : " Too many empty selects " ; } } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { handleIO ( sk ) ; } selectedKeys . clear ( ) ; } checkPotentiallyTimedOutConnection ( ) ; if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ; } redistributeOperations ( retryOps ) ; retryOps . clear ( ) ; handleShutdownQueue ( ) ; }
public Builder clearOneofNested ( ) { if ( oneofNestedBuilder_ = = null ) { if ( oneofCase_ = = 24 ) { oneofCase_ = 0 ; oneof_ = null ; onChanged ( ) ; } } else { if ( oneofCase_ = = 24 ) { oneofCase_ = 0 ; oneof_ = null ; } oneofNestedBuilder_ . clear ( ) ; } return this ; }
public int compareTo ( final AbstractTerm that ) { if ( that = = this ) return 0 ; if ( Parameters . TERM_ELEMENT_EQUIVALENCY ) { if ( that instanceof CompoundTerm ) { CompoundTerm t = ( CompoundTerm ) that ; int h = Integer . compare ( hashCode ( ) , t . hashCode ( ) ) ; if ( h ! = 0 ) return h ; int o = operator ( ) . compareTo ( t . operator ( ) ) ; if ( o ! = 0 ) return o ; int c = Integer . compare ( getComplexity ( ) , t . getComplexity ( ) ) ; if ( c ! = 0 ) return c ; if ( ! equals ( that ) ) { return Integer . compare ( System . identityHashCode ( this ) , System . identityHashCode ( that ) ) ; } return 0 ; } else return super . compareTo ( that ) ; } return super . compareTo ( that ) ;
public String getHttpRequestVersion ( ) { return m_aRequestScope . getHttpVersion ( ) . getName ( ) ; }
public int hashCode ( ) { return 37 * ( this . stm_ . hashCode ( ) ) + this . budget_ . hashCode ( ) ; }
public static Term make ( ArrayList < Term > argument , Memory memory ) { String name = makeCompoundName ( Symbols . PRODUCT_OPERATOR , argument ) ; Term t = memory . nameToListedTerm ( name ) ; return ( t ! = null ) ? t : new Product ( argument ) ; }
private void initialize ( ) { while ( ! this . toTraverse . isEmpty ( ) ) { this . currentRope = this . toTraverse . pop ( ) ; if ( this . currentRope instanceof ConcatenationRope ) { this . toTraverse . push ( ( ( ConcatenationRope ) this . currentRope ) . getLeft ( ) ) ; this . toTraverse . push ( ( ( ConcatenationRope ) this . currentRope ) . getRight ( ) ) ; } else { break ; } } if ( this . currentRope = = null ) throw new IllegalArgumentException ( " No terminal ropes present. " ) ; this . currentRopePos = this . currentRope . length ( ) ; this . currentAbsolutePos = this . rope . length ( ) ; }
private static Term parseCompoundTerm ( final String s0 , final Memory memory ) throws InvalidInputException { String s = s0 . trim ( ) ; if ( s . isEmpty ( ) ) { throw new InvalidInputException ( " Empty compound term:  " + s ) ; } int firstSeparator = s . indexOf ( ARGUMENT_SEPARATOR ) ; if ( firstSeparator = = - 1 ) { throw new InvalidInputException ( " Invalid compound term (missing ARGUMENT_SEPARATOR):  " + s ) ; } String op = s . substring ( 0 , firstSeparator ) . trim ( ) ; NativeOperator oNative = Symbols . getOperator ( op ) ; Operator oRegistered = memory . getOperator ( op ) ; if ( ( oRegistered = = null ) & & ( oNative = = null ) ) { throw new InvalidInputException ( " Unknown operator:  " + op ) ; } ArrayList < Term > arg = parseArguments ( s . substring ( firstSeparator + 1 ) + ARGUMENT_SEPARATOR , memory ) ; Term [ ] argA = arg . toArray ( new Term [ arg . size ( ) ] ) ; Term t ; if ( oNative ! = null ) { t = Language . make ( oNative , argA , memory ) ; } else if ( oRegistered ! = null ) { t = Operation . make ( oRegistered , argA , memory ) ; } else { throw new InvalidInputException ( " Invalid compound term " ) ; } return t ; }
public T get ( int index ) { synchronized ( mLOCK ) { final ListIterator < T > itr = this . listIterator ( index ) ;
public void run ( ) { CoverInfo coverInfo ; while ( mActive ) {
public HoconConfig parseConfig ( Reader reader ) { HoconConfig config = new HoconConfig ( ) ; put ( ConfigFactory . parseReader ( reader , OPTIONS ) . resolve ( ) , config ) ; return config ; }
final void start ( final int mpdState ) { mIsActive = true ; mIsPlaying = MPDStatus . STATE_PLAYING = = mpdState ; if ( ! mPreparingStream & & mIsPlaying ) { tryToStream ( ) ;
public void initDynamicComponent ( @Nonnull final IAS2Session aSession , @Nullable final IStringMap aParameters ) throws OpenAS2Exception { m_aSession = ValueEnforcer . notNull ( aSession , " Session " ) ; setAttributes ( aParameters ! = null ? aParameters . getAllAttributes ( ) : null ) ; }
public void initialize ( ) { byte [ ] defBytes = new byte [ 4 ] ; defBytes [ 0 ] = ( byte ) ( ( def > > 24 ) & 0xff ) ; defBytes [ 1 ] = ( byte ) ( ( def > > 16 ) & 0xff ) ; defBytes [ 2 ] = ( byte ) ( ( def > > 8 ) & 0xff ) ; defBytes [ 3 ] = ( byte ) ( def & 0xff ) ; prepareBuffer ( key , EMPTY_BYTES , by , defBytes , exp ) ; }
public boolean onPreDraw ( ) { if ( coverHelper ! = null ) coverHelper . setCachedCoverMaxSize ( coverArt . getMeasuredHeight ( ) ) ; return true ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; b = new ConnectionFactoryBuilder ( ) ; }
public static void main ( String args [ ] ) throws Exception { MemcachedClient c = new MemcachedClient ( AddrUtil . getAddresses ( " localhost:11200 localhost:11201 " ) ) ; while ( true ) { for ( int i = 0 ; i < 1000 ; i + + ) {
public Object put ( String key , Object value ) { return wrapped . put ( key , checkedValue ( value ) ) ; }
public void testAsyncGetBulkWithTranscoderIterator ( ) throws Exception { ArrayList < String > keys = new ArrayList < String > ( ) ; keys . add ( " test1 " ) ; keys . add ( " test2 " ) ; keys . add ( " test3 " ) ; ArrayList < Transcoder < String > > tcs = new ArrayList < Transcoder < String > > ( keys . size ( ) ) ; for ( String key : keys ) { tcs . add ( new TestWithKeyTranscoder ( key ) ) ; } for ( String key : keys ) { tcs . add ( new TestWithKeyTranscoder ( key ) ) ; } assertEquals ( 0 , client . asyncGetBulk ( keys , tcs . listIterator ( ) ) . get ( ) . size ( ) ) ; client . set ( keys . get ( 0 ) , 5 , " val1 " , tcs . get ( 0 ) ) ; client . set ( keys . get ( 1 ) , 5 , " val2 " , tcs . get ( 1 ) ) ; Future < Map < String , String > > vals = client . asyncGetBulk ( keys , tcs . listIterator ( ) ) ; assertEquals ( 2 , vals . get ( ) . size ( ) ) ; assertEquals ( " val1 " , vals . get ( ) . get ( keys . get ( 0 ) ) ) ; assertEquals ( " val2 " , vals . get ( ) . get ( keys . get ( 1 ) ) ) ; keys . add ( 0 , " test4 " ) ; Transcoder < String > encodeTranscoder = new TestWithKeyTranscoder ( keys . get ( 0 ) ) ; client . set ( keys . get ( 0 ) , 5 , " val4 " , encodeTranscoder ) . get ( ) ; Transcoder < String > decodeTranscoder = new TestWithKeyTranscoder ( " not  " + keys . get ( 0 ) ) ; tcs . add ( 0 , decodeTranscoder ) ; try { client . asyncGetBulk ( keys , tcs . listIterator ( ) ) . get ( ) ;
public void onCreate ( ) { super . onCreate ( ) ; isServiceRunning = true ; mediaPlayer = new MediaPlayer ( ) ; audioManager = ( AudioManager ) getSystemService ( Context . AUDIO_SERVICE ) ; buffering = true ; oldStatus = " " ; isPlaying = true ; isPaused = false ; needStoppedNotification = false ; lastStartID = 0 ; mediaPlayer . setOnBufferingUpdateListener ( this ) ; mediaPlayer . setOnCompletionListener ( this ) ; mediaPlayer . setOnPreparedListener ( this ) ; mediaPlayer . setOnErrorListener ( this ) ; mediaPlayer . setOnInfoListener ( this ) ; remoteControlResponder = new ComponentName ( getPackageName ( ) , RemoteControlReceiver . class . getName ( ) ) ; initializeRemoteControlRegistrationMethods ( ) ; registerMediaButtonEvent ( ) ; TelephonyManager tmgr = ( TelephonyManager ) getSystemService ( Context . TELEPHONY_SERVICE ) ; tmgr . listen ( phoneStateListener , PhoneStateListener . LISTEN_CALL_STATE ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; app . oMPDAsyncHelper . addStatusChangeListener ( this ) ; app . oMPDAsyncHelper . addConnectionListener ( this ) ; streamSource = " http:// " + app . oMPDAsyncHelper . getConnectionSettings ( ) . getConnectionStreamingServer ( ) + " : " + app . oMPDAsyncHelper . getConnectionSettings ( ) . iPortStreaming + " / " ; }
public void register ( ConverterRegistry registry ) { registry . addConverter ( double . class , String . class , this ) ; registry . addConverter ( float . class , String . class , this ) ; registry . addConverter ( int . class , String . class , this ) ; registry . addConverter ( long . class , String . class , this ) ; registry . addConverter ( short . class , String . class , this ) ; registry . addConverter ( byte . class , String . class , this ) ; registry . addConverter ( String . class , double . class , this ) ; registry . addConverter ( String . class , float . class , this ) ; registry . addConverter ( String . class , int . class , this ) ; registry . addConverter ( String . class , long . class , this ) ; registry . addConverter ( String . class , short . class , this ) ; registry . addConverter ( String . class , byte . class , this ) ; }
public void addKeyHandler ( Object obj , String methodName ) { try { keyHandlerMethod = obj . getClass ( ) . getMethod ( methodName ,
public abstract Tab setCustomView ( View view ) ; public abstract Tab setCustomView ( int layoutResId ) ; public abstract View getCustomView ( ) ; public abstract Tab setTag ( Object obj ) ; public abstract Object getTag ( ) ; public abstract Tab setTabListener ( TabListener listener ) ; public abstract void select ( ) ; public abstract Tab setContentDescription ( int resId ) ; public abstract Tab setContentDescription ( CharSequence contentDesc ) ; public abstract CharSequence getContentDescription ( ) ; } public interface TabListener { public void onTabSelected ( Tab tab , FragmentTransaction ft ) ; public void onTabUnselected ( Tab tab , FragmentTransaction ft ) ; public void onTabReselected ( Tab tab , FragmentTransaction ft ) ; } public static class LayoutParams extends MarginLayoutParams { @ViewDebug.ExportedProperty ( mapping = { @ViewDebug.IntToString ( from = - 1 , to = " NONE " ) , @ViewDebug.IntToString ( from = Gravity . NO_GRAVITY , to = " NONE " ) , @ViewDebug.IntToString ( from = Gravity . TOP , to = " TOP " ) , @ViewDebug.IntToString ( from = Gravity . BOTTOM , to = " BOTTOM " ) , @ViewDebug.IntToString ( from = Gravity . LEFT , to = " LEFT " ) , @ViewDebug.IntToString ( from = Gravity . RIGHT , to = " RIGHT " ) , @ViewDebug.IntToString ( from = Gravity . CENTER_VERTICAL , to = " CENTER_VERTICAL " ) , @ViewDebug.IntToString ( from = Gravity . FILL_VERTICAL , to = " FILL_VERTICAL " ) , @ViewDebug.IntToString ( from = Gravity . CENTER_HORIZONTAL , to = " CENTER_HORIZONTAL " ) , @ViewDebug.IntToString ( from = Gravity . FILL_HORIZONTAL , to = " FILL_HORIZONTAL " ) , @ViewDebug.IntToString ( from = Gravity . CENTER , to = " CENTER " ) , @ViewDebug.IntToString ( from = Gravity . FILL , to = " FILL " ) } ) public int gravity = - 1 ; public LayoutParams ( Context c , AttributeSet attrs ) { super ( c , attrs ) ; } public LayoutParams ( int width , int height ) { super ( width , height ) ; this . gravity = Gravity . CENTER_VERTICAL | Gravity . LEFT ; } public LayoutParams ( int width , int height , int gravity ) { super ( width , height ) ; this . gravity = gravity ; } public LayoutParams ( int gravity ) { this ( WRAP_CONTENT , FILL_PARENT , gravity ) ; } public LayoutParams ( LayoutParams source ) { super ( source ) ; this . gravity = source . gravity ; } public LayoutParams ( ViewGroup . LayoutParams source ) { super ( source ) ; } } }
public Iterable < Row > translate ( Row message ) { String value = RowUtils . get ( message , Translator . VALUE_FIELD_NAME ) ; String [ ] stringValues = value . split ( ( delimiterRegex ) ? delimiter : Pattern . quote ( delimiter ) , fieldNames . size ( ) ) ; values . clear ( ) ; for ( int valuePos = 0 ; valuePos < fieldNames . size ( ) ; valuePos + + ) { if ( valuePos < stringValues . length ) { String fieldValue = stringValues [ valuePos ] ; if ( fieldValue . length ( ) = = 0 ) { values . add ( null ) ; } else { switch ( fieldTypes . get ( valuePos ) ) { case " string " : values . add ( fieldValue ) ; break ; case " float " : values . add ( Float . parseFloat ( fieldValue ) ) ; break ; case " double " : values . add ( Double . parseDouble ( fieldValue ) ) ; break ; case " int " : values . add ( Integer . parseInt ( fieldValue ) ) ; break ; case " long " : values . add ( Long . parseLong ( fieldValue ) ) ; break ; case " boolean " : values . add ( Boolean . parseBoolean ( fieldValue ) ) ; break ; case " timestamp " : values . add ( new Timestamp ( dateTimeParser . parse ( fieldValue ) . getMillis ( ) ) ) ; break ; default : throw new RuntimeException ( " Unsupported delimited field type:  " + fieldTypes . get ( valuePos ) ) ; } } } else { values . add ( null ) ; } } Row row = new RowWithSchema ( schema , values . toArray ( ) ) ; return Collections . singleton ( row ) ; }
protected void asyncUpdate ( ) { try { mItems = mApp . oMPDAsyncHelper . oMPD . getAlbums ( mArtist , mIsCountDisplayed ) ;
public static String getKerberosRealm ( Config config ) throws KrbException { if ( config . hasPath ( REALM_CONFIG ) ) { return config . getString ( REALM_CONFIG ) ; } return getKrb5config ( ) . getDefaultRealm ( ) ; }
public final Map . Entry < K , V > lowerEntry ( K key ) { return exportEntry ( subLower ( key ) ) ; }
public V get ( K key ) { SkipList . Node < K > node = list . getNode ( key ) ; if ( node instanceof SkipListMapNode ) { SkipListMapNode < K , V > mapNode = ( SkipListMapNode < K , V > ) node ; return mapNode . value ; } return null ; }
public void testFastBag2 ( boolean random ) { ContinuousBag2 < NullItem > f = new ContinuousBag2 ( 4 , p . conceptForgetDurations , new ContinuousBag2 . DefaultBagCurve ( ) , random ) ; f . putIn ( new NullItem ( .25f ) ) ; assert ( f . size ( ) = = 1 ) ; assert ( f . getMass ( ) > 0 ) ; f . putIn ( new NullItem ( .9f ) ) ; f . putIn ( new NullItem ( .75f ) ) ; assert ( f . size ( ) = = 3 ) ; assert ( f . items . first ( ) . getPriority ( ) < f . items . last ( ) . getPriority ( ) ) ; assert ( f . items . first ( ) . getPriority ( ) < f . items . exact ( 1 ) . getPriority ( ) ) ; assert ( f . items . size ( ) = = f . nameTable . size ( ) ) ; assert ( f . size ( ) = = 3 ) ; f . takeOut ( ) ; assert ( f . size ( ) = = 2 ) ; assert ( f . items . size ( ) = = f . nameTable . size ( ) ) ; f . takeOut ( ) ; assert ( f . size ( ) = = 1 ) ; assert ( f . items . size ( ) = = f . nameTable . size ( ) ) ; assert ( f . getMass ( ) > 0 ) ; f . takeOut ( ) ; assert ( f . size ( ) = = 0 ) ; assert ( f . getMass ( ) = = 0 ) ; assert ( f . items . size ( ) = = f . nameTable . size ( ) ) ;
private static boolean isEmpty ( String s ) { return null = = s | | 0 = = s . length ( ) ; }
protected void feelMotion ( ) { float xa = torso . getAngularVelocity ( ) ; float angleScale = 1.50f ; float a = ( float ) ( Math . log ( Math . abs ( xa * angleScale ) + 1f ) ) ; float maxAngleVelocityFelt = 0.8f ; if ( a > maxAngleVelocityFelt ) { a = maxAngleVelocityFelt ; } if ( a < 0.1 ) { feltAngularVelocity . set ( " $0.4;0.5$ <0 --> feltAngularMotion>. :|: %1.00;0.90% " ) ; } else { String direction ; String da = Texts . n1 ( a ) ; if ( xa < 0 ) { direction = " left " ; } else { direction = " right " ; } feltAngularVelocity . set ( " $0.4;0.5$ <(*, " + da + " , " + direction + " ) --> feltAngularMotion>. :|: " ) ; } float h = torso . getAngle ( ) % ( MathUtils . TWOPI ) ; if ( h < 0 ) { h + = MathUtils . TWOPI ; } h = h / MathUtils . TWOPI ; String dh = " a " + ( int ) ( h * 18 ) ; feltOrientation . set ( " $0.4;0.5$ < " + dh + "  --> feltOrientation>. :|: " ) ; float speed = Math . abs ( torso . getLinearVelocity ( ) . length ( ) ) ; if ( speed > 0.9f ) { speed = 0.9f ; } String sp = Texts . n1 ( speed ) ; feltSpeed . set ( " $0.4;0.5$ < " + sp + "  --> feltSpeed>. :|: " ) ;
public void resetLearning ( ) ; public void trainOnInstance ( E example ) ; public double [ ] getVotesForInstance ( E example ) ; public Measurement [ ] getModelMeasurements ( ) ; public Learner [ ] getSublearners ( ) ; public MOAObject getModel ( ) ; public void setModelContext ( InstancesHeader ih ) ; public InstancesHeader getModelContext ( ) ; }
void setPartnership ( @Nullable Partnership aPartnership ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; }
public final void connect ( InetAddress server , int port ) throws MPDServerException { this . mpdConnection = new MPDConnection ( server , port ) ; this . mpdIdleConnection = new MPDConnection ( server , port , 1000 ) ; this . mpdStatusConnection = new MPDConnection ( server , port , 1000 ) ; }
private boolean doesCache ( ) { if ( ! config . hasPath ( CACHE_ENABLED_PROPERTY ) ) return false ; return config . getBoolean ( CACHE_ENABLED_PROPERTY ) ; }
MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; BlockingQueue < Operation > createOperationQueue ( ) ; BlockingQueue < Operation > createReadOperationQueue ( ) ; BlockingQueue < Operation > createWriteOperationQueue ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; boolean isDaemon ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; }
public static Term make ( Product product , Term relation , short index , Memory memory ) { if ( relation instanceof Product ) { Product p2 = ( Product ) relation ; if ( ( product . size ( ) = = 2 ) & & ( p2 . size ( ) = = 2 ) ) { if ( ( index = = 0 ) & & product . componentAt ( 1 ) . equals ( p2 . componentAt ( 1 ) ) ) { return p2 . componentAt ( 0 ) ; } if ( ( index = = 1 ) & & product . componentAt ( 0 ) . equals ( p2 . componentAt ( 0 ) ) ) { return p2 . componentAt ( 1 ) ; } } } Term [ ] argument = product . cloneComponents ( ) ; argument [ index ] = relation ; return make ( argument , index , memory ) ; }
public void onQuestion ( Task t ) { index + = 0.25f ; VertexDisplay d = updateVertex ( t ) ; d . position ( level , index , priority ) ; deadVertices . remove ( t ) ; levelContents + + ; lastTerm = null ; lastTermVertex = null ; }
public boolean isNull ( List < String > path ) { final int lastIndex = path . size ( ) - 1 ; Map < String , Object > parentMap = getMap ( path . subList ( 0 , lastIndex ) ) ; if ( parentMap = = null ) { return false ; } String lastKey = path . get ( lastIndex ) ; Object value = parentMap . get ( lastKey ) ; return value = = NULL_OBJECT ; }
public AS2ClientResponse sendSynchronous ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2ClientRequest aRequest ) { ValueEnforcer . notNull ( aSettings , " ClientSettings " ) ; ValueEnforcer . notNull ( aRequest , " ClientRequest " ) ; final AS2ClientResponse aResponse = createResponse ( ) ; IMessage aMsg = null ; final StopWatch aSW = StopWatch . createdStarted ( ) ; try { final Partnership aPartnership = buildPartnership ( aSettings ) ; aMsg = createMessage ( aPartnership , aRequest ) ; aResponse . setOriginalMessageID ( aMsg . getMessageID ( ) ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " MessageID to send:  " + aMsg . getMessageID ( ) ) ; final boolean bHasRetries = aSettings . getRetryCount ( ) > 0 ; final AS2Session aSession = createSession ( ) ; initCertificateFactory ( aSettings , aSession ) ; initPartnershipFactory ( aSession ) ; initMessageProcessor ( aSession ) ; if ( bHasRetries ) { final IProcessorResenderModule aResender = new ImmediateResenderModule ( ) ; aResender . initDynamicComponent ( aSession , null ) ; aSession . getMessageProcessor ( ) . addModule ( aResender ) ; } aSession . getMessageProcessor ( ) . startActiveModules ( ) ; try { beforeSend ( aSettings , aSession , aMsg ) ; final ICommonsMap < String , Object > aHandleOptions = new CommonsHashMap < > ( ) ; if ( bHasRetries ) aHandleOptions . put ( IProcessorResenderModule . OPTION_RETRIES , Integer . toString ( aSettings . getRetryCount ( ) ) ) ; final AS2SenderModule aSender = m_aAS2SenderModuleFactory . get ( ) ; aSender . initDynamicComponent ( aSession , null ) ; aSender . putIn ( AbstractHttpSenderModule . ATTR_CONNECT_TIMEOUT , aSettings . getConnectTimeoutMS ( ) ) ; aSender . putIn ( AbstractHttpSenderModule . ATTR_READ_TIMEOUT , aSettings . getReadTimeoutMS ( ) ) ; aMsg . headers ( ) . setAllHeaders ( aSettings . customHeaders ( ) ) ; aSession . getMessageProcessor ( ) . addModule ( aSender ) ; aSender . handle ( IProcessorSenderModule . DO_SEND , aMsg , aHandleOptions ) ; } finally { aSession . getMessageProcessor ( ) . stopActiveModules ( ) ; } } catch ( final Throwable t ) { s_aLogger . error ( " Error sending AS2 message " , t ) ; aResponse . setException ( t ) ; } finally { if ( aMsg ! = null & & aMsg . getMDN ( ) ! = null ) { aResponse . setMDN ( aMsg . getMDN ( ) ) ; } } if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Response retrieved:  " + aResponse . getAsString ( ) ) ; aResponse . setExecutionDuration ( aSW . stopAndGetDuration ( ) ) ; return aResponse ; }
public static Collection params ( ) { List l = new LinkedList ( ) ; File folder = new File ( " nal/test " ) ; for ( final File file : folder . listFiles ( ) ) { if ( file . getName ( ) . equals ( " README.txt " ) ) continue ; addTest ( file . getName ( ) ) ; l . add ( new Object [ ] { file . getAbsolutePath ( ) } ) ; } return l ; }
public Task processInput ( String s , Narsese narsese ) throws Narsese . InvalidInputException { StringBuilder result = new StringBuilder ( ) ; s = s . replace ( " go to " , " go-to " ) . replace ( " should be " , " is " ) ; String punct = " . " ; if ( s . endsWith ( " ? " ) ) { punct = " ? " ; } else if ( s . endsWith ( " ! " ) ) { punct = " ! " ; } s = s . replace ( " ? " , " " ) . replace ( " ! " , " " ) . replace ( " . " , " " ) . replace ( " , " , " " ) ; s = s . replace ( " who  " , " ?1  " ) . replace ( " what  " , " ?1  " ) . replace ( " when  " , " ?1  " ) . replace ( " where  " , " ?1  " ) ; s = s . replace ( " somewhere " , " #1 " ) . replace ( " something " , " #1 " ) ; String [ ] words = s . split ( "   " ) ; ArrayList < String > realwords = new ArrayList < String > ( ) ; for ( int i = 0 ; i < words . length ; i + + ) { if ( ! ( words [ i ] . equals ( " a " ) | | words [ i ] . equals ( " an " ) | | words [ i ] . equals ( " the " ) ) ) { realwords . add ( words [ i ] ) ; if ( ! wordmem . contains ( words [ i ] ) ) { wordmem . add ( words [ i ] ) ; } } } words = realwords . toArray ( new String [ realwords . size ( ) ] ) ; for ( String word : words ) { for ( String mword : wordmem ) { if ( word . equals ( mword ) ) { continue ; } int difference = levenshteinDistance ( word . replace ( " ing " , " " ) , mword . replace ( " ing " , " " ) ) ; int longerword = Math . max ( word . length ( ) , mword . length ( ) ) ; double perc = ( ( double ) difference ) / ( ( double ) longerword ) ; if ( perc < 0.3 ) { result . append ( " < " + word + "  <->  " + mword + " >. " ) . append ( '\n' ) ; } } } String sentence = " " ; if ( words . length = = 2 ) { sentence = " (^ " + words [ 0 ] + " , " + words [ 1 ] + " ) " + punct + "  :|: " ; } else if ( words . length = = 3 | | ( words . length > 3 & & ( words [ 3 ] . equals ( " at " ) | | words [ 3 ] . equals ( " on " ) | | words [ 3 ] . equals ( " in " ) ) ) ) { if ( " is " . equals ( words [ 1 ] ) ) { sentence = " < " + words [ 0 ] + "  -->  " + words [ 2 ] + " > " + punct + "  :|: " ; } else { sentence = " <(*, " + words [ 0 ] + " , " + words [ 2 ] + " ) -->  " + words [ 1 ] + " > " + punct + "  :|: " ; } } else { boolean contains_is = false ; for ( int i = 0 ; i < words . length ; i + + ) { if ( words [ i ] . equals ( " is " ) ) { contains_is = true ; String left = " <(* " ; String right = " (* " ; int leftcnt = 0 ; int rightcnt = 0 ; for ( int j = 0 ; j < i ; j + + ) { if ( words [ j ] . equals ( " at " ) | | words [ j ] . equals ( " on " ) | | words [ j ] . equals ( " in " ) ) { break ; } leftcnt + + ; left + = " , " + words [ j ] ; } for ( int j = i + 1 ; j < words . length ; j + + ) { if ( words [ j ] . equals ( " at " ) | | words [ j ] . equals ( " on " ) | | words [ j ] . equals ( " in " ) ) { break ; } rightcnt + + ; right + = " , " + words [ j ] ; } left + = " ) " ; right + = " )> " ; if ( rightcnt = = 1 ) { right = right . replace ( " (*, " , " " ) ; right = right . replace ( " ) " , " " ) ; } if ( leftcnt = = 1 ) { left = left . replace ( " (*, " , " " ) ; left = left . replace ( " ) " , " " ) ; } sentence = left + "  -->  " + right + punct + "  :|: " ; } } if ( contains_is = = false ) { sentence = " <(* " ; for ( int i = 0 ; i < words . length ; i + + ) { sentence + = " , " + words [ i ] ; } sentence + = " ) --> sentence> " + punct + "  :|: " ; } } result . append ( sentence ) . append ( " \ n " ) ; for ( int i = 0 ; i < words . length - 1 ; i + + ) { if ( words [ i ] . equals ( " at " ) | | words [ i ] . equals ( " on " ) | | words [ i ] . equals ( " in " ) ) { result . append ( " < " + words [ i + 1 ] + "  --> place>. " ) . append ( '\n' ) ; } } return narsese . parseNarsese ( result ) ; }
public Concept conceptualize ( final BudgetValue budget , Term term ) { if ( term instanceof Interval ) { return null ; } term = CompoundTerm . replaceIntervals ( term ) ; final Concept displaced ; Concept concept ; synchronized ( concepts ) { concept = concepts . pickOut ( term ) ; if ( concept = = null ) { concept = new Concept ( budget , term , this ) ; emit ( Events . ConceptNew . class , concept ) ; } else if ( concept ! = null ) { BudgetFunctions . activate ( concept . budget , budget , BudgetFunctions . Activating . TaskLink ) ; } else { return null ; } displaced = concepts . putBack ( concept , cycles ( narParameters . CONCEPT_FORGET_DURATIONS ) , this ) ; } if ( displaced = = null ) {
public K next ( ) { return i . next ( ) . getKey ( ) ; }
public Iterable < Row > translate ( byte [ ] key , byte [ ] value ) throws Exception { if ( value = = null | | value . length < 1 ) { throw new RuntimeException ( " Payload value is null or empty " ) ; } DynamicMessage msg ; BufferedInputStream valueInputStream = new BufferedInputStream ( new ByteArrayInputStream ( value ) ) ; try { if ( ProtobufUtils . isGzipped ( valueInputStream ) ) { LOG . trace ( " Decompressing GZIP byte array " ) ; msg = DynamicMessage . parseFrom ( descriptor , new GZIPInputStream ( valueInputStream ) ) ; } else { msg = DynamicMessage . parseFrom ( descriptor , valueInputStream ) ; } } catch ( InvalidProtocolBufferException ex ) { throw new RuntimeException ( " Error while parsing message from descriptor and raw bytes " , ex ) ; } List < Object > rowValues = ProtobufUtils . buildRowValues ( descriptor , msg , schema ) ; Row row = RowFactory . create ( rowValues . toArray ( ) ) ; if ( doesAppendRaw ) { row = RowUtils . append ( row , key ) ; row = RowUtils . append ( row , value ) ; } return Collections . singletonList ( row ) ; }
public static synchronized void closeJavaStreamingContext ( boolean cleanupHiveMetastore ) { if ( INSTANCE . jsc ! = null ) { INSTANCE . jsc . close ( ) ;
private void updateAudioNameText ( final MPDStatus status ) { StringBuilder optionalTrackInfo = null ; if ( mCurrentSong ! = null & & mIsAudioNameTextEnabled & & ! status . isState ( MPDStatus . STATE_STOPPED ) ) { final char [ ] separator = { ' ' , '|' , ' ' } ; final String fileExtension = Tools . getExtension ( mCurrentSong . getFullPath ( ) ) ; final long bitRate = status . getBitrate ( ) ; final int bitsPerSample = status . getBitsPerSample ( ) ; final int sampleRate = status . getSampleRate ( ) ; optionalTrackInfo = new StringBuilder ( 40 ) ; if ( fileExtension ! = null ) { optionalTrackInfo . append ( fileExtension . toUpperCase ( ) ) ; } if ( bitRate > 0 L ) { if ( optionalTrackInfo . length ( ) > 0 ) { optionalTrackInfo . append ( separator ) ; } optionalTrackInfo . append ( bitRate ) ; optionalTrackInfo . append ( " kbps " ) ; } if ( bitsPerSample > 0 ) { if ( optionalTrackInfo . length ( ) > 0 ) { optionalTrackInfo . append ( separator ) ; } optionalTrackInfo . append ( bitsPerSample ) ; optionalTrackInfo . append ( " bits " ) ; } if ( sampleRate > 1000 ) { if ( optionalTrackInfo . length ( ) > 0 ) { optionalTrackInfo . append ( separator ) ; } optionalTrackInfo . append ( Math . abs ( sampleRate / 1000.0f ) ) ; optionalTrackInfo . append ( " kHz " ) ; } if ( optionalTrackInfo . length ( ) > 0 ) { mAudioNameText . setText ( optionalTrackInfo ) ; mAudioNameText . setVisibility ( View . VISIBLE ) ; } } if ( optionalTrackInfo = = null | | optionalTrackInfo . length ( ) = = 0 ) { mAudioNameText . setVisibility ( View . GONE ) ;
private static final String toBinaryString ( int value ) { if ( value < 0 ) return " null " ; StringBuilder builder = new StringBuilder ( Integer . toBinaryString ( value ) ) ; builder = builder . reverse ( ) ; while ( builder . length ( ) < BITS ) { builder . append ( '0' ) ; } return builder . toString ( ) ; }
public static Map < GenericRecord , List < GenericRecord > > recordsByKey ( List < GenericRecord > records , List < String > keyFieldNames ) { Map < GenericRecord , List < GenericRecord > > recordsByKey = Maps . newHashMap ( ) ; if ( records . size ( ) > 0 ) { Schema keySchema = RecordUtils . subsetSchema ( records . get ( 0 ) . getSchema ( ) , keyFieldNames ) ; for ( GenericRecord record : records ) { GenericRecord key = RecordUtils . subsetRecord ( record , keySchema ) ; if ( ! recordsByKey . containsKey ( key ) ) { recordsByKey . put ( key , new ArrayList < GenericRecord > ( ) ) ; } List < GenericRecord > rowsForKey = recordsByKey . get ( key ) ; rowsForKey . add ( record ) ; } } return recordsByKey ; }
public static void registerSketch ( PApplet app ) { if ( sketchApplet = = null ) { sketchApplet = app ;
public boolean run ( Integer [ ] unsorted , Integer [ ] sorted , String input ) { this . input = input ; SkipList < Integer > skipList = new SkipList < Integer > ( ) ; Collection < Integer > lCollection = skipList . toCollection ( ) ; if ( ! testJavaCollection ( lCollection , Integer . class , name , unsorted , sorted , input ) ) return false ; return true ; }
protected void beforeSend ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2Session aSession , @Nonnull final IMessage aMsg ) { } @Nonnull public AS2ClientResponse sendSynchronous ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2ClientRequest aRequest ) { final AS2ClientResponse aResponse = createResponse ( ) ; IMessage aMsg = null ; try { final Partnership aPartnership = buildPartnership ( aSettings ) ; aMsg = createMessage ( aPartnership , aRequest ) ; aResponse . setOriginalMessageID ( aMsg . getMessageID ( ) ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " MessageID to send:  " + aMsg . getMessageID ( ) ) ; final boolean bHasRetries = aSettings . getRetryCount ( ) > 0 ; final AS2Session aSession = createSession ( ) ; initCertificateFactory ( aSettings , aSession ) ; initPartnershipFactory ( aSession ) ; initMessageProcessor ( aSession ) ; if ( bHasRetries ) { final IProcessorResenderModule aResender = new ImmediateResenderModule ( ) ; aResender . initDynamicComponent ( aSession , null ) ; aSession . getMessageProcessor ( ) . addModule ( aResender ) ; } aSession . getMessageProcessor ( ) . startActiveModules ( ) ; try { beforeSend ( aSettings , aSession , aMsg ) ; final Map < String , Object > aHandleOptions = new HashMap < String , Object > ( ) ; if ( bHasRetries ) aHandleOptions . put ( IProcessorResenderModule . OPTION_RETRIES , Integer . toString ( aSettings . getRetryCount ( ) ) ) ; final AS2SenderModule aSender = m_aAS2SenderModuleFactory . get ( ) ; aSender . initDynamicComponent ( aSession , null ) ; aSession . getMessageProcessor ( ) . addModule ( aSender ) ; aSender . handle ( IProcessorSenderModule . DO_SEND , aMsg , aHandleOptions ) ; } finally { aSession . getMessageProcessor ( ) . stopActiveModules ( ) ; } } catch ( final Throwable t ) { s_aLogger . error ( " Error sending AS2 message " , t ) ; aResponse . setException ( t ) ; } finally { if ( aMsg ! = null & & aMsg . getMDN ( ) ! = null ) { aResponse . setMDN ( aMsg . getMDN ( ) ) ; } } if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Response retrieved:  " + aResponse . getAsString ( ) ) ; return aResponse ; } }
public String getName ( ) ; public void setName ( String name ) ; }
public String toString ( ) { StringBuffer sb = new StringBuffer ( ) ; sb . append ( " + " + getFullpath ( ) + " \ n " ) ; for ( String file : files . keySet ( ) ) { sb . append ( files . get ( file ) . toString ( ) + " \ n " ) ; } for ( String dir : directories . keySet ( ) ) { sb . append ( directories . get ( dir ) . toString ( ) + " \ n " ) ; } sb . append ( " - " + this . getFullpath ( ) + " \ n " ) ; return sb . toString ( ) ; }
public String toString ( ) { return " clauses:  " + clauses + " \ n " + " goal:  " + goal + " \ n " +
public String toString ( ) { return " MyObject{ " + " integer= " + integer +
private byte [ ] serialize ( Object o ) { assert o ! = null ; byte rv [ ] = null ; try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream os = new ObjectOutputStream ( bos ) ; os . writeObject ( o ) ; os . close ( ) ; bos . close ( ) ; rv = bos . toByteArray ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException encoding %s " , o , e ) ; } return rv ; }
public void moveCheckState ( int from , int to ) { SparseBooleanArray cip = getCheckedItemPositions ( ) ; int rangeStart = from ; int rangeEnd = to ; if ( to < from ) { rangeStart = to ; rangeEnd = from ; } rangeEnd + = 1 ; int [ ] runStart = new int [ cip . size ( ) ] ; int [ ] runEnd = new int [ cip . size ( ) ] ; int runCount = buildRunList ( cip , rangeStart , rangeEnd , runStart , runEnd ) ; if ( runCount = = 1 & & ( runStart [ 0 ] = = runEnd [ 0 ] ) ) { return ; } if ( from < to ) { for ( int i = 0 ; i ! = runCount ; i + + ) {
public Conjunction clone ( ) { return new Conjunction ( name ( ) , cloneTerms ( ) , isConstant ( ) , complexity , temporalOrder ) ; }
public boolean add ( final Sentence s , final Item c ) { if ( super . add ( s , c ) ) { concepts . put ( s , c ) ; return true ; } return false ; }
public String toString ( ) { return ( " {LogLevel:   " + name ( ) + " } " ) ; }
public void readWordFrequencies ( ) { System . out . println ( " INFO in WordNet.readWordFrequencies(): Reading WordNet word frequencies " ) ; int counter = 0 ; File wfFile = null ; String canonicalPath = " " ; try { wfFile = getWnFile ( " word_frequencies " ) ; if ( wfFile = = null ) { System . out . println ( " INFO in WordNet.readWordFrequencies():  " + " The word frequencies file does not exist " ) ; return ; } canonicalPath = wfFile . getCanonicalPath ( ) ; long t1 = System . currentTimeMillis ( ) ; FileReader r = new FileReader ( wfFile ) ; LineNumberReader lr = new LineNumberReader ( r ) ; Matcher m = null ; String key = null ; String values = null ; String [ ] words = null ; HashMap frequencies = null ; String word = null ; String freq = null ; String line = null ; while ( ( line = lr . readLine ( ) ) ! = null ) { line = line . trim ( ) ; m = regexPatterns [ 17 ] . matcher ( line ) ; if ( m . matches ( ) ) { key = m . group ( 1 ) ; values = m . group ( 2 ) ; words = values . split ( "   " ) ; frequencies = new HashMap ( ) ; for ( int i = 0 ; i < words . length - 3 ; i + + ) { if ( words [ i ] . equals ( " SUMOterm: " ) ) { i = words . length ; } else { if ( words [ i ] . indexOf ( '_' ) = = - 1 ) { } else { word = words [ i ] . substring ( 0 , words [ i ] . indexOf ( '_' ) ) ; freq = words [ i ] . substring ( words [ i ] . lastIndexOf ( '_' ) + 1 , words [ i ] . length ( ) ) ; frequencies . put ( word . intern ( ) , Integer . decode ( freq ) ) ; } } } wordFrequencies . put ( key . intern ( ) , frequencies ) ; counter + + ; if ( counter = = 1000 ) { System . out . print ( " . " ) ; counter = 0 ; } } } System . out . println ( " x " ) ; System . out . println ( "    " + ( ( System . currentTimeMillis ( ) - t1 ) / 1000.0 ) + "  seconds to process  " + canonicalPath ) ; } catch ( Exception i ) { System . out . println ( ) ; System . out . println ( " Error in WordNet.readWordFrequencies() reading file  " + canonicalPath + " :  " + i . getMessage ( ) ) ; i . printStackTrace ( ) ; } return ; }
private static final int indexToFigure ( final TLink link1 , final TLink link2 ) { return ( link1 . getIndex ( 0 ) + 1 ) * 10 + ( link2 . getIndex ( 0 ) + 1 ) ; }
public SortedSet < ParticlePath > activate ( final Term source , final boolean forward , int iterations , double distance ) { double particleActivation = 1.0 / iterations ; List < Sentence > currentPath = new ArrayList ( ) ; List < Sentence > nextEdges = new ArrayList ( ) ; for ( int i = 0 ; i < iterations ; i + + ) { currentPath . clear ( ) ; double energy = distance ; Term current = source ; boolean choicesAvailable = false ; boolean operationTraversed = false ; while ( energy > 0 ) { Set < Sentence > graphEdges = forward ? graph . outgoingEdgesOf ( current ) : graph . incomingEdgesOf ( current ) ; nextEdges . clear ( ) ; for ( final Sentence s : graphEdges ) { Term etarget = forward ? graph . getEdgeTarget ( s ) : graph . getEdgeSource ( s ) ; if ( ! etarget . equals ( source ) ) { nextEdges . add ( s ) ; } if ( etarget instanceof Operation ) { operationTraversed = true ; } } if ( nextEdges . isEmpty ( ) ) { break ; } Sentence nextEdge = null ; if ( nextEdges . size ( ) = = 1 ) { nextEdge = nextEdges . get ( 0 ) ; } else { int numEdges = nextEdges . size ( ) ; double totalProb = 0 ; for ( int j = 0 ; j < numEdges ; j + + ) { totalProb + = 1.0 / graph . getEdgeWeight ( nextEdges . get ( j ) ) ; } double r = Memory . randomNumber . nextDouble ( ) * totalProb ; System . out . print ( totalProb + "   " + r ) ; int j ; for ( j = 0 ; j < numEdges ; j + + ) { nextEdge = nextEdges . get ( j ) ; r - = 1.0 / graph . getEdgeWeight ( nextEdge ) ; if ( r < = 0 ) { break ; } } choicesAvailable = true ; } double weight = graph . getEdgeWeight ( nextEdge ) ; energy - = weight ; currentPath . add ( nextEdge ) ; current = forward ? graph . getEdgeTarget ( nextEdge ) : graph . getEdgeSource ( nextEdge ) ; if ( ( current = = null ) | | ( ! graph . containsVertex ( current ) ) ) break ; } if ( ( currentPath . isEmpty ( ) ) | | ( ! operationTraversed ) ) continue ; ParticlePath ppath = termPaths . get ( current ) ; if ( ppath = = null ) { termPaths . put ( current , ppath = new ParticlePath ( source , currentPath , distance - energy ) ) ; } else { ppath . addPath ( currentPath , distance - energy ) ; } if ( choicesAvailable ) { ppath . activation + = particleActivation ; } else { ppath . activation = 1 ; break ; } } Collection < ParticlePath > paths = termPaths . values ( ) ; double maxAct = 0 ; for ( final ParticlePath p : paths ) if ( p . activation > maxAct ) maxAct = p . activation ; if ( maxAct > 0 ) for ( final ParticlePath p : paths ) p . activation / = maxAct ; return new TreeSet ( paths ) ; }
public void asyncUpdate ( ) { try { MPDApplication app = ( MPDApplication ) getApplication ( ) ; dispMusic = new ArrayList < Music > ( app . oMPDAsyncHelper . oMPD . find ( MPD . MPD_FIND_ALBUM , album ) ) ; } catch ( MPDServerException e ) { } Collections . sort ( dispMusic , new MusicComparator ( ) ) ; for ( Music music : dispMusic ) { items . add ( music . getTitle ( ) ) ;
public SASLMechsOperation saslMechs ( OperationCallback cb ) { throw new UnsupportedOperationException ( ) ; }
public void testCarryForwardMultipleWhenNull ( ) { p = new EventTimeHistoryPlanner ( ) ; config = config . withValue ( EventTimeHistoryPlanner . CARRY_FORWARD_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( true ) ) ; assertNoValidationFailures ( p , config ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES , " " ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , null , 200L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , null , 150L ) ) ; key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 3 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( planned . get ( 0 ) . getAs ( " value " ) , " hello " ) ; assertEquals ( planned . get ( 0 ) . getAs ( " startdate " ) , 100L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " enddate " ) , 149L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; assertEquals ( planned . get ( 1 ) . getAs ( " value " ) , " hello " ) ; assertEquals ( planned . get ( 1 ) . getAs ( " startdate " ) , 150L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " enddate " ) , 199L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 2 ) ) , MutationType . INSERT ) ; assertEquals ( planned . get ( 2 ) . getAs ( " value " ) , " hello " ) ; assertEquals ( planned . get ( 2 ) . getAs ( " startdate " ) , 200L ) ; assertEquals ( planned . get ( 2 ) . getAs ( " enddate " ) , 253402214400000L ) ; assertEquals ( planned . get ( 2 ) . getAs ( " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES ) ; }
public boolean add ( C value ) { return trie . add ( value ) ; }
public void run ( int bit1Iterations , int bit2Iterations , int bit2Thinking ) { inputProb = 0.1 ; for ( int i = 0 ; i < bit1Iterations ; i + + ) nar . step ( 1 ) ; inputProb = 0.0 ; for ( int i = 0 ; i < bit1Iterations ; i + + ) nar . step ( 1 ) ; nextLevel ( ) ; inputProb = 0.1 ; for ( int i = 0 ; i < bit2Iterations ; i + + ) nar . step ( 1 ) ; inputProb = 0.0 ; for ( int i = 0 ; i < bit2Iterations ; i + + ) nar . step ( 1 ) ; for ( int i = 0 ; i < bit2Thinking ; i + + ) nar . step ( 1 ) ;
protected String makeName ( ) { if ( nameBuilder = = null ) nameBuilder = new StringBuilder ( ) ; return makeStatementName ( getSubject ( ) , operator ( ) , getPredicate ( ) , nameBuilder ) ; }
public void add ( int index , E element ) { throw new UnsupportedOperationException ( " add " ) ; }
public AS2ClientRequest setData ( @Nonnull final String sText , @Nullable final Charset aCharset ) { m_aDataByteArray = null ; m_sDataText = ValueEnforcer . notNull ( sText , " Text " ) ; m_aDataCharset = aCharset ; m_aDataHandler = null ; return this ; }
void close ( ) ; @Override default FileConfig checked ( ) { return new CheckedFileConfig ( this ) ; } < R > R bulkUpdate ( Function < ? super Config , R > action ) ; default void bulkUpdate ( Consumer < ? super Config > action ) { bulkUpdate ( config - > { action . accept ( config ) ; return null ; } ) ; } static FileConfig of ( File file ) { return of ( file . toPath ( ) ) ; } static FileConfig of ( File file , ConfigFormat < ? extends Config > format ) { return of ( file . toPath ( ) , format ) ; } static FileConfig of ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return of ( file , format ) ; } static FileConfig of ( Path file , ConfigFormat < ? extends Config > format ) { return builder ( file , format ) . build ( ) ; } static FileConfig of ( String filePath ) { return of ( Paths . get ( filePath ) ) ; } static FileConfig of ( String filePath , ConfigFormat < ? > format ) { return of ( Paths . get ( filePath ) , format ) ; } @Deprecated static FileConfig ofConcurrent ( File file ) { return ofConcurrent ( file . toPath ( ) ) ; } @Deprecated static FileConfig ofConcurrent ( File file , ConfigFormat < ? > format ) { return ofConcurrent ( file . toPath ( ) , format ) ; } @Deprecated static FileConfig ofConcurrent ( Path file ) { return builder ( file ) . concurrent ( ) . build ( ) ; } @Deprecated static FileConfig ofConcurrent ( Path file , ConfigFormat < ? > format ) { return builder ( file , format ) . concurrent ( ) . build ( ) ; } @Deprecated static FileConfig ofConcurrent ( String filePath ) { return ofConcurrent ( Paths . get ( filePath ) ) ; } @Deprecated static FileConfig ofConcurrent ( String filePath , ConfigFormat < ? > format ) { return ofConcurrent ( Paths . get ( filePath ) , format ) ; } static FileConfigBuilder builder ( File file ) { return builder ( file . toPath ( ) ) ; } static FileConfigBuilder builder ( File file , ConfigFormat < ? > format ) { return builder ( file . toPath ( ) , format ) ; } static FileConfigBuilder builder ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return builder ( file , format ) ; } static FileConfigBuilder builder ( Path file , ConfigFormat < ? > format ) { return new FileConfigBuilder ( file , format ) ; } static FileConfigBuilder builder ( String filePath ) { return builder ( Paths . get ( filePath ) ) ; } static FileConfigBuilder builder ( String filePath , ConfigFormat < ? > format ) { return builder ( Paths . get ( filePath ) , format ) ; } }
final void start ( ) { mRemoteControlClient . setOnGetPlaybackPositionListener ( this ) ; mRemoteControlClient . setPlaybackPositionUpdateListener ( this ) ; MPDroidService . MPD_ASYNC_HELPER . addTrackPositionListener ( this ) ; }
public void windDownResources ( ) { Log . d ( TAG , " Winding down resources. " ) ; if ( audioManager ! = null ) { audioManager . abandonAudioFocus ( this ) ; } sendIntent ( ACTION_STOP , NotificationService . class ) ; if ( delayedPlayHandler ! = null ) { delayedPlayHandler . removeCallbacksAndMessages ( null ) ; } if ( mTelephonyManager ! = null ) { mTelephonyManager . listen ( phoneStateListener , PhoneStateListener . LISTEN_NONE ) ; } if ( mediaPlayer ! = null ) {
public void testCostPathPair ( ) { final List < Edge < Integer > > s1 = new ArrayList < Graph . Edge < Integer > > ( 3 ) ; s1 . add ( new Edge < Integer > ( 1 , new Vertex < Integer > ( 10 ) , new Vertex < Integer > ( 20 ) ) ) ; s1 . add ( new Edge < Integer > ( 2 , new Vertex < Integer > ( 20 ) , new Vertex < Integer > ( 30 ) ) ) ; final Graph . CostPathPair < Integer > p1 = new Graph . CostPathPair < Integer > ( 1 , s1 ) ; final List < Edge < Integer > > s2 = new ArrayList < Graph . Edge < Integer > > ( 3 ) ; s2 . add ( new Edge < Integer > ( 2 , new Vertex < Integer > ( 10 ) , new Vertex < Integer > ( 20 ) ) ) ; s2 . add ( new Edge < Integer > ( 1 , new Vertex < Integer > ( 20 ) , new Vertex < Integer > ( 30 ) ) ) ; final Graph . CostPathPair < Integer > p2 = new Graph . CostPathPair < Integer > ( 1 , s2 ) ; final List < Edge < Integer > > s3 = new ArrayList < Graph . Edge < Integer > > ( 3 ) ; s3 . add ( new Edge < Integer > ( 2 , new Vertex < Integer > ( 10 ) , new Vertex < Integer > ( 20 ) ) ) ; s3 . add ( new Edge < Integer > ( 1 , new Vertex < Integer > ( 20 ) , new Vertex < Integer > ( 30 ) ) ) ; final Graph . CostPathPair < Integer > p3 = new Graph . CostPathPair < Integer > ( 1 , s3 ) ; Assert . assertFalse ( p1 . equals ( p2 ) ) ; Assert . assertFalse ( p2 . equals ( p1 ) ) ; Assert . assertTrue ( p2 . equals ( p3 ) & & p2 . hashCode ( ) = = p3 . hashCode ( ) ) ; Assert . assertTrue ( p3 . equals ( p2 ) & & p3 . hashCode ( ) = = p2 . hashCode ( ) ) ; }
public synchronized void registerRenderer ( Class type , TableCellRenderer renderer ) { typeToRenderer . put ( type , renderer ) ; }
public void event ( final Class event , final Object [ ] arguments ) { if ( event = = Events . TaskAdd . class ) { onTaskAdd ( ( Task ) arguments [ 0 ] , ( String ) arguments [ 1 ] ) ;
void removePlugin ( final Nar . PluginState pluginState ) ; List getPlugins ( ) ; }
private List < String > extractAlbumIds ( String response ) { JSONObject jsonRoot ; JSONArray jsonAlbums ; JSONObject jsonAlbum ; String albumId ; List < String > albumIds = new ArrayList < String > ( ) ; try { jsonRoot = new JSONObject ( response ) ; jsonAlbums = jsonRoot . optJSONArray ( " albums " ) ; if ( jsonAlbums ! = null ) { for ( int a = 0 ; a < jsonAlbums . length ( ) ; a + + ) { jsonAlbum = jsonAlbums . optJSONObject ( a ) ; if ( jsonAlbum ! = null ) { albumId = jsonAlbum . optString ( " href " ) ; if ( albumId ! = null & & albumId . length ( ) > 0 ) { albumId = albumId . replace ( " spotify:album: " , " " ) ; albumIds . add ( albumId ) ; } } } } } catch ( final Exception e ) { Log . e ( TAG , " Failed to get cover URL from Spotify. " , e ) ; } return albumIds ; }
public void doStop ( ) throws OpenAS2Exception { final int nRemainingItems = getResendItemCount ( ) ; if ( nRemainingItems > 0 ) { if ( LOGGER . isErrorEnabled ( ) ) LOGGER . error ( " InMemoryResenderModule is stopped but  " + nRemainingItems + "  items are still contained. They are discarded and will be lost! " ) ; } super . doStop ( ) ; }
public static Term make ( Collection < Term > t ) { if ( t . isEmpty ( ) ) return null ; final TreeSet < Term > set = new TreeSet < > ( t ) ; return make ( set . toArray ( new Term [ set . size ( ) ] ) ) ; }
< T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public static void main ( String [ ] arg ) { NAR nar = new DefaultNARBuilder ( ) . build ( ) ; nar . param ( ) . duration . set ( 100 ) ; nar . param ( ) . decisionThreshold . set ( 0.1 ) ; nar . param ( ) . noiseLevel . set ( 0 ) ; NARio nario = new NARio ( nar ) ; new NARSwing ( nar ) ; nar . start ( 50 , 500 ) ; }
public String getDefaultDescription ( ) { return " List all partners in the current partnership store " ; }
@Override public Object react ( String input ) { if ( input . equals ( Symbols . REBOOT_COMMAND ) ) { memory . emit ( IN . class , " reboot " ) ; memory . reset ( ) ; return new Reboot ( ) ; } return null ; }
public InetAddress getHostAddress ( ) throws MPDConnectionException { if ( mpdConnection = = null ) { throw new MPDConnectionException ( " MPD Connection is null. " ) ; } return mpdConnection . getHostAddress ( ) ; }
public abstract NAR addInput ( final Task t ) ; public void step_start ( ) { } public void step_finished ( ) { for ( final SensoryChannel ch : reportResultsTo ) { for ( final Task t : results ) { ch . addInput ( t ) ; } } results . clear ( ) ; } public double topDownPriority ( final Term t ) { double prioritysum = 0.0f ; int k = 0 ; for ( final SensoryChannel chan : reportResultsTo ) { prioritysum + = chan . priority ( t ) ; k + + ; } return prioritysum / ( double ) reportResultsTo . size ( ) ; } public double priority ( final Term t ) { if ( this instanceof NAR ) { final Concept c = ( ( NAR ) this ) . memory . concept ( t ) ; if ( c ! = null ) { return c . getPriority ( ) ; } } return 0.0 ; } }
public void stateChanged ( MPDStatus mpdStatus , String oldState ) { } @Override public void repeatChanged ( boolean repeating ) { } @Override public void randomChanged ( boolean random ) { } @Override public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } private TouchInterceptor . DropListener dropListener = new TouchInterceptor . DropListener ( ) { public void drop ( int from , int to ) { if ( from = = to ) { return ; } HashMap < String , Object > itemFrom = songlist . get ( from ) ; Integer songID = ( Integer ) itemFrom . get ( " songid " ) ; try { app . oMPDAsyncHelper . oMPD . getPlaylist ( ) . move ( songID , to ) ; } catch ( MPDServerException e ) { } } } ; }
private ProcessingItem createPi ( Processor processor , int parallelism ) { ProcessingItem pi = this . componentFactory . createPi ( processor , parallelism ) ; this . topology . addProcessingItem ( pi , parallelism ) ; return pi ; }
public static int [ ] breadthFirstTraversal ( int n , byte [ ] [ ] adjacencyMatrix , int source ) { final int [ ] visited = new int [ n ] ; for ( int i = 0 ; i < visited . length ; i + + ) visited [ i ] = - 1 ; int element = source ; int i = source ; int arr [ ] = new int [ n ] ; int k = 0 ; arr [ k ] = element ; visited [ i ] = 1 ; k + + ; final Queue < Integer > queue = new ArrayDeque < Integer > ( ) ; queue . add ( source ) ; while ( ! queue . isEmpty ( ) ) { element = queue . peek ( ) ; i = 0 ; while ( i < n ) { if ( adjacencyMatrix [ element ] [ i ] = = 1 & & visited [ i ] = = - 1 ) { queue . add ( i ) ; visited [ i ] = 1 ; arr [ k ] = i ; k + + ; } i + + ; } queue . poll ( ) ; } return arr ; }
public void run ( ) { s . cells . click ( " NOT " , " " , " " ) ; }
static List < ? > parse ( CharacterInput input , TomlParser parser ) { List < Object > list = new ArrayList < > ( parser . getInitialListCapacity ( ) ) ; while ( true ) { char firstChar = Toml . readUsefulChar ( input ) ;
public void retryOperation ( Operation op ) { retryOps . add ( op ) ; }
private CountDownLatch broadcastOp ( BroadcastOpFactory of , Collection < MemcachedNode > nodes , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of , nodes ) ; }
private static void convertConfig ( UnmodifiableConfig input , ConcurrentCommentedConfig into ) { if ( input instanceof UnmodifiableCommentedConfig ) { into . bulkCommentedUpdate ( view - > {
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " level= " ) . append ( level ) . append ( "  key= " ) . append ( toBinaryString ( key ) ) . append ( " \ n " ) ; for ( int i = 0 ; i < children . length ; i + + ) { Node < K > c = children [ i ] ; if ( c ! = null ) builder . append ( c . toString ( ) ) . append ( " ,  " ) ; } return builder . toString ( ) ; }
public boolean equals ( Object that ) { if ( that instanceof Interval ) { return magnitude = = ( ( Interval ) that ) . magnitude ; } return false ; }
public void playlistChanged ( MPDStatus mpdStatus , int oldPlaylistVersion ) { } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { } @Override public void repeatChanged ( boolean repeating ) { } @Override public void randomChanged ( boolean random ) { } @Override public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } }
public void testManualMeters ( ) { DefaultManualTracker dmt = new DefaultManualTracker ( " incidence1 " ) ; for ( int i = 0 ; i < 5 ; i + + ) { dmt . setValue ( Math . random ( ) ) ; dmt . commit ( ) ; } assertTrue ( true ) ; }
public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { Operation op = opFact . saslAuth ( mechs , n . toString ( ) , null , cbh , new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { statuses . add ( status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; return op ; } } ) ;
public void previous ( ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; mpdConnection . sendCommand ( MPD_CMD_PREV ) ; }
public static long pow ( long a , long b , long mod ) { if ( mod < = 0 ) throw new IllegalArgumentException ( " Mod argument is not grater then 0 " ) ; if ( b < 0 ) throw new IllegalArgumentException ( " Exponent have to be grater or equal to zero " ) ; a = modularAbs ( a , mod ) ; if ( a = = 0 & & b = = 0 ) throw new IllegalArgumentException ( " 0^0 expression " ) ; if ( a = = 0 ) return 0 ; long res = 1 ; while ( b > 0 ) { if ( b % 2 = = 1 ) res = multiply ( res , a , mod ) ; a = multiply ( a , a , mod ) ; b / = 2 ; } return res ; }
@Override protected E addItem ( E newItem ) { float newPriority = newItem . getPriority ( ) ; E oldItem = null ; if ( size ( ) > = capacity ) { if ( newPriority < getMinPriority ( ) ) return newItem ; oldItem = removeItem ( 0 ) ; } items . add ( newItem ) ; nameTable . put ( newItem . name ( ) , newItem ) ; mass + = ( newItem . budget . getPriority ( ) ) ; size ( ) ; return oldItem ; }
public void testExceptionArg ( ) throws Exception { Object [ ] args = new Object [ ] { " a " , 42 , new Exception ( " test " ) } ; Throwable t = ( ( AbstractLogger ) logger ) . getThrowable ( args ) ; assertNotNull ( t ) ; assertEquals ( " test " , t . getMessage ( ) ) ; }
private void testInvalidTableDeclaration6 ( ) { String toml = " [a.b..''] \ n " ; parseAndPrint ( toml ) ; }
public void testReadChunkLenEmpty ( ) throws Exception { final NonBlockingByteArrayInputStream noNewLine = new NonBlockingByteArrayInputStream ( " \ n " . getBytes ( StandardCharsets . UTF_8 ) ) ; final int res = HTTPHelper . readChunkLen ( noNewLine ) ; assertEquals ( " Chunk size with header " , 0 , res ) ; }
public void resolveMixedArrayAndGenericTypes ( ) throws Exception { Class < ? > cls = Mixed . class ; checkField ( cls . getDeclaredField ( " nested " ) , " java.util.List<X[]> " , Optional . of ( List . class ) ) ; checkField ( cls . getDeclaredField ( " nestedExtend " ) , " java.util.List<? extends X[]> " , Optional . of ( List . class ) ) ; checkField ( cls . getDeclaredField ( " nestedSuper " ) , " java.util.List<? super X[]> " , Optional . of ( List . class ) ) ; var custom = cls . getDeclaredField ( " custom " ) ; checkField ( custom , " com.electronwill.nightconfig.core.serde.TypeConstraintArrayTest$MyListOfString<X> " , Optional . of ( MyListOfString . class ) ) ; var vt = TypeConstraintCollectionTest . extractCollectionValueType ( new TypeConstraint ( custom . getGenericType ( ) ) ) ; assertEquals ( String [ ] . class , vt . getFullType ( ) ) ; assertEquals ( Optional . of ( String [ ] . class ) , vt . getSatisfyingRawType ( ) ) ; }
private String whyNonTraversible ( GridAgent agent , int x , int y , int tx , int ty ) { int dx = Math . abs ( tx - x ) ; int dy = Math . abs ( ty - y ) ; if ( ! ( ( dx < = 1 ) & & ( dy < = 1 ) ) ) return " Too far " ; Cell from = cells . at ( x , y ) ; Cell to = cells . at ( tx , ty ) ; if ( ( to . material = = Material . StoneWall ) | | to . is_solid ) return " Too solid " ; final float maxTraversableHeight = 8 ; float dHeight = to . height - from . height ; if ( dHeight > maxTraversableHeight ) return " Too high " ; return null ; }
private static void initDefaultParsers ( ) { defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { try { int cycles = Integer . parseInt ( input ) ; nar . step ( cycles ) ; return true ; } catch ( NumberFormatException e ) { return false ; } } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { if ( input . equals ( Symbols . RESET_COMMAND ) ) { nar . reset ( ) ; return true ; } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { if ( ! nar . isWorking ( ) ) { if ( input . equals ( Symbols . STOP_COMMAND ) ) { nar . output ( Output . OUT . class , " stopping. " ) ; nar . setWorking ( false ) ; return true ; } } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { if ( nar . isWorking ( ) ) { if ( input . equals ( Symbols . START_COMMAND ) ) { nar . setWorking ( true ) ; nar . output ( Output . OUT . class , " starting. " ) ; return true ; } } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { if ( input . indexOf ( Symbols . SILENCE_COMMAND ) = = 0 ) { String [ ] p = input . split ( " = " ) ; if ( p . length = = 2 ) { int silenceLevel = Integer . parseInt ( p [ 1 ] ) ; nar . param . setSilenceLevel ( silenceLevel ) ; nar . output ( Output . OUT . class , " Silence level:  " + silenceLevel ) ; } return true ; } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { char c = input . charAt ( 0 ) ; if ( c = = Symbols . URL_INCLUDE_MARK ) { try { new TextInput ( nar , new URL ( input . substring ( 1 ) ) ) ; } catch ( IOException ex ) { nar . output ( ERR . class , ex ) ; } return true ; } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { char c = input . charAt ( 0 ) ; if ( c = = Symbols . ECHO_MARK ) { String echoString = input . substring ( 1 ) ; nar . output ( Output . ECHO . class , '\"' + echoString + '\"' ) ; return true ; } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override
abstract public int getCapacity ( ) ; abstract public float getMass ( ) ; abstract public boolean putIn ( final E newItem , boolean insertIntoNameTable ) ; public boolean putIn ( final E newItem ) { return putIn ( newItem , true ) ; } abstract public int size ( ) ; abstract public E takeOut ( boolean removeFromNameTable ) ; abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } protected int forgetRate ( ) { if ( forgettingRate ! = null ) { return forgettingRate . get ( ) ; } return - 1 ; } protected void forget ( final E x ) { int r = forgetRate ( ) ; if ( r > 0 ) { BudgetFunctions . forget ( x . budget , r , RELATIVE_THRESHOLD ) ; } } public final boolean putBack ( final E oldItem , final boolean insertIntoNameTable ) { forget ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public final boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( boolean forget ) { final E x = takeOut ( false ) ; if ( x ! = null ) { if ( forget ) forget ( x ) ; boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else return null ; } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( CharSequence key ) ; }
public void add ( T o ) { synchronized ( LOCK ) { this . checkConcurrentModification ( ) ;
protected abstract String getFilename ( IMessage aMsg , String sFileParam , String sAction ) throws InvalidParameterException ; protected void store ( @Nonnull final File aMsgFile , @Nonnull @WillClose final InputStream aIS ) throws IOException { final String sTempDirname = getAttributeAsString ( ATTR_TEMPDIR ) ; if ( sTempDirname ! = null ) { final File aTempDir = IOUtil . getDirectoryFile ( sTempDirname ) ; final File aTempFile = IOUtil . getUniqueFile ( aTempDir , aMsgFile . getName ( ) ) ; _writeStream ( aIS , aTempFile ) ; if ( IOUtil . getFileOperationManager ( ) . renameFile ( aTempFile , aMsgFile ) . isFailure ( ) ) throw new IOException ( " Rename from  " + aTempFile . getAbsolutePath ( ) + "  to  " + aMsgFile . getAbsolutePath ( ) + "  failed! " ) ; } else { _writeStream ( aIS , aMsgFile ) ; } } private void _writeStream ( @Nonnull @WillClose final InputStream aIS , @Nonnull final File aDestination ) throws IOException { final FileOutputStream aOS = new FileOutputStream ( aDestination ) ; if ( StreamHelper . copyInputStreamToOutputStreamAndCloseOS ( aIS , aOS ) . isFailure ( ) ) throw new IOException ( " Failed to write content to  " + aDestination . getAbsolutePath ( ) ) ; } }
public boolean add ( final Sentence s , final CompoundTerm ct , final Item c ) { if ( ! ( ct instanceof Implication ) ) { return false ; } final Implication st = ( Implication ) ct ; if ( ( st . getTemporalOrder ( ) = = TemporalRules . ORDER_NONE ) | | ( st . operator ( ) = = NativeOperator . IMPLICATION_BEFORE ) | | ( ! s . isEternal ( ) ) ) return false ; final Term subject , predicate ; boolean reverse = false ; if ( reverse ) { return false ; } else { subject = st . getSubject ( ) ; predicate = st . getPredicate ( ) ; } if ( s . content . hasVarIndep ( ) ) { return false ; } final Term predicatePre = predicate ; final Term predicatePost = postcondition ( predicatePre ) ; addVertex ( predicatePre ) ; addVertex ( predicatePost ) ; if ( subject instanceof Conjunction ) { Conjunction seq = ( Conjunction ) subject ; if ( seq . operator ( ) = = Symbols . NativeOperator . SEQUENCE ) { Term prev = ( predicatePre ! = predicatePost ) ? predicatePre : null ; if ( prev ! = null ) addVertex ( prev ) ; for ( int i = 0 ; i < seq . term . length ; i + + ) { Term a = seq . term [ i ] ; meter ( a ) ; if ( Executive . isPlanTerm ( a ) ) { if ( ( ( i > 0 ) & & ( i < seq . term . length - 1 ) ) | | ( a instanceof Interval ) ) a = newExecutableVertex ( st , a , prev ) ; else { addVertex ( a ) ; } if ( prev ! = null ) { newImplicationEdge ( prev , a , c , s ) ; } prev = a ; } else { Term aPre = a ; Term aPost = postcondition ( a ) ; addVertex ( aPre ) ; addVertex ( aPost ) ; if ( prev ! = null ) { addVertex ( prev ) ; newImplicationEdge ( prev , aPre , c , s ) ; } prev = aPost ; } } newImplicationEdge ( prev , predicatePost , c , s ) ; return true ; } else if ( seq . operator ( ) = = Symbols . NativeOperator . PARALLEL ) { } } else { if ( Executive . isPlanTerm ( subject ) ) { addVertex ( subject ) ; newImplicationEdge ( subject , predicatePost , c , s ) ; } else { PostCondition subjectPost = new PostCondition ( subject ) ; addVertex ( predicatePre ) ; addVertex ( subject ) ; addVertex ( subjectPost ) ; newImplicationEdge ( predicatePre , subject , c , s ) ; newImplicationEdge ( subjectPost , predicatePost , c , s ) ; } meter ( subject ) ; } return true ; }
private static boolean testJavaArrayQueue ( ) { String aName = " Java's Queue [array] " ; java . util . Deque < Integer > aCollection = new java . util . ArrayDeque < Integer > ( ) ; if ( ! testJavaCollection ( aCollection , Type . Integer , aName ) ) return false ; return true ; }
public void setSingle ( boolean single ) throws MPDServerException { mConnection . sendCommand ( MPDCommand . MPD_CMD_SINGLE , single ? " 1 " : " 0 " ) ; }
private List < String > searchForRelease ( final AlbumInfo albumInfo ) { final String response ; final String url = " http://musicbrainz.org/ws/2/release-group/?query= " + albumInfo . getArtist ( ) + "   " + albumInfo . getAlbum ( ) + " &type=release-group&limit=5 " ; response = executeGetRequestWithConnection ( url ) ; return extractReleaseIds ( response ) ; }
private ArrayList merge ( KIF kif , String pathname ) { ArrayList formulasPresent = new ArrayList ( ) ; try { terms . addAll ( kif . terms ) ; Set keys = kif . formulas . keySet ( ) ; Iterator it = keys . iterator ( ) ; while ( it . hasNext ( ) ) { String key = ( String ) it . next ( ) ; ArrayList newFormulas = new ArrayList ( ( Collection ) kif . formulas . get ( key ) ) ; if ( formulas . containsKey ( key ) ) { ArrayList oldFormulas = ( ArrayList ) formulas . get ( key ) ; for ( int i = 0 ; i < newFormulas . size ( ) ; i + + ) { Formula newFormula = ( Formula ) newFormulas . get ( i ) ; if ( pathname ! = null ) { newFormula . sourceFile = pathname ; } boolean found = false ; for ( int j = 0 ; j < oldFormulas . size ( ) ; j + + ) { Formula oldFormula = ( Formula ) oldFormulas . get ( j ) ; if ( newFormula . theFormula . equals ( oldFormula . theFormula ) ) { found = true ; formulasPresent . add ( oldFormula ) ; } } if ( ! found ) { oldFormulas . add ( newFormula ) ; formulaMap . put ( newFormula . theFormula . intern ( ) , newFormula ) ; } } } else { formulas . put ( key , newFormulas ) ; Iterator it2 = newFormulas . iterator ( ) ; Formula f = null ; while ( it2 . hasNext ( ) ) { f = ( Formula ) it2 . next ( ) ; if ( Formula . isNonEmptyString ( f . theFormula ) ) { formulaMap . put ( f . theFormula . intern ( ) , f ) ; } } } } } catch ( Exception ex ) { System . out . println ( ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; } return formulasPresent ; }
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { } } ; BlockingQueue < Operation > oQueue = new LinkedBlockingQueue < Operation > ( ) ; BlockingQueue < Operation > rQueue = new LinkedBlockingQueue < Operation > ( ) ; BlockingQueue < Operation > wQueue = new LinkedBlockingQueue < Operation > ( ) ; ConnectionFactory f = b . setDaemon ( false ) . setShouldOptimize ( false ) . setFailureMode ( FailureMode . Redistribute ) . setHashAlg ( HashAlgorithm . KETAMA_HASH ) . setInitialObservers ( Collections . singleton ( testObserver ) ) . setOpFact ( new BinaryOperationFactory ( ) ) . setOpTimeout ( 4225 ) . setOpQueue ( oQueue ) . setReadOpQueue ( rQueue ) . setWriteOpQueue ( wQueue ) . setReadBufferSize ( 19 ) . setTranscoder ( new WhalinTranscoder ( ) ) . build ( ) ; assertEquals ( 4225 , f . getOperationTimeout ( ) ) ; assertEquals ( 19 , f . getReadBufSize ( ) ) ; assertSame ( HashAlgorithm . KETAMA_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof WhalinTranscoder ) ; assertSame ( FailureMode . Redistribute , f . getFailureMode ( ) ) ; assertEquals ( 1 , f . getInitialObservers ( ) . size ( ) ) ; assertSame ( testObserver , f . getInitialObservers ( ) . iterator ( ) . next ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof BinaryOperationFactory ) ; assertSame ( oQueue , f . createOperationQueue ( ) ) ; assertSame ( rQueue , f . createReadOperationQueue ( ) ) ; assertSame ( wQueue , f . createWriteOperationQueue ( ) ) ; assertFalse ( f . isDaemon ( ) ) ; assertFalse ( f . shouldOptimize ( ) ) ; } }
public void enqueueStringMessage ( String queue , String key , String message ) { } @Override public Schema getSchema ( ) throws Exception { return Translator . translatorFor ( props ) . getSchema ( ) ; } @Override public RecordModel getRecordModel ( ) throws Exception { return Translator . translatorFor ( props ) . getRecordModel ( ) ; } }
static void transformProductImage ( Inheritance inh , CompoundTerm oldContent , short [ ] indices , NAL nal ) { final Memory memory = nal . mem ( ) ; Term subject = inh . getSubject ( ) ; Term predicate = inh . getPredicate ( ) ; if ( inh . equals ( oldContent ) ) { if ( subject instanceof CompoundTerm ) { transformSubjectPI ( ( CompoundTerm ) subject , predicate , nal ) ; } if ( predicate instanceof CompoundTerm ) { transformPredicatePI ( subject , ( CompoundTerm ) predicate , nal ) ; } return ; } short index = indices [ indices . length - 1 ] ; short side = indices [ indices . length - 2 ] ; Term compT = inh . term [ side ] ; if ( ! ( compT instanceof CompoundTerm ) ) return ; CompoundTerm comp = ( CompoundTerm ) compT ; if ( comp instanceof Product ) { if ( side = = 0 ) { subject = comp . term [ index ] ; predicate = ImageExt . make ( ( Product ) comp , inh . getPredicate ( ) , index ) ; } else { subject = ImageInt . make ( ( Product ) comp , inh . getSubject ( ) , index ) ; predicate = comp . term [ index ] ; } } else if ( ( comp instanceof ImageExt ) & & ( side = = 1 ) ) { if ( index = = ( ( ImageExt ) comp ) . relationIndex ) { subject = Product . make ( comp , inh . getSubject ( ) , index ) ; predicate = comp . term [ index ] ; } else { subject = comp . term [ index ] ; predicate = ImageExt . make ( ( ImageExt ) comp , inh . getSubject ( ) , index ) ; } } else if ( ( comp instanceof ImageInt ) & & ( side = = 0 ) ) { if ( index = = ( ( ImageInt ) comp ) . relationIndex ) { subject = comp . term [ index ] ; predicate = Product . make ( comp , inh . getPredicate ( ) , index ) ; } else { subject = ImageInt . make ( ( ImageInt ) comp , inh . getPredicate ( ) , index ) ; predicate = comp . term [ index ] ; } } else { return ; } Inheritance newInh = Inheritance . make ( subject , predicate ) ; if ( newInh = = null ) return ; CompoundTerm content = null ; if ( indices . length = = 2 ) { content = newInh ; } else if ( ( oldContent instanceof Statement ) & & ( indices [ 0 ] = = 1 ) ) { content = Statement . make ( ( Statement ) oldContent , oldContent . term [ 0 ] , newInh , oldContent . getTemporalOrder ( ) ) ; } else { Term [ ] componentList ; Term condition = oldContent . term [ 0 ] ; if ( ( ( oldContent instanceof Implication ) | | ( oldContent instanceof Equivalence ) ) & & ( condition instanceof Conjunction ) ) { componentList = ( ( CompoundTerm ) condition ) . cloneTerms ( ) ; componentList [ indices [ 1 ] ] = newInh ; Term newCond = memory . term ( ( CompoundTerm ) condition , componentList ) ; content = Statement . make ( ( Statement ) oldContent , newCond , ( ( Statement ) oldContent ) . getPredicate ( ) , oldContent . getTemporalOrder ( ) ) ; } else { componentList = oldContent . cloneTerms ( ) ; componentList [ indices [ 0 ] ] = newInh ; if ( oldContent instanceof Conjunction ) { Term newContent = memory . term ( oldContent , componentList ) ; if ( ! ( newContent instanceof CompoundTerm ) ) return ; content = ( CompoundTerm ) newContent ; } else if ( ( oldContent instanceof Implication ) | | ( oldContent instanceof Equivalence ) ) { content = Statement . make ( ( Statement ) oldContent , componentList [ 0 ] , componentList [ 1 ] , oldContent . getTemporalOrder ( ) ) ; } } } if ( content = = null ) return ; Sentence sentence = nal . getCurrentTask ( ) . sentence ; TruthValue truth = sentence . truth ; BudgetValue budget ; if ( sentence . isQuestion ( ) | | sentence . isQuest ( ) ) { budget = BudgetFunctions . compoundBackward ( content , nal ) ; } else { budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; } nal . singlePremiseTask ( content , truth , budget ) ; }
public boolean remove ( T value ) { for ( int i = firstIndex ; i < lastIndex ; i + + ) { T obj = array [ i % array . length ] ; if ( obj . equals ( value ) ) return remove ( i ) ; } return false ; }
public void testMultipleArrivingNoneExisting ( ) { p = new EventTimeHistoryPlanner ( ) ; assertNoValidationFailures ( p , config ) ; p . configure ( config ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " hello " , 100L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 200L ) ) ; key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 2 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . INSERT ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; assertEquals ( planned . get ( 0 ) . getAs ( " startdate " ) , 100L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " enddate " ) , 199L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( planned . get ( 1 ) . getAs ( " startdate " ) , 200L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " enddate " ) , 253402214400000L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES ) ; }
private void print_header ( ) { Enumeration states ; int i ; int j ; int chars_printed = 0 ; CDTrans dtrans ; int last_transition ; String str ; CAccept accept ; String state ; Integer index ; System . out . println ( " /*---------------------- DFA ----------------------- " ) ; states = m_spec . m_states . keys ( ) ; while ( states . hasMoreElements ( ) ) { state = ( String ) states . nextElement ( ) ; index = ( Integer ) m_spec . m_states . get ( state ) ; if ( CUtility . DEBUG ) { CUtility . ASSERT ( null ! = state ) ; CUtility . ASSERT ( null ! = index ) ; } System . out . println ( " State  \" " + state + " \"  has identifying index  " + index . toString ( ) + " . " ) ; i = index . intValue ( ) ; if ( CDTrans . F ! = m_spec . m_state_dtrans [ i ] ) { System . out . println ( " \ tStart index in transition table:  " + m_spec . m_state_dtrans [ i ] ) ; } else { System . out . println ( " \ tNo associated transition states. " ) ; } } for ( i = 0 ; i < m_spec . m_dtrans_vector . size ( ) ; + + i ) { dtrans = ( CDTrans ) m_spec . m_dtrans_vector . elementAt ( i ) ; if ( null = = m_spec . m_accept_vector & & null = = m_spec . m_anchor_array ) { if ( null = = dtrans . m_accept ) { System . out . print ( "  * State  " + i + "  [nonaccepting] " ) ; } else { System . out . print ( "  * State  " + i + "  [accepting, line  " + dtrans . m_accept . m_line_number + "  < " + ( new String ( dtrans . m_accept . m_action , 0 , dtrans . m_accept . m_action_read ) ) + " >] " ) ; if ( CSpec . NONE ! = dtrans . m_anchor ) { System . out . print ( "  Anchor:  " + ( ( 0 ! = ( dtrans . m_anchor & CSpec . START ) ) ? " start  " : " " ) + ( ( 0 ! = ( dtrans . m_anchor & CSpec . END ) ) ? " end  " : " " ) ) ; } } } else { accept = ( CAccept ) m_spec . m_accept_vector . elementAt ( i ) ; if ( null = = accept ) { System . out . print ( "  * State  " + i + "  [nonaccepting] " ) ; } else { System . out . print ( "  * State  " + i + "  [accepting, line  " + accept . m_line_number + "  < " + ( new String ( accept . m_action , 0 , accept . m_action_read ) ) + " >] " ) ; if ( CSpec . NONE ! = m_spec . m_anchor_array [ i ] ) { System . out . print ( "  Anchor:  " + ( ( 0 ! = ( m_spec . m_anchor_array [ i ] & CSpec . START ) ) ? " start  " : " " ) + ( ( 0 ! = ( m_spec . m_anchor_array [ i ] & CSpec . END ) ) ? " end  " : " " ) ) ; } } } last_transition = - 1 ; for ( j = 0 ; j < m_spec . m_dtrans_ncols ; + + j ) { if ( CDTrans . F ! = dtrans . m_dtrans [ j ] ) { if ( last_transition ! = dtrans . m_dtrans [ j ] ) { System . out . println ( ) ; System . out . print ( "  *    goto  " + dtrans . m_dtrans [ j ] + "  on  " ) ; chars_printed = 0 ; } str = interp_int ( ( int ) j ) ; System . out . print ( str ) ; chars_printed = chars_printed + str . length ( ) ; if ( 56 < chars_printed ) { System . out . println ( ) ; System . out . print ( "  *              " ) ; chars_printed = 0 ; } last_transition = dtrans . m_dtrans [ j ] ; } } System . out . println ( ) ; } System . out . println ( "  */ " ) ; System . out . println ( ) ; }
public AttributeTable getAttributes ( final Map parameters ) { final AttributeTable ret = aAttrGen . getAttributes ( parameters ) ; return ret . remove ( CMSAttributes . cmsAlgorithmProtect ) ; }
public boolean offer ( T value ) { int currentSize = lastIndex - firstIndex ; if ( currentSize > = array . length ) { int growSize = ( currentSize + ( currentSize > > 1 ) ) ; T [ ] temp = ( T [ ] ) new Object [ growSize ] ; int adjLast = lastIndex % array . length ; if ( adjLast < = firstIndex ) { System . arraycopy ( array , 0 , temp , array . length - adjLast , adjLast + 1 ) ; } System . arraycopy ( array , firstIndex , temp , 0 , array . length - firstIndex ) ; array = temp ; lastIndex = ( lastIndex - firstIndex ) ; firstIndex = 0 ; } array [ lastIndex % array . length ] = value ; lastIndex + + ; return true ; }
public void onListItemClick ( ListView l , View v , int position , long id ) { Intent intent = new Intent ( getActivity ( ) , SongsActivity . class ) ; intent . putExtra ( " album " , items . get ( position ) . getName ( ) ) ; intent . putExtra ( " artist " , getActivity ( ) . getIntent ( ) . getStringExtra ( " artist " ) ) ; startActivityForResult ( intent , - 1 ) ; }
void clear ( ) ; default UnmodifiableConfig unmodifiable ( ) { return new UnmodifiableConfig ( ) { @Override public < T > T get ( List < String > path ) { return Config . this . get ( path ) ; } @Override public boolean contains ( List < String > path ) { return Config . this . contains ( path ) ; } @Override public int size ( ) { return Config . this . size ( ) ; } @Override public Map < String , Object > valueMap ( ) { return Collections . unmodifiableMap ( Config . this . valueMap ( ) ) ; } @Override public Set < ? extends Entry > entrySet ( ) { return Config . this . entrySet ( ) ; } @Override public ConfigFormat < ? , ? , ? > configFormat ( ) { return Config . this . configFormat ( ) ; } } ; } default Config checked ( ) { return new CheckedConfig ( this ) ; } Map < String , Object > valueMap ( ) ; @Override Set < ? extends Entry > entrySet ( ) ; interface Entry extends UnmodifiableConfig . Entry { < T > T setValue ( Object value ) ; } Config createSubConfig ( ) ; default void update ( String path , Object value ) { set ( path , value ) ; } default void update ( List < String > path , Object value ) { set ( path , value ) ; } static Config of ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format , false ) ; } static Config ofConcurrent ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format , true ) ; } static Config inMemory ( ) { return InMemoryFormat . defaultInstance ( ) . createConfig ( ) ; } static Config inMemoryConcurrent ( ) { return InMemoryFormat . defaultInstance ( ) . createConcurrentConfig ( ) ; } static Config wrap ( Map < String , Object > map , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( map , format ) ; } static Config copy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) , false ) ; } static Config copy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( config , format , false ) ; } static Config concurrentCopy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) , true ) ; } static Config concurrentCopy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( config , format , true ) ; } }
public void save ( String filename ) throws FileNotFoundException , IOException { ObjectOutputStream out = new ObjectOutputStream ( new FileOutputStream ( filename ) ) ; out . writeObject ( w ) ; out . close ( ) ; }
public int compareTo ( Object obj ) { MutableDouble other = ( MutableDouble ) obj ; return Double . compare ( value , other . value ) ;
public Set < ImageSize > availableSizes ( ) { return imageUrls . keySet ( ) ; }
public ProcessingItem createPi ( Processor processor , int parallelism ) { return new SamzaProcessingItem ( processor , parallelism ) ; }
public boolean addAll ( int index , Collection < ? extends E > c ) { boolean b = super . addAll ( index , c ) ; if ( autoupdateData ) { updateData ( ) ; } return b ; }
public void add ( IProcessingItem destinationPi , int type , int parallelism ) { this . listProcessingItem . add ( destinationPi ) ; this . listTypeStream . add ( type ) ; this . listParallelism . add ( parallelism ) ; }
public NAR build ( ) { Param p = newParam ( ) ; Operator [ ] operators = DefaultOperators . get ( ) ; Memory m = new Memory ( p , newAttention ( p , getConceptBuilder ( ) ) , newNovelTaskBag ( p ) , operators ) ; for ( Operator o : ExampleOperators . get ( ) ) { m . addOperator ( o ) ; } return new NAR ( m , new Perception ( ) ) ; }
public void testMultipleFieldEntityKeyPivot ( ) throws Exception { List < Row > sourceList = Lists . newArrayList ( RowFactory . create ( " A " , " AA " , " AAA " , " hello " , " 1 " ) , RowFactory . create ( " A " , " AA " , " AAA " , " world " , " 2 " ) , RowFactory . create ( " B " , " BB " , " BBB " , " hello " , " 3 " ) , RowFactory . create ( " C " , " CC " , " CCC " , " world " , " 4 " ) ) ; StructType schema = SchemaUtils . structTypeFor ( Lists . newArrayList ( " entity_id1 " , " entity_id2 " , " entity_id3 " , " key " , " value " ) , Lists . newArrayList ( " string " , " string " , " string " , " string " , " string " ) ) ; Dataset < Row > source = Contexts . getSparkSession ( ) . createDataFrame ( sourceList , schema ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " source " , source ) ; Config config = ConfigFactory . empty ( ) . withValue ( PivotDeriver . STEP_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " source " ) ) . withValue ( PivotDeriver . ENTITY_KEY_FIELD_NAMES_CONFIG , ConfigValueFactory . fromAnyRef ( Lists . newArrayList ( " entity_id1 " , " entity_id2 " , " entity_id3 " ) ) ) . withValue ( PivotDeriver . PIVOT_KEY_FIELD_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " key " ) ) . withValue ( PivotDeriver . PIVOT_VALUE_FIELD_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " value " ) ) ; PivotDeriver d = new PivotDeriver ( ) ; assertNoValidationFailures ( d , config ) ; d . configure ( config ) ; List < Row > results = d . derive ( dependencies ) . collectAsList ( ) ; assertEquals ( results . size ( ) , 3 ) ; assertTrue ( results . contains ( RowFactory . create ( " A " , " AA " , " AAA " , " 1 " , " 2 " ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " B " , " BB " , " BBB " , " 3 " , null ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " C " , " CC " , " CCC " , null , " 4 " ) ) ) ; }
public void paint ( Graphics g ) { if ( initdone ) draw ( DRAWALL ) ;
public Object react ( String input ) { if ( input . contains ( BINDING_SYMBOL ) ) { String [ ] p = input . split ( BINDING_SYMBOL ) ; if ( p . length ! = 2 ) { throw new RuntimeException ( " Invalid syntax for expression binding " ) ; } String newOp = Operator . addPrefixIfMissing ( p [ 0 ] . trim ( ) ) ; Operator existing = memory . getOperator ( newOp ) ; if ( existing ! = null ) { throw new RuntimeException ( " Unable to bind new expression to existing Operator:  " + existing ) ; } String proc = p [ 1 ] . trim ( ) ; if ( ! proc . startsWith ( " js{ " ) ) { throw new RuntimeException ( " Unrecognized expression format:  " + proc ) ; } if ( ! proc . endsWith ( " } " ) ) { throw new RuntimeException ( " Expression must end with '}' " ) ; } proc = proc . substring ( 3 , proc . length ( ) - 1 ) . trim ( ) ; if ( js = = null ) { ScriptEngineManager factory = new ScriptEngineManager ( ) ; js = factory . getEngineByName ( " JavaScript " ) ; } final String o = newOp . substring ( 1 ) ; try { String jsFunc = " function  " + o + " ($1, $2, $3, $4, $5, $6) {  " + proc + " ; } " ; js . eval ( jsFunc ) ; memory . addOperator ( new Operator ( newOp ) { @Override protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { StringBuilder argsToParameters = new StringBuilder ( ) ; for ( int i = 0 ; i < args . length ; i + + ) { argsToParameters . append ( " ' " ) . append ( args [ i ] . toString ( ) ) . append ( " ' " ) ; if ( args . length - 1 ! = i ) argsToParameters . append ( " , " ) ; } Object result = null ; try { result = js . eval ( o + " ( " + argsToParameters + " ) " ) ; } catch ( ScriptException ex ) { throw new RuntimeException ( " Exception in executing  " + operation + " :  " + ex . toString ( ) , ex ) ; } return null ; } } ) ; memory . emit ( EXE . class , " Bound:  " + jsFunc ) ; } catch ( ScriptException ex ) { throw new RuntimeException ( ex . toString ( ) , ex ) ; } return true ; } return null ; }
public abstract int size ( ) ; public static < T > List < T > createList ( ListType type ) { switch ( type ) { case ArrayList : return new ArrayList < T > ( ) ; default : return new LinkedList < T > ( ) ; } } public static class ArrayList < T > extends List < T > { private static final int GROW_IN_CHUNK_SIZE = 1000 ; private static final int SHRINK_IN_CHUNK_SIZE = 1000 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int size = 0 ; @Override public void add ( T value ) { if ( size > = array . length ) { array = Arrays . copyOf ( array , size + GROW_IN_CHUNK_SIZE ) ; } array [ size + + ] = value ; } @Override public boolean remove ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) { System . arraycopy ( array , i + 1 , array , i , array . length - i - 1 ) ; array [ - - size ] = null ; if ( array . length - size > = SHRINK_IN_CHUNK_SIZE ) { array = Arrays . copyOf ( array , size ) ; } return true ; } } return false ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public T get ( int index ) { if ( index > = size ) return null ; return array [ index ] ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i + + ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } public static class LinkedList < T > extends List < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; @Override public void add ( T value ) { add ( new Node < T > ( value ) ) ; } private void add ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > prev = tail ; prev . nextNode = node ; node . previousNode = prev ; tail = node ; } size + + ; } @Override public boolean remove ( T value ) { Node < T > node = head ; while ( node ! = null & & ( ! node . value . equals ( value ) ) ) { node = node . nextNode ; } if ( node = = null ) return false ; if ( node . equals ( tail ) ) tail = node . previousNode ; Node < T > prev = node . previousNode ; Node < T > next = node . nextNode ; if ( prev ! = null & & next ! = null ) { prev . nextNode = next ; next . previousNode = prev ; } else if ( prev ! = null & & next = = null ) { prev . nextNode = null ; } else if ( prev = = null & & next ! = null ) { next . previousNode = null ; head = next ; } else { head = null ; } size - - ; return true ; } @Override public boolean contains ( T value ) { Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . nextNode ; } return false ; } @Override public T get ( int index ) { T result = null ; Node < T > node = head ; int i = 0 ; while ( node ! = null & & i < index ) { node = node . nextNode ; i + + ; } if ( node ! = null ) result = node . value ; return result ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . nextNode ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > previousNode = null ; private Node < T > nextNode = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( previousNode ! = null ) ? previousNode . value : " NULL " ) + "  next= " + ( ( nextNode ! = null ) ? nextNode . value : " NULL " ) ; } } } }
public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { for ( PlaylistMusic song : songlist ) { if ( ( song . getSongId ( ) ) = = mpdStatus . getSongId ( ) ) song . setPlay ( android . R . drawable . ic_media_play ) ; else song . setPlay ( 0 ) ; } final ArrayAdapter adapter = ( ArrayAdapter ) getListAdapter ( ) ; if ( adapter ! = null ) adapter . notifyDataSetChanged ( ) ;
public void testBag ( final boolean arraylist , final int levels , final int capacity , final int forgetRate ) { totalPriority = 0 ; totalMass = 0 ; totalMaxItemsPerLevel = totalMinItemsPerLevel = 0 ; Performance p = new Performance ( ( arraylist ? " DequeArray " : " LinkedList " ) + " , " + levels + " , " + capacity , repeats , warmups ) { @Override public void init ( ) { } @Override public void run ( boolean warmup ) { DefaultBag < NullItem > b = new DefaultBag < NullItem > ( levels , capacity , forgetRate ) { @Override protected Deque < NullItem > newLevel ( ) { if ( arraylist ) return super . newLevel ( ) ; return new LinkedList < > ( ) ; } } ; randomBagIO ( b , randomAccesses , insertRatio ) ; if ( ! warmup ) { totalPriority + = b . getAveragePriority ( ) ; totalMass + = b . getMass ( ) ; totalMinItemsPerLevel + = b . getMinItemsPerLevel ( ) ; totalMaxItemsPerLevel + = b . getMaxItemsPerLevel ( ) ; } } } . printCSV ( true ) ; System . out . print ( ( totalMaxItemsPerLevel / p . repeats ) + " , " ) ; System . out . print ( totalPriority / p . repeats + " , " ) ; System . out . print ( totalMass / repeats / levels + " , " ) ; System . out . println ( ) ; }
public void resetLearningImpl ( ) { this . kernels = new ClustreamKernel [ maxNumKernelsOption . getValue ( ) ] ; this . timeWindow = timeWindowOption . getValue ( ) ; this . initialized = false ; this . buffer = new LinkedList < > ( ) ; this . bufferSize = maxNumKernelsOption . getValue ( ) ; t = kernelRadiFactorOption . getValue ( ) ; m = maxNumKernelsOption . getValue ( ) ; }
public void onMouseClick ( GridButtonPanel . ConceptButton c , boolean press , int wheelRotation ) { int x = c . bx ; int y = c . by ; int i = c . by * 3 + c . bx ; if ( ! en | | field [ i ] ! = 0 ) { return ; } nar . addInput ( " < " + i + "  --> set>. :|: " ) ; c . setText ( " X " ) ; field [ i ] = 1 ; updateField ( ) ; if ( ! updateField ( ) ) {
public List < Music > getSavedStreams ( ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; List < String > response = mpdConnection . sendCommand ( MPDCommand . MPD_CMD_LISTPLAYLISTS ) ; for ( String line : response ) { if ( line . startsWith ( " playlist " ) ) { String name = line . substring ( " playlist:  " . length ( ) ) ; if ( null ! = name & & name . equals ( STREAMS_PLAYLIST ) ) { String args [ ] = new String [ 1 ] ; args [ 0 ] = STREAMS_PLAYLIST ; List < Music > music = genericSearch ( MPDCommand . MPD_CMD_PLAYLIST_INFO , args , false ) ; for ( int i = 0 ; i < music . size ( ) ; + + i ) { music . get ( i ) . setSongId ( i ) ; } return music ; } } } return null ; }
KeyStore loadKeyStore ( @Nonnull @WillNotClose InputStream aIS , @Nonnull char [ ] aPassword ) throws Exception ; boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isCompressed ( @Nonnull String sContentType ) throws OpenAS2Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
public void mouseMoved ( ) { } void keyPressed ( ) { hnav . keyPressed ( ) ; } void mouseScrolled ( ) { hnav . mouseScrolled ( ) ; } void Camera ( ) { } } }
default < T > T get ( List < String > path ) { Object raw = getRaw ( path ) ; return ( raw = = NULL_OBJECT ) ? null : ( T ) raw ; }
public void playlistChanged ( MPDStatus mpdStatus , int oldPlaylistVersion ) { } private void prev ( ) { Log . d ( TAG , " StreamingService.prev() " ) ; MPD mpd = app . oMPDAsyncHelper . oMPD ; try { mpd . previous ( ) ; } catch ( MPDServerException e ) { } } @Override public void randomChanged ( boolean random ) { } @Override public void repeatChanged ( boolean repeating ) { } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Log . d ( TAG , " StreamingService.stateChanged() " ) ; Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd = = null ) { return ; } String state = statusMpd . getState ( ) ; if ( state = = null | | state . equals ( prevMpdState ) ) { return ; } if ( state . equals ( MPDStatus . MPD_STATE_PLAYING ) ) { isPaused = false ; beginStreaming ( ) ; isPlaying = true ; } else { prevMpdState = state ; isPlaying = false ; stopStreaming ( ) ; } } private void stop ( ) { Log . d ( TAG , " StreamingService.stop() " ) ; stopStreaming ( ) ; die ( ) ; } private void stopStreaming ( ) { Log . d ( TAG , " StreamingService.stopStreaming() " ) ; prevMpdState = " " ; if ( mediaPlayer = = null ) { return ; } mediaPlayer . stop ( ) ; } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { Log . d ( TAG , " StreamingService.trackChanged() " ) ; prevMpdState = " " ; } @Override public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } }
public void testBasic ( ) throws InvalidParameterException { final AS2Message aMsg = new AS2Message ( ) ; aMsg . addHeader ( " message-id " , " 12345 " ) ; aMsg . getPartnership ( ) . setSenderAS2ID ( " s1 " ) ; aMsg . getPartnership ( ) . setReceiverAS2ID ( " r1 " ) ; final CompositeParameters aParams = new CompositeParameters ( false ) . add ( " date " , new DateParameters ( ) ) . add ( " msg " , new MessageParameters ( aMsg ) ) ; final String sNow = new SimpleDateFormat ( " yyyyMMddhhmmss " ) . format ( new Date ( ) ) ; String sName = aParams . format ( " $date.yyyyMMddhhmmss$ " ) ; assertEquals ( sNow , sName ) ; sName = aParams . format ( " any$date.yyyyMMddhhmmss$else " ) ; assertEquals ( " any " + sNow + " else " , sName ) ; assertEquals ( " sender.as2_id, receiver.as2_id, headers.message-id " , aParams . format ( " sender.as2_id, receiver.as2_id, headers.message-id " ) ) ; assertEquals ( " s1, r1, 12345 " , aParams . format ( " $msg.sender.as2_id$, $msg.receiver.as2_id$, $msg.headers.message-id$ " ) ) ; try { aParams . format ( " $dummy$ " ) ; fail ( ) ; } catch ( final InvalidParameterException ex ) { } assertEquals ( " $s1 " , aParams . format ( " $$$msg.sender.as2_id$ " ) ) ; assertEquals ( " $$s1 " , aParams . format ( " $$$$$msg.sender.as2_id$ " ) ) ; assertEquals ( " s1$ " , aParams . format ( " $msg.sender.as2_id$$$ " ) ) ; assertEquals ( " s1$$ " , aParams . format ( " $msg.sender.as2_id$$$$$ " ) ) ; assertEquals ( " s1$r1 " , aParams . format ( " $msg.sender.as2_id$$$$msg.receiver.as2_id$ " ) ) ; assertEquals ( " s1$$r1 " , aParams . format ( " $msg.sender.as2_id$$$$$$msg.receiver.as2_id$ " ) ) ; assertEquals ( " $$s1$$r1$$ " , aParams . format ( " $$$$$msg.sender.as2_id$$$$$$msg.receiver.as2_id$$$$$ " ) ) ; }
protected String decodeString ( byte [ ] data ) { String rv = null ; try { if ( data ! = null ) { rv = new String ( data , charset ) ; } } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } return rv ; }
public static double noise ( double xin , double yin , double zin ) { double n0 , n1 , n2 , n3 ; double s = ( xin + yin + zin ) * F3 ; int i = fastfloor ( xin + s ) ; int j = fastfloor ( yin + s ) ; int k = fastfloor ( zin + s ) ; double t = ( i + j + k ) * G3 ; double X0 = i - t ; double Y0 = j - t ; double Z0 = k - t ; double x0 = xin - X0 ; double y0 = yin - Y0 ; double z0 = zin - Z0 ; int i1 , j1 , k1 ; int i2 , j2 , k2 ; if ( x0 > = y0 ) { if ( y0 > = z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } else if ( x0 > = z0 ) { i1 = 1 ; j1 = 0 ; k1 = 0 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } else { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 1 ; j2 = 0 ; k2 = 1 ; } } else { if ( y0 < z0 ) { i1 = 0 ; j1 = 0 ; k1 = 1 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else if ( x0 < z0 ) { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 0 ; j2 = 1 ; k2 = 1 ; } else { i1 = 0 ; j1 = 1 ; k1 = 0 ; i2 = 1 ; j2 = 1 ; k2 = 0 ; } } double x1 = x0 - i1 + G3 ; double y1 = y0 - j1 + G3 ; double z1 = z0 - k1 + G3 ; double x2 = x0 - i2 + 2.0 * G3 ; double y2 = y0 - j2 + 2.0 * G3 ; double z2 = z0 - k2 + 2.0 * G3 ; double x3 = x0 - 1.0 + 3.0 * G3 ; double y3 = y0 - 1.0 + 3.0 * G3 ; double z3 = z0 - 1.0 + 3.0 * G3 ; int ii = i & 255 ; int jj = j & 255 ; int kk = k & 255 ; int gi0 = permMod12 [ ii + perm [ jj + perm [ kk ] ] ] ; int gi1 = permMod12 [ ii + i1 + perm [ jj + j1 + perm [ kk + k1 ] ] ] ; int gi2 = permMod12 [ ii + i2 + perm [ jj + j2 + perm [ kk + k2 ] ] ] ; int gi3 = permMod12 [ ii + 1 + perm [ jj + 1 + perm [ kk + 1 ] ] ] ; double t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 ; if ( t0 < 0 ) n0 = 0.0 ; else { t0 * = t0 ; n0 = t0 * t0 * dot ( grad3 [ gi0 ] , x0 , y0 , z0 ) ; } double t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 ; if ( t1 < 0 ) n1 = 0.0 ; else { t1 * = t1 ; n1 = t1 * t1 * dot ( grad3 [ gi1 ] , x1 , y1 , z1 ) ; } double t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 ; if ( t2 < 0 ) n2 = 0.0 ; else { t2 * = t2 ; n2 = t2 * t2 * dot ( grad3 [ gi2 ] , x2 , y2 , z2 ) ; } double t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 ; if ( t3 < 0 ) n3 = 0.0 ; else { t3 * = t3 ; n3 = t3 * t3 * dot ( grad3 [ gi3 ] , x3 , y3 , z3 ) ; } return 32.0 * ( n0 + n1 + n2 + n3 ) ; }
public int hashCode ( ) { int hashCode = 1 ; synchronized ( mLOCK ) { for ( final Iterator < ? > itr = this . iterator ( ) ; itr . hasNext ( ) ; ) { final Object obj = itr . next ( ) ; hashCode = 31 * hashCode + ( obj = = null ? 0 : obj . hashCode ( ) ) ; } } return hashCode ; }
public String next ( ) { if ( history . size ( ) = = 0 ) return " " ; index + + ; if ( index > = history . size ( ) ) index = history . size ( ) - 1 ; return ( String ) history . get ( index ) ; }
public void setAttribute ( final String sKey , final String sValue ) { m_aAttributes . setAttribute ( sKey , sValue ) ; }
public boolean equals ( Object that ) { return ( ( that instanceof Base ) & & this . include ( ( Base ) that ) & & ( ( Base ) that ) . include ( this ) ) ; }
public void testGraph ( ) { NAR n = new Default ( ) . build ( ) ; n . addInput ( " <a --> b>. " ) ; n . run ( 2 ) ; NARGraph g = new NARGraph ( ) ; g . add ( n , IncludeEverything , new DefaultGraphizer ( true , true , true , true , 0 , true , true ) ) ; assert ( g . vertexSet ( ) . size ( ) > 0 ) ; assert ( g . edgeSet ( ) . size ( ) > 0 ) ; }
public void testToRowValueMapRow ( final @Mocked Row inputRow , final @Mocked StructType rowSchema ) { DataType fieldNotNullable = DataTypes . createMapType ( DataTypes . StringType , DataTypes . LongType , false ) ; DataType fieldNullable = DataTypes . createMapType ( DataTypes . StringType , DataTypes . LongType , true ) ; Map < Object , Object > expectedValues = Maps . newHashMap ( ) ; expectedValues . put ( " field1 " , 1L ) ; expectedValues . put ( " field2 " , 2L ) ; Map < Object , Object > expectedNulls = Maps . newHashMap ( ) ; expectedNulls . put ( " field1 " , null ) ; expectedNulls . put ( " field2 " , 2L ) ; new Expectations ( ) { { inputRow . schema ( ) ; result = rowSchema ; rowSchema . fieldNames ( ) ; result = new String [ ] { " field1 " , " field2 " } ; inputRow . get ( 0 ) ; returns ( 1L , 1L , ByteBuffer . allocate ( 1 ) , null ) ; inputRow . get ( 1 ) ; returns ( 2L , " 2 " , 2L ) ; } } ; assertEquals ( " Invalid map of values " , expectedValues , RowUtils . toRowValue ( inputRow , fieldNotNullable ) ) ; assertEquals ( " Invalid map of values " , expectedValues , RowUtils . toRowValue ( inputRow , fieldNotNullable ) ) ; try { RowUtils . toRowValue ( ByteBuffer . allocate ( 1 ) , fieldNotNullable ) ; fail ( " Expected a RuntimeException for type " ) ; } catch ( RuntimeException e ) { assertThat ( e . getMessage ( ) , JUnitMatchers . containsString ( " Invalid or unrecognized input format " ) ) ; } try { RowUtils . toRowValue ( inputRow , fieldNotNullable ) ; fail ( " Expected a RuntimeException for invalid value type " ) ; } catch ( RuntimeException e ) { assertThat ( e . getMessage ( ) , JUnitMatchers . containsString ( " Invalid or unrecognized value format " ) ) ; } try { RowUtils . toRowValue ( inputRow , fieldNotNullable ) ; fail ( " Expected a RuntimeException for 'null' value " ) ; } catch ( RuntimeException e ) { assertThat ( e . getMessage ( ) , JUnitMatchers . containsString ( " Value cannot be 'null' " ) ) ; } assertEquals ( " Invalid null value " , expectedNulls , RowUtils . toRowValue ( inputRow , fieldNullable ) ) ; try { RowUtils . toRowValue ( RowFactory . create ( " " ) , fieldNotNullable ) ;
private String sumoDisplay ( String synsetBlock , String word , String type , String sumokbname , String synsetNum ) { StringBuilder result = new StringBuilder ( ) ; String synset ; String documentation = new String ( ) ; String sumoEquivalent = new String ( ) ; int listLength ; String [ ] synsetList = splitSynsets ( synsetBlock ) ; if ( synsetList ! = null ) listLength = synsetList . length ; else listLength = 0 ; result . append ( " <i>According to WordNet, the  " ) . append ( type ) . append ( " \" " ) . append ( word ) . append ( " \"  has  " ) ; result . append ( String . valueOf ( listLength ) ) . append ( "  sense(s).</i><P> \ n \ n " ) ; for ( int i = 0 ; i < listLength ; i + + ) { synset = synsetList [ i ] ; synset . trim ( ) ; if ( synset . equals ( synsetNum ) ) result . append ( " <b> " ) ; if ( type . compareTo ( " noun " ) = = 0 ) { documentation = ( String ) nounDocumentationHash . get ( synset ) ; result . append ( " <a href= \" WordNet.jsp?synset=1 " ) . append ( synset ) . append ( " \" >1 " ) . append ( synset ) . append ( " </a>  " ) ; result . append ( "   " ) . append ( documentation ) . append ( " . \ n " ) ; sumoEquivalent = ( String ) nounSUMOHash . get ( synset ) ; } else { if ( type . compareTo ( " verb " ) = = 0 ) { documentation = ( String ) verbDocumentationHash . get ( synset ) ; result . append ( " <a href= \" WordNet.jsp?synset=2 " ) . append ( synset ) . append ( " \" >2 " ) . append ( synset ) . append ( " </a>  " ) ; result . append ( "   " ) . append ( documentation ) . append ( " . \ n " ) ; sumoEquivalent = ( String ) verbSUMOHash . get ( synset ) ; } else { if ( type . compareTo ( " adjective " ) = = 0 ) { documentation = ( String ) adjectiveDocumentationHash . get ( synset ) ; result . append ( " <a href= \" WordNet.jsp?synset=3 " ) . append ( synset ) . append ( " \" >3 " ) . append ( synset ) . append ( " </a>  " ) ; result . append ( "   " ) . append ( documentation ) . append ( " . \ n " ) ; sumoEquivalent = ( String ) adjectiveSUMOHash . get ( synset ) ; } else { if ( type . compareTo ( " adverb " ) = = 0 ) { documentation = ( String ) adverbDocumentationHash . get ( synset ) ; result . append ( " <a href= \" WordNet.jsp?synset=4 " ) . append ( synset ) . append ( " \" >4 " ) . append ( synset ) . append ( " </a>  " ) ; result . append ( "   " ) . append ( documentation ) . append ( " . \ n " ) ; sumoEquivalent = ( String ) adverbSUMOHash . get ( synset ) ; } } } } if ( synset . equals ( synsetNum ) ) { result . append ( " </b> " ) ; } if ( sumoEquivalent = = null ) { result . append ( " <P><ul><li> " ) . append ( word ) . append ( "  not yet mapped to SUMO</ul><P> " ) ; } else { result . append ( sumoEquivalent ) . append ( "   " ) . append ( sumokbname ) ; } } String searchTerm = word . replaceAll ( " _+ " , " + " ) ; searchTerm = searchTerm . replaceAll ( " \\ s+ " , " + " ) ; result . append ( " <hr>Explore the word <a href= \" http://wordnet.princeton.edu/perl/webwn/webwn?s= " ) ; result . append ( searchTerm ) . append ( " \" > " ) . append ( word ) . append ( " </a> on the WordNet web site. \ n " ) ; return result . toString ( ) ; }
boolean dispatchMenuItemSelected ( MenuBuilder menu , MenuItem item ) { return super . dispatchMenuItemSelected ( menu , item ) | | mParentMenu . dispatchMenuItemSelected ( menu , item ) ;
public static Term make ( ArrayList < Term > argument , Memory memory ) { if ( argument . size ( ) ! = 1 ) return null ; String name = makeCompoundName ( Symbols . NEGATION_OPERATOR , argument ) ; Term t = memory . nameToListedTerm ( name ) ; return ( t ! = null ) ? t : new Negation ( name , argument ) ; }
protected synchronized void ensureChain ( ) { if ( derivationChain = = EmptyDerivationChain ) { derivationChain = new LinkedHashSet ( ) ; return ; } if ( this . derivationChain ! = null ) return ; if ( derivationBuilder = = null ) throw new RuntimeException ( " Null derivationChain and derivationBuilder " ) ; this . derivationChain = derivationBuilder . build ( ) ; this . derivationBuilder = null ; }
private static void convertedJudgment ( final TruthValue newTruth , final BudgetValue newBudget , final Memory memory ) { Statement content = ( Statement ) memory . getCurrentTask ( ) . getContent ( ) ; Statement beliefContent = ( Statement ) memory . getCurrentBelief ( ) . content ; int order = TemporalRules . reverseOrder ( beliefContent . getTemporalOrder ( ) ) ; final Term subjT = content . getSubject ( ) ; final Term predT = content . getPredicate ( ) ; final Term subjB = beliefContent . getSubject ( ) ; final Term predB = beliefContent . getPredicate ( ) ; Term otherTerm ; if ( Variables . containVarQuery ( subjT . toString ( ) ) ) { otherTerm = ( predT . equals ( subjB ) ) ? predB : subjB ; content = Statement . make ( content , otherTerm , predT , order , memory ) ; } if ( Variables . containVarQuery ( predT . toString ( ) ) ) { otherTerm = ( subjT . equals ( subjB ) ) ? predB : subjB ; content = Statement . make ( content , subjT , otherTerm , order , memory ) ; } if ( content = = null ) return ; memory . singlePremiseTask ( content , Symbols . JUDGMENT_MARK , newTruth , newBudget ) ; }
public void testSupportAll ( ) throws Exception { ObjectConverter converter = new ObjectConverter ( ) ; Config config = new SimpleConfig ( type - > true ) ; MyObject object = new MyObject ( ) ; converter . toConfig ( object , config ) ; System . out . println ( " MyObject mapped to a SimpleConfig with support_all strategy: " ) ; System . out . println ( config ) ; assert config . < Integer > get ( " integer " ) = = object . integer ; assert config . < Double > get ( " decimal " ) = = object . decimal ; assert config . < String > get ( " string " ) = = object . string ; assert config . < List < String > > get ( " stringList " ) = = object . stringList ; assert config . < Config > get ( " config " ) = = object . config ; assert config . get ( " subObject " ) = = object . subObject ; assert config . get ( " infos.coordinates " ) . equals ( object . coords . toString ( ) ) ; }
public LinkedList < FilesystemTreeEntry > getDir ( ) throws MPDServerException { return getDir ( " " ) ; }
public void testPrimitivesWithConversions ( ) throws Exception { var conf = Config . copy ( Primitives . SERIALIZED ) ; conf . set ( " l " , Integer . MAX_VALUE ) ; conf . set ( " i " , Short . MAX_VALUE ) ; conf . set ( " s " , Byte . MAX_VALUE ) ; conf . set ( " f " , Integer . MAX_VALUE ) ; conf . set ( " d " , Long . MAX_VALUE ) ; var deserialized = ObjectDeserializer . standard ( ) . deserializeFields ( conf , Primitives : : new ) ; var expectedObj = new Primitives ( ) ; expectedObj . l = Integer . MAX_VALUE ; expectedObj . i = Short . MAX_VALUE ; expectedObj . s = Byte . MAX_VALUE ; expectedObj . f = Integer . MAX_VALUE ; expectedObj . d = Long . MAX_VALUE ; assertEquals ( expectedObj , deserialized ) ; conf . set ( " i " , 1234L ) ; conf . set ( " s " , 123 ) ; conf . set ( " b " , 10 ) ; conf . set ( " f " , 1234L ) ; deserialized = ObjectDeserializer . standard ( ) . deserializeFields ( conf , Primitives : : new ) ; expectedObj . i = 1234 ; expectedObj . s = 123 ; expectedObj . b = 10 ; expectedObj . f = 1234L ; assertEquals ( expectedObj , deserialized ) ; conf . set ( " i " , Long . MIN_VALUE ) ; assertThrows ( SerdeException . class , ( ) - > { ObjectDeserializer . standard ( ) . deserializeFields ( conf , Primitives : : new ) ; } ) ; conf . set ( " i " , 1234 ) ; conf . set ( " s " , Short . MAX_VALUE + 1 ) ; assertThrows ( SerdeException . class , ( ) - > { ObjectDeserializer . standard ( ) . deserializeFields ( conf , Primitives : : new ) ;
public void onLayoutChange ( View v , int left , int top , int right , int bottom , int oldLeft , int oldTop , int oldRight , int oldBottom ) { adjustDropDownSizeAndPosition ( ) ; }
public final int read ( @Nonnull byte [ ] b , int nOffset , int nLength ) throws IOException { if ( nLeft < 0 ) return - 1 ; int readCount = 0 ; while ( nLength > readCount ) { if ( nLeft = = 0 ) { if ( afterFirstChunk ) { HTTPHelper . readTillNexLine ( aIS ) ; } else { afterFirstChunk = true ; } nLeft = HTTPHelper . readChunkLen ( aIS ) ; s_aLogger . debug ( " Read chunk size:{} " , nLeft ) ; if ( nLeft < = 0 ) { nLeft = - 1 ; return readCount > 0 ? readCount : - 1 ; } } int ret = super . read ( b , nOffset , Math . min ( nLength - readCount , nLeft ) ) ; nOffset + = ret ; nLeft - = ret ; readCount + = ret ; } return readCount ; }
public static void processJudgment ( final Concept concept , final DerivationContext nal , final Task task ) { handleOperationFeedback ( task , nal ) ; final Sentence judg = task . sentence ; confirmAnticipation ( task , concept , nal ) ; final Task oldBeliefT = concept . selectCandidate ( task , concept . beliefs ) ; Sentence oldBelief = null ; if ( oldBeliefT ! = null ) { oldBelief = oldBeliefT . sentence ; final Stamp newStamp = judg . stamp ; final Stamp oldStamp = oldBelief . stamp ; if ( newStamp . equals ( oldStamp , false , false , true ) ) { concept . memory . removeTask ( task , " Duplicated " ) ; return ; } else if ( revisible ( judg , oldBelief ) ) { nal . setTheNewStamp ( newStamp , oldStamp , concept . memory . time ( ) ) ; final Sentence projectedBelief = oldBelief . projection ( concept . memory . time ( ) , newStamp . getOccurrenceTime ( ) ) ; if ( projectedBelief ! = null ) { nal . setCurrentBelief ( projectedBelief ) ; revision ( judg , projectedBelief , false , nal ) ; } } } if ( ! task . aboveThreshold ( ) ) { return ; } final int nnq = concept . questions . size ( ) ; for ( int i = 0 ; i < nnq ; i + + ) { trySolution ( judg , concept . questions . get ( i ) , nal , true ) ; } final int nng = concept . desires . size ( ) ; for ( int i = 0 ; i < nng ; i + + ) { trySolution ( judg , concept . desires . get ( i ) , nal , true ) ; } concept . addToTable ( task , false , concept . beliefs , Parameters . CONCEPT_BELIEFS_MAX , Events . ConceptBeliefAdd . class , Events . ConceptBeliefRemove . class ) ; if ( isExecutableHypothesis ( task , nal ) ) { addToTargetConceptsPreconditions ( task , nal , concept ) ;
int read ( ) ; default int readAndSkip ( char [ ] toSkip ) { int c ; do { c = read ( ) ; } while ( c ! = - 1 & & Utils . arrayContains ( toSkip , ( char ) c ) ) ; return c ; } char [ ] read ( int n ) ; char readChar ( ) ; default char readCharAndSkip ( char [ ] toSkip ) { char c ; do { c = readChar ( ) ; } while ( Utils . arrayContains ( toSkip , c ) ) ; return c ; } char [ ] readChars ( int n ) ; default CharsWrapper readCharUntil ( char [ ] stop ) { CharsWrapper . Builder builder = new CharsWrapper . Builder ( 10 ) ; char c = readChar ( ) ; while ( ! Utils . arrayContains ( stop , c ) ) { builder . append ( c ) ; c = readChar ( ) ; } return builder . build ( ) ; } }
public void testCarryForwardWhenNull ( ) { p = new BitemporalHistoryPlanner ( ) ; config = config . withValue ( BitemporalHistoryPlanner . CARRY_FORWARD_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( true ) ) ; assertNoValidationFailures ( p , config ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , 1L , 253402214400000L , CURRENT_FLAG_DEFAULT_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , null , 200L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 3 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 2 ) ) , MutationType . INSERT ) ; Long systemStart1 = RowUtils . get ( planned . get ( 1 ) , " systemstart " ) ; Long systemStart2 = RowUtils . get ( planned . get ( 2 ) , " systemstart " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " systemstart " ) , 1L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " systemend " ) , systemStart1 - 1 ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " eventend " ) , 199L ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " systemend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " eventstart " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " eventend " ) , 253402214400000L ) ; assertTrue ( systemStart2 > = preplanSystemTime ) ; assertTrue ( systemStart2 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " systemend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " currentflag " ) , CURRENT_FLAG_DEFAULT_YES ) ; }
protected void onReceivedMDNError ( @Nonnull final AS2Message aMsg , @Nonnull final OpenAS2Exception ex ) { final OpenAS2Exception oae2 = new OpenAS2Exception ( " Message was sent but an error occured while receiving the MDN " , ex ) ; oae2 . addSource ( OpenAS2Exception . SOURCE_MESSAGE , aMsg ) ; oae2 . terminate ( ) ; }
protected BlockingQueue < Runnable > createWorkQueue ( ) { BlockingQueue < Runnable > queue ; int queueSize = StatsProperties . getIntegerProperty ( PROP_QUEUE_SIZE , DEFAULT_QUEUE_SIZE ) ; if ( queueSize < 1 ) { queue = new LinkedBlockingQueue < > ( ) ; } else { queue = new ArrayBlockingQueue < > ( queueSize ) ; } return queue ; }
public void testGetStats ( ) throws Exception { Map < SocketAddress , Map < String , String > > stats = client . getStats ( ) ; System . out . println ( " Stats:   " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " curr_items " ) ) ; }
protected void addStatisticsforInstanceReceived ( int instanceIndex , int classifierIndex , double [ ] prediction , int add ) { if ( this . mapCountsforInstanceReceived = = null ) { this . mapCountsforInstanceReceived = new HashMap < > ( ) ; this . mapVotesforInstanceReceived = new HashMap < > ( ) ; } DoubleVector vote = new DoubleVector ( prediction ) ; if ( vote . sumOfValues ( ) > 0.0 ) { vote . normalize ( ) ; DoubleVector combinedVote = this . mapVotesforInstanceReceived . get ( instanceIndex ) ; if ( combinedVote = = null ) { combinedVote = new DoubleVector ( ) ; } vote . scaleValues ( getEnsembleMemberWeight ( classifierIndex ) ) ; combinedVote . addValues ( vote ) ; this . mapVotesforInstanceReceived . put ( instanceIndex , combinedVote ) ; } Integer count = this . mapCountsforInstanceReceived . get ( instanceIndex ) ; if ( count = = null ) { count = 0 ; } this . mapCountsforInstanceReceived . put ( instanceIndex , count + add ) ; }
public AbstractBag < Concept , Term > newConceptBag ( Param p ) { return new ContinuousBag2 < > ( getConceptBagSize ( ) , curve , randomRemoval ) ; }
public void set ( T o ) { synchronized ( LOCK ) { this . checkConcurrentModification ( ) ;
public String toString ( ) { String occupant = piece ! = null ? piece . toString ( ) : " EMPTY " ; return " [ " + x + " ,  " + y + " ] :  " + occupant ; }
protected final int [ ] connect ( ) throws MPDServerException { int [ ] result = null ; int retry = 0 ; MPDServerException lastException = null ; while ( result = = null & & retry < MAX_CONNECT_RETRY & & ! cancelled ) { try { result = innerConnect ( ) ; } catch ( final MPDServerException e1 ) { lastException = e1 ; try { Thread . sleep ( 500L ) ; } catch ( final InterruptedException ignored ) { } } catch ( final Exception e2 ) { lastException = new MPDServerException ( e2 ) ; } retry + + ; } if ( result ! = null ) { mpdVersion = result ;
public void actionPerformed ( ActionEvent e ) { new NWindow ( " Concept Graph " , new ProcessingGraphPanel ( nar , new ConceptGraphCanvas ( nar ) ) ) . show ( 500 , 500 ) ; }
@Override public AbstractBag newBag ( ) { return new DefaultBag < Item > ( _levels , capacity , forgetRate ) { @Override
public boolean nextInput ( ) { if ( timer > 0 ) { timer - - ; return true ; } if ( ! ready ) { return false ; } String text = inputText . getText ( ) . trim ( ) ; String line ; int endOfLine ; while ( ( text . length ( ) > 0 ) & & ( timer = = 0 ) ) { endOfLine = text . indexOf ( '\n' ) ; if ( endOfLine < 0 ) { line = text ; text = " " ; } else { line = text . substring ( 0 , endOfLine ) . trim ( ) ; text = text . substring ( endOfLine + 1 ) ; } try { timer = Integer . parseInt ( line ) ; reasoner . walk ( timer ) ; } catch ( NumberFormatException e ) { try { reasoner . textInputLine ( line ) ; } catch ( NullPointerException e1 ) { System . out . println ( " InputWindow.nextInput() - NullPointerException: please correct the input " ) ; ready = false ; return false ; } } inputText . setText ( text ) ; if ( text . isEmpty ( ) ) { ready = false ; } } return ( ( text . length ( ) > 0 ) | | ( timer > 0 ) ) ; }
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
public void drawString ( float x , float y , String s , Color3f color ) { Graphics2D g = getGraphics ( ) ; if ( g = = null ) { return ; } Color c = new Color ( color . x , color . y , color . z ) ; g . setColor ( c ) ; g . drawString ( s , x , y ) ; }
boolean isRequestingAsynchMDN ( ) ; @Nullable TempSharedFileInputStream getTempSharedFileInputStream ( ) ; void setTempSharedFileInputStream ( @Nullable TempSharedFileInputStream m_TempSharedFileInputStream ) ; }
public int size ( ) ; public boolean validate ( ) ; public java . util . Map < K , V > toMap ( ) ; }
public void inputTask ( final Task task ) { if ( task . budget . aboveThreshold ( ) ) { addNewTask ( task , " Perceived " ) ;
public static Term make ( final Term term1 , final Term term2 ) { if ( ( term1 instanceof SetExt ) & & ( term2 instanceof SetExt ) ) { final Term [ ] both = ObjectArrays . concat ( ( ( CompoundTerm ) term1 ) . term , ( ( CompoundTerm ) term2 ) . term , Term . class ) ; return SetExt . make ( both ) ; } if ( ( term1 instanceof SetInt ) & & ( term2 instanceof SetInt ) ) { final NavigableSet < Term > set = Term . toSortedSet ( ( ( CompoundTerm ) term1 ) . term ) ; set . retainAll ( ( ( CompoundTerm ) term2 ) . asTermList ( ) ) ; return SetInt . make ( set . toArray ( new Term [ set . size ( ) ] ) ) ; } final List < Term > se = new ArrayList ( ) ; if ( term1 instanceof IntersectionInt ) { ( ( CompoundTerm ) term1 ) . addTermsTo ( se ) ; if ( term2 instanceof IntersectionInt ) { ( ( CompoundTerm ) term2 ) . addTermsTo ( se ) ; } else { se . add ( term2 ) ; } } else if ( term2 instanceof IntersectionInt ) { ( ( CompoundTerm ) term2 ) . addTermsTo ( se ) ; se . add ( term1 ) ; } else { se . add ( term1 ) ; se . add ( term2 ) ; } return make ( se . toArray ( new Term [ se . size ( ) ] ) ) ; }
public boolean equals ( final StatsKeyMatcher other ) { ContainsMatcher containsMatcher = ( ContainsMatcher ) other ; return target = = containsMatcher . target & & string . equals ( containsMatcher . string ) ;
public void actionPerformed ( ActionEvent event ) { viewAboutInformation ( ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int key = 0 ; key < map . length ; key + + ) { List < Pair < K , V > > list = map [ key ] ; for ( int item = 0 ; item < list . size ( ) ; item + + ) { Pair < K , V > p = list . get ( item ) ; V value = p . value ; if ( value ! = null ) builder . append ( key ) . append ( " = " ) . append ( value ) . append ( " ,  " ) ; } } return builder . toString ( ) ; }
public void remove ( ) { synchronized ( mLOCK ) { checkConcurrentModification ( ) ;
public int hashCode ( ) { int hash = 7 ; hash = 43 * hash + Objects . hashCode ( this . components ) ; hash = 43 * hash + operator ( ) . hashCode ( ) ; return hash ; }
public void onCreate ( int id ) { this . localStats = HashBasedTable . create ( ) ; }
public static DataRecorder [ ] locking ( final DataRecorder [ ] dataRecorders , final Lock lock ) { if ( dataRecorders = = null ) { return null ; } DataRecorder [ ] result = new DataRecorder [ dataRecorders . length ] ; for ( int i = 0 ; i < dataRecorders . length ; i + + ) { result [ i ] = locking ( dataRecorders [ i ] , lock ) ; } return result ; }
private static BudgetValue budgetInference ( final float qual , final int complexity , final Memory memory ) { Item t = memory . currentTaskLink ; if ( t = = null ) { t = memory . currentTask ; } float priority = t . getPriority ( ) ; float durability = t . getDurability ( ) / complexity ; final float quality = qual / complexity ; final TermLink bLink = memory . currentBeliefLink ; if ( bLink ! = null ) { priority = or ( priority , bLink . getPriority ( ) ) ; durability = and ( durability , bLink . getDurability ( ) ) ; final float targetActivation = memory . getConceptActivation ( bLink . getTarget ( ) ) ; bLink . incPriority ( or ( quality , targetActivation ) ) ; bLink . incDurability ( quality ) ; } return new BudgetValue ( priority , durability , quality ) ; }
public boolean add ( List < String > path , Object value ) { throw new UnsupportedOperationException ( " Cannot add elements to a bound config " ) ; }
public boolean removeAll ( final Collection < ? > c ) { synchronized ( mLOCK ) { boolean changed = false ;
public boolean supportsType ( Class < ? > type ) { if ( supportedTypes . contains ( type ) ) { return true ; } for ( Class < ? > supportedType : extensibleSupportedTypes ) { if ( supportedType . isAssignableFrom ( type ) ) { return true ; } } return false ; }
public Term clone ( final Term [ ] replaced ) { return make ( replaced ) ; }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o instanceof com . googlecode . opennars . parser . loan . Loan . Absyn . LitQVar ) { com . googlecode . opennars . parser . loan . Loan . Absyn . LitQVar x = ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitQVar ) o ; return this . ident_ . equals ( x . ident_ ) ; } return false ; }
public void testUUIDKey ( ) { Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( AppendPlanner . UUID_KEY_CONFIG_NAME , " true " ) ; configMap . put ( AppendPlanner . KEY_FIELD_NAMES_CONFIG_NAME , Lists . newArrayList ( " key " ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; BulkPlanner ap = new AppendPlanner ( ) ; ap . configure ( config ) ; List < Tuple2 < MutationType , Dataset < Row > > > planned = ap . planMutationsForSet ( dataFrame ) ; assertEquals ( planned . size ( ) , 1 ) ; Dataset < Row > plannedDF = planned . get ( 0 ) . _2 ( ) ; assertEquals ( planned . get ( 0 ) . _1 ( ) , MutationType . INSERT ) ; assertEquals ( plannedDF . count ( ) , 1 ) ; Row plannedRow = plannedDF . collectAsList ( ) . get ( 0 ) ; assertNotNull ( plannedRow . get ( plannedRow . fieldIndex ( " key " ) ) ) ; assertEquals ( plannedRow . getString ( plannedRow . fieldIndex ( " key " ) ) . length ( ) , 36 ) ; }
protected static Partnership getPartnership ( @Nonnull final List < Partnership > aPartnerships , @Nullable final String sName ) { for ( final Partnership aCurrentPartnership : aPartnerships ) if ( EqualsUtils . equals ( aCurrentPartnership . getName ( ) , sName ) ) return aCurrentPartnership ; return null ; }
String getAttributeAsString ( @Nullable String sName ) ; @Nullable String getAttributeAsString ( @Nullable String sName , @Nullable String sDefault ) ; int getAttributeAsInt ( @Nullable String sName ) ; int getAttributeAsInt ( @Nullable String sName , int nDefault ) ; long getAttributeAsLong ( @Nullable String sName ) ; long getAttributeAsLong ( @Nullable String sName , long nDefault ) ; double getAttributeAsDouble ( @Nullable String sName ) ; double getAttributeAsDouble ( @Nullable String sName , double dDefault ) ; boolean getAttributeAsBoolean ( @Nullable String sName ) ; boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; @Nonnull @ReturnsMutableCopy Enumeration < String > getAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Collection < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; Iterator < Entry < String , String > > iterator ( ) ; }
private void _sendAsyncMDN ( @Nonnull final AS2Message aMsg ) throws OpenAS2Exception { s_aLogger . info ( " Async MDN submitted " + aMsg . getLoggingText ( ) ) ; final DispositionType aDisposition = new DispositionType ( " automatic-action " , " MDN-sent-automatically " , " processed " ) ; try {
public static Term parseTerm ( String s0 , Memory memory ) { String s = s0 . trim ( ) ; try { if ( s . length ( ) = = 0 ) { throw new InvalidInputException ( " missing content " ) ; } Term t = memory . nameToListedTerm ( s ) ; if ( t ! = null ) { return t ; } int index = s . length ( ) - 1 ; char first = s . charAt ( 0 ) ; char last = s . charAt ( index ) ; switch ( first ) { case COMPOUND_TERM_OPENER : if ( last = = COMPOUND_TERM_CLOSER ) { return parseCompoundTerm ( s . substring ( 1 , index ) , memory ) ; } else { throw new InvalidInputException ( " missing CompoundTerm closer " ) ; } case SET_EXT_OPENER : if ( last = = SET_EXT_CLOSER ) { return SetExt . make ( parseArguments ( s . substring ( 1 , index ) + ARGUMENT_SEPARATOR , memory ) , memory ) ; } else { throw new InvalidInputException ( " missing ExtensionSet closer " ) ; } case SET_INT_OPENER : if ( last = = SET_INT_CLOSER ) { return SetInt . make ( parseArguments ( s . substring ( 1 , index ) + ARGUMENT_SEPARATOR , memory ) , memory ) ; } else { throw new InvalidInputException ( " missing IntensionSet closer " ) ; } case STATEMENT_OPENER : if ( last = = STATEMENT_CLOSER ) { return parseStatement ( s . substring ( 1 , index ) , memory ) ; } else { throw new InvalidInputException ( " missing Statement closer " ) ; } default : return parseAtomicTerm ( s ) ; } } catch ( InvalidInputException e ) { System . out . println ( "  !!! INVALID INPUT: parseTerm:  " + s + "  ---  " + e . getMessage ( ) ) ; } return null ; }
public boolean performIdentifierAction ( int id , int flags ) { return mNativeMenu . performIdentifierAction ( id , flags ) ; }
public final ICommonsMap < String , Object > getOptions ( ) { return options ( ) ; }
public void initDynamicComponent ( final ISession session , final Map < String , String > options ) throws OpenAS2Exception { super . initDynamicComponent ( session , options ) ; getParameterRequired ( PARAM_OUTBOX_DIRECTORY ) ; getParameterRequired ( PARAM_ERROR_DIRECTORY ) ; }
public void testClient ( ) { OperationException oe = new OperationException ( OperationErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( OperationErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: CLIENT_ERROR nope " , String . valueOf ( oe ) ) ;
public static void loadFrom ( final String filepath , final Pluggable reasoner , final NarParameters parameters ) throws IOException , IllegalAccessException , ParseException , ParserConfigurationException , SAXException , ClassNotFoundException , NoSuchMethodException , InstantiationException , InvocationTargetException { loadFromImpl ( new File ( filepath ) , reasoner , parameters ) ; }
private void testAlreadyDefinedKey ( ) { String toml = " string =  \" value \" \ n " + " test = 'success' \ n " + " test = 'already defined!' " ; parseAndPrint ( toml ) ; }
private static void decomposeCompound ( CompoundTerm compound , Term component , Term term1 , int index , boolean compoundTask , int order , DerivationContext nal ) { if ( ( compound instanceof Statement ) | | ( compound instanceof ImageExt ) | | ( compound instanceof ImageInt ) ) { return ; } Term term2 = reduceComponents ( compound , component , nal . mem ( ) ) ; if ( term2 = = null ) { return ; } long delta = 0 ; while ( ( term2 instanceof Conjunction ) & & ( ( ( CompoundTerm ) term2 ) . term [ 0 ] instanceof Interval ) ) { Interval interval = ( Interval ) ( ( CompoundTerm ) term2 ) . term [ 0 ] ; delta + = interval . getTime ( nal . memory ) ; term2 = ( ( CompoundTerm ) term2 ) . setComponent ( 0 , null , nal . mem ( ) ) ; } Task task = nal . getCurrentTask ( ) ; Sentence sentence = task . sentence ; Sentence belief = nal . getCurrentBelief ( ) ; Statement oldContent = ( Statement ) task . getTerm ( ) ; TruthValue v1 , v2 ; if ( compoundTask ) { v1 = sentence . truth ; v2 = belief . truth ; } else { v1 = belief . truth ; v2 = sentence . truth ; } TruthValue truth = null ; Term content ; if ( index = = 0 ) { content = Statement . make ( oldContent , term1 , term2 , order ) ; if ( content = = null ) { return ; } if ( oldContent instanceof Inheritance ) { if ( compound instanceof IntersectionExt ) { truth = reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof IntersectionInt ) { truth = reduceDisjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetInt ) & & ( component instanceof SetInt ) ) { truth = reduceConjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetExt ) & & ( component instanceof SetExt ) ) { truth = reduceDisjunction ( v1 , v2 ) ; } else if ( compound instanceof DifferenceExt ) { if ( compound . term [ 0 ] . equals ( component ) ) { truth = reduceDisjunction ( v2 , v1 ) ; } else { truth = reduceConjunctionNeg ( v1 , v2 ) ; } } } else if ( oldContent instanceof Implication ) { if ( compound instanceof Conjunction ) { truth = reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof Disjunction ) { truth = reduceDisjunction ( v1 , v2 ) ; } } } else { content = Statement . make ( oldContent , term2 , term1 , order ) ; if ( content = = null ) { return ; } if ( oldContent instanceof Inheritance ) { if ( compound instanceof IntersectionInt ) { truth = reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof IntersectionExt ) { truth = reduceDisjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetExt ) & & ( component instanceof SetExt ) ) { truth = reduceConjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetInt ) & & ( component instanceof SetInt ) ) { truth = reduceDisjunction ( v1 , v2 ) ; } else if ( compound instanceof DifferenceInt ) { if ( compound . term [ 1 ] . equals ( component ) ) { truth = reduceDisjunction ( v2 , v1 ) ; } else { truth = reduceConjunctionNeg ( v1 , v2 ) ; } } } else if ( oldContent instanceof Implication ) { if ( compound instanceof Disjunction ) { truth = reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof Conjunction ) { truth = reduceDisjunction ( v1 , v2 ) ; } } } if ( truth ! = null ) { BudgetValue budget = BudgetFunctions . compoundForward ( truth , content , nal ) ;
public void actionPerformed ( ActionEvent event ) { clear ( ) ; }
private JComponent newParameterPanel ( ) { JPanel p = new JPanel ( ) ; JPanel pc = new JPanel ( ) ; pc . setLayout ( new GridLayout ( 1 , 0 ) ) ; stopButton = new FAButton ( FA_StopCharacter ) ; stopButton . addActionListener ( this ) ; pc . add ( stopButton ) ; walkButton = new FAButton ( '\uf051' ) ; walkButton . setToolTipText ( " Walk 1 Cycle " ) ; walkButton . addActionListener ( this ) ; pc . add ( walkButton ) ; JButton focusButton = new FAButton ( FA_FocusCharacter ) ; focusButton . setToolTipText ( " Focus " ) ; focusButton . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent e ) { setSpeed ( 1.0 ) ; volumeSlider . setValue ( 20 ) ; } } ) ; pc . add ( focusButton ) ; p . setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints c = new GridBagConstraints ( ) ; c . anchor = GridBagConstraints . NORTH ; c . fill = GridBagConstraints . HORIZONTAL ; c . weightx = 1 ; c . gridx = 0 ; c . ipady = 8 ; p . add ( pc , c ) ; NSlider vs = newVolumeSlider ( ) ; vs . setFont ( vs . getFont ( ) . deriveFont ( Font . BOLD ) ) ; p . add ( vs , c ) ; NSlider ss = newSpeedSlider ( ) ; ss . setFont ( vs . getFont ( ) ) ; p . add ( ss , c ) ; c . ipady = 4 ; p . add ( newIntSlider ( memory . param . taskForgettingRate , " Task Forgetting Rate " , 1 , 99 ) , c ) ; p . add ( newIntSlider ( memory . param . beliefForgettingRate , " Belief Forgetting Rate " , 1 , 99 ) , c ) ; p . add ( newIntSlider ( memory . param . conceptForgettingRate , " Concept Forgetting Rate " , 1 , 99 ) , c ) ; { this . chart = new PLineChart ( nar . memory . logic , chartHistoryLength ) ; } c . weighty = 1.0 ; c . fill = GridBagConstraints . BOTH ; p . add ( chart , c ) ; return p ; }
boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isCompressed ( @Nonnull String sContentType ) throws OpenAS2Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt , boolean bLargeFileOn ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
public byte [ ] serialize ( String topic , Row data ) { if ( data = = null ) { return null ; } String message = joiner . join ( RowUtils . valuesFor ( data ) ) ; return stringSerializer . serialize ( null , message ) ; }
public void removeSongs ( int [ ] songIds ) throws MPDServerException { for ( int i = songIds . length - 1 ; i > = 0 ; i - - ) { String [ ] args = new String [ 1 ] ; args [ 0 ] = Integer . toString ( songIds [ i ] ) ; this . mpd . getMpdConnection ( ) . queueCommand ( MPD_CMD_PLAYLIST_REMOVE_ID , args ) ; } this . mpd . getMpdConnection ( ) . sendCommandQueue ( ) ; for ( int i = songIds . length - 1 ; i > = 0 ; i - - ) { list . removeBySongId ( songIds [ i ] ) ;
public void run ( ) { mVersion . setSummary ( versionText ) ; mArtists . setSummary ( String . valueOf ( mpdStatistics . getArtists ( ) ) ) ; mAlbums . setSummary ( String . valueOf ( mpdStatistics . getAlbums ( ) ) ) ; mSongs . setSummary ( String . valueOf ( mpdStatistics . getSongs ( ) ) ) ; }
public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; }
public boolean isAssociatedWithTask ( DNSTask task , DNSState state ) ; public boolean isCanceled ( ) ; public boolean isCanceling ( ) ; public boolean isClosed ( ) ; public boolean isClosing ( ) ; public boolean isProbing ( ) ; public boolean recoverState ( ) ; public void removeAssociationWithTask ( DNSTask task ) ; public boolean revertState ( ) ; public boolean waitForAnnounced ( long timeout ) ; public boolean waitForCanceled ( long timeout ) ; }
public void write ( UnmodifiableConfig config , Writer writer ) { currentIndentLevel = - 1 ; CharacterOutput output = new WriterOutput ( writer ) ; TableWriter . writeNormal ( config , new ArrayList < > ( ) , output , this ) ; }
double hsit ( int i1 , int i2 ) { double diff1 = ( coords1 [ i1 ] [ i2 ] - coords1 [ winnerx ] [ winnery ] ) * ( coords1 [ i1 ] [ i2 ] - coords1 [ winnerx ] [ winnery ] ) ; double diff2 = ( coords2 [ i1 ] [ i2 ] - coords2 [ winnerx ] [ winnery ] ) * ( coords2 [ i1 ] [ i2 ] - coords2 [ winnerx ] [ winnery ] ) ; return 1.0f / ( ( double ) Math . sqrt ( 2 * Math . PI * gamma * gamma ) ) * ( ( double ) Math . exp ( ( diff1 + diff2 ) / ( - 2 * gamma * gamma ) ) ) ;
public boolean add ( C value ) { if ( value = = null ) return false ; final int before = size ; if ( root = = null ) this . root = insert ( null , null , value , 0 ) ; else insert ( null , root , value , 0 ) ; final int after = size ; return ( before = = ( after - 1 ) ) ; }
public boolean equals ( Object obj ) { return signal . equals ( ( ( SimilarOutput ) obj ) . signal ) ; }
public void testDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , genericCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertCallback ( op2 ) ; }
boolean isTimedOutUnsent ( ) ; long getWriteCompleteTimestamp ( ) ; byte [ ] getErrorMsg ( ) ; }
private void testAlreadyDefinedKeyInlineDotted ( ) { parseAndPrint ( " tbl = { a.b =  \" a_b \" , a.b.c =  \" a_b_c \"  } " ) ; }
public boolean put ( K key , V value ) { int hashedKey = hashingFunction ( key ) ; List < V > list = map [ hashedKey ] ; for ( int i = 0 ; i < list . size ( ) ; i + + ) { V v = list . get ( i ) ; if ( v = = value ) return false ; } list . add ( value ) ; size + + ; return true ; }
public void movePosition ( final float dx , final float dy ) { this . tx + = dx ; this . ty + = dy ; }
boolean sameValue ( DNSRecord other ) { Text txt = ( Text ) other ; if ( txt . _text . length ! = _text . length ) { return false ; } for ( int i = _text . length ; i - - > 0 ; ) { if ( txt . _text [ i ] ! = _text [ i ] ) { return false ; } } return true ; }
protected void updateHttpHeaders ( @Nonnull final IAS2HttpHeaderWrapper aConn , @Nonnull final IMessage aMsg ) { final Partnership aPartnership = aMsg . partnership ( ) ; aMsg . headers ( ) . forEachSingleHeader ( ( k , v ) - > aConn . setHttpHeader ( k , v ) ) ; aConn . setHttpHeader ( CHttpHeader . CONNECTION , CAS2Header . DEFAULT_CONNECTION ) ; aConn . setHttpHeader ( CHttpHeader . USER_AGENT , CAS2Header . DEFAULT_USER_AGENT ) ; aConn . setHttpHeader ( CHttpHeader . DATE , DateHelper . getFormattedDateNow ( CAS2Header . DEFAULT_DATE_FORMAT ) ) ; aConn . setHttpHeader ( CHttpHeader . MESSAGE_ID , aMsg . getMessageID ( ) ) ; aConn . setHttpHeader ( CHttpHeader . MIME_VERSION , CAS2Header . DEFAULT_MIME_VERSION ) ; aConn . setHttpHeader ( CHttpHeader . CONTENT_TYPE , aMsg . getContentType ( ) ) ; aConn . setHttpHeader ( CHttpHeader . AS2_VERSION , CAS2Header . DEFAULT_AS2_VERSION ) ; aConn . setHttpHeader ( CHttpHeader . RECIPIENT_ADDRESS , aPartnership . getAS2URL ( ) ) ; aConn . setHttpHeader ( CHttpHeader . AS2_FROM , aPartnership . getSenderAS2ID ( ) ) ; aConn . setHttpHeader ( CHttpHeader . AS2_TO , aPartnership . getReceiverAS2ID ( ) ) ; aConn . setHttpHeader ( CHttpHeader . SUBJECT , aMsg . getSubject ( ) ) ; aConn . setHttpHeader ( CHttpHeader . FROM , aPartnership . getSenderEmail ( ) ) ; aConn . setHttpHeader ( CHttpHeader . CONTENT_TRANSFER_ENCODING , aMsg . getHeader ( CHttpHeader . CONTENT_TRANSFER_ENCODING ) ) ; final String sDispTo = aPartnership . getAS2MDNTo ( ) ; if ( sDispTo ! = null ) aConn . setHttpHeader ( CHttpHeader . DISPOSITION_NOTIFICATION_TO , sDispTo ) ; final String sDispositionNotificationOptions = aPartnership . getAS2MDNOptions ( ) ; if ( sDispositionNotificationOptions ! = null ) aConn . setHttpHeader ( CHttpHeader . DISPOSITION_NOTIFICATION_OPTIONS , sDispositionNotificationOptions ) ; final String sReceiptDeliveryOption = aPartnership . getAS2ReceiptDeliveryOption ( ) ; if ( sReceiptDeliveryOption ! = null ) aConn . setHttpHeader ( CHttpHeader . RECEIPT_DELIVERY_OPTION , sReceiptDeliveryOption ) ; final String sContententDisposition = aMsg . getContentDisposition ( ) ; if ( sContententDisposition ! = null ) aConn . setHttpHeader ( CHttpHeader . CONTENT_DISPOSITION , sContententDisposition ) ;
void testIterator ( ) { Iterator < Character > it = charsWrapper . iterator ( ) ; assertTrue ( it . hasNext ( ) ) ; assertEquals ( 'a' , ( char ) it . next ( ) ) ; assertFalse ( it . hasNext ( ) ) ; }
private void plot ( long t , List < InferenceEvent > v ) { float timeScale = 4f ; float itemScale = timeScale * 0.95f ; float yScale = itemScale ; float x = t * timeScale , y = 0 ; for ( InferenceEvent i : v ) {
private TreeSet gatherVariables ( TreeSet accumulator ) { if ( accumulator = = null ) { accumulator = new TreeSet ( ) ; } try { if ( this . listP ( ) & & ! ( this . empty ( ) ) ) { String arg0 = this . car ( ) ; Formula arg0F = new Formula ( ) ; arg0F . read ( arg0 ) ; arg0F . gatherVariables ( accumulator ) ; this . cdrAsFormula ( ) . gatherVariables ( accumulator ) ; } else if ( isVariable ( this . theFormula ) ) { accumulator . add ( this . theFormula ) ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return accumulator ; }
private static Boolean parseFalse ( CharacterInput input ) { CharsWrapper remaining = input . readCharsUntil ( END_OF_VALUE ) ; if ( ! remaining . contentEquals ( FALSE_END ) ) { throw new ParsingException ( " Invalid value f " + remaining + "  - Expected the boolean value false. " ) ; } return false ; }
public void testMultipleArrivingOneExistingWhereOneArrivingSameTimeAsExistingWithSameValuesAndRestArrivingLaterThanExisting ( ) { p = new EventTimeHistoryPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES , " " ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " hello " , 100L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 200L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world! " , 300L ) ) ; key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 3 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " startdate " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " enddate " ) , 199L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " startdate " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " enddate " ) , 299L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 2 ) ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " startdate " ) , 300L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " enddate " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES ) ; }
public Document visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . DocBR p , A arg ) { BaseRule baserule_ = p . baserule_ . accept ( this , arg ) ; ListSentence listsentence_ = new ListSentence ( ) ; for ( Sentence x : p . listsentence_ ) { listsentence_ . add ( x . accept ( this , arg ) ) ; } return new com . googlecode . opennars . parser . loan . Loan . Absyn . DocBR ( baserule_ , listsentence_ ) ; }
public void openSaveFile ( ) { FileDialog dialog = new FileDialog ( ( FileDialog ) null , " Save experience " , FileDialog . SAVE ) ; dialog . setVisible ( true ) ; String directoryName = dialog . getDirectory ( ) ; String fileName = dialog . getFile ( ) ; try { outExp = new PrintWriter ( new FileWriter ( directoryName + fileName ) ) ; } catch ( IOException ex ) { System . out . println ( " i/o error:  " + ex . getMessage ( ) ) ; } reasoner . addOutputChannel ( this ) ; }
public V getSome ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException ; }
public static boolean executeOperation ( final DerivationContext nal , final Task t ) { final Term content = t . getTerm ( ) ; if ( ! ( nal . memory . allowExecution ) | | ! ( content instanceof Operation ) ) { return false ; } final Operation op = ( Operation ) content ; final Operator oper = op . getOperator ( ) ; final Product prod = ( Product ) op . getSubject ( ) ; final Term arg = prod . term [ 0 ] ; if ( oper instanceof FunctionOperator ) { for ( int i = 0 ; i < prod . term . length - 1 ; i + + ) { if ( prod . term [ i ] . hasVarDep ( ) | | prod . term [ i ] . hasVarIndep ( ) ) { return false ; } } } else { if ( content . hasVarDep ( ) | | content . hasVarIndep ( ) ) { return false ; } } if ( ! arg . equals ( Term . SELF ) ) { return false ; } op . setTask ( t ) ; if ( ! oper . call ( op , nal . memory , nal . time ) ) { return false ; } if ( MiscFlags . DEBUG ) { System . out . println ( t . toStringLong ( ) ) ; } return true ; }
public void onPanelExpanded ( final View panel ) { nowPlayingSmallFragment . setVisibility ( View . GONE ) ; nowPlayingSmallFragment . setAlpha ( 1.0f ) ; mDrawerLayout . setDrawerLockMode ( DrawerLayout . LOCK_MODE_LOCKED_CLOSED ) ; }
public static void after ( ) throws Exception { List < URI > uris = new LinkedList < URI > ( ) ; uris . add ( URI . create ( SERVER_URI ) ) ; TestingClient c = new TestingClient ( uris , " default " , " " ) ; String json = c . asyncHttpGet ( " /default/_design/ " + TestingClient . MODE_PREFIX + DESIGN_DOC_W_REDUCE ) . get ( ) ; String rev = ( new JSONObject ( json ) ) . getString ( " _rev " ) ; c . asyncHttpDelete ( " /default/_design/ " + TestingClient . MODE_PREFIX + DESIGN_DOC_W_REDUCE + " ?rev= " + rev ) . get ( ) ; json = c . asyncHttpGet ( " /default/_design/ " + TestingClient . MODE_PREFIX + DESIGN_DOC_WO_REDUCE ) . get ( ) ; rev = ( new JSONObject ( json ) ) . getString ( " _rev " ) ; c . asyncHttpDelete ( " /default/_design/ " + TestingClient . MODE_PREFIX + DESIGN_DOC_WO_REDUCE + " ?rev= " + rev ) . get ( ) ;
public boolean isTimedOut ( ) { return timedout ; }
protected void checkState ( ) { if ( shutDown ) { throw new IllegalStateException ( " Shutting down " ) ; } assert isAlive ( ) : " IO Thread is not running. " ; }
public void insertTaskLink ( final TaskLink taskLink ) { final BudgetValue taskBudget = taskLink . budget ; taskLinks . putIn ( taskLink ) ; memory . conceptActivate ( this , taskBudget ) ; }
public List < Album > getAllAlbums ( boolean trackCountNeeded ) throws MPDServerException { if ( ! cacheOK ( ) ) { return super . getAllAlbums ( trackCountNeeded ) ; } Set < Album > albums = new HashSet < Album > ( ) ; Set < List < String > > albumset = cache . getUniqueAlbumSet ( ) ; for ( List < String > ai : albumset ) { Album album ; if ( " " . equals ( ai . get ( 2 ) ) ) { album = ( new Album ( ai . get ( 0 ) , new Artist ( ai . get ( 1 ) ) , false ) ) ; } else { album = ( new Album ( ai . get ( 0 ) , new Artist ( ai . get ( 2 ) ) , true ) ) ; } albums . add ( album ) ; } List < Album > result = new ArrayList < Album > ( albums ) ; Collections . sort ( result ) ; getAlbumDetails ( result , true ) ; return result ; }
public void testMultipleArrivingOneExistingWhereOneArrivingSameTimeAsExistingWithSameValuesAndRestArrivingLaterThanExistingNoCurrentFlag ( ) { p = new BitemporalHistoryPlanner ( ) ; p . configure ( configWithoutCurrentFlag ) ; existing . add ( new RowWithSchema ( existingSchemaWithoutCurrentFlag , " a " , " hello " , 100L , 100L , FAR_FUTURE_MILLIS , 1L , FAR_FUTURE_MILLIS ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " hello " , 100L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 200L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world! " , 300L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 4 ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . UPDATE ) ; assertEquals ( planned . get ( 1 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( planned . get ( 2 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( planned . get ( 3 ) . getMutationType ( ) , MutationType . INSERT ) ; Long systemStart1 = ( Long ) RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemstart " ) ; Long systemStart2 = ( Long ) RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " systemstart " ) ; Long systemStart3 = ( Long ) RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " systemstart " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemstart " ) , 1L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemend " ) , RowUtils . precedingTimestamp ( systemStart1 ) ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventend " ) , 199L ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " eventstart " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " eventend " ) , 299L ) ; assertTrue ( systemStart2 > = preplanSystemTime ) ; assertTrue ( systemStart2 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " value " ) , " world! " ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " eventstart " ) , 300L ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertTrue ( systemStart3 > = preplanSystemTime ) ; assertTrue ( systemStart3 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; }
public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { return opFact . version ( new OperationCallback ( ) {
private ViewResponseWithDocs parseDocsViewResult ( String json ) throws ParseException { final Collection < ViewRow > rows = new LinkedList < ViewRow > ( ) ; final Collection < RowError > errors = new LinkedList < RowError > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String id = elem . getString ( " id " ) ; String key = elem . getString ( " key " ) ; String value = elem . getString ( " value " ) ; rows . add ( new ViewRowWithDocs ( id , key , value , null ) ) ; } } if ( base . has ( " errors " ) ) { JSONArray ids = base . getJSONArray ( " errors " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { JSONObject elem = ids . getJSONObject ( i ) ; String from = elem . getString ( " from " ) ; String reason = elem . getString ( " reason " ) ; errors . add ( new RowError ( from , reason ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json:  " + json , 0 ) ; } } return new ViewResponseWithDocs ( rows , errors ) ; }
public NavigableSet < E > descendingSet ( ) { return new IndexedTreeSet ( m . descendingMap ( ) ) ; }
boolean run ( File file , ConfigFormat < ? > configFormat ) throws IOException ; FileNotFoundAction CREATE_EMPTY = ( f , c ) - > { Files . createFile ( f ) ; c . initEmptyFile ( f ) ; return false ; } ; FileNotFoundAction READ_NOTHING = ( f , c ) - > false ; FileNotFoundAction THROW_ERROR = ( f , c ) - > { throw new FileNotFoundException ( f . toString ( ) ) ; } ; static FileNotFoundAction copyData ( URL url ) { return ( f , c ) - > { Files . copy ( url . openStream ( ) , f ) ; return true ; } ; } static FileNotFoundAction copyData ( File file ) { return ( f , c ) - > { Files . copy ( file , f ) ; return true ; } ; } static FileNotFoundAction copyData ( InputStream data ) { return ( f , c ) - > { Files . copy ( data , f ) ; return true ; } ; } static FileNotFoundAction copyResource ( String resourcePath ) { return copyData ( FileNotFoundAction . class . getResource ( resourcePath ) ) ; } }
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
public void actionPerformed ( ActionEvent e ) { NWindow outputWindow = new NWindow ( " Timeline " , new TimelinePanel ( nar ) ) ; outputWindow . show ( 900 , 700 ) ; }
private static void writePadded ( int value , int numberOfDigits , CharacterOutput output ) { String str = Integer . toString ( value ) ; for ( int i = str . length ( ) ; i < numberOfDigits ; i + + ) { output . write ( '0' ) ; } output . write ( str ) ; }
protected static CharSequence newName ( char type , int index ) { int digits = ( index > = 256 ? 3 : ( index > = 16 ) ? 2 : 1 ) ; CharBuffer cb = CharBuffer . allocate ( 1 + digits ) . append ( type ) ; do { cb . append ( Character . forDigit ( index % 16 , 16 ) ) ; index / = 16 ; } while ( index ! = 0 ) ; return cb . compact ( ) ;
public void run ( ) { s . cells . click ( " " , " go-to " , " " ) ; s . nar . start ( 1 ) ; }
public void getDescription ( StringBuilder sb , int indent ) ; @Override public ChangeDetector copy ( ) ; }
public boolean checkAsyncMDN ( @Nonnull final AS2Message aMsg ) throws AS2Exception { try { final String sReturnMIC = aMsg . getMDN ( ) . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_MIC ) ; final MIC aReturnMIC = MIC . parse ( sReturnMIC ) ; final String sOrigMessageID = aMsg . getMDN ( ) . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_ORIG_MESSAGEID ) ; final String sPendingInfoFolder = AS2IOHelper . getSafeFileAndFolderName ( getModule ( ) . getSession ( ) . getMessageProcessor ( ) . attrs ( ) . getAsString ( IMessageProcessor . ATTR_PENDINGMDNINFO ) ) ; final String sPendingInfoFile = sPendingInfoFolder + FilenameHelper . UNIX_SEPARATOR_STR + AS2IOHelper . getFilenameFromMessageID ( sOrigMessageID ) ; final String sOriginalMIC ; final MIC aOriginalMIC ; final File aPendingFile ; try ( final NonBlockingBufferedReader aPendingInfoReader = FileHelper . getBufferedReader ( new File ( sPendingInfoFile ) , StandardCharsets . ISO_8859_1 ) ) { sOriginalMIC = aPendingInfoReader . readLine ( ) ; aOriginalMIC = MIC . parse ( sOriginalMIC ) ; aPendingFile = new File ( aPendingInfoReader . readLine ( ) ) ; } final String sDisposition = aMsg . getMDN ( ) . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_DISPOSITION ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " received MDN [ " + sDisposition + " ] " + aMsg . getLoggingText ( ) ) ; if ( aOriginalMIC = = null | | aReturnMIC = = null | | ! aReturnMIC . equals ( aOriginalMIC ) ) { m_aMICMatchingHandler . onMICMismatch ( aMsg , sOriginalMIC , sReturnMIC ) ; return false ; } m_aMICMatchingHandler . onMICMatch ( aMsg , sReturnMIC ) ; final File aPendingInfoFile = new File ( sPendingInfoFile ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " delete pendinginfo file :  " + aPendingInfoFile . getName ( ) + "  from pending folder :  " + sPendingInfoFolder + aMsg . getLoggingText ( ) ) ; if ( ! aPendingInfoFile . delete ( ) ) { if ( LOGGER . isErrorEnabled ( ) ) LOGGER . error ( " Error delete pendinginfo file  " + aPendingFile ) ; } if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " delete pending file :  " + aPendingFile . getName ( ) + "  from pending folder :  " + aPendingFile . getParent ( ) + aMsg . getLoggingText ( ) ) ; if ( ! aPendingFile . delete ( ) ) { if ( LOGGER . isErrorEnabled ( ) ) LOGGER . error ( " Error delete pending file  " + aPendingFile ) ; } } catch ( final IOException | AS2ComponentNotFoundException ex ) { LOGGER . error ( " Error checking async MDN " , ex ) ; return false ; } return true ; }
public ListIterator < T > listIterator ( int index ) { return ( new ArrayListListIterator < T > ( this ) ) ; }
boolean isType ( int type ) { return getType ( ) = = type ; }
private String _getDispositionText ( @Nonnull final Exception ex ) { if ( m_bSendExceptionsInMDN ) return CHttp . EOL + MessageParameters . getEscapedString ( StackTraceHelper . getStackAsString ( ex , true , CHttp . EOL ) ) ; return " " ; }
private HashAlgorithm lookupHashAlgorithm ( String algorithm ) { HashAlgorithm ha = HashAlgorithm . NATIVE_HASH ; if ( " crc " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . CRC32_HASH ; } else if ( " fnv1_32 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1_32_HASH ; } else if ( " fnv1_64 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1_64_HASH ; } else if ( " fnv1a_32 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1A_32_HASH ; } else if ( " fnv1a_64 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . FNV1A_64_HASH ; } else if ( " md5 " . equalsIgnoreCase ( algorithm ) ) { ha = HashAlgorithm . KETAMA_HASH ; } else { throw new IllegalArgumentException ( " Unhandled algorithm type:  " + algorithm ) ; } return ha ; }
public void addPartner ( @Nonnull final StringMap aNewPartner ) throws OpenAS2Exception { ValueEnforcer . notNull ( aNewPartner , " NewPartner " ) ; final String sName = aNewPartner . getAttributeAsString ( PARTNER_NAME ) ; if ( m_aMap . containsKey ( sName ) ) throw new OpenAS2Exception ( " Partner is defined more than once: ' " + sName + " ' " ) ; m_aMap . put ( sName , aNewPartner ) ; }
public boolean isTemporalInducted ( ) { return temporalInducted ; }
protected void updateComponent ( Task t , JLabel c ) { if ( c instanceof TaskLabel ) ( ( TaskLabel ) c ) . updateTask ( ) ;
protected void addTerm ( NARGraph g , Term t ) { if ( terms . add ( t ) ) { g . addVertex ( t ) ;
public void setPartners ( @Nonnull final PartnerMap aPartners ) { ValueEnforcer . notNull ( aPartners , " Partners " ) ; m_aMap . setAll ( aPartners . m_aMap ) ; }
public boolean isAnnouncing ( ) { return this . _state . isAnnouncing ( ) ; }
public void testEmptyVarargConstructor ( ) throws Exception { try { client = new MemcachedClient ( ) ;
public int hashCode ( ) { int hashCode = 1 ; synchronized ( LOCK ) { for ( final Iterator < ? > itr = this . iterator ( ) ; itr . hasNext ( ) ; ) { final Object obj = itr . next ( ) ; hashCode = 31 * hashCode + ( obj = = null ? 0 : obj . hashCode ( ) ) ; } } return hashCode ; }
public NARGraph add ( NAR n , Filter filter , Graphize graphize ) { graphize . onTime ( this , n . time ( ) ) ; Collection < ? extends Concept > cc = n . memory . getConcepts ( ) ; for ( Concept c : cc ) { float p = c . getPriority ( ) ; if ( ! filter . includePriority ( p ) ) { continue ; } if ( ! filter . includeConcept ( c ) ) { continue ; } graphize . onConcept ( this , c ) ; } graphize . onFinish ( this ) ; return this ;
public static Term make ( Term [ ] argList ) { if ( argList . length = = 1 ) { return argList [ 0 ] ; } if ( argList . length ! = 2 ) { return null ; } if ( ( argList [ 0 ] instanceof SetInt ) & & ( argList [ 1 ] instanceof SetInt ) ) { TreeSet < Term > set = new TreeSet < Term > ( ( ( CompoundTerm ) argList [ 0 ] ) . cloneTermsList ( ) ) ; set . removeAll ( ( ( CompoundTerm ) argList [ 1 ] ) . cloneTermsList ( ) ) ; return SetInt . make ( set ) ; } return new DifferenceInt ( argList ) ; }
public static Term stringToTerm ( NAR nar , String s ) { Narsese narsese = new Narsese ( nar . memory ) ; Task ret ; try { ret = narsese . parseTask ( s + Symbols . JUDGMENT_MARK ) ; } catch ( Narsese . InvalidInputException ex ) { throw new IllegalStateException ( " Could not parse task " , ex ) ; } if ( ret = = null ) { return null ; } return ret . getTerm ( ) ; }
public InnateOperator operator ( ) { switch ( temporalOrder ) { case TemporalRules . ORDER_FORWARD : return InnateOperator . IMPLICATION_AFTER ; case TemporalRules . ORDER_CONCURRENT : return InnateOperator . IMPLICATION_WHEN ; case TemporalRules . ORDER_BACKWARD : return InnateOperator . IMPLICATION_BEFORE ; } return InnateOperator . IMPLICATION ; }
public static IParser createParser ( String theory ) { return new Parser ( theory ) ; }
protected boolean isCached ( ) { return mIsEnabled & & mCache . refresh ( ) ; }
@Deprecated static BudgetValue solutionEval ( final Sentence problem , final Sentence solution , final Task task , final Memory memory ) { throw new IllegalStateException ( " Moved to TemporalRules.java " ) ; }
public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) ) ; }
public void testLongEncoding ( ) throws Exception { assertLong ( Long . MIN_VALUE ) ; assertLong ( 1 ) ; assertLong ( 23852 ) ; assertLong ( 0 L ) ; assertLong ( - 1 ) ; assertLong ( - 23835 ) ; assertLong ( Long . MAX_VALUE ) ; }
public V put ( K key , V value ) { V prev = null ; Trie . Node node = trie . addSequence ( key ) ; if ( node ! = null & & node instanceof TrieMapNode ) { TrieMapNode < V > trieMapNode = ( TrieMapNode < V > ) node ; if ( trieMapNode . value ! = null ) prev = trieMapNode . value ; trieMapNode . value = value ; } return prev ; }
private List < Row > createPlannedMutations ( ) { List < Row > records = new ArrayList < > ( ) ; long beginTime = 1_000_000_000 ; for ( int i = 0 ; i < INPUT_ROWS ; + + i ) { Row insertRow = new RowWithSchema ( planningSchema , SYMBOLS [ i % SYMBOLS . length ] , beginTime + i , Integer . toString ( i ) , i , i % 10 , i + i % 10 ) ; records . add ( PlannerUtils . setMutationType ( insertRow , MutationType . UPSERT ) ) ; Row updateRow = RowUtils . set ( insertRow , " leavesqty " , ( i % 10 ) + 10 ) ; records . add ( PlannerUtils . setMutationType ( updateRow , MutationType . UPSERT ) ) ; } return records ; }
void limitBuffer ( int incomingDataSize ) { Document doc = ioText . getDocument ( ) ; int overLength = doc . getLength ( ) + incomingDataSize - maxIOTextSize ; if ( overLength > 0 ) { try {
protected byte [ ] decompress ( byte [ ] in ) { ByteArrayOutputStream bos = null ; if ( in ! = null ) { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis ; try { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Failed to decompress data " , e ) ; bos = null ; } } return bos = = null ? null : bos . toByteArray ( ) ; }
public ICommonsOrderedMap < String , Certificate > getCertificates ( ) throws OpenAS2Exception { m_aRWLock . readLock ( ) . lock ( ) ; try {
NoopOperation noop ( OperationCallback cb ) ; DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( String key , long casId , int flags , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }
public long estimateSize ( ) { return internalSpliterator . estimateSize ( ) ; }
public void onClick ( final DialogInterface dialog , final int which ) { savePlaylist ( mPlaylistToSave ) ; }
public boolean equals ( final Object that ) { if ( that = = this ) return true ; if ( ! ( that instanceof Term ) ) return false ; return name ( ) . equals ( ( ( Term ) that ) . name ( ) ) ; }
public static void before ( ) throws Exception { zk = new TestingServer ( 2181 , true ) ; }
public Concept newConcept ( BudgetValue b , Term t , Memory m ) { Bag < TaskLink , Task > taskLinks = new LevelBag < > ( Parameters . TASK_LINK_BAG_LEVELS , Parameters . TASK_LINK_BAG_SIZE ) ; Bag < TermLink , TermLink > termLinks = new LevelBag < > ( Parameters . TERM_LINK_BAG_LEVELS , Parameters . TERM_LINK_BAG_SIZE ) ; return new Concept ( b , t , taskLinks , termLinks , m ) ; }
public void testIntervalSegmentTree3 ( ) { List < SegmentTree . Data . IntervalData < String > > intervals = new ArrayList < SegmentTree . Data . IntervalData < String > > ( ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 5 , 20 , " a " ) ) ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 10 , 30 , " b " ) ) ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 12 , 15 , " c " ) ) ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 15 , 20 , " d " ) ) ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 17 , 19 , " e " ) ) ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 30 , 40 , " f " ) ) ) ; DynamicSegmentTree < SegmentTree . Data . IntervalData < String > > tree = new DynamicSegmentTree < SegmentTree . Data . IntervalData < String > > ( intervals ) ; SegmentTree . Data . IntervalData < String > query = tree . query ( 6 , 7 ) ; assertTrue ( " Segment Tree query error. returned= " + query , tree , collectionsEqual ( query . getData ( ) , Arrays . asList ( " a " ) ) ) ; }
public String operator ( ) { return Character . toString ( Symbols . SET_EXT_OPENER ) ; }
protected void reload ( ) { if ( memory = = null ) throw new RuntimeException ( " Memory not set " ) ; this . now = memory . time ( ) ; this . latencyMin = memory . param . cycles ( forgetRate ) ; float forgetCycles = memory . param . cycles ( forgetRate ) ; int j = 0 ; int originalSize = size ( ) ; numPriorityThru = mass = 0 ; overcapacity = originalSize > = capacity ; int numToRemove = originalSize - capacity ; if ( originalSize > = capacity ) { toRemove . clear ( ) ; toRemove . setCapacity ( numToRemove + 1 ) ; } E e = null ; for ( final Map . Entry < K , E > ee : items . entrySet ( ) ) { e = ee . getValue ( ) ; if ( forgettable ( e ) ) BudgetFunctions . forgetPeriodic ( e . budget , forgetCycles , Parameters . FORGET_QUALITY_RELATIVE , now ) ; float p = e . getPriority ( ) ; mass + = p ; numPriorityThru + + ; if ( fireable ( e ) ) { if ( j + + % 2 = = 0 ) pending . addFirst ( e ) ; else pending . addLast ( e ) ; } else if ( removeable ( e ) ) { toRemove . add ( e ) ; } reloadIteration + + ; } avgPriority = numPriorityThru / mass ; if ( numToRemove > 0 ) { int rj = 0 ; for ( final E r : toRemove ) { E removed = removeItem ( r . name ( ) ) ; if ( removed = = null ) throw new RuntimeException ( " Unable to remove item:  " + r ) ; if ( rj + + = = numToRemove ) break ; } } adjustActivationThreshold ( ) ; adjustForgettingThreshold ( ) ; if ( pending . isEmpty ( ) & & ( e ! = null ) ) pending . add ( e ) ;
void addScore ( Task q , Task a , boolean correct , float confidence ) { Term questionTerm = q . getContent ( ) ; long questionTime = q . getCreationTime ( ) ; long answerTime = a . getCreationTime ( ) ; long time = nar . time ( ) ; if ( questionTime > answerTime ) { } long delay = time - questionTime ; double s ; if ( correct ) { s = confidence / ( 1 + delay * delayFactor ) ; } else { s = - confidence ; } Double existingScore = questionScores . get ( questionTerm ) ; if ( existingScore = = null ) { questionScores . put ( questionTerm , s ) ; } else { questionScores . put ( questionTerm , Math . max ( s , existingScore ) ) ; } updateScore ( ) ; System . out . println ( questionTime + " , " + delay + " :  " + q . sentence + "  |  " + a . sentence . truth + "   +/-( " + s + " )      " + score + "  of  " + qanswered + " / " + questionScores . size ( ) + "  < " + answered . size ( ) + " > " ) ; }
public E pickOut ( final CharSequence key ) { final E picked = nameTable . remove ( key ) ; outOfBase ( picked ) ; return picked ; }
public CountDownLatch broadcastOperation ( BroadcastOpFactory of ) { return broadcastOperation ( of , locator . getAll ( ) ) ; }
public < T > T set ( List < String > path , Object value ) { switch ( path . size ( ) ) { case 0 :
protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ) ; HashMap < String , Object > item = songlist . get ( position ) ; item . get ( " marked " ) ; if ( item . get ( " marked " ) . equals ( true ) ) { item . put ( " marked " , false ) ; } else { item . put ( " marked " , true ) ; } ( ( SimpleAdapter ) getListAdapter ( ) ) . notifyDataSetChanged ( ) ; }
public final ICertificateFactory getCertificateFactory ( ) throws ComponentNotFoundException { return ( ICertificateFactory ) getComponent ( ICertificateFactory . COMPONENT_ID_CERTIFICATE_FACTORY ) ; }
public boolean noneMatch ( Predicate < ? super E > predicate ) { return wrapped . noneMatch ( e - > predicate . test ( unwrap ( e ) ) ) ; }
public final void addCallback ( final FullTrackInfoUpdate listener ) { mFullTrackInfoListener = listener ; }
public void configure ( Config config ) { kvpDelimiter = resolveDelimiter ( config . getString ( KVP_DELIMITER_CONFIG_NAME ) ) ; fieldDelimiter = resolveDelimiter ( config . getString ( FIELD_DELIMITER_CONFIG_NAME ) ) ; schema = SchemaFactory . create ( config . getConfig ( SCHEMA_CONFIG ) , true ) . getSchema ( ) ; if ( config . hasPath ( TIMESTAMP_FORMAT_CONFIG_NAME ) ) { rowValueMetadata . put ( RowUtils . RowValueMetadata . TIMESTAMP_FORMATS ,
private static File createSingleMessage ( File temp ) { ProtobufSingleMessage . SingleExample msg = ProtobufSingleMessage . SingleExample . newBuilder ( ) . setString ( " single message " ) . setDouble ( 1.1D ) . setFloat ( 1.1F ) . setInt32 ( 2 ) . setInt64 ( 2L ) . setUint32 ( 3 ) . setUint64 ( 3L ) . setSint32 ( 4 ) . setSint64 ( 4L ) . setFixed32 ( 5 ) . setFixed64 ( 5L ) . setSfixed32 ( 6 ) . setSfixed64 ( 6L ) . setBoolean ( true ) . setBytes ( ByteString . copyFrom ( " test " . getBytes ( ) ) ) . setEnum ( ProtobufSingleMessage . SingleExample . EnumExample . TWO ) . setNested ( ProtobufSingleMessage . SingleExample . NestedExample . newBuilder ( ) . setNested ( " nested message " ) . build ( ) ) . putMapInt ( " one " , 1 ) . addRepeatingMessage ( ProtobufSingleMessage . SingleExample . NestedExample . newBuilder ( ) . setNested ( " nested repeating message " ) ) . addRepeatingInt32 ( 7 ) . addRepeatingEnum ( ProtobufSingleMessage . SingleExample . EnumExample . THREE ) . setOneofString ( " oneof string " ) . build ( ) ; try ( FileOutputStream writer = new FileOutputStream ( temp ) ) { msg . writeTo ( writer ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return temp ; }
public void onCreate ( final Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; mApp . setupServiceBinder ( ) ; if ( mApp . isTabletUiEnabled ( ) ) { setContentView ( R . layout . main_activity_nagvigation_tablet ) ; } else { setContentView ( R . layout . main_activity_nagvigation ) ; } mTextView = initializeTextView ( ) ; mLibraryRootFrame = findViewById ( R . id . library_root_frame ) ; mOutputsRootFrame = findViewById ( R . id . outputs_root_frame ) ; mIsDualPaneMode = findViewById ( R . id . nowplaying_dual_pane ) ! = null ; mDrawerLayout = ( DrawerLayout ) findViewById ( R . id . drawer_layout ) ; mDrawerToggle = initializeDrawerToggle ( ) ; mDrawerLayout . setDrawerListener ( mDrawerToggle ) ; mDrawerList = initializeDrawerList ( ) ; mFragmentManager = getSupportFragmentManager ( ) ; mFragmentManager . addOnBackStackChangedListener ( this ) ; mLibraryFragment = initializeLibraryFragment ( ) ; mOutputsFragment = initializeOutputsFragment ( ) ; mQueueFragment = ( QueueFragment ) mFragmentManager . findFragmentById ( R . id . queue_fragment ) ; mNowPlayingPager = initializeNowPlayingPager ( ) ; if ( savedInstanceState = = null ) { switchMode ( DisplayMode . MODE_LIBRARY ) ; } else { switchMode ( ( DisplayMode ) savedInstanceState . getSerializable ( EXTRA_DISPLAY_MODE ) ) ; } mHeaderTitle = ( TextView ) findViewById ( R . id . header_title ) ; mHeaderDragView = findViewById ( R . id . header_dragview ) ; mHeaderPlayQueue = initializeHeaderPlayQueue ( ) ; final ImageButton headerOverflowMenu = ( ImageButton ) findViewById ( R . id . header_overflow_menu ) ; if ( headerOverflowMenu ! = null ) { mHeaderOverflowPopupMenu = initializeHeaderOverflowPopup ( headerOverflowMenu ) ; } mSlidingLayout = initializeSlidingLayout ( savedInstanceState ) ; refreshQueueIndicator ( false ) ; mApp . setPersistentOverride ( false ) ; }
public ArrayList < Task > cutoutAppend ( int ind1 , int ind2 , ArrayList < Task > first , ArrayList < Task > second ) { ArrayList < Task > res = new ArrayList < > ( ) ; for ( int i = ind1 ; i < = first . size ( ) + ind2 ; i + + ) { res . add ( first . get ( i ) ) ; } for ( Task t : second ) { res . add ( t ) ; } return res ; }
@Override public Chart newChart ( ) { return new LineChart ( trace . getCharts ( " concept.priority.mean " ) ) . height ( 1 ) ; }
< T extends IProcessorModule > T getModuleOfClass ( @Nonnull Class < T > aClass ) ; void startActiveModules ( ) ; void stopActiveModules ( ) ; @Nonnull @ReturnsMutableCopy List < IProcessorActiveModule > getAllActiveModules ( ) ; }
public void deriveBlankStepName ( ) throws Exception { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( MorphlineDeriver . STEP_NAME_CONFIG , " " ) ; final Config config = ConfigFactory . parseMap ( paramMap ) ; Deriver deriver = new MorphlineDeriver ( ) ; deriver . configure ( config ) ; }
public SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { throw new UnsupportedOperationException ( " SASL is not supported for  " + " ASCII protocol " ) ;
public List < String > listAlbums ( String artist , boolean sortInsensitive , boolean includeUnknownAlbum ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; boolean foundSongWithoutAlbum = false ; List < String > response = mpdConnection . sendCommand ( MPDCommand . MPD_CMD_LIST_TAG , MPDCommand . MPD_TAG_ALBUM , artist ) ; ArrayList < String > result = new ArrayList < String > ( ) ; for ( String line : response ) { String name = line . substring ( " Album:  " . length ( ) ) ; if ( name . length ( ) > 0 ) { result . add ( name ) ; } else { foundSongWithoutAlbum = true ; } } if ( sortInsensitive ) Collections . sort ( result , String . CASE_INSENSITIVE_ORDER ) ; else Collections . sort ( result ) ; if ( ( includeUnknownAlbum = = true ) & & ( foundSongWithoutAlbum = = true ) ) { result . add ( " " ) ; } return result ; }
public void addAll ( final Iterable < Music > collection ) throws MPDServerException { final CommandQueue commandQueue = new CommandQueue ( ) ; for ( final Music music : collection ) { commandQueue . add ( MPD_CMD_PLAYLIST_ADD , music . getFullpath ( ) ) ; } commandQueue . send ( mMPD . getMpdConnection ( ) ) ; refresh ( ) ; }
public static void eliminateVariableOfConditionAbductive ( int figure , Sentence sentence , Sentence belief , Memory memory ) { Term T1 = sentence . content . clone ( ) ; Term T2 = belief . content . clone ( ) ; Term S1 = ( ( Statement ) T2 ) . getSubject ( ) ; Term P1 = ( ( Statement ) T2 ) . getPredicate ( ) ; Term S2 = ( ( Statement ) T1 ) . getSubject ( ) ; Term P2 = ( ( Statement ) T1 ) . getPredicate ( ) ; if ( figure = = 21 ) { HashMap < Term , Term > res1 = new HashMap < > ( ) ; HashMap < Term , Term > res2 = new HashMap < > ( ) ; Variables . findSubstitute ( Symbols . VAR_INDEPENDENT , P1 , S2 , res1 , res2 ) ; ( ( CompoundTerm ) T1 ) . applySubstitute ( res2 ) ; ( ( CompoundTerm ) T2 ) . applySubstitute ( res1 ) ; if ( S1 instanceof Conjunction ) { for ( Term s1 : ( ( CompoundTerm ) S1 ) . cloneTerms ( ) ) { HashMap < Term , Term > res3 = new HashMap < > ( ) ; HashMap < Term , Term > res4 = new HashMap < > ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , P2 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) S1 ) . cloneTerms ( ) ) { ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ! s2 . equals ( s1 ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , memory ) ; memory . doublePremiseTask ( s2 , truth , budget ) ; } } } } } if ( P2 instanceof Conjunction ) { for ( Term s1 : ( ( CompoundTerm ) P2 ) . cloneTerms ( ) ) { HashMap < Term , Term > res3 = new HashMap < > ( ) ; HashMap < Term , Term > res4 = new HashMap < > ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , S1 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) P2 ) . cloneTerms ( ) ) { ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ! s2 . equals ( s1 ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , memory ) ; memory . doublePremiseTask ( s2 , truth , budget ) ; } } } } } } if ( figure = = 12 ) { HashMap < Term , Term > res1 = new HashMap < > ( ) ; HashMap < Term , Term > res2 = new HashMap < > ( ) ; Variables . findSubstitute ( Symbols . VAR_INDEPENDENT , S1 , P2 , res1 , res2 ) ; ( ( CompoundTerm ) T1 ) . applySubstitute ( res2 ) ; ( ( CompoundTerm ) T2 ) . applySubstitute ( res1 ) ; if ( S2 instanceof Conjunction ) { for ( Term s1 : ( ( CompoundTerm ) S2 ) . cloneTerms ( ) ) { HashMap < Term , Term > res3 = new HashMap < > ( ) ; HashMap < Term , Term > res4 = new HashMap < > ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , P1 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) S2 ) . cloneTerms ( ) ) { ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ! s2 . equals ( s1 ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , memory ) ; memory . doublePremiseTask ( s2 , truth , budget ) ; } } } } } if ( P1 instanceof Conjunction ) { for ( Term s1 : ( ( CompoundTerm ) P1 ) . cloneTerms ( ) ) { HashMap < Term , Term > res3 = new HashMap < > ( ) ; HashMap < Term , Term > res4 = new HashMap < > ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , S2 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) P1 ) . cloneTerms ( ) ) { ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ! s2 . equals ( s1 ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , memory ) ; memory . doublePremiseTask ( s2 , truth , budget ) ; } } } } } } if ( figure = = 11 ) { HashMap < Term , Term > res1 = new HashMap < > ( ) ; HashMap < Term , Term > res2 = new HashMap < > ( ) ; Variables . findSubstitute ( Symbols . VAR_INDEPENDENT , S1 , S2 , res1 , res2 ) ; ( ( CompoundTerm ) T1 ) . applySubstitute ( res2 ) ; ( ( CompoundTerm ) T2 ) . applySubstitute ( res1 ) ; if ( P1 instanceof Conjunction ) { for ( Term s1 : ( ( CompoundTerm ) P1 ) . cloneTerms ( ) ) { HashMap < Term , Term > res3 = new HashMap < > ( ) ; HashMap < Term , Term > res4 = new HashMap < > ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , P2 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) P1 ) . cloneTerms ( ) ) { if ( ! ( s2 instanceof CompoundTerm ) ) continue ; ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ( ! s2 . equals ( s1 ) ) & & ( sentence . truth ! = null ) & & ( belief . truth ! = null ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , memory ) ; memory . doublePremiseTask ( s2 , truth , budget ) ; } } } } } if ( P2 instanceof Conjunction ) { for ( Term s1 : ( ( CompoundTerm ) P2 ) . cloneTerms ( ) ) { HashMap < Term , Term > res3 = new HashMap < > ( ) ; HashMap < Term , Term > res4 = new HashMap < > ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , P1 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) P2 ) . cloneTerms ( ) ) { if ( ! ( s2 instanceof CompoundTerm ) ) continue ; ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ! s2 . equals ( s1 ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , memory ) ; memory . doublePremiseTask ( s2 , truth , budget ) ; } } } } } } if ( figure = = 22 ) { HashMap < Term , Term > res1 = new HashMap < > ( ) ;
public void save ( @Nonnull @WillClose final OutputStream aOS , @Nonnull final char [ ] aPassword ) throws OpenAS2Exception { try {
void processPreviousRequest ( ) { new Thread ( new Runnable ( ) { @Override public void run ( ) { try { final MPDApplication app = ( MPDApplication ) getApplication ( ) ; if ( app ! = null ) { app . oMPDAsyncHelper . oMPD . previous ( ) ; } } catch ( MPDServerException e ) { Log . w ( MPDApplication . TAG , e . getMessage ( ) ) ; } } } ) . start ( ) ; final Intent service = new Intent ( this , NotificationService . class ) ; service . setAction ( ACTION_UPDATE_INFO ) ; startService ( service ) ; }
protected void paintComponent ( Graphics gg ) { Graphics2D g = ( Graphics2D ) gg ; g . setColor ( Color . blue ) ; if ( pickRecord ! = null ) { DockingRegionTabbed tabbed
public void testBasic ( ) { for ( final ECryptoAlgorithmCrypt e : ECryptoAlgorithmCrypt . values ( ) ) { assertTrue ( StringHelper . hasText ( e . getID ( ) ) ) ; assertNotNull ( e . getOID ( ) ) ; assertSame ( e , ECryptoAlgorithmCrypt . getFromIDOrNull ( e . getID ( ) ) ) ; assertSame ( e , ECryptoAlgorithmCrypt . getFromIDOrDefault ( e . getID ( ) , ECryptoAlgorithmCrypt . CRYPT_3DES ) ) ; assertSame ( e , ECryptoAlgorithmCrypt . getFromIDOrThrow ( e . getID ( ) ) ) ; } assertSame ( ECryptoAlgorithmCrypt . CRYPT_3DES , ECryptoAlgorithmCrypt . getFromIDOrNull ( " 3des " ) ) ; assertSame ( ECryptoAlgorithmCrypt . CRYPT_3DES , ECryptoAlgorithmCrypt . getFromIDOrNull ( " 3DES " ) ) ; }
public String getClientInfo ( @Nonnull final Socket aSocket ) { return aSocket . getInetAddress ( ) . getHostAddress ( ) + "   " + aSocket . getPort ( ) ; }
private static boolean testSplayTree ( ) { String bstName = " Splay Tree " ; BinarySearchTree < Integer > bst = new SplayTree < Integer > ( ) ; Collection < Integer > bstCollection = bst . toCollection ( ) ; if ( ( validateStructure | | validateContents ) & & ! testTree ( bst , Type . Integer , bstName ) ) return false ; if ( ! testCollection ( bstCollection , Type . Integer , bstName ) ) return false ; return true ; }
public void setUp ( ) throws Exception { } @After public void tearDown ( ) throws Exception { } @Test ( expected = EOFException . class ) public void readBufferFromEmpty ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " " . getBytes ( ) ) ; byte [ ] buf = new byte [ 17 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( buf , 0 , buf . length ) ; fail ( " An EOFException should have been thrown " ) ; } @Test public void readPastEOS ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " 3 \ n123 \ r \ n0 \ r \ n " . getBytes ( ) ) ; byte [ ] buf = new byte [ 17 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( buf , 0 , buf . length ) ; assertEquals ( " read correct num of bytes " , ret , 3 ) ; assertEquals ( " read the chunk " , new String ( buf , 0 , ret ) , " 123 " ) ; ret = cIS . read ( buf , 0 , buf . length ) ; assertEquals ( " read past EOS " , ret , - 1 ) ; } @Test ( expected = EOFException . class ) public void readByteFromEmpty ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " " . getBytes ( ) ) ; byte [ ] buf = new byte [ 17 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( ) ; fail ( " An EOFException should have been thrown " ) ; } @Test public void readOneChunkBuffer ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " 3 \ n123 " . getBytes ( ) ) ; byte [ ] buf = new byte [ 3 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( buf , 0 , buf . length ) ; assertEquals ( " Read one chunk: 3 chars read " , 3 , ret ) ; assertEquals ( " Read one Chunk: corect data returned " , new String ( buf ) , " 123 " ) ; } @Test public void readOneChunkBytes ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " 3 \ n123 " . getBytes ( ) ) ; byte [ ] buf = new byte [ 3 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( ) ; assertEquals ( " Read first char " , '1' , ret ) ; ret = cIS . read ( ) ; assertEquals ( " Read second char " , '2' , ret ) ; ret = cIS . read ( ) ; assertEquals ( " Read third char " , '3' , ret ) ; } @Test public void read1 ( ) throws Exception { } @Test public void readTwoChunkBuffer ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " 2 \ r \ n12 \ r \ n1 \ na \ r \ n0 \ r \ n " . getBytes ( ) ) ; byte [ ] buf = new byte [ 3 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( buf , 0 , buf . length ) ; assertEquals ( " Read two chunk: 3 chars read " , 3 , ret ) ; assertEquals ( " Read one Chunk: corect data returned " , " 12a " , new String ( buf ) ) ; } @Test public void readTwoChunkBufferMultipleReads ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " 2 \ r \ n12 \ r \ n1 \ na \ r \ n0 \ r \ n " . getBytes ( ) ) ; byte [ ] buf = new byte [ 3 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( buf , 0 , 1 ) ; assertEquals ( " Read two chunk-1: 1 chars read " , 1 , ret ) ; assertEquals ( " Read one Chunk-1: correct data returned " , '1' , buf [ 0 ] ) ; ret = cIS . read ( buf , 0 , 1 ) ; assertEquals ( " Read two chunk-1: 1 chars read " , 1 , ret ) ; assertEquals ( " Read one Chunk-1: correct data returned " , '2' , buf [ 0 ] ) ; ret = cIS . read ( buf , 0 , 1 ) ; assertEquals ( " Read two chunk-1: 1 chars read " , 1 , ret ) ; assertEquals ( " Read one Chunk-1: correct data returned " , 'a' , buf [ 0 ] ) ; } @Test public void readTwoChunkByteMultipleReads ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " 2 \ r \ n12 \ r \ n1 \ na \ r \ n0 \ r \ n " . getBytes ( ) ) ; byte [ ] buf = new byte [ 3 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( ) ; assertEquals ( " Read one Chunk-1: correct data returned " , '1' , ret ) ; ret = cIS . read ( ) ; assertEquals ( " Read one Chunk-1: correct data returned " , '2' , ret ) ; ret = cIS . read ( ) ; assertEquals ( " Read one Chunk-1: correct data returned " , 'a' , ret ) ; } }
private boolean doesAppendRaw ( ) { return ConfigUtils . getOrElse ( config , APPEND_RAW_ENABLED_CONFIG , APPEND_RAW_ENABLED_DEFAULT ) ; }
public void testEmptyDCGAction ( ) throws InvalidTermException { String s = " {} " ; Parser p = new Parser ( s ) ; Struct result = new Struct ( " {} " ) ; assertEquals ( result , p . nextTerm ( false ) ) ; }
abstract void learnFromInstance ( Instance inst , ModelAggregatorProcessor proc ) ; @Override protected boolean isLeaf ( ) { return true ; } @Override protected FoundNode filterInstanceToLeaf ( Instance inst , SplitNode parent , int parentBranch ) { return new FoundNode ( this , parent , parentBranch ) ; } }
public void testMoreThanOneExists ( ) { Validation v = new ExactlyOnePathExistsValidation ( " hello " , " world " ) ; ValidationResult vr = v . validate ( ConfigFactory . parseString ( " hello = 2 \ nworld = 5 " ) ) ; assertEquals ( vr . getValidity ( ) , Validity . INVALID ) ; }
< T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > append ( String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; Future < Boolean > prepend ( String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > prepend ( String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public abstract void setTitle ( String title ) ; public abstract void setBag ( AbstractBag < E > concepts ) ; public abstract void post ( String str ) ; public abstract void refresh ( String string ) ; public boolean isActive ( ) ; public abstract void stop ( ) ; }
public void onBufferingUpdate ( MediaPlayer mp , int percent ) { } @Override public boolean onError ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public boolean onInfo ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public void connectionFailed ( String message ) { Toast . makeText ( this , " Connection Failed ! " , Toast . LENGTH_SHORT ) . show ( ) ; } @Override public void connectionSucceeded ( String message ) { } }
public boolean equals ( Object that ) { if ( that = = this ) return true ; if ( that instanceof UniqueInterval ) { UniqueInterval ui = ( UniqueInterval ) that ; return ( ui . id = = id & & ui . parent . equals ( parent ) & & ui . magnitude = = magnitude ) ; } return false ; }
public void testLookupsClone ( ) { setupNodes ( 4 ) ; assertSame ( nodes [ 0 ] . toString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " dustin " ) . toString ( ) ) ; assertSame ( nodes [ 2 ] . toString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " noelani " ) . toString ( ) ) ; assertSame ( nodes [ 0 ] . toString ( ) , locator . getReadonlyCopy ( ) . getPrimary ( " some other key " ) . toString ( ) ) ;
private int refresh ( ) throws MPDServerException { if ( firstRefreash ) { MPDStatus status = this . mpd . getStatus ( ) ; List < String > response = this . mpd . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_LIST ) ; List < Music > playlist = Music . getMusicFromList ( response , false ) ; list . clear ( ) ; list . addAll ( playlist ) ; lastPlaylistVersion = status . getPlaylistVersion ( ) ; firstRefreash = false ; } else { this . lastPlaylistVersion = this . refresh ( lastPlaylistVersion ) ; } return this . lastPlaylistVersion ; }
public final void removeCallback ( final TrackInfoUpdate ignored ) { mTrackInfoListener = null ; }
static String removeDiscReference ( final String album ) { String cleanedAlbum = album . toLowerCase ( ) ; for ( final String discReference : DISC_REFERENCES ) { cleanedAlbum = cleanedAlbum . replaceAll ( discReference + " \\ s* \\ d+ " , "   " ) ; } return cleanedAlbum ; }
public boolean equals ( Object that ) { return ( that instanceof Term ) & & ( compareTo ( ( Term ) that ) = = 0 ) ; }
DataHistory getHistory ( ) ; void setHistory ( @Nullable DataHistory aHistory ) ; String getMessageID ( ) ; void setMessageID ( String sMessageID ) ; @Nonnull Partnership getPartnership ( ) ; void setPartnership ( @Nullable Partnership aPartnership ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; }
public void initDynamicComponent ( final ISession aSession , final Map < String , String > aOptions ) throws OpenAS2Exception { super . initDynamicComponent ( aSession , aOptions ) ; getParameterRequired ( PARAM_PORT ) ; }
public boolean containsAll ( Collection < ? > c ) { return wrapped . contains ( c ) ; }
private void jButton5ActionPerformed ( java . awt . event . ActionEvent evt ) { try { Desktop . getDesktop ( ) . browse ( new URI ( " http://webchat.freenode.net/?channels=nars " ) ) ;
void resemblance ( Term term1 , Term term2 , Judgement belief , Sentence sentence , int figure ) { if ( Statement . invalidStatement ( term1 , term2 ) ) return ; Statement st1 = ( Statement ) belief . getContent ( ) ; Statement st2 = ( Statement ) sentence . getContent ( ) ; CompoundTerm . TemporalOrder order1 = st1 . getTemporalOrder ( ) ; CompoundTerm . TemporalOrder order2 = st2 . getTemporalOrder ( ) ; CompoundTerm . TemporalOrder order = CompoundTerm . temporalInferenceWithFigure ( order1 , order2 , figure ) ; if ( order = = CompoundTerm . TemporalOrder . UNSURE ) return ; Term statement = Statement . make ( st1 , term1 , term2 , order , this . memory ) ; TruthValue truth = null ; BudgetValue budget ; Task task = this . memory . currentTask ; if ( sentence instanceof Question ) { budget = this . budgetfunctions . backward ( belief . getTruth ( ) ) ; } else { if ( sentence instanceof Goal ) truth = TruthFunctions . desireStrong ( sentence . getTruth ( ) , belief . getTruth ( ) ) ; else truth = TruthFunctions . resemblance ( belief . getTruth ( ) , sentence . getTruth ( ) ) ; budget = this . budgetfunctions . forward ( truth ) ; } this . memory . doublePremiseTask ( budget , statement , truth ) ; }
public static double compare ( String label , BagBuilder b , final int iterations , final int randomAccesses , final float insertRatio , int repeats , int warmups ) { Performance p = new Performance ( label , repeats , warmups ) { @Override public void init ( ) { } @Override public void run ( boolean warmup ) { AbstractBag bag = b . newBag ( ) ; randomBagIO ( bag , randomAccesses , insertRatio ) ; for ( int i = 0 ; i < iterations ; i + + ) iterate ( bag ) ; if ( ! warmup ) { } } } ; return p . getCycleTimeMS ( ) ;
public void testAllClone ( ) throws Exception { setupNodes ( 4 ) ; Collection < MemcachedNode > all = locator . getReadonlyCopy ( ) . getAll ( ) ; assertEquals ( 4 , all . size ( ) ) ; }
@Override public void run ( ) { setCaretPosition ( getDocument ( ) . getLength ( ) ) ; }
public MimeBodyPart verify ( @Nonnull final MimeBodyPart aPart , @Nonnull final X509Certificate aX509Cert ) throws GeneralSecurityException , IOException , MessagingException , CMSException , OperatorCreationException { if ( ! isSigned ( aPart ) ) throw new GeneralSecurityException ( " Content-Type indicates data isn't signed " ) ; final MimeMultipart aMainParts = ( MimeMultipart ) aPart . getContent ( ) ; final SMIMESigned aSignedPart = new SMIMESigned ( aMainParts ) ; final SignerInformationVerifier aSIV = new JcaSimpleSignerInfoVerifierBuilder ( ) . setProvider ( BouncyCastleProvider . PROVIDER_NAME ) . build ( aX509Cert ) ; for ( final Object aSigner : aSignedPart . getSignerInfos ( ) . getSigners ( ) ) { final SignerInformation aSignerInfo = ( SignerInformation ) aSigner ; if ( ! aSignerInfo . verify ( aSIV ) ) throw new SignatureException ( " Verification failed " ) ; } return aSignedPart . getContent ( ) ; }
public void testLongDecode ( ) { assertEquals ( 4294967296L , decodeLong ( new byte [ ] { 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 } , 0 ) ) ; assertEquals ( 1L , decodeLong ( new byte [ ] { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } , 0 ) ) ;
public static void appendNewline ( StringBuilder out ) { out . append ( newline ) ; }
abstract public E get ( final CharSequence key ) ; abstract public Set < CharSequence > keySet ( ) ; abstract public int getCapacity ( ) ; abstract public float getMass ( ) ; abstract public boolean putIn ( final E newItem , boolean insertIntoNameTable ) ; public boolean putIn ( final E newItem ) { return putIn ( newItem , true ) ; } abstract public int size ( ) ; abstract public E takeOut ( boolean removeFromNameTable ) ; abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } protected int forgetRate ( ) { if ( forgettingRate ! = null ) { return forgettingRate . get ( ) ; } return - 1 ; } public void forget ( final E x ) { int forgetRate = forgetRate ( ) ; if ( forgetRate > 0 ) { BudgetFunctions . forget ( x . budget , forgetRate , RELATIVE_THRESHOLD ) ; } } public final boolean putBack ( final E oldItem , final boolean insertIntoNameTable ) { forget ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public final boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( boolean forget ) { final E x = takeOut ( false ) ; if ( x ! = null ) { if ( forget ) { forget ( x ) ; } boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else { return null ; } } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; @Override public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( CharSequence key ) ; }
public void testOps ( ) throws Exception { MembaseClient mc = null ; try { URI base = new URI ( " http:// " + TestConfig . IPV4_ADDR + " :8091/pools " ) ; mc = new MembaseClient ( Arrays . asList ( base ) , " default " , " Administrator " , " password " ) ; } catch ( IOException ex ) { Logger . getLogger ( VBucketMembaseClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ConfigurationException ex ) { Logger . getLogger ( VBucketMembaseClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( URISyntaxException ex ) { Logger . getLogger ( VBucketMembaseClientTest . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } Integer i ; for ( i = 0 ; i < 10000 ; i + + ) { mc . set ( " test " + i , 0 , i . toString ( ) ) ; } mc . set ( " hello " , 0 , " world " ) ; String result = ( String ) mc . get ( " hello " ) ; assert ( result . equals ( " world " ) ) ; for ( i = 0 ; i < 10000 ; i + + ) { String res = ( String ) mc . get ( " test " + i ) ; assert ( res . equals ( i . toString ( ) ) ) ; } assert mc . flush ( ) . get ( ) . booleanValue ( ) ; mc . shutdown ( 3 , TimeUnit . SECONDS ) ; }
public KeyedOperation touch ( String key , int expiration , OperationCallback cb ) { throw new UnsupportedOperationException ( " Touch is only supported in " + "  the binary protocol " ) ;
private double score ( ) { return 1.0 / distance ; }
int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }
public void collapseSelectedNodes ( ) { TreePath [ ] paths = spyTree . getSelectionPaths ( ) ; if ( paths ! = null ) {
public void handleIO ( ) throws IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long then = reconnectQueue . firstKey ( ) ; delay = Math . max ( then - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; if ( selectedKeys . isEmpty ( ) & & ! shutDown ) { getLogger ( ) . debug ( " No selectors ready, interrupted:  " + Thread . interrupted ( ) ) ; if ( + + emptySelects > DOUBLE_CHECK_EMPTY ) { for ( SelectionKey sk : selector . keys ( ) ) { getLogger ( ) . info ( " %s has %s, interested in %s " , sk , sk . readyOps ( ) , sk . interestOps ( ) ) ; if ( sk . readyOps ( ) ! = 0 ) { getLogger ( ) . info ( " %s has a ready op, handling IO " , sk ) ; handleIO ( sk ) ; } else { lostConnection ( ( MemcachedNode ) sk . attachment ( ) ) ; } } assert emptySelects < EXCESSIVE_EMPTY : " Too many empty selects " ; } } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { if ( continuousTimeout . get ( ) > timeoutExceptionThreshold ) { MemcachedNode mn = ( MemcachedNode ) sk . attachment ( ) ; lostConnection ( mn ) ; } else { handleIO ( sk ) ; } } selectedKeys . clear ( ) ; } if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ;
public void fireAllEvents ( boolean all ) { reportAllButtonEvents = all ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof RangeMinimumData ) ) return false ; @SuppressWarnings ( " unchecked " ) RangeMinimumData < N > data = ( RangeMinimumData < N > ) obj ; if ( this . start = = data . start & & this . end = = data . end & & this . minimum . equals ( data . minimum ) ) return true ; return false ; }
public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( - 1 , op2 . getExpiration ( ) ) ; assertEquals ( - 1 , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; }
private static String generateDoc ( String type , String small , String large ) { return " { \" type \" : \" " + type + " \" " + " \" small range \" : \" " + small + " \" " + " \" large range \" : \" " + large + " \" } " ;
public void onSaveInstanceState ( Bundle outState ) { outState . putParcelable ( EXTRA_ALBUM , album ) ; super . onSaveInstanceState ( outState ) ; }
public AbstractViewHolder findInnerViews ( View targetView ) ; public int getLayoutId ( ) ; public boolean isEnabled ( int position , List < ? extends Item > items , Object item ) ; public void onDataBind ( Context context , View targetView , AbstractViewHolder viewHolder , List < ? extends Item > items , Object item , int position ) ; public View onLayoutInflation ( Context context , View targetView , List < ? extends Item > items ) ; }
public void toDataTypeRecordNested ( ) { Schema inner = SchemaBuilder . record ( " inner " ) . fields ( ) . name ( " field1 " ) . type ( ) . intType ( ) . noDefault ( ) . endRecord ( ) ; Schema outer = SchemaBuilder . record ( " outer " ) . fields ( ) . name ( " inner " ) . type ( inner ) . noDefault ( ) . endRecord ( ) ; assertEquals ( " Invalid DataType " , DataTypes . createStructType ( Lists . newArrayList (
boolean handleResponse ( JmDNSImpl dns ) { return false ; }
public Term applySubstitute ( final Map < Term , Term > subs ) { if ( ( subs = = null ) | | ( subs . isEmpty ( ) ) ) { return this ; } Term [ ] tt = new Term [ term . length ] ; boolean modified = false ; for ( int i = 0 ; i < tt . length ; i + + ) { Term t1 = tt [ i ] = term [ i ] ; if ( subs . containsKey ( t1 ) ) { Term t2 = subs . get ( t1 ) ; while ( subs . containsKey ( t2 ) ) { t2 = subs . get ( t2 ) ; } if ( ! t2 . containsTerm ( t1 ) ) { tt [ i ] = t2 ; modified = true ; } } else if ( t1 instanceof CompoundTerm ) { Term ss = ( ( CompoundTerm ) t1 ) . applySubstitute ( subs ) ; if ( ss ! = null ) { tt [ i ] = ss ; if ( ! tt [ i ] . equals ( term [ i ] ) ) modified = true ; } } } if ( ! modified ) return this ; if ( this . isCommutative ( ) ) { Arrays . sort ( tt ) ; } return this . clone ( tt ) ; }
public synchronized void connectionSucceeded ( String message ) { dismissAlertDialog ( ) ;
protected int forgetRate ( ) { return Parameters . CONCEPT_DEFAULT_FORGETTING_CYCLE ; }
MemcachedNode getPrimary ( String k ) ; Iterator < MemcachedNode > getSequence ( String k ) ; Collection < MemcachedNode > getAll ( ) ; NodeLocator getReadonlyCopy ( ) ; void updateLocator ( final List < MemcachedNode > nodes ) ; }
private void reduce ( ) { int i ; int j ; int k ; int nrows ; int reduced_ncols ; int reduced_nrows ; SparseBitSet set ; CDTrans dtrans ; int size ; set = new SparseBitSet ( ) ; size = m_spec . m_dtrans_vector . size ( ) ; m_spec . m_anchor_array = new int [ size ] ; m_spec . m_accept_vector = new Vector ( ) ; for ( i = 0 ; i < size ; + + i ) { dtrans = ( CDTrans ) m_spec . m_dtrans_vector . elementAt ( i ) ; m_spec . m_accept_vector . addElement ( dtrans . m_accept ) ; m_spec . m_anchor_array [ i ] = dtrans . m_anchor ; dtrans . m_accept = null ; } m_spec . m_col_map = new int [ m_spec . m_dtrans_ncols ] ; for ( i = 0 ; i < m_spec . m_dtrans_ncols ; + + i ) { m_spec . m_col_map [ i ] = - 1 ; } for ( reduced_ncols = 0 ; ; + + reduced_ncols ) { if ( CUtility . DEBUG ) { for ( i = 0 ; i < reduced_ncols ; + + i ) { CUtility . ASSERT ( - 1 ! = m_spec . m_col_map [ i ] ) ; } } for ( i = reduced_ncols ; i < m_spec . m_dtrans_ncols ; + + i ) { if ( - 1 = = m_spec . m_col_map [ i ] ) { break ; } } if ( i > = m_spec . m_dtrans_ncols ) { break ; } if ( CUtility . DEBUG ) { CUtility . ASSERT ( false = = set . get ( i ) ) ; CUtility . ASSERT ( - 1 = = m_spec . m_col_map [ i ] ) ; } set . set ( i ) ; m_spec . m_col_map [ i ] = reduced_ncols ; for ( j = i + 1 ; j < m_spec . m_dtrans_ncols ; + + j ) { if ( - 1 = = m_spec . m_col_map [ j ] & & true = = col_equiv ( i , j ) ) { m_spec . m_col_map [ j ] = reduced_ncols ; } } } k = 0 ; for ( i = 0 ; i < m_spec . m_dtrans_ncols ; + + i ) { if ( set . get ( i ) ) { + + k ; set . clear ( i ) ; j = m_spec . m_col_map [ i ] ; if ( CUtility . DEBUG ) { CUtility . ASSERT ( j < = i ) ; } if ( j = = i ) { continue ; } col_copy ( j , i ) ; } } m_spec . m_dtrans_ncols = reduced_ncols ; trunc_col ( ) ; if ( CUtility . DEBUG ) { CUtility . ASSERT ( k = = reduced_ncols ) ; } nrows = m_spec . m_dtrans_vector . size ( ) ; m_spec . m_row_map = new int [ nrows ] ; for ( i = 0 ; i < nrows ; + + i ) { m_spec . m_row_map [ i ] = - 1 ; } for ( reduced_nrows = 0 ; ; + + reduced_nrows ) { if ( CUtility . DEBUG ) { for ( i = 0 ; i < reduced_nrows ; + + i ) { CUtility . ASSERT ( - 1 ! = m_spec . m_row_map [ i ] ) ; } } for ( i = reduced_nrows ; i < nrows ; + + i ) { if ( - 1 = = m_spec . m_row_map [ i ] ) { break ; } } if ( i > = nrows ) { break ; } if ( CUtility . DEBUG ) { CUtility . ASSERT ( false = = set . get ( i ) ) ; CUtility . ASSERT ( - 1 = = m_spec . m_row_map [ i ] ) ; } set . set ( i ) ; m_spec . m_row_map [ i ] = reduced_nrows ; for ( j = i + 1 ; j < nrows ; + + j ) { if ( - 1 = = m_spec . m_row_map [ j ] & & true = = row_equiv ( i , j ) ) { m_spec . m_row_map [ j ] = reduced_nrows ; } } } k = 0 ; for ( i = 0 ; i < nrows ; + + i ) { if ( set . get ( i ) ) { + + k ; set . clear ( i ) ; j = m_spec . m_row_map [ i ] ; if ( CUtility . DEBUG ) { CUtility . ASSERT ( j < = i ) ; } if ( j = = i ) { continue ; } row_copy ( j , i ) ; } } m_spec . m_dtrans_vector . setSize ( reduced_nrows ) ; if ( CUtility . DEBUG ) {
public void writeValue ( Object v , CharacterOutput output ) { if ( v = = null ) output . write ( NULL_CHARS ) ;
public IntervalData < O > query ( long start , long end ) { IntervalData < O > results = null ; for ( IntervalData < O > data : overlap ) { if ( data . start > end ) break ; IntervalData < O > temp = data . query ( start , end ) ; if ( results = = null & & temp ! = null ) results = temp ; else if ( results ! = null & & temp ! = null ) results . combined ( temp ) ; } if ( left ! = null & & start < center ) { IntervalData < O > temp = left . query ( start , end ) ; if ( temp ! = null & & results = = null ) results = temp ; else if ( results ! = null & & temp ! = null ) results . combined ( temp ) ; } if ( right ! = null & & end > = center ) { IntervalData < O > temp = right . query ( start , end ) ; if ( temp ! = null & & results = = null ) results = temp ; else if ( results ! = null & & temp ! = null ) results . combined ( temp ) ; } return results ; }
long getAttributeAsLong ( @Nullable String sName , long nDefault ) ; double getAttributeAsDouble ( @Nullable String sName ) ; double getAttributeAsDouble ( @Nullable String sName , double dDefault ) ; boolean getAttributeAsBoolean ( @Nullable String sName ) ; boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; @Nonnull @ReturnsMutableCopy Enumeration < String > getAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy ICommonsOrderedSet < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy ICommonsList < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; }
private boolean recurseOnCreatePanelMenu ( ArrayList < Fragment > newMenus , Fragment f , Menu menu , MenuInflater inflater ) { boolean show = false ; if ( f ! = null & & ! f . mHidden & & f . mHasMenu & & f . mMenuVisible & & f instanceof OnCreateOptionsMenuListener ) { show = true ; ( ( OnCreateOptionsMenuListener ) f ) . onCreateOptionsMenu ( menu , inflater ) ; if ( newMenus = = null ) { newMenus = new ArrayList < Fragment > ( ) ; } newMenus . add ( f ) ; } if ( ! f . mMenuVisible ) return show ; if ( f ! = null & & f . mChildFragmentManager ! = null & & f . mChildFragmentManager . mAdded ! = null ) { for ( int j = 0 ; j < f . mChildFragmentManager . mAdded . size ( ) ; j + + ) { Fragment f2 = f . mChildFragmentManager . mAdded . get ( j ) ; show | = recurseOnCreatePanelMenu ( newMenus , f2 , menu , inflater ) ; } } return show ; }
protected static int do_escaped ( PrintWriter out , char c ) { StringBuffer escape = new StringBuffer ( ) ; if ( c < = 0xFF ) { escape . append ( Integer . toOctalString ( c ) ) ; while ( escape . length ( ) < 3 ) escape . insert ( 0 , '0' ) ; } else { escape . append ( Integer . toHexString ( c ) ) ; while ( escape . length ( ) < 4 ) escape . insert ( 0 , '0' ) ; escape . insert ( 0 , 'u' ) ; } escape . insert ( 0 , '\\' ) ; out . print ( escape . toString ( ) ) ; if ( c = = 0 ) return 2 ; if ( c > = 0x01 & & c < = 0x7F ) return 1 ; if ( c > = 0x80 & & c < = 0x7FF ) return 2 ; return 3 ; }
public String getAS2From ( ) { return getHeader ( CAS2Header . HEADER_AS2_FROM ) ; }
protected void markAsChanged ( ) throws OpenAS2Exception { } @Nonnull @OverridingMethodsMustInvokeSuper public Partnership getPartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { ValueEnforcer . notNull ( aPartnership , " Partnership " ) ; m_aRWLock . readLock ( ) . lock ( ) ; try { Partnership aRealPartnership = m_aPartnerships . getPartnershipByName ( aPartnership . getName ( ) ) ; if ( aRealPartnership = = null ) { aRealPartnership = m_aPartnerships . getPartnershipByID ( aPartnership . getAllSenderIDs ( ) , aPartnership . getAllReceiverIDs ( ) ) ; } if ( aRealPartnership = = null ) throw new PartnershipNotFoundException ( aPartnership ) ; return aRealPartnership ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nullable public Partnership getPartnershipByName ( @Nullable final String sName ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartnerships . getPartnershipByName ( sName ) ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nonnull @ReturnsMutableCopy public Set < String > getAllPartnershipNames ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartnerships . getAllPartnershipNames ( ) ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nonnull @ReturnsMutableCopy public List < Partnership > getAllPartnerships ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartnerships . getAllPartnerships ( ) ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nonnull public IPartnershipMap getPartnershipMap ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try { return m_aPartnerships ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } protected final void setPartnerships ( @Nonnull final PartnershipMap aPartnerships ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { m_aPartnerships . setPartnerships ( aPartnerships ) ; markAsChanged ( ) ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } @Nonnull public final EChange addPartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { if ( m_aPartnerships . addPartnership ( aPartnership ) . isUnchanged ( ) ) return EChange . UNCHANGED ; markAsChanged ( ) ; return EChange . CHANGED ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } @Nonnull public final EChange removePartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { if ( m_aPartnerships . removePartnership ( aPartnership ) . isUnchanged ( ) ) return EChange . UNCHANGED ; markAsChanged ( ) ; return EChange . CHANGED ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } public final void updatePartnership ( @Nonnull final IMessage aMsg , final boolean bOverwrite ) throws OpenAS2Exception { ValueEnforcer . notNull ( aMsg , " Message " ) ; final Partnership aPartnership = getPartnership ( aMsg . getPartnership ( ) ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Updating partnership  " + aPartnership ) ; aMsg . getPartnership ( ) . copyFrom ( aPartnership ) ; if ( bOverwrite ) { final String sSubject = aPartnership . getSubject ( ) ; if ( sSubject ! = null ) { aMsg . setSubject ( new MessageParameters ( aMsg ) . format ( sSubject ) ) ; } } } public final void updatePartnership ( @Nonnull final IMessageMDN aMdn , final boolean bOverwrite ) throws OpenAS2Exception { ValueEnforcer . notNull ( aMdn , " MessageMDN " ) ; final Partnership aPartnership = getPartnership ( aMdn . getPartnership ( ) ) ; aMdn . getPartnership ( ) . copyFrom ( aPartnership ) ; } }
public Matrix multiply ( Matrix input ) { Matrix output = new Matrix ( this . rows , input . cols ) ; if ( this . cols ! = input . rows ) return output ; for ( int r = 0 ; r < output . rows ; r + + ) { for ( int c = 0 ; c < output . cols ; c + + ) { int [ ] row = getRow ( r ) ; int [ ] column = input . getColumn ( c ) ; int result = 0 ; for ( int i = 0 ; i < cols ; i + + ) { result + = row [ i ] * column [ i ] ; } output . set ( r , c , result ) ; } } return output ; }
private Formula maybeRemoveMatchingLits ( List litArr ) { Formula f = KB . literalListToFormula ( litArr ) ; return maybeRemoveMatchingLits ( f ) ; }
public void failed ( SessionRequest request ) { getLogger ( ) . error ( request . getRemoteAddress ( ) + "  - Session request failed " ) ; IOException ex = request . getException ( ) ; if ( ex ! = null ) { ex . printStackTrace ( ) ; } connRequest . cancel ( ) ; }
public int read ( ) throws IndexOutOfBoundsException { if ( next ! = - 1 ) { char c = ( char ) next ; next = - 1 ; return c ; } if ( index > = str . length ( ) ) return - 1 ; return readChar ( ) ; }
public void testMultipleArrivingOneExistingWhereAllArrivingLaterThanExisting ( ) { p = new BitemporalHistoryPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , FAR_FUTURE_MILLIS , 1L , FAR_FUTURE_MILLIS , CURRENT_FLAG_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 200L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world! " , 300L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world? " , 400L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 5 ) ; Long systemStart1 = ( Long ) RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemstart " ) ; Long systemStart2 = ( Long ) RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " systemstart " ) ; Long systemStart3 = ( Long ) RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " systemstart " ) ; Long systemStart4 = ( Long ) RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " systemstart " ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . UPDATE ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemstart " ) , 1L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemend " ) , RowUtils . precedingTimestamp ( systemStart1 ) ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( planned . get ( 1 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventend " ) , 199L ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( planned . get ( 2 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " eventstart " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " eventend " ) , 299L ) ; assertTrue ( systemStart2 > = preplanSystemTime ) ; assertTrue ( systemStart2 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( planned . get ( 3 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " value " ) , " world! " ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " eventstart " ) , 300L ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " eventend " ) , 399L ) ; assertTrue ( systemStart3 > = preplanSystemTime ) ; assertTrue ( systemStart3 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( planned . get ( 4 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " value " ) , " world? " ) ; assertEquals ( RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " eventstart " ) , 400L ) ; assertEquals ( RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertTrue ( systemStart4 > = preplanSystemTime ) ; assertTrue ( systemStart4 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 4 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_YES ) ; }
protected void deriveDidntHappen ( Term aTerm , long expectedOccurenceTime ) { TruthValue truth = expiredTruth ; BudgetValue budget = expiredBudget ; Stamp stamp = new Stamp ( nal . memory ) ; stamp . setOccurrenceTime ( expectedOccurenceTime ) ; Sentence S = new Sentence ( aTerm , Symbols . JUDGMENT_MARK , truth , stamp ) ; Task task = new Task ( S , budget ) ; nal . derivedTask ( task , false , true , null , null ) ; task . setParticipateInTemporalInduction ( true ) ; }
public static Term text ( final String t ) { return Term . get ( " \" " + t + " \" " ) ; }
public CommentedConfig createSubConfig ( ) { return config . createSubConfig ( ) ; }
protected void beforeSend ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2Session aSession , @Nonnull final IMessage aMsg ) { } @Nonnull public AS2ClientResponse sendSynchronous ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2ClientRequest aRequest ) { ValueEnforcer . notNull ( aSettings , " ClientSettings " ) ; ValueEnforcer . notNull ( aRequest , " ClientRequest " ) ; final AS2ClientResponse aResponse = createResponse ( ) ; IMessage aMsg = null ; final StopWatch aSW = StopWatch . createdStarted ( ) ; try { final Partnership aPartnership = buildPartnership ( aSettings ) ; aMsg = createMessage ( aPartnership , aRequest ) ; aResponse . setOriginalMessageID ( aMsg . getMessageID ( ) ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " MessageID to send:  " + aMsg . getMessageID ( ) ) ; final boolean bHasRetries = aSettings . getRetryCount ( ) > 0 ; final AS2Session aSession = createSession ( ) ; initCertificateFactory ( aSettings , aSession ) ; initPartnershipFactory ( aSession ) ; initMessageProcessor ( aSession ) ; if ( bHasRetries ) { final IProcessorResenderModule aResender = new ImmediateResenderModule ( ) ; aResender . initDynamicComponent ( aSession , null ) ; aSession . getMessageProcessor ( ) . addModule ( aResender ) ; } aSession . getMessageProcessor ( ) . startActiveModules ( ) ; try { beforeSend ( aSettings , aSession , aMsg ) ; final ICommonsMap < String , Object > aHandleOptions = new CommonsHashMap < > ( ) ; if ( bHasRetries ) aHandleOptions . put ( IProcessorResenderModule . OPTION_RETRIES , Integer . toString ( aSettings . getRetryCount ( ) ) ) ; aPartnership . setContentTransferEncodingSend ( aRequest . getContentTransferEncoding ( ) ) ; aPartnership . setContentTransferEncodingReceive ( aRequest . getContentTransferEncoding ( ) ) ; final AS2SenderModule aSender = m_aAS2SenderModuleFactory . get ( ) ; aSender . initDynamicComponent ( aSession , null ) ; aSender . setConnectionTimeoutMilliseconds ( aSettings . getConnectTimeoutMS ( ) ) ; aSender . setReadTimeoutMilliseconds ( aSettings . getReadTimeoutMS ( ) ) ; aSender . setQuoteHeaderValues ( aSettings . isQuoteHeaderValues ( ) ) ; aSender . setHttpOutgoingDumperFactory ( aSettings . getHttpOutgoingDumperFactory ( ) ) ; aSender . setHttpIncomingDumper ( aSettings . getHttpIncomingDumper ( ) ) ; if ( aSettings . getMICMatchingHandler ( ) ! = null ) aSender . setMICMatchingHandler ( aSettings . getMICMatchingHandler ( ) ) ; aSender . setVerificationCertificateConsumer ( aSettings . getVerificationCertificateConsumer ( ) ) ; aMsg . headers ( ) . setAllHeaders ( aSettings . customHeaders ( ) ) ; aSession . getMessageProcessor ( ) . addModule ( aSender ) ; aSender . handle ( IProcessorSenderModule . DO_SEND , aMsg , aHandleOptions ) ; } finally { aSession . getMessageProcessor ( ) . stopActiveModules ( ) ; } } catch ( final Exception ex ) { LOGGER . error ( " Error sending AS2 message " , ex ) ; aResponse . setException ( ex ) ; } finally { if ( aMsg ! = null & & aMsg . getMDN ( ) ! = null ) { aResponse . setMDN ( aMsg . getMDN ( ) ) ; final String sReceivedCert = aMsg . attrs ( ) . getAsString ( AS2Message . ATTRIBUTE_RECEIVED_SIGNATURE_CERTIFICATE ) ; if ( sReceivedCert ! = null ) { final X509Certificate aReceivedCert = CertificateHelper . convertStringToCertficateOrNull ( sReceivedCert ) ; aResponse . setMDNVerificationCertificate ( aReceivedCert ) ; } } } if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Response retrieved:  " + aResponse . getAsString ( ) ) ; aResponse . setExecutionDuration ( aSW . stopAndGetDuration ( ) ) ; return aResponse ; } }
private void windDownResources ( ) { Log . d ( TAG , " windDownResources() " ) ; if ( mAudioManager ! = null ) { mIsAudioFocusedOnThis = false ; mAudioManager . abandonAudioFocus ( null ) ; } if ( mNotificationHandler ! = null ) { mNotificationHandler . onDestroy ( ) ;
public byte [ ] readBytes ( InputStream inputStream ) throws IOException { try {
public boolean isRunning ( ) { return initalized & & ! shutdown ; }
protected void finishedPayload ( byte [ ] pl ) throws IOException { if ( errorCode = = SASL_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) ) ) ;
default void initEmptyFile ( Path f ) throws IOException { initEmptyFile ( ( ) - > Files . newBufferedWriter ( f ) ) ; }
protected boolean areAttributesEqual ( final StatsKey other ) { Class < ? > keyClass = other . getClass ( ) ; if ( keyClass = = SingleAttributeStatsKey . class ) { return ( ( AbstractStatsKey ) other ) . areAttributesEqual ( this ) ; } return attributes . equals ( other . getAttributes ( ) ) ; }
public void setReceiverID ( @Nullable final String sKey , final String sValue ) { m_aReceiverIDs . setAttribute ( sKey , sValue ) ; }
public void onLayoutInflation ( Context context , View targetView , List < ? extends Item > items ) { targetView . findViewById ( R . id . track_artist ) . setVisibility ( showArtist ? View . VISIBLE : View . GONE ) ; }
public void run ( ) { s . nar . start ( 4 ) ; for ( GridObject g : s . objects ) { if ( g instanceof LocalGridObject ) { LocalGridObject obi = ( LocalGridObject ) g ; if ( obi instanceof Key ) { s . nar . addInput ( " <(^go-to, " + obi . doorname + " ) =/> <Self --> [curious]>>. " ) ; s . nar . addInput ( " <(^pick, " + obi . doorname + " ) =/> <Self --> [curious]>>. " ) ; } } } for ( int i = 0 ; i < s . cells . w ; i + + ) { for ( int j = 0 ; j < s . cells . h ; j + + ) { if ( s . cells . readCells [ i ] [ j ] . name . startsWith ( " switch " ) | | s . cells . readCells [ i ] [ j ] . name . startsWith ( " place " ) ) { s . nar . addInput ( " <(^go-to, " + s . cells . readCells [ i ] [ j ] . name + " ) =/> <Self --> [curious]>>. " ) ; } if ( s . cells . readCells [ i ] [ j ] . logic = = Logic . SWITCH | | s . cells . readCells [ i ] [ j ] . logic = = Logic . OFFSWITCH ) { s . nar . addInput ( " <(^activate, " + s . cells . readCells [ i ] [ j ] . name + " ) =/> <Self --> [curious]>>. " ) ; s . nar . addInput ( " <(^deactivate, " + s . cells . readCells [ i ] [ j ] . name + " ) =/> <Self --> [curious]>>. " ) ; } } } s . nar . addInput ( " <<Self --> [curious]> =/> <Self --> [exploring]>>. " ) ; s . nar . addInput ( " <<Self --> [curious]> =/> <Self --> [exploring]>>. " ) ; s . nar . addInput ( " <Self --> [curious]>! " ) ; s . nar . addInput ( " <Self --> [curious]>! " ) ; s . nar . addInput ( " <Self --> [exploring]>! " ) ; s . nar . addInput ( " <Self --> [exploring]>! " ) ; }
public int hashCode ( ) { synchronized ( rootMonitor ) { return map . hashCode ( ) ;
private void replaceWithChild ( RedBlackNode < T > nodeToReplace , RedBlackNode < T > nodeToReplaceWith ) { nodeToReplace . id = nodeToReplaceWith . id ; nodeToReplace . color = nodeToReplaceWith . color ; if ( nodeToReplace . parent = = null ) nodeToReplace . color = BLACK ; nodeToReplace . lesser = nodeToReplaceWith . lesser ; nodeToReplace . greater = nodeToReplaceWith . greater ; }
private void addMeasurement ( ) { List < Measurement > measurements = new Vector < Measurement > ( ) ; measurements . add ( new Measurement ( ORDERING_MEASUREMENT_NAME , totalCount * this . samplingFrequency ) ) ; addClusteringPerformanceMeasurements ( measurements ) ; Measurement [ ] finalMeasurements = measurements . toArray ( new Measurement [ measurements . size ( ) ] ) ; LearningEvaluation learningEvaluation = new LearningEvaluation ( finalMeasurements ) ; learningCurve . insertEntry ( learningEvaluation ) ; logger . debug ( " evaluator id = {} " , this . id ) ; if ( immediateResultStream ! = null ) { if ( firstDump ) {
public void testCommutativeCompoundTerm ( ) { final NAR n = new NAR ( ) ; assertEquivalent ( " (&&,a,b) " , " (&&,b,a) " ) ; assertEquivalent ( " (&&,(||,b,c),a) " , " (&&,a,(||,b,c)) " ) ; assertEquivalent ( " (&&,(||,c,b),a) " , " (&&,a,(||,b,c)) " ) ;
protected MimeBodyPart compress ( @Nonnull final IMessage aMsg , @Nonnull final MimeBodyPart aData , @Nonnull final ECompressionType eCompressionType ) throws SMIMEException , MessagingException { final SMIMECompressedGenerator aCompressedGenerator = new SMIMECompressedGenerator ( ) ; final String sCTE = aMsg . partnership ( ) . getContentTransferEncodingSend ( EContentTransferEncoding . AS2_DEFAULT . getID ( ) ) ; aCompressedGenerator . setContentTransferEncoding ( sCTE ) ; final MimeBodyPart aCompressedBodyPart = aCompressedGenerator . generate ( aData , eCompressionType . createOutputCompressor ( ) ) ; aMsg . headers ( ) . addHeader ( CHttpHeader . CONTENT_TRANSFER_ENCODING , sCTE ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Compressed data with  " + eCompressionType + "  to  " + aCompressedBodyPart . getContentType ( ) + " : " + aMsg . getLoggingText ( ) ) ; return aCompressedBodyPart ; }
public int compare ( Integer arg0 , Integer arg1 ) { if ( arg0 . compareTo ( arg1 ) = = 1 ) return - 1 ; else if ( arg1 . compareTo ( arg0 ) = = 1 ) return 1 ; return 0 ; }
GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( String key , long casId , int flags , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }
public static Map < String , String > mapAttributeNodes ( @Nonnull final IMicroElement aNode , final String sNodeName , final String sNodeKeyName , final String sNodeValueName ) throws OpenAS2Exception { final Map < String , String > ret = new HashMap < String , String > ( ) ; for ( final IMicroElement eChild : aNode . getAllChildElements ( sNodeName ) ) { final String sName = eChild . getAttribute ( sNodeKeyName ) ; if ( sName = = null ) throw new OpenAS2Exception ( eChild . toString ( ) + "  does not have key attribute:  " + sNodeKeyName ) ; final String sValue = eChild . getAttribute ( sNodeValueName ) ; if ( sValue = = null ) throw new OpenAS2Exception ( eChild . toString ( ) + "  does not have value attribute:  " + sNodeValueName ) ; ret . put ( sName , sValue ) ; } return ret ; }
protected void execute ( final Operation op , final Task task ) { Operator oper = op . getOperator ( ) ; op . setTask ( task ) ; oper . call ( op , memory ) ; }
public void testOneArrivingMultipleExistingWhereArrivingEarlierThanAllExisting ( ) { p = new BitemporalHistoryPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , 1L , 2L , CURRENT_FLAG_DEFAULT_NO ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 199L , 3L , 253402214400000L , CURRENT_FLAG_DEFAULT_NO ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello! " , 200L , 200L , 253402214400000L , 3L , 4L , CURRENT_FLAG_DEFAULT_NO ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello! " , 200L , 200L , 299L , 5L , 253402214400000L , CURRENT_FLAG_DEFAULT_NO ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello? " , 300L , 300L , 253402214400000L , 5L , 253402214400000L , CURRENT_FLAG_DEFAULT_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 50L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 1 ) ; Long systemStart0 = ( Long ) RowUtils . get ( planned . get ( 0 ) , " systemstart " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventstart " ) , 50L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventend " ) , 99L ) ; assertTrue ( systemStart0 > = preplanSystemTime ) ; assertTrue ( systemStart0 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " systemend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; }
public int vectorize ( double [ ] d , int index ) { range . vectorizeSmooth ( d , index , get ( ) , quantization ) ; return quantization ; }
public static CompoundTerm ReduceTillLayer2 ( CompoundTerm itself , Term replacement , Memory memory ) { if ( ! ( itself instanceof CompoundTerm ) ) return null ; Term reduced = reduceComponentOneLayer ( itself , replacement , memory ) ; if ( ! ( reduced instanceof CompoundTerm ) ) return null ; itself = ( CompoundTerm ) reduced ; int j = 0 ; for ( Term t : itself . term ) { Term t2 = unwrapNegation ( t ) ; if ( ! ( t2 instanceof Implication ) & & ! ( t2 instanceof Equivalence ) & & ! ( t2 instanceof Conjunction ) & & ! ( t2 instanceof Disjunction ) ) { j + + ; continue ; } Term ret2 = reduceComponentOneLayer ( ( CompoundTerm ) t2 , replacement , memory ) ; CompoundTerm itselfCompound = itself ; CompoundTerm replaced = null ; if ( j < itself . term . length ) replaced = ( CompoundTerm ) CompoundTerm . setComponent ( itself , j , ret2 , memory ) ; if ( replaced ! = null ) { itself = replaced ; } j + + ; } return itself ; }
void dumpPayload ( int nByte ) ; default void finishedPayload ( ) { } default void close ( ) throws IOException { } }
public void updateFromItems ( ) { if ( arrayArtistsResults ! = null ) { listArtists . setAdapter ( new SeparatedListAdapter ( this , R . layout . search_list_item , new SearchResultDataBinder ( ) , arrayArtistsResults ) ) ; try { listArtists . setEmptyView ( noResultArtistsView ) ; loadingView . setVisibility ( View . GONE ) ; } catch ( Exception e ) { } } if ( arrayAlbumsResults ! = null ) { listAlbums . setAdapter ( new SeparatedListAdapter ( this , R . layout . search_list_item , new SearchResultDataBinder ( ) , arrayAlbumsResults ) ) ; try { listAlbums . setEmptyView ( noResultAlbumsView ) ; loadingView . setVisibility ( View . GONE ) ; } catch ( Exception e ) { } } if ( arraySongsResults ! = null ) { listSongs . setAdapter ( new SeparatedListAdapter ( this ,
public CompoundTerm cloneDeepVariables ( ) { return clone ( cloneVariableTermsDeep ( ) ) ; }
private static boolean testTreeMap ( ) { String name = " TreeMap <String> " ; java . util . Map < String , Integer > jMap = treeMap . toMap ( ) ; if ( ! testJavaMap ( jMap , String . class , name ) ) return false ; return true ; }
public static Term make ( final CompoundTerm image , final Term component , final int index , final Memory memory ) { Term [ ] argument = image . cloneComponents ( ) ; argument [ index ] = component ; return make ( argument , memory ) ; }
public void onItemClick ( AdapterView < ? > adpaterView , View view , int position , long id ) { final int action = ( ( PopupMenuItem ) adpaterView . getAdapter ( ) . getItem ( position ) ) . actionId ; app . oMPDAsyncHelper . execAsync ( new Runnable ( ) { @Override public void run ( ) { boolean replace = false ; boolean play = false ; switch ( action ) { case ADDNREPLACEPLAY : replace = true ; play = true ; break ; case ADDNREPLACE : replace = true ; break ; case ADDNPLAY : play = true ; break ; } try { app . oMPDAsyncHelper . oMPD . add ( artist , album , replace , play ) ; Tools . notifyUser ( String . format ( getResources ( ) . getString ( R . string . albumAdded ) , album ) , getActivity ( ) ) ; } catch ( MPDServerException e ) { e . printStackTrace ( ) ; } } } ) ; popupMenu . dismiss ( ) ; }
public void testGetIndependentNonStreamingSteps ( ) { Step step1 = new BatchStep ( " step1 " , ConfigFactory . empty ( ) . withValue ( " dependencies " , ConfigValueFactory . fromIterable ( Sets . newHashSet ( " step3 " ) ) ) ) ; Step step2 = new StreamingStep ( " step2 " , ConfigFactory . empty ( ) . withValue ( " dependencies " , ConfigValueFactory . fromIterable ( Sets . newHashSet ( " step4 " ) ) ) . withValue ( " input.translator " , ConfigFactory . empty ( ) . root ( ) ) ) ; Step step3 = new BatchStep ( " step3 " , ConfigFactory . empty ( ) ) ; Step step4 = new StreamingStep ( " step4 " , ConfigFactory . empty ( ) . withValue ( " input.translator " , ConfigFactory . empty ( ) . root ( ) ) ) ; Set < Step > steps = Sets . newHashSet ( step1 , step2 , step3 , step4 ) ; assertEquals ( StepUtils . getIndependentNonStreamingSteps ( steps ) , Sets . newHashSet ( step3 ) ) ; }
private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout ) ; Operation op = addOp ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ) ; rv . setOperation ( op ) ; return rv ; }
protected void beliefReason ( final Sentence belief , final Term beliefTerm , final Term taskTerm , final DerivationContext nal ) { final Memory memory = nal . memory ; if ( Memory . randomNumber . nextDouble ( ) < INTERNAL_EXPERIENCE_RARE_PROBABILITY ) { final Operator op = memory . getOperator ( nonInnateBeliefOperators [ Memory . randomNumber . nextInt ( nonInnateBeliefOperators . length ) ] ) ; final Product prod = new Product ( belief . term ) ; if ( op ! = null & & prod ! = null ) { final Term new_term = Inheritance . make ( prod , op ) ; final Sentence sentence = new Sentence ( new_term , Symbols . GOAL_MARK , new TruthValue ( 1 , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) , new Stamp ( memory ) ) ; final float quality = BudgetFunctions . truthToQuality ( sentence . truth ) ; final BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_GOAL_PRIORITY * INTERNAL_EXPERIENCE_PRIORITY_MUL , Parameters . DEFAULT_GOAL_DURABILITY * INTERNAL_EXPERIENCE_DURABILITY_MUL , quality ) ; final Task newTask = new Task ( sentence , budget , Task . EnumType . INPUT ) ; nal . derivedTask ( newTask , false , false , false ) ; } } if ( beliefTerm instanceof Implication & & Memory . randomNumber . nextDouble ( ) < = INTERNAL_EXPERIENCE_PROBABILITY ) { final Implication imp = ( Implication ) beliefTerm ;
void addPrivateKey ( @Nonnull @Nonempty String sAlias , @Nonnull Key aKey , @Nonnull String sPassword ) throws AS2Exception ; void clearCertificates ( ) throws AS2Exception ; void removeCertificate ( @Nonnull X509Certificate aCert ) throws AS2Exception ; void removeCertificate ( String sAlias ) throws AS2Exception ; }
boolean getAndSetAttributeFlag ( String sName ) ; @Nonnull Iterator < Entry < String , String > > iterator ( ) ; }
public int compareTo ( final CharSequence sequence ) { final int minCommonLength = Math . min ( sequence . length ( ) , this . length ( ) ) ; final Iterator < Character > i = this . iterator ( ) ; for ( int j = 0 ; j < minCommonLength ; j + + ) { final char x = charAt ( j ) ; final char y = sequence . charAt ( j ) ; if ( x ! = y ) { return x - y ; } } return this . length ( ) - sequence . length ( ) ; }
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { Term t1 = args [ 0 ] ; float priority = operation . getTask ( ) . budget . getPriority ( ) ; if ( args . length > 1 ) { Term t2 = args [ 1 ] ; switch ( t1 . name ( ) . toString ( ) + " , " + t2 . name ( ) . toString ( ) ) { case " turn,left " : rover . rotate ( rotationSpeed ) ; break ; case " turn,right " : rover . rotate ( - rotationSpeed ) ; break ; } } else { switch ( t1 . name ( ) . toString ( ) ) { case " forward " : rover . thrust ( 0 , linearSpeed ) ; break ; case " backward " : rover . thrust ( 0 , - linearSpeed ) ; break ; case " stop " : rover . stop ( ) ; break ; case " random " : nar . addInput ( " (^motor,forward). :|: " ) ; rover . thrust ( 0 , linearSpeed ) ; nar . step ( 100 ) ; ArrayList < String > candids = new ArrayList < String > ( ) ; candids . add ( " (^motor,turn,left). :|: " ) ; candids . add ( " (^motor,turn,right). :|: " ) ; candids . add ( " (^motor,backward). :|: " ) ; candids . add ( " (^motor,forward). :|: " ) ; int candid = ( int ) ( Math . random ( ) * candids . size ( ) - 0.001 ) ; if ( candid > = 3 ) rover . thrust ( 0 , linearSpeed ) ; if ( candid = = 2 ) rover . thrust ( 0 , - linearSpeed ) ; if ( candid = = 1 ) rover . rotate ( - rotationSpeed ) ; if ( candid = = 0 ) rover . rotate ( rotationSpeed ) ; nar . addInput ( candids . get ( candid ) ) ; break ; } } Rover . cnt = 0 ; return null ; }
public String calculateMIC ( @Nonnull final MimeBodyPart aPart , @Nonnull final ECryptoAlgorithmSign eDigestAlgorithm , final boolean bIncludeHeaders ) throws GeneralSecurityException , MessagingException , IOException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( eDigestAlgorithm , " DigestAlgorithm " ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " BCCryptoHelper.calculateMIC ( " + eDigestAlgorithm + "  [ " + eDigestAlgorithm . getOID ( ) . getId ( ) + " ],  " + bIncludeHeaders + " ) " ) ; final ASN1ObjectIdentifier aMICAlg = eDigestAlgorithm . getOID ( ) ; final MessageDigest aMessageDigest = MessageDigest . getInstance ( aMICAlg . getId ( ) , BouncyCastleProvider . PROVIDER_NAME ) ; if ( bIncludeHeaders ) { final byte [ ] aCRLF = new byte [ ] { '\r' , '\n' } ; final Enumeration < ? > aHeaderLines = aPart . getAllHeaderLines ( ) ; while ( aHeaderLines . hasMoreElements ( ) ) { aMessageDigest . update ( _getBytes ( ( String ) aHeaderLines . nextElement ( ) ) ) ; aMessageDigest . update ( aCRLF ) ; } aMessageDigest . update ( aCRLF ) ; } final DigestOutputStream aDOS = new DigestOutputStream ( new NullOutputStream ( ) , aMessageDigest ) ; final OutputStream aOS = MimeUtility . encode ( aDOS , aPart . getEncoding ( ) ) ; final OutputStream aFOS ; if ( EContentTransferEncoding . BINARY . getID ( ) . equals ( aPart . getEncoding ( ) ) ) { aFOS = aOS ; } else { aFOS = new CRLFOutputStream ( aOS ) ; } aPart . getDataHandler ( ) . writeTo ( aFOS ) ; aFOS . close ( ) ; aOS . close ( ) ; aDOS . close ( ) ; final byte [ ] aMIC = aMessageDigest . digest ( ) ; final String ret = Base64 . encodeBytes ( aMIC ) + " ,  " + eDigestAlgorithm . getID ( ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( "   MIC =  " + ret ) ; return ret ; }
public < C > void on ( final Class < ? extends C > event , final Observer < ? extends C > o ) { if ( events . containsKey ( event ) ) events . get ( event ) . add ( o ) ;
private static Term findCommonTermPredicate ( Term tested , Term containedTest , Term commonTerm , boolean firstIsImage , boolean secondIsSameImage ) { Term resultCommonTerm = commonTerm ; if ( tested . containsTermRecursively ( containedTest ) ) { resultCommonTerm = containedTest ; } if ( secondIsSameImage & & resultCommonTerm = = null ) { resultCommonTerm = retCommonTerm ( tested , containedTest , firstIsImage ) ; } return resultCommonTerm ; }
protected void transitionState ( State newState ) { getLogger ( ) . debug ( " Transitioned state from %s to %s " , state , newState ) ; state = newState ; if ( state ! = State . WRITING ) { cmd = null ; } if ( state = = State . COMPLETE ) { callback . complete ( ) ;
void setHeaders ( @Nullable InternetHeaders aHeaders ) ; @Nullable default String getMessageID ( ) { return getHeader ( CAS2Header . HEADER_MESSAGE_ID ) ; } default void setMessageID ( @Nullable final String sMessageID ) { setHeader ( CAS2Header . HEADER_MESSAGE_ID , sMessageID ) ; } @Nonnull String generateMessageID ( ) ; default void updateMessageID ( ) { setMessageID ( generateMessageID ( ) ) ; } @Nonnull @ReturnsMutableObject ( " Design " ) Partnership getPartnership ( ) ; void setPartnership ( @Nonnull Partnership aPartnership ) ; @Nonnull @Nonempty String getAsString ( ) ; }
public void testIgnore ( ) throws InvalidParameterException { final AS2Message aMsg = new AS2Message ( ) ; aMsg . addHeader ( " message-id " , " 12345 " ) ; aMsg . getPartnership ( ) . setSenderAS2ID ( " s1 " ) ; aMsg . getPartnership ( ) . setReceiverAS2ID ( " r1 " ) ; final CompositeParameters aParams = new CompositeParameters ( true ) . add ( " msg " , new MessageParameters ( aMsg ) ) ; assertEquals ( " sender.as2_id, receiver.as2_id, headers.message-id " , aParams . format ( " sender.as2_id, receiver.as2_id, headers.message-id " ) ) ; assertEquals ( " s1, r1, 12345 " , aParams . format ( " $msg.sender.as2_id$, $msg.receiver.as2_id$, $msg.headers.message-id$ " ) ) ; assertEquals ( " " , aParams . format ( " $dummy$ " ) ) ; assertEquals ( " any " , aParams . format ( " any$dummy$ " ) ) ; assertEquals ( " any " , aParams . format ( " $dummy$any " ) ) ; assertEquals ( " foobar " , aParams . format ( " foo$dummy$bar " ) ) ; }
public Character next ( ) { if ( index > = limit ) { throw new NoSuchElementException ( " Index beyond limit:  " + index ) ; } return chars [ index + + ] ; }
void addComponent ( @Nonnull @Nonempty String sComponentID , @Nonnull IDynamicComponent aComponent ) throws ComponentDuplicateException ; @Nonnull IDynamicComponent getComponent ( @Nonnull @Nonempty String sComponentID ) throws ComponentNotFoundException ; @Nonnull @ReturnsMutableCopy ICommonsMap < String , IDynamicComponent > getAllComponents ( ) ; @Nonnull ICertificateFactory getCertificateFactory ( ) throws ComponentNotFoundException ; @Nonnull IPartnershipFactory getPartnershipFactory ( ) throws ComponentNotFoundException ; @Nonnull IMessageProcessor getMessageProcessor ( ) throws ComponentNotFoundException ; boolean isCryptoSignIncludeCertificateInBodyPart ( ) ; void setCryptoSignIncludeCertificateInBodyPart ( boolean bCryptoSignIncludeCertificateInBodyPart ) ; boolean isCryptoVerifyUseCertificateInBodyPart ( ) ; void setCryptoVerifyUseCertificateInBodyPart ( boolean bCryptoVerifyUseCertificateInBodyPart ) ; @Nullable Proxy getHttpProxy ( ) ; void setHttpProxy ( @Nullable Proxy aHttpProxy ) ; }
private static boolean runTests ( ) { testIndex = 0 ; testNumber + + ; System . out . println ( " Generating data. " ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Array= " ) ; unsorted = new Integer [ ARRAY_SIZE ] ; java . util . Set < Integer > set = new java . util . HashSet < Integer > ( ) ; for ( int i = 0 ; i < ARRAY_SIZE ; i + + ) { Integer j = RANDOM . nextInt ( RANDOM_SIZE ) ; boolean found = true ; while ( found ) { if ( set . contains ( j ) ) { j = RANDOM . nextInt ( RANDOM_SIZE ) ; } else { unsorted [ i ] = j ; set . add ( j ) ; found = false ; } } unsorted [ i ] = j ; if ( i ! = ARRAY_SIZE - 1 ) builder . append ( j ) . append ( ',' ) ; } set . clear ( ) ; set = null ; builder . append ( '\n' ) ; string = builder . toString ( ) ; if ( debug > 1 ) System . out . println ( string ) ; sorted = Arrays . copyOf ( unsorted , unsorted . length ) ; Arrays . sort ( sorted ) ; System . out . println ( " Generated data. " ) ; boolean passed = true ; passed = testJavaRedBlackIntegerTree ( ) ; if ( ! passed ) { System . err . println ( " Java Red-Black [Integer] failed. " ) ; return false ; } passed = testRedBlackTree ( ) ; if ( ! passed ) { System . err . println ( " Red-Black Tree failed. " ) ; return false ; } passed = testAVLTree ( ) ; if ( ! passed ) { System . err . println ( " AVL Tree failed. " ) ; return false ; } passed = testSplayTree ( ) ; if ( ! passed ) { System . err . println ( " Splay Tree failed. " ) ; return false ; } passed = testBTree ( ) ; if ( ! passed ) { System . err . println ( " B-Tree failed. " ) ; return false ; } passed = testTreap ( ) ; if ( ! passed ) { System . err . println ( " Treap failed. " ) ; return false ; } passed = testBST ( ) ; if ( ! passed ) { System . err . println ( " BST failed. " ) ; return false ; } passed = testJavaRedBlackStringTree ( ) ; if ( ! passed ) { System . err . println ( " Java Red-Black [String] failed. " ) ; return false ; } passed = testTrie ( ) ; if ( ! passed ) { System . err . println ( " Trie failed. " ) ; return false ; } passed = testPatriciaTrie ( ) ; if ( ! passed ) { System . err . println ( " Patricia Trie failed. " ) ; return false ; } passed = testJavaSkipList ( ) ; if ( ! passed ) { System . err . println ( " Java's Skip List failed. " ) ; return false ; } passed = testSkipList ( ) ; if ( ! passed ) { System . err . println ( " Skip List failed. " ) ; return false ; } passed = testJavaMinHeap ( ) ; if ( ! passed ) { System . err . println ( " Java Min-Heap failed. " ) ; return false ; } passed = testMinHeap ( ) ; if ( ! passed ) { System . err . println ( " Min-Heap failed. " ) ; return false ; } passed = testJavaMaxHeap ( ) ; if ( ! passed ) { System . err . println ( " Java Max-Heap failed. " ) ; return false ; } passed = testMaxHeap ( ) ; if ( ! passed ) { System . err . println ( " Max-Heap failed. " ) ; return false ; } passed = testJavaArrayList ( ) ; if ( ! passed ) { System . err . println ( " Java List failed. " ) ; return false ; } passed = testArrayList ( ) ; if ( ! passed ) { System . err . println ( " List failed. " ) ; return false ; } passed = testJavaLinkedList ( ) ; if ( ! passed ) { System . err . println ( " Java List failed. " ) ; return false ; } passed = testLinkedList ( ) ; if ( ! passed ) { System . err . println ( " List failed. " ) ; return false ; } passed = testJavaArrayQueue ( ) ; if ( ! passed ) { System . err . println ( " Java Queue failed. " ) ; return false ; } passed = testArrayQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } passed = testJavaLinkedQueue ( ) ; if ( ! passed ) { System . err . println ( " Java Queue failed. " ) ; return false ; } passed = testLinkedQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } passed = testJavaStack ( ) ; if ( ! passed ) { System . err . println ( " Java Stack failed. " ) ; return false ; } passed = testArrayStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } passed = testLinkedStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } passed = testJavaHashMap ( ) ; if ( ! passed ) { System . err . println ( " Java Hash Map failed. " ) ; return false ; } passed = testHashMap ( ) ; if ( ! passed ) { System . err . println ( " Hash Map failed. " ) ; return false ; } passed = testJavaTreeMap ( ) ; if ( ! passed ) { System . err . println ( " Java Tree Map failed. " ) ; return false ; } passed = testTreeMap ( ) ; if ( ! passed ) { System . err . println ( " Tree Map failed. " ) ; return false ; } passed = testTrieMap ( ) ; if ( ! passed ) { System . err . println ( " Trie Map failed. " ) ; return false ; } passed = testRadixTrie ( ) ; if ( ! passed ) { System . err . println ( " Radix Trie failed. " ) ; return false ; } passed = testJavaSkipListMap ( ) ; if ( ! passed ) { System . err . println ( " Java's Skip List Map failed. " ) ; return false ; } passed = testSkipListMap ( ) ; if ( ! passed ) { System . err . println ( " Skip List Map failed. " ) ; return false ; } passed = testHAMT ( ) ; if ( ! passed ) { System . err . println ( " HAMT failed. " ) ; return false ; } if ( debugTime & & debugMemory ) { String results = getTestResults ( testNumber , testNames , testResults ) ; System . out . println ( results ) ; } passed = testCompactSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Compact Suffix Trie failed. " ) ; return false ; } passed = testGraph ( ) ; if ( ! passed ) { System . err . println ( " Graph failed. " ) ; return false ; } passed = testIntervalTree ( ) ; if ( ! passed ) { System . err . println ( " Interval Tree failed. " ) ; return false ; } passed = testKdTree ( ) ; if ( ! passed ) { System . err . println ( " k-d Tree Tree failed. " ) ; return false ; } passed = testMatrix ( ) ; if ( ! passed ) { System . err . println ( " Matrix failed. " ) ; return false ; } passed = testQuadTree ( ) ; if ( ! passed ) { System . err . println ( " QuadTree failed. " ) ; return false ; } passed = testSegmentTree ( ) ; if ( ! passed ) { System . err . println ( " Segment Tree failed. " ) ; return false ; } passed = testSuffixTree ( ) ; if ( ! passed ) { System . err . println ( " Suffix Tree failed. " ) ; return false ; } passed = testSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Suffix Trie failed. " ) ; return false ; } return true ; }
private String sqlFileAsString ( String sqlFile ) throws Exception { String contents ; FileSystem fs = FileSystem . get ( new URI ( sqlFile ) , new Configuration ( ) ) ; InputStream stream = fs . open ( new Path ( sqlFile ) ) ; InputStreamReader reader = new InputStreamReader ( stream , Charsets . UTF_8 ) ; contents = CharStreams . toString ( reader ) ; reader . close ( ) ; stream . close ( ) ; return contents ; }
private X509Certificate _getCertificate ( final String sPartnershipType , final String sAlias ) throws OpenAS2Exception { try {
public void run ( final String [ ] args ) { final TextOutputHandler output = new TextOutputHandler ( nar , new PrintWriter ( out , true ) ) ; output . setErrors ( true ) ; output . setErrorStackTrace ( true ) ; final InputThread it ; final boolean hasInputFile = ! args [ 2 ] . toLowerCase ( ) . equals ( " null " ) ; final boolean hasNumberOfSteps = ! args [ 3 ] . toLowerCase ( ) . equals ( " null " ) ; if ( hasInputFile ) { nar . addInputFile ( args [ 2 ] ) ; } it = new InputThread ( System . in , nar ) ; it . start ( ) ; final int numberOfSteps = hasNumberOfSteps ? Integer . parseInt ( args [ 3 ] ) : - 1 ; if ( hasNumberOfSteps ) { nar . cycles ( numberOfSteps ) ;
public void next ( ) throws MPDServerException { mConnection . sendCommand ( nextCommand ( ) ) ; }
public abstract void doStart ( ) throws OpenAS2Exception ; public abstract void doStop ( ) throws OpenAS2Exception ; public boolean canHandle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) { return false ; } public void handle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) throws OpenAS2Exception { throw new UnsupportedException ( " Active modules don't handle anything by default " ) ; } public void forceStop ( final Exception aCause ) { new ForcedStopException ( aCause ) . terminate ( ) ; try { stop ( ) ; } catch ( final OpenAS2Exception ex ) { ex . terminate ( ) ; } } private void _setRunning ( final boolean bRunning ) { m_bRunning = bRunning ; } public void start ( ) throws OpenAS2Exception { _setRunning ( true ) ; doStart ( ) ; } public void stop ( ) throws OpenAS2Exception { _setRunning ( false ) ; doStop ( ) ; } @Override public String toString ( ) { return ToStringGenerator . getDerived ( super . toString ( ) ) . append ( " running " , m_bRunning ) . toString ( ) ; } }
private static void symmetricSymmetric ( final Sentence belief , final Sentence taskSentence , int figure , final Memory memory ) { Statement s1 = ( Statement ) belief . content ; Statement s2 = ( Statement ) taskSentence . content ; Term ut1 , ut2 ; Term rt1 , rt2 ; switch ( figure ) { case 11 : ut1 = s1 . getSubject ( ) ; ut2 = s2 . getSubject ( ) ; rt1 = s1 . getPredicate ( ) ; rt2 = s2 . getPredicate ( ) ; break ; case 12 : ut1 = s1 . getSubject ( ) ; ut2 = s2 . getPredicate ( ) ; rt1 = s1 . getPredicate ( ) ; rt2 = s2 . getSubject ( ) ; break ; case 21 : ut1 = s1 . getPredicate ( ) ; ut2 = s2 . getSubject ( ) ; rt1 = s1 . getSubject ( ) ; rt2 = s2 . getPredicate ( ) ; break ; case 22 : ut1 = s1 . getPredicate ( ) ; ut2 = s2 . getPredicate ( ) ; rt1 = s1 . getSubject ( ) ; rt2 = s2 . getSubject ( ) ; break ; default : throw new RuntimeException ( " Invalid figure:  " + figure ) ; } Term [ ] u = new Term [ ] { s1 , s2 } ; if ( Variables . unify ( VAR_INDEPENDENT , ut1 , ut2 , u ) ) {
BlockingQueue < Operation > createWriteOperationQueue ( ) ; long getOpQueueMaxBlockTime ( ) ; ExecutorService getListenerExecutorService ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; boolean isDaemon ( ) ; boolean useNagleAlgorithm ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; int getReadBufSize ( ) ; HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; MetricType enableMetrics ( ) ; MetricCollector getMetricCollector ( ) ; }
void print ( Class c , Object o ) { String s = TextOutput . getOutputString ( c , o , true , showStamp , nar ) ; if ( logFile ! = null ) { logFile . println ( s ) ; } StringBuilder h = getOutputHTML ( c , o , true , showStamp ) ; js ( new StringBuilder ( ) . append ( " var e = document.createElement('div'); e.innerHTML= \" " ) . append ( h ) . append ( " \" ;  document.getElementById('content').appendChild(e); " ) . toString ( ) ) ; scrollBottom ( ) ; }
protected boolean cacheOK ( ) { return ( useCache & & cache . refresh ( ) ) ; }
public ClauseInfo removeFirst ( ) { ClauseInfo ci = get ( 0 ) ; if ( remove ( ci ) ) { return ci ; } return null ; }
public static void main ( String [ ] arg ) { NAR nar = new DefaultNARBuilder ( ) . simulationTime ( ) . build ( ) ; nar . param ( ) . noiseLevel . set ( 0 ) ; int memCyclesPerFrame = 500 ; float fps = 20 f ; gameRate = 1.0f / fps ; NARio nario = new NARio ( nar ) ; new NARSwing ( nar ) ; nar . startFPS ( fps , memCyclesPerFrame , 1f ) ;
public void testMultipleArrivingMultipleExistingWhereAllArrivingSameTimeAsExistingWithDifferentValues ( ) { p = new EventTimeHistoryPlanner ( ) ; assertNoValidationFailures ( p , config ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 199L , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO , " " ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello! " , 200L , 200L , 299L , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO , " " ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello? " , 300L , 300L , 253402214400000L , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES , " " ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 100L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world! " , 200L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world? " , 300L ) ) ; key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 3 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " startdate " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " enddate " ) , 199L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . UPDATE ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " value " ) , " world! " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " startdate " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " enddate " ) , 299L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 2 ) ) , MutationType . UPDATE ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " value " ) , " world? " ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " startdate " ) , 300L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " enddate " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES ) ; }
public void event ( Class event , Object [ ] args ) { if ( ( event = = Solved . class ) | | ( event = = OUT . class ) ) { Task task = ( Task ) args [ 0 ] ;
protected void markAsChanged ( ) throws OpenAS2Exception { storePartnership ( ) ; }
public void onMICMatch ( @Nonnull final IMessage aMsg , @Nonnull final String sMIC ) { LOGGER . info ( " MIC is matched, MIC:  " + sMIC + aMsg . getLoggingText ( ) ) ; }
public MimeBodyPart sign ( @Nonnull final MimeBodyPart aPart , @Nonnull final X509Certificate aX509Cert , @Nonnull final PrivateKey aPrivateKey , @Nonnull final ECryptoAlgorithmSign eAlgorithm , final boolean bIncludeCertificateInSignedContent , final boolean bUseOldRFC3851MicAlgs ) throws GeneralSecurityException , SMIMEException , MessagingException , OperatorCreationException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( aX509Cert , " X509Cert " ) ; ValueEnforcer . notNull ( aPrivateKey , " PrivateKey " ) ; ValueEnforcer . notNull ( eAlgorithm , " Algorithm " ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " BCCryptoHelper.sign; X509 subject= " + aX509Cert . getSubjectX500Principal ( ) . getName ( ) + " ; algorithm= " + eAlgorithm + " ; includeCertificateInSignedContent= " + bIncludeCertificateInSignedContent ) ; aX509Cert . checkValidity ( ) ; final ICommonsList < X509Certificate > aCertList = new CommonsArrayList < > ( aX509Cert ) ; final JcaCertStore aCertStore = new JcaCertStore ( aCertList ) ; final ASN1EncodableVector aSignedAttrs = new ASN1EncodableVector ( ) ; final SMIMECapabilityVector aCapabilities = new SMIMECapabilityVector ( ) ; aCapabilities . addCapability ( eAlgorithm . getOID ( ) ) ; aSignedAttrs . add ( new SMIMECapabilitiesAttribute ( aCapabilities ) ) ; final SMIMESignedGenerator aSGen = new SMIMESignedGenerator ( bUseOldRFC3851MicAlgs ? SMIMESignedGenerator . RFC3851_MICALGS : SMIMESignedGenerator . RFC5751_MICALGS ) ; aSGen . addSignerInfoGenerator ( new JcaSimpleSignerInfoGeneratorBuilder ( ) . setProvider ( PBCProvider . getProvider ( ) ) . setSignedAttributeGenerator ( new AttributeTable ( aSignedAttrs ) ) . build ( eAlgorithm . getSignAlgorithmName ( ) , aPrivateKey , aX509Cert ) ) ; if ( bIncludeCertificateInSignedContent ) { aSGen . addCertificates ( aCertStore ) ; } final MimeMultipart aSignedData = aSGen . generate ( aPart ) ; final MimeBodyPart aTmpBody = new MimeBodyPart ( ) ; aTmpBody . setContent ( aSignedData ) ; aTmpBody . setHeader ( CHttpHeader . CONTENT_TYPE , aSignedData . getContentType ( ) ) ; return aTmpBody ; }
public PrivateKey getPrivateKey ( @Nullable final X509Certificate aCert ) throws OpenAS2Exception { final KeyStore aKeyStore = getKeyStore ( ) ; String sAlias = null ; try {
X509Certificate getCertificate ( IMessageMDN aMsg , String sPartnershipType ) throws OpenAS2Exception ; PrivateKey getPrivateKey ( IMessageMDN aMsg , X509Certificate aCert ) throws OpenAS2Exception ; }
Future < Boolean > append ( String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > append ( String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; Future < Boolean > prepend ( String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > prepend ( String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; CASResponse cas ( String key , long casId , int exp , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public Tracker reset ( ) { int len = trackers . length ; for ( int i = 0 ; i < len ; i + + ) { trackers [ i ] . reset ( ) ; } return this ; }
protected void updateGUI ( ) { speedSlider . repaint ( ) ; long nowTime = nar . getTime ( ) ; if ( lastUpdateCycle ! = nowTime ) { chart . update ( true ) ;
public HttpHeaderMap getHeaderFields ( ) { final HttpHeaderMap ret = new HttpHeaderMap ( ) ; for ( final Map . Entry < String , List < String > > aEntry : m_aHttpURLConnection . getHeaderFields ( ) . entrySet ( ) ) { final String sName = aEntry . getKey ( ) ; for ( final String sValue : aEntry . getValue ( ) ) ret . addHeader ( sName , sValue ) ; } return ret ; }
public Object clone ( ) { return new Operation ( name , cloneList ( components ) , isConstant , complexity ) ; }
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) { return asyncGetBulk ( keys , new SingleElementInfiniteIterator < Transcoder < T > > ( tc ) ) ;
public boolean containsAll ( Collection < ? > arg0 ) { return false ; }
public void setCrossfade ( int time ) throws MPDServerException { mpdConnection . sendCommand ( MPDCommand . MPD_CMD_CROSSFADE , Integer . toString ( Math . max ( 0 , time ) ) ) ;
public List < String > listAlbums ( ) throws MPDServerException { return listAlbums ( null , false , false ) ; }
public void actionPerformed ( ActionEvent event ) { redoAction ( ) ; }
protected final void receiveMDN ( @Nonnull final AS2Message aMsg , final byte [ ] aData , @Nonnull final IAS2HttpResponseHandler aResponseHandler ) throws OpenAS2Exception , IOException { try {
public static Bitmap decodeSampledBitmapFromBytes ( byte [ ] bytes , int reqWidth , int reqHeight , boolean resizePerfectly ) { final BitmapFactory . Options options = new BitmapFactory . Options ( ) ; options . inJustDecodeBounds = true ; BitmapFactory . decodeByteArray ( bytes , 0 , bytes . length , options ) ; options . inSampleSize = calculateInSampleSize ( options , reqWidth , reqHeight ) ; options . inJustDecodeBounds = false ; final Bitmap bitmap = BitmapFactory . decodeByteArray ( bytes , 0 , bytes . length , options ) ; if ( resizePerfectly ) { final Bitmap scaledBitmap = Bitmap
public void onChange ( float v ) { canvas . setMotionBlur ( v ) ; }
Collection < StatsSession > getSessions ( StatsKeyMatcher keyMatcher ) ; StatsSession getSession ( StatsKey key ) ; StatsSession getOrCreateSession ( StatsKey key ) ; StatsSession remove ( StatsKey key ) ; boolean remove ( StatsSession session ) ; void clear ( ) ; void clearAllSessions ( ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; int [ ] heap = getHeap ( ) ; for ( int node : heap ) { builder . append ( node ) . append ( " ,  " ) ; } return builder . toString ( ) ; }
protected Node < T > addValue ( T value ) { RedBlackNode < T > nodeAdded = null ; boolean added = false ; if ( root = = null ) { root = new RedBlackNode < T > ( null , value , Color . Black ) ; root . lesser = new RedBlackNode < T > ( root , null , Color . Black ) ; root . greater = new RedBlackNode < T > ( root , null , Color . Black ) ; nodeAdded = ( RedBlackNode < T > ) root ; added = true ; } else { Node < T > node = root ; while ( node ! = null ) { if ( node . value = = null ) { node . value = value ; ( ( RedBlackNode < T > ) node ) . color = Color . Red ; node . lesser = new RedBlackNode < T > ( node , null , Color . Black ) ; node . greater = new RedBlackNode < T > ( node , null , Color . Black ) ; nodeAdded = ( RedBlackNode < T > ) node ; added = true ; break ; } else if ( value . compareTo ( node . value ) < = 0 ) { node = node . lesser ; } else { node = node . greater ; } } } if ( added = = true ) { boolean result = balanceAfterInsert ( nodeAdded ) ; if ( result ) size + + ; } return nodeAdded ; }
public AS2MDNReceiverHandler createHandler ( ) { return new AS2MDNReceiverHandler ( this ) ; }
public synchronized void removeAllExceptionListeners ( ) { exceptionListeners . clear ( ) ; }
public void multiply ( final double x ) { if ( x = = 1.0 ) return ; if ( relevancy = = null ) return ; List < Term > toRemove = null ; for ( Map . Entry < Term , Double > e : relevancy . entrySet ( ) ) { double newValue = e . getValue ( ) * x ; if ( newValue < minStrength ) { if ( toRemove = = null ) toRemove = new ArrayList ( ) ; toRemove . add ( e . getKey ( ) ) ; } else e . setValue ( newValue ) ; } for ( Term t : toRemove ) relevancy . remove ( t ) ; }
public < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) { return asyncGetBulk ( Arrays . asList ( keys ) , tc ) ; }
public long decr ( String key , long by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; }
public String cdr ( ) { try { if ( ! listP ( ) ) { return null ; } List quoteChars = Arrays . asList ( '"' , '\'' ) ; int i = 0 ; while ( theFormula . charAt ( i ) ! = '(' ) i + + ; i + + ; while ( Character . isWhitespace ( theFormula . charAt ( i ) ) ) i + + ; if ( theFormula . charAt ( i ) = = '(' ) { boolean insideQuote = false ; char quoteCharInForce = '0' ; int level = 0 ; i + + ; while ( insideQuote | | theFormula . charAt ( i ) ! = ')' | | level > 0 ) { if ( quoteChars . contains ( theFormula . charAt ( i ) ) ) { if ( theFormula . charAt ( i - 1 ) ! = '\\' ) { if ( quoteCharInForce = = '0' ) { quoteCharInForce = theFormula . charAt ( i ) ; insideQuote = true ; } else if ( quoteCharInForce = = theFormula . charAt ( i ) ) { quoteCharInForce = '0' ; insideQuote = false ; } } } if ( ! insideQuote ) { if ( theFormula . charAt ( i ) = = ')' ) level - - ; if ( theFormula . charAt ( i ) = = '(' ) level + + ; } i + + ; } i + + ; } else { if ( theFormula . charAt ( i ) = = '"' | | theFormula . charAt ( i ) = = '\'' ) { char quoteChar = theFormula . charAt ( i ) ; i + + ; while ( ( ( theFormula . charAt ( i ) ! = quoteChar | | ( theFormula . charAt ( i ) = = quoteChar & & theFormula . charAt ( i - 1 ) = = '\\' ) ) & & i < theFormula . length ( ) - 1 ) ) { i + + ; } i + + ; } else { while ( ! Character . isWhitespace ( theFormula . charAt ( i ) ) & & i < theFormula . length ( ) - 1 ) i + + ; } } while ( ( i < theFormula . length ( ) ) & & Character . isWhitespace ( theFormula . charAt ( i ) ) ) i + + ; int end = theFormula . lastIndexOf ( ')' ) ; return " ( " + theFormula . substring ( i , end ) + " ) " ; } catch ( Exception ex ) { System . out . println ( " \ nError in Formula.cdr( " + theFormula + " ):  " + ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; } return null ; }
public void onActivityResult ( int requestCode , int resultCode , Intent data ) { super . onActivityResult ( requestCode , resultCode , data ) ; switch ( requestCode ) { case SETTINGS :
public void parse ( Reader reader , Config destination , ParsingMode parsingMode ) { CharacterInput input = new ReaderInput ( reader ) ; if ( input . peek ( ) = = - 1 ) { if ( emptyDataAccepted ) { return ; } else { throw new ParsingException ( " No json data: input is empty " ) ; } } char firstChar = input . readCharAndSkip ( SPACES ) ; if ( firstChar ! = '{' ) { throw new ParsingException ( " Invalid first character for a json object:  " + firstChar ) ; } if ( destination instanceof ConcurrentConfig ) { ( ( ConcurrentConfig ) destination ) . bulkUpdate ( view - > { parsingMode . prepareParsing ( view ) ; parseObject ( input , view , parsingMode ) ; } ) ; } else { parsingMode . prepareParsing ( destination ) ; parseObject ( input , destination , parsingMode ) ; } checkNoTrailingData ( input ) ; }
public abstract Schema getSchema ( ) throws Exception ; public abstract RecordModel getRecordModel ( ) throws Exception ; public static QueueSource queueSourceFor ( Properties props ) throws Exception { QueueSource qs = null ; String queueSourceName = props . getProperty ( " source " ) ; if ( queueSourceName . equals ( " kafka " ) ) { qs = new KafkaQueueSource ( props ) ; } else { Class < ? > clazz = Class . forName ( queueSourceName ) ; Constructor < ? > constructor = clazz . getConstructor ( ) ; qs = ( QueueSource ) constructor . newInstance ( props ) ; } return qs ; } }
public List < String > listArtists ( ) throws IOException , MPDException { return listArtists ( true ) ; }
void dragElems ( ) { } void checkSelect ( ) { } } static class Edge { public final int from ; public final int to ; public final int alpha ; public Edge ( final int from , final int to , int alpha ) { this . from = from ; this . to = to ; this . alpha = alpha ; } public Edge ( final int from , final int to , float alpha ) { this ( from , to , ( int ) ( 255.0 * alpha ) ) ; } } }
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenu . ContextMenuInfo menuInfo ) { super . onCreateContextMenu ( menu , v , menuInfo ) ; MenuInflater inflater = getMenuInflater ( ) ; inflater . inflate ( R . menu . mpd_playlistcnxmenu , menu ) ; AdapterView . AdapterContextMenuInfo info = ( AdapterView . AdapterContextMenuInfo ) menuInfo ; title = ( String ) songlist . get ( info . position ) . get ( " title " ) ; menu . setHeaderTitle ( title ) ; }
public void derive ( ) throws Exception { StructType existingSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " field1 " , DataTypes . IntegerType , true ) , DataTypes . createStructField ( " field2 " , DataTypes . StringType , true ) ) ) ; List < Row > existingRows = Lists . newArrayList ( ) ; existingRows . add ( RowFactory . create ( 1000 , " Envelopes " ) ) ; existingRows . add ( RowFactory . create ( 1001 , " Stamps " ) ) ; Dataset < Row > existingDF = Contexts . getSparkSession ( ) . createDataFrame ( existingRows , existingSchema ) ; StructType newSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " field1 " , DataTypes . IntegerType , true ) , DataTypes . createStructField ( " field2 " , DataTypes . StringType , true ) , DataTypes . createStructField ( " field3 " , DataTypes . StringType , true ) ) ) ; List < Row > newRows = Lists . newArrayList ( ) ; newRows . add ( RowFactory . create ( 1000 , " Envelopes " , " Nope " ) ) ; newRows . add ( RowFactory . create ( 1001 , " Stamps " , " Nope " ) ) ; newRows . add ( RowFactory . create ( 1000 , " Stamps " , " Yep " ) ) ; newRows . add ( RowFactory . create ( 1000 , " Staplers " , " Yep " ) ) ; newRows . add ( RowFactory . create ( 1001 , " Envelopes " , " Yep " ) ) ; Dataset < Row > newDF = Contexts . getSparkSession ( ) . createDataFrame ( newRows , newSchema ) ; Map < String , Dataset < Row > > dependencies = new HashMap < > ( ) ; dependencies . put ( " New " , newDF ) ; dependencies . put ( " Existing " , existingDF ) ; Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( ExcludeDeriver . EXCLUSION_COMPARE_CONFIG , " New " ) ; paramMap . put ( ExcludeDeriver . EXCLUSION_WITH_CONFIG , " Existing " ) ; paramMap . put ( ExcludeDeriver . EXCLUSION_FIELDS_CONFIG , Lists . newArrayList ( " field1 " , " field2 " ) ) ; config = ConfigFactory . parseMap ( paramMap ) ; ExcludeDeriver excludeDeriver = new ExcludeDeriver ( ) ; excludeDeriver . configure ( config ) ; Dataset < Row > results = excludeDeriver . derive ( dependencies ) ; assertNotNull ( " Results is null " , results ) ; assertNotNull ( " Invalid schema " , results . schema ( ) ) ; assertEquals ( " Invalid schema field count " , 3 , results . schema ( ) . fieldNames ( ) . length ) ; assertEquals ( " Invalid schema field name " , " field3 " , results . schema ( ) . fieldNames ( ) [ 2 ] ) ; assertEquals ( " Invalid schema field name " , DataTypes . StringType , results . schema ( ) . fields ( ) [ 2 ] . dataType ( ) ) ; assertEquals ( " Invalid row count " , 3 , results . count ( ) ) ; }
public static EContentTransferEncoding getFromIDCaseInsensitiveOrDefault ( @Nullable final String sID , @Nullable final EContentTransferEncoding eDefault ) { return EnumHelper . getFromIDCaseInsensitiveOrDefault ( EContentTransferEncoding . class , sID , eDefault ) ; }
public boolean remove ( T value ) { Node < T > prev = null ; Node < T > node = head ; while ( node ! = null & & ( ! node . value . equals ( value ) ) ) { prev = node ; node = node . next ; } if ( node = = null ) return false ; if ( node . equals ( tail ) ) { tail = prev ; if ( prev ! = null ) prev . next = null ; } Node < T > next = node . next ; if ( prev ! = null & & next ! = null ) { prev . next = next ; } else if ( prev ! = null & & next = = null ) { prev . next = null ; } else if ( prev = = null & & next ! = null ) { head = next ; } else { head = null ; } size - - ; return true ; }
protected ArrayList listRelnsWithRelnArgs ( ) { if ( relnsWithRelnArgs ! = null ) { return new ArrayList ( relnsWithRelnArgs . keySet ( ) ) ; } return null ; }
static Object parse ( CharacterInput input , TomlParser parser , CommentedConfig parentConfig ) { return parse ( input , Toml . readNonSpaceChar ( input , false ) , parser , parentConfig ) ; }
public void onStart ( ) { super . onStart ( ) ; app . setActivity ( this ) ; if ( app . isNotificationPersistent ( ) ) { startService ( MPDroidService . class , MPDroidService . ACTION_START ) ;
protected synchronized void reload ( ) { if ( ! pending . isEmpty ( ) ) return ; this . now = memory . time ( ) ; int j = 0 ; for ( Map . Entry < K , E > s : items . entrySet ( ) ) { E e = s . getValue ( ) ; if ( ready ( e ) ) { if ( j + + % 2 = = 0 ) pending . addFirst ( e ) ; else pending . addLast ( e ) ; } else if ( forget ( e ) ) toRemove . add ( e . name ( ) ) ; } for ( final K k : toRemove ) { E r = items . remove ( k ) ; if ( r instanceof Concept ) attention . conceptRemoved ( ( Concept ) r ) ; } toRemove . clear ( ) ; int activated = pending . size ( ) ; if ( activated < targetActivations ) { activityThreshold * = 0.99f ; if ( activityThreshold < 0.01 ) activityThreshold = 0.01f ; skippedPerSample = 0 ; } else if ( activated > targetActivations ) { activityThreshold * = 1.1f ; if ( activityThreshold > 0.99 ) activityThreshold = 0.99f ; skippedPerSample = ( int ) Math . ceil ( activated / targetActivations ) - 1 ; if ( skippedPerSample < 0 ) skippedPerSample = 0 ; } int s = size ( ) ; if ( s > capacity ) { forgetThreshold * = 1.01f ;
public double continuous ( int discretized ) { return continuous ( ( double ) discretized ) ; }
public void buildRowValues ( ) { DynamicMessage nestedMessage0 = DynamicMessage . newBuilder ( SINGLE_DESC . findNestedTypeByName ( " NestedExample " ) ) . setField ( SINGLE_DESC . findNestedTypeByName ( " NestedExample " ) . findFieldByName ( " nested " ) , " a nested type " ) . build ( ) ; DynamicMessage nestedMessage1 = DynamicMessage . newBuilder ( SINGLE_DESC . findNestedTypeByName ( " NestedExample " ) ) . setField ( SINGLE_DESC . findNestedTypeByName ( " NestedExample " ) . findFieldByName ( " nested " ) , " another nested type " ) . build ( ) ; DynamicMessage mapInt0 = DynamicMessage . newBuilder ( SINGLE_DESC . findNestedTypeByName ( " MapIntEntry " ) ) . setField ( SINGLE_DESC . findNestedTypeByName ( " MapIntEntry " ) . findFieldByName ( " key " ) , " key value " ) . setField ( SINGLE_DESC . findNestedTypeByName ( " MapIntEntry " ) . findFieldByName ( " value " ) , 987 ) . build ( ) ; DynamicMessage mapInt1 = DynamicMessage . newBuilder ( SINGLE_DESC . findNestedTypeByName ( " MapIntEntry " ) ) . setField ( SINGLE_DESC . findNestedTypeByName ( " MapIntEntry " ) . findFieldByName ( " key " ) , " another key value " ) . setField ( SINGLE_DESC . findNestedTypeByName ( " MapIntEntry " ) . findFieldByName ( " value " ) , 123 ) . build ( ) ; Map < String , Integer > stringIntegerMap = new HashMap < > ( ) ; stringIntegerMap . put ( " key value " , 987 ) ; stringIntegerMap . put ( " another key value " , 123 ) ; DynamicMessage message = DynamicMessage . newBuilder ( SINGLE_DESC ) . setField ( SINGLE_DESC . findFieldByName ( " string " ) , " string value " ) . setField ( SINGLE_DESC . findFieldByName ( " double " ) , 987.654D ) . setField ( SINGLE_DESC . findFieldByName ( " float " ) , 987.654F ) . setField ( SINGLE_DESC . findFieldByName ( " int32 " ) , 987 ) . setField ( SINGLE_DESC . findFieldByName ( " int64 " ) , 987L ) . setField ( SINGLE_DESC . findFieldByName ( " uint32 " ) , 987 ) . setField ( SINGLE_DESC . findFieldByName ( " uint64 " ) , 987L ) . setField ( SINGLE_DESC . findFieldByName ( " sint32 " ) , 987 ) . setField ( SINGLE_DESC . findFieldByName ( " sint64 " ) , 987L ) . setField ( SINGLE_DESC . findFieldByName ( " fixed32 " ) , 987 ) . setField ( SINGLE_DESC . findFieldByName ( " fixed64 " ) , 987L ) . setField ( SINGLE_DESC . findFieldByName ( " sfixed32 " ) , 987 ) . setField ( SINGLE_DESC . findFieldByName ( " sfixed64 " ) , 987L ) . setField ( SINGLE_DESC . findFieldByName ( " boolean " ) , true ) . setField ( SINGLE_DESC . findFieldByName ( " bytes " ) , ByteString . copyFrom ( " foo " . getBytes ( ) ) ) . setField ( SINGLE_DESC . findFieldByName ( " enum " ) , SINGLE_DESC . findEnumTypeByName ( " EnumExample " ) . findValueByName ( " THREE " ) ) . setField ( SINGLE_DESC . findFieldByName ( " nested " ) , nestedMessage0 ) . addRepeatedField ( SINGLE_DESC . findFieldByName ( " map_int " ) , mapInt0 ) . addRepeatedField ( SINGLE_DESC . findFieldByName ( " map_int " ) , mapInt1 ) . addRepeatedField ( SINGLE_DESC . findFieldByName ( " repeating_message " ) , nestedMessage0 ) . addRepeatedField ( SINGLE_DESC . findFieldByName ( " repeating_message " ) , nestedMessage1 ) . addRepeatedField ( SINGLE_DESC . findFieldByName ( " repeating_int32 " ) , 1234 ) . addRepeatedField ( SINGLE_DESC . findFieldByName ( " repeating_int32 " ) , 5678 ) . addRepeatedField ( SINGLE_DESC . findFieldByName ( " repeating_enum " ) , SINGLE_DESC . findEnumTypeByName ( " EnumExample " ) . findValueByName ( " TWO " ) ) . addRepeatedField ( SINGLE_DESC . findFieldByName ( " repeating_enum " ) , SINGLE_DESC . findEnumTypeByName ( " EnumExample " ) . findValueByName ( " TWO " ) ) . build ( ) ; List < Object > results = ProtobufUtils . buildRowValues ( SINGLE_DESC , message , SINGLE_SCHEMA ) ; assertThat ( results , contains ( ( Object ) " string value " ,
public E remove ( K key , E value ) { E removed = null ; if ( key ! = null ) { removed = removeKey ( key ) ; } if ( value ! = null ) { boolean b = removeItem ( value ) ; if ( ( removed ! = null ) & & ( ! b ) ) { throw new RuntimeException ( " removed key but not value, inconsisency " ) ; } if ( ( removed = = null ) & & b ) removed = value ; } return removed ; }
int getIndex ( ) ; interface Callback extends OperationCallback { void gotData ( String key , long cas , MemcachedNode node , ObserveResponse or ) ; } }
static BudgetValue solutionEval ( Sentence problem , Sentence solution , Task task , Memory memory ) { BudgetValue budget = null ; boolean feedbackToLinks = false ; if ( task = = null ) { task = memory . currentTask ; feedbackToLinks = true ; } boolean judgmentTask = task . getSentence ( ) . isJudgment ( ) ; float quality = LocalRules . solutionQuality ( problem , solution ) ; if ( judgmentTask ) { task . incPriority ( quality ) ; } else { float taskPriority = task . getPriority ( ) ; budget = new BudgetValue ( or ( taskPriority , quality ) , task . getDurability ( ) , truthToQuality ( solution . getTruth ( ) ) ) ; task . setPriority ( Math . min ( 1 - quality , taskPriority ) ) ; } if ( feedbackToLinks ) { TaskLink tLink = memory . currentTaskLink ; tLink . setPriority ( Math . min ( 1 - quality , tLink . getPriority ( ) ) ) ; TermLink bLink = memory . currentBeliefLink ; bLink . incPriority ( quality ) ; } return budget ; }
public char directReadChar ( ) throws ParsingException { int read ; try { read = reader . read ( ) ; } catch ( IOException e ) { throw new ParsingException ( " Failed to read data " , e ) ; } if ( read = = - 1 ) { throw new ParsingException ( " Not enough data available " ) ; } return ( char ) read ; }
public void skipToPosition ( final int position ) throws IOException , MPDException { mConnection . sendCommand ( skipToPositionCommand ( position ) ) ; }
boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull String sDigest , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull String sAlgorithm ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey key , @Nonnull String sAlgorithm ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert ) throws Exception ; }
public Row translate ( String key , String message ) { kvpMap . clear ( ) ; values . clear ( ) ; String [ ] kvps = message . split ( Pattern . quote ( kvpDelimiter ) ) ; for ( String kvp : kvps ) { String [ ] components = kvp . split ( Pattern . quote ( fieldDelimiter ) ) ; String kvpKey = components [ 0 ] ; String kvpValue = components [ 1 ] ; kvpMap . put ( kvpKey , kvpValue ) ; } for ( StructField field : schema . fields ( ) ) { String fieldName = field . name ( ) ; if ( kvpMap . containsKey ( fieldName ) ) { String kvpValue = kvpMap . get ( fieldName ) ; if ( field . dataType ( ) . equals ( DataTypes . StringType ) ) { values . add ( kvpValue ) ; } else if ( field . dataType ( ) . equals ( DataTypes . FloatType ) ) { values . add ( Float . parseFloat ( kvpValue ) ) ; } else if ( field . dataType ( ) . equals ( DataTypes . DoubleType ) ) { values . add ( Double . parseDouble ( kvpValue ) ) ; } else if ( field . dataType ( ) . equals ( DataTypes . IntegerType ) ) { values . add ( Integer . parseInt ( kvpValue ) ) ; } else if ( field . dataType ( ) . equals ( DataTypes . LongType ) ) { values . add ( Long . parseLong ( kvpValue ) ) ; } else if ( field . dataType ( ) . equals ( DataTypes . BooleanType ) ) { values . add ( Boolean . parseBoolean ( kvpValue ) ) ; } else { throw new RuntimeException ( " Unsupported KVP field type:  " + field . dataType ( ) ) ; } } else { values . add ( null ) ; } } Row row = RowFactory . create ( values . toArray ( ) ) ; return row ; }
public static void main ( String [ ] arg ) { NAR nar = new DefaultNARBuilder ( ) . setConceptBagSize ( 2048 ) . build ( ) ; nar . param ( ) . duration . set ( 3 ) ; nar . param ( ) . noiseLevel . set ( 0 ) ; nar . param ( ) . shortTermMemorySize . set ( 35 ) ; NARio nario = new NARio ( nar ) ; new NARSwing ( nar ) ; nar . start ( 100 , 2 ) ; }
public static int minIndex ( double [ ] doubles ) { double minimum = 0 ; int minIndex = 0 ; for ( int i = 0 ; i < doubles . length ; i + + ) { if ( ( i = = 0 ) | | ( doubles [ i ] < minimum ) ) { minIndex = i ; minimum = doubles [ i ] ; } } return minIndex ; }
public Term clone ( ) { Term t = new Term ( ) ; t . name = name ; return t ; }
public SolveInfo solveNext ( double maxTimeSec ) throws NoMoreSolutionException { if ( hasOpenAlternatives ( ) ) { SolveInfo sinfo = engineManager . solveNext ( maxTimeSec ) ;
default public void onVisible ( boolean showing ) { } }
public void byteMessageInvalid ( ) throws Exception { new Expectations ( ) { { config . getString ( MorphlineTranslator . ENCODING_KEY ) ; result = " UTF-8 " ; config . getString ( MorphlineTranslator . ENCODING_MSG ) ; result = " US-ASCII " ; config . getString ( MorphlineTranslator . MORPHLINE ) ; result = getResourcePath ( MORPHLINE_FILE ) ; config . getString ( MorphlineTranslator . MORPHLINE_ID ) ; result = " encoding-message " ; config . getStringList ( MorphlineTranslator . FIELD_NAMES ) ; result = Lists . newArrayList ( " int " , " str " , " float " ) ; config . getStringList ( MorphlineTranslator . FIELD_TYPES ) ; result = Lists . newArrayList ( " int " , " string " , " float " ) ; } } ; byteMorphline . configure ( config ) ; String message = " \ u16b7 " ; Iterator < Row > result = byteMorphline . translate ( " The Key " . getBytes ( " UTF-8 " ) , message . getBytes ( " UTF-16 " ) ) ; Row row = result . next ( ) ; Assert . assertNotNull ( " Row is null " , result ) ; Assert . assertEquals ( " Invalid number of fields " , 3 , row . length ( ) ) ; Assert . assertEquals ( " Invalid field value " , 123 , row . get ( 0 ) ) ; Assert . assertFalse ( " Invalid encoded field value " , message . equals ( row . get ( 1 ) ) ) ; Assert . assertEquals ( " Invalid field value " , 234 F , row . get ( 2 ) ) ; }
private void testConfigToObject ( Config config , Object object ) throws Exception { System . out . println ( " Before:  " + object ) ; ConfigToObjectMapper mapper = new ConfigToObjectMapper ( ) ; mapper . map ( config , object ) ; System . out . println ( " After:  " + object ) ; }
public void SaveToFile ( String name ) throws FileNotFoundException , IOException { FileOutputStream outStream = new FileOutputStream ( name ) ; ObjectOutputStream stream = new ObjectOutputStream ( outStream ) ; stream . writeObject ( this ) ; outStream . close ( ) ; }
private void processConnectionRequests ( ) { while ( this . allConns . size ( ) < this . maxConnections ) { AsyncConnectionRequest request = this . pendingRequests . poll ( ) ;
DeleteOperation delete ( String key , int when , OperationCallback operationCallback ) ; FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; MutatatorOperation mutate ( MutatatorOperation . Mutator m , String key , int by , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }
public void testOneKeyFieldName ( ) throws Exception { StructType ordersSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " order_id " , DataTypes . IntegerType , true ) , DataTypes . createStructField ( " product_name " , DataTypes . StringType , true ) , DataTypes . createStructField ( " customer_id " , DataTypes . IntegerType , true ) ) ) ; StructType customersSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " customer_id " , DataTypes . IntegerType , true ) , DataTypes . createStructField ( " name " , DataTypes . StringType , true ) ) ) ; List < Row > orderRows = Lists . newArrayList ( ) ; orderRows . add ( RowFactory . create ( 1000 , " Envelopes " , 10000 ) ) ; orderRows . add ( RowFactory . create ( 1001 , " Stamps " , 10000 ) ) ; orderRows . add ( RowFactory . create ( 1002 , " Pens " , 10000 ) ) ; orderRows . add ( RowFactory . create ( 1003 , " Paper " , 10001 ) ) ; List < Row > customerRows = Lists . newArrayList ( ) ; customerRows . add ( RowFactory . create ( 10000 , " Jane " ) ) ; customerRows . add ( RowFactory . create ( 10001 , " Joe " ) ) ; DataFrame orders = sqlc . createDataFrame ( orderRows , ordersSchema ) ; DataFrame customers = sqlc . createDataFrame ( customerRows , customersSchema ) ; Map < String , DataFrame > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " orders " , orders ) ; dependencies . put ( " customers " , customers ) ; Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( NestDeriver . NEST_FROM_CONFIG_NAME , " orders " ) ; configMap . put ( NestDeriver . NEST_INTO_CONFIG_NAME , " customers " ) ; configMap . put ( NestDeriver . KEY_FIELD_NAMES_CONFIG_NAME , Lists . newArrayList ( " customer_id " ) ) ; configMap . put ( NestDeriver . NESTED_FIELD_NAME_CONFIG_NAME , " orders " ) ; Config config = ConfigFactory . parseMap ( configMap ) ; Deriver deriver = new NestDeriver ( config ) ; DataFrame nested = deriver . derive ( dependencies ) ; assertEquals ( nested . count ( ) , 2 ) ; List < Row > jane = nested . where ( " name = 'Jane' " ) . collectAsList ( ) ; assertEquals ( jane . size ( ) , 1 ) ; Row janeRow = jane . get ( 0 ) ; assertEquals ( janeRow . getList ( janeRow . fieldIndex ( " orders " ) ) . size ( ) , 3 ) ; List < Row > joe = nested . where ( " name = 'Joe' " ) . collectAsList ( ) ; assertEquals ( joe . size ( ) , 1 ) ; Row joeRow = joe . get ( 0 ) ; assertEquals ( joeRow . getList ( joeRow . fieldIndex ( " orders " ) ) . size ( ) , 1 ) ; }
public Collection < V > values ( ) { Collection < V > vs = values ; return ( vs ! = null ) ? vs : ( values = new Values ( ) ) ; }
public void polygons ( double d , double d1 , double d2 , String s ) { addFaces ( 0 , d , d1 , d2 , s ) ; }
private void windDownResources ( final int action ) { Log . d ( TAG , " Winding down resources. " ) ; sendToBoundService ( SERVICE_WOUND_DOWN ) ; if ( STREAMING_STOP = = action ) { setupServiceControlHandlers ( ) ; } if ( action ! = INVALID_INT ) { sendToBoundService ( action ) ; } if ( mTelephonyManager ! = null ) { mTelephonyManager . listen ( phoneStateListener , PhoneStateListener . LISTEN_NONE ) ; } if ( audioManager ! = null ) { audioManager . abandonAudioFocus ( this ) ; } if ( mediaPlayer ! = null ) { if ( mediaPlayer . isPlaying ( ) ) {
public void connectionStateChanged ( final boolean connected , final boolean connectionLost ) { if ( DEBUG ) { Log . d ( TAG , " connectionStateChanged( " + connected + " ,  " + connectionLost + ')' ) ; } final MPDStatus mpdStatus = getMPDStatus ( ) ; if ( connected ) { stateChanged ( mpdStatus , MPDStatus . STATE_UNKNOWN ) ;
private static final String convertToHex ( byte [ ] data ) { if ( data = = null | | data . length = = 0 ) { return null ; } final StringBuffer buffer = new StringBuffer ( ) ; for ( int byteIndex = 0 ; byteIndex < data . length ; byteIndex + + ) { int halfbyte = ( data [ byteIndex ] > > > 4 ) & 0x0F ; int two_halfs = 0 ; do { if ( ( 0 < = halfbyte ) & & ( halfbyte < = 9 ) ) buffer . append ( ( char ) ( '0' + halfbyte ) ) ; else buffer . append ( ( char ) ( 'a' + ( halfbyte - 10 ) ) ) ; halfbyte = data [ byteIndex ] & 0x0F ; } while ( two_halfs + + < 1 ) ; } return buffer . toString ( ) ; }
public void emitParticles ( float particleSpeed , float spread , float heading , float angle , float px , float py , int numberSquare ) { for ( int x = 0 ; x < = numberSquare ; x + + ) { for ( int y = 0 ; y < = numberSquare ; y + + ) {
public float edgeWeight ( Object edge ) { throw new UnsupportedOperationException ( " Not supported yet. " ) ; }
protected DataSet createDataSet ( final boolean drainedSession ) { DataSet dataSet = new DefaultDataSet ( System . currentTimeMillis ( ) , drainedSession , new FastPutsLinkedMap < > ( ) ) { @Override protected Map < String , Object > createMetaDataMap ( ) { return new FastPutsLinkedMap < > ( ) ; } } ; return dataSet ; }
public ICommonsList < Partner > getAllPartners ( ) { return m_aRWLock . readLockedGet ( m_aPartners : : getAllPartners ) ; }
public void testCreateKeyStores ( ) throws GeneralSecurityException { final BCCryptoHelper x = new BCCryptoHelper ( ) ; for ( final EKeyStoreType e : EKeyStoreType . values ( ) ) if ( e . isKeyStorePathRequired ( ) )
public void testReadTwoChunkBuffer ( ) throws Exception { try ( final InputStream empty = new NonBlockingByteArrayInputStream ( " 2 \ r \ n12 \ r \ n1 \ na \ r \ n0 \ r \ n " . getBytes ( ) ) ; final ChunkedInputStream cIS = new ChunkedInputStream ( empty ) )
public abstract void log ( Level level , Object message , Throwable e ) ; }
protected void updateHttpHeaders ( @Nonnull final IAS2HttpHeaderWrapper aConn , @Nonnull final IMessage aMsg ) { final Partnership aPartnership = aMsg . partnership ( ) ; aMsg . forEachHeader ( ( k , v ) - > aConn . setHttpHeader ( k , v ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_CONNECTION , CAS2Header . DEFAULT_CONNECTION ) ; aConn . setHttpHeader ( CAS2Header . HEADER_USER_AGENT , CAS2Header . DEFAULT_USER_AGENT ) ; aConn . setHttpHeader ( CAS2Header . HEADER_DATE , DateHelper . getFormattedDateNow ( CAS2Header . DEFAULT_DATE_FORMAT ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_MESSAGE_ID , aMsg . getMessageID ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_MIME_VERSION , CAS2Header . DEFAULT_MIME_VERSION ) ; aConn . setHttpHeader ( CAS2Header . HEADER_CONTENT_TYPE , aMsg . getContentType ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_AS2_VERSION , CAS2Header . DEFAULT_AS2_VERSION ) ; aConn . setHttpHeader ( CAS2Header . HEADER_RECIPIENT_ADDRESS , aPartnership . getAS2URL ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_AS2_FROM , aPartnership . getSenderAS2ID ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_AS2_TO , aPartnership . getReceiverAS2ID ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_SUBJECT , aMsg . getSubject ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_FROM , aPartnership . getSenderEmail ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING , aMsg . getHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING ) ) ; final String sDispTo = aPartnership . getAS2MDNTo ( ) ; if ( sDispTo ! = null ) aConn . setHttpHeader ( CAS2Header . HEADER_DISPOSITION_NOTIFICATION_TO , sDispTo ) ; final String sDispositionNotificationOptions = aPartnership . getAS2MDNOptions ( ) ; if ( sDispositionNotificationOptions ! = null ) aConn . setHttpHeader ( CAS2Header . HEADER_DISPOSITION_NOTIFICATION_OPTIONS , sDispositionNotificationOptions ) ; final String sReceiptDeliveryOption = aPartnership . getAS2ReceiptDeliveryOption ( ) ; if ( sReceiptDeliveryOption ! = null ) aConn . setHttpHeader ( CAS2Header . HEADER_RECEIPT_DELIVERY_OPTION , sReceiptDeliveryOption ) ; final String sContententDisposition = aMsg . getContentDisposition ( ) ; if ( sContententDisposition ! = null ) aConn . setHttpHeader ( CAS2Header . HEADER_CONTENT_DISPOSITION , sContententDisposition ) ;
public static void introVarOuter ( final Statement taskContent , final Statement beliefContent , final int index , final DerivationContext nal ) { if ( ! ( taskContent instanceof Inheritance ) ) { return ; } Term term11 = taskContent . getSubject ( ) ; Term term21 = beliefContent . getSubject ( ) ; Term term12 = taskContent . getPredicate ( ) ; Term term22 = beliefContent . getPredicate ( ) ; Statement state1 = Inheritance . make ( term11 , term12 ) ; Statement state2 = Inheritance . make ( term21 , term22 ) ; final TruthValue truthT = nal . getCurrentTask ( ) . sentence . truth ; final TruthValue truthB = nal . getCurrentBelief ( ) . truth ; if ( ( truthT = = null ) | | ( truthB = = null ) ) { if ( MiscFlags . DEBUG ) { System . out . println ( " ERROR: Belief with null truth value. (introVarOuter) " ) ; } return ; } for ( boolean subjectIntroduction : new boolean [ ] { true , false } ) { Set < Term > contents = CompositionalRules . introduceVariables ( Implication . make ( state1 , state2 ) , subjectIntroduction ) ;
Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
private double randWeight ( ) { return Rand . d ( - maxWeight , maxWeight ) ; }
public static Term sop ( final String operatorName , final Term . . . t ) { final Term [ ] m = new Term [ t . length ] ; int i = 0 ; for ( final Term x : t ) m [ i + + ] = getMetaTerm ( x ) ; return Inheritance . make ( Product . make ( m ) , Term . get ( operatorName ) ) ; }
boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; @Nonnull @ReturnsMutableCopy Enumeration < String > getAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Collection < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; }
public static com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . OtherExample parseFrom ( com . google . protobuf . ByteString data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
public static com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . OtherExample parseFrom ( byte [ ] data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
private void dodash ( CSet set ) throws java . io . IOException { int first = - 1 ; if ( CUtility . DESCENT_DEBUG ) { CUtility . enter ( " dodash " , m_spec . m_lexeme , m_spec . m_current_token ) ; } while ( m_lexGen . EOS ! = m_spec . m_current_token & & m_lexGen . CCL_END ! = m_spec . m_current_token ) { if ( m_lexGen . DASH = = m_spec . m_current_token & & - 1 ! = first ) { m_lexGen . advance ( ) ; if ( m_spec . m_current_token = = m_lexGen . CCL_END ) { set . add ( '-' ) ; break ; } for ( ; first < = m_spec . m_lexeme ; + + first ) { if ( m_spec . m_ignorecase ) set . addncase ( ( char ) first ) ; else set . add ( first ) ; } } else { first = m_spec . m_lexeme ; if ( m_spec . m_ignorecase ) set . addncase ( m_spec . m_lexeme ) ; else set . add ( m_spec . m_lexeme ) ; } m_lexGen . advance ( ) ; } if ( CUtility . DESCENT_DEBUG ) {
protected void createChannel ( ) { ClientBootstrap bootstrap = new ClientBootstrap ( factory ) ; bootstrap . setPipelineFactory ( new BucketMonitorPipelineFactory ( ) ) ; ChannelFuture future = bootstrap . connect ( new InetSocketAddress ( host , port ) ) ; channel = future . awaitUninterruptibly ( ) . getChannel ( ) ; if ( ! future . isSuccess ( ) ) { bootstrap . releaseExternalResources ( ) ; throw new ConnectionException ( " Could not connect to any pool member. " ) ; } assert ( channel ! = null ) ; }
public static < T extends Comparable < T > > T [ ] sort ( T [ ] unsorted ) { boolean swapped = true ; int length = unsorted . length ; while ( swapped ) { swapped = false ; for ( int i = 1 ; i < length ; i + + ) { if ( unsorted [ i ] . compareTo ( unsorted [ i - 1 ] ) = = - 1 ) { swap ( i , i - 1 , unsorted ) ; swapped = true ; } } length - - ; } return unsorted ; }
public void testOneArrivingMultipleExistingWhereArrivingLaterThanAllExistingNoCurrentFlag ( ) { p = new BitemporalHistoryPlanner ( ) ; p . configure ( configWithoutCurrentFlag ) ; existing . add ( new RowWithSchema ( existingSchemaWithoutCurrentFlag , " a " , " hello " , 100L , 100L , 253402214400000L , 1L , 2L ) ) ; existing . add ( new RowWithSchema ( existingSchemaWithoutCurrentFlag , " a " , " hello " , 100L , 100L , 199L , 3L , 253402214400000L ) ) ; existing . add ( new RowWithSchema ( existingSchemaWithoutCurrentFlag , " a " , " hello! " , 200L , 200L , 253402214400000L , 3L , 4L ) ) ; existing . add ( new RowWithSchema ( existingSchemaWithoutCurrentFlag , " a " , " hello! " , 200L , 200L , 299L , 5L , 253402214400000L ) ) ; existing . add ( new RowWithSchema ( existingSchemaWithoutCurrentFlag , " a " , " hello? " , 300L , 300L , 253402214400000L , 5L , 253402214400000L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 400L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 3 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 2 ) ) , MutationType . INSERT ) ; Long systemStart1 = ( Long ) RowUtils . get ( planned . get ( 1 ) , " systemstart " ) ; Long systemStart2 = ( Long ) RowUtils . get ( planned . get ( 2 ) , " systemstart " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " value " ) , " hello? " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventstart " ) , 300L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " systemstart " ) , 5L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " systemend " ) , systemStart1 - 1 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " value " ) , " hello? " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " eventstart " ) , 300L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " eventend " ) , 399L ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " systemend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " eventstart " ) , 400L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " eventend " ) , 253402214400000L ) ; assertTrue ( systemStart2 > = preplanSystemTime ) ; assertTrue ( systemStart2 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " systemend " ) , 253402214400000L ) ; }
public void onPanelExpanded ( View panel ) { nowPlayingSmallFragment . setVisibility ( View . GONE ) ; nowPlayingSmallFragment . setAlpha ( 1 ) ; mDrawerLayout . setDrawerLockMode ( DrawerLayout . LOCK_MODE_LOCKED_CLOSED ) ; }
public ArrayList < Task > execute ( Term [ ] args , Memory memory ) { Term content = args [ 0 ] ; TruthValue truth = new TruthValue ( 1 , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) ; Sentence sentence = new Sentence ( content , Symbols . GOAL_MARK , truth , new Stamp ( memory ) ) ; float quality = BudgetFunctions . truthToQuality ( truth ) ; BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_GOAL_PRIORITY , Parameters . DEFAULT_GOAL_DURABILITY , quality ) ; Task task = new Task ( sentence , budget ) ; ArrayList < Task > feedback = new ArrayList < > ( 1 ) ; feedback . add ( task ) ; return feedback ; }
public void writeParquet ( ) throws Exception { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( FileSystemOutput . FORMAT_CONFIG , " parquet " ) ; paramMap . put ( FileSystemOutput . PATH_CONFIG , results . getPath ( ) ) ; config = ConfigFactory . parseMap ( paramMap ) ; FileSystemOutput fileSystemOutput = new FileSystemOutput ( ) ; fileSystemOutput . configure ( config ) ; fileSystemOutput . applyBulkMutations ( plannedRows ) ; File [ ] files = results . listFiles ( new FilenameFilter ( ) { @Override public boolean accept ( File dir , String name ) { return name . endsWith ( " parquet " ) ; } } ) ; assertEquals ( " Incorrect number of Parquet files " , 1 , files . length ) ; Path path = new Path ( files [ 0 ] . toURI ( ) ) ; AvroParquetReader < GenericRecord > reader = new AvroParquetReader < > ( path ) ; int i = 0 ; GenericRecord record = reader . read ( ) ; while ( null ! = record ) { i + + ; record = reader . read ( ) ; } assertEquals ( " Invalid record count " , 4 , i ) ; }
public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) ) ; }
public void testThread_get_msg_2 ( ) throws InvalidTheoryException , MalformedGoalException , NoSolutionException { theory = " start(X) :- msg_queue_create('CODA'), thread_create(ID, thread1(X)), thread_sleep(500), invio('CODA', 'messaggio molto importante'), lettura(ID,X). \ n " + " thread1(X) :- thread_get_msg('CODA', a(X)).  \ n  " + " invio(ID, M):- thread_send_msg(ID, a(M)).  \ n " + " lettura(ID, X):- thread_join(ID, thread1(X)).  " ; engine . setTheory ( new Theory ( theory ) ) ; SolveInfo sinfo = engine . solve ( " start(X). " ) ; assertTrue ( sinfo . isSuccess ( ) ) ; Term X = sinfo . getVarValue ( " X " ) ; assertEquals ( new Struct ( " messaggio molto importante " ) , X ) ; }
private static boolean testJavaSkipList ( ) { String name = " Java's SkipListSet <Integer> " ; Collection < Integer > lCollection = javaSkipList ; if ( ! testJavaCollection ( lCollection , Integer . class , name ) ) return false ; return true ; }
public static final String reverseWithStringBuilder ( String string ) { final StringBuilder builder = new StringBuilder ( ) ; for ( int i = ( string . length ( ) - 1 ) ; i > = 0 ; i - - ) { builder . append ( string . charAt ( i ) ) ; } return builder . toString ( ) ; }
public boolean isCommutative ( ) { if ( temporalOrder = = TemporalRules . ORDER_FORWARD ) { return false ;
public void remove ( ) { if ( last = = null ) return ; SkipList . Node < T > p = last . getPrev ( 0 ) ; SkipList . Node < T > n = last . getNext ( 0 ) ; if ( p ! = null ) p . setNext ( 0 , n ) ; if ( n ! = null ) n . setPrev ( 0 , p ) ; if ( last . equals ( list . head ) ) list . head = n ; list . size - - ; }
@Override public AbstractBag newBag ( ) { return new ContinuousBag2 ( bagCapacity , new ContinuousBag2 . DefaultBagCurve ( ) , true ) ; }
public int hashCode ( ) { return 37 * ( 37 * ( this . term_ . hashCode ( ) ) + this . listterm_1 . hashCode ( ) ) + this . listterm_2 . hashCode ( ) ; }
public void paintComponent ( Graphics g ) { if ( root ! = null ) { Graphics2D g2 = ( Graphics2D ) g ;
public boolean run ( Integer [ ] unsorted , Integer [ ] sorted , String input ) { this . input = input ; java . util . List < Integer > javaLinkedList = new java . util . LinkedList < Integer > ( ) ; if ( ! testJavaCollection ( javaLinkedList , Integer . class , name , unsorted , sorted , input ) ) return false ; return true ; }
static void IntroVarSameSubjectOrPredicate ( Sentence originalMainSentence , Sentence subSentence , Term component , Term content , int index , Memory memory ) { Sentence cloned = ( Sentence ) originalMainSentence . clone ( ) ; Term T1 = cloned . content ; if ( ! ( T1 instanceof CompoundTerm ) | | ! ( content instanceof CompoundTerm ) ) { return ; } CompoundTerm T = ( CompoundTerm ) T1 ; CompoundTerm T2 = ( CompoundTerm ) content . clone ( ) ; if ( ( component instanceof Inheritance & & content instanceof Inheritance ) | | ( component instanceof Similarity & & content instanceof Similarity ) ) {
final public static Term make ( final Term [ ] argList , final int temporalOrder ) { if ( Parameters . DEBUG ) { Terms . verifyNonNull ( argList ) ; } if ( argList . length = = 0 ) { return null ; } if ( argList . length = = 1 ) { return argList [ 0 ] ; } if ( temporalOrder = = TemporalRules . ORDER_FORWARD ) {
public final boolean isLocalAudible ( ) { return isStreamingServiceRunning ( ) | | " 127.0.0.1 " . equals ( oMPDAsyncHelper . getConnectionSettings ( ) . sServer ) ;
public void reset ( ) ; public Concept concept ( Term term ) ; public Concept conceptualize ( BudgetValue budget , Term term , boolean createIfMissing ) ; public void activate ( Concept c , BudgetValue b , Activating mode ) ; public Concept sampleNextConcept ( ) ; public void init ( Memory m ) ; public void conceptRemoved ( Concept c ) ; public Memory getMemory ( ) ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof QuadrantData ) ) return false ; QuadrantData data = ( QuadrantData ) obj ; if ( this . start = = data . start & & this . end = = data . end & & this . quad0 = = data . quad0 & & this . quad1 = = data . quad1 & & this . quad2 = = data . quad2 & & this . quad3 = = data . quad3 ) { return true ; } return false ; }
boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isCompressed ( @Nonnull String sContentType ) throws OpenAS2Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bAllowCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
public float next ( final long time , final NAR nar ) { if ( concept = = null ) { concept = nar . memory . concept ( conceptTerm ) ; if ( concept = = null ) { return 0 ; } } switch ( mode ) { case Priority : return concept . getPriority ( ) ; case Duration : return concept . getDurability ( ) ; case BeliefConfidenceMax : if ( concept . beliefs . size ( ) > 0 ) { return concept . beliefs . get ( 0 ) . truth . getConfidence ( ) ; } return 0 ; } return 0f ; }
public static int compareNaturalIgnoreCaseAscii ( String s , String t ) { return compareNatural ( s , t , false , null ) ; }
public static void main ( String [ ] arg ) { NAR nar = new DefaultNARBuilder ( ) . build ( ) ; nar . param ( ) . cycleInputTasks . set ( 32 ) ; nar . param ( ) . cycleMemory . set ( 23 ) ; new NARSwing ( nar ) ; new TextOutput ( nar , System . out ) . setShowInput ( false ) ; nar . start ( 100 ) ; NARio nario = new NARio ( nar ) ; nario . TICKS_PER_SECOND = 12 ; nar . param ( ) . noiseLevel . set ( 50 ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitQVarAn p , A arg ) { R r = leaf ( arg ) ; return r ; }
public boolean offer ( T value ) { return add ( new Node < T > ( value ) ) ; }
public void removeEntry ( final Entry p ) { deleteEntry ( p ) ; }
public boolean startsWith ( CharSequence prefix , int offset ) ; public boolean endsWith ( CharSequence suffix ) ; public boolean endsWith ( CharSequence suffix , int offset ) ; public static final long [ ] FIBONACCI = { 0 l , 1l , 1l , 2l , 3l , 5l , 8l , 13l , 21l , 34l , 55l , 89l , 144l , 233l , 377l , 610l , 987l , 1597l , 2584l , 4181l , 6765l , 10946l , 17711l , 28657l , 46368l , 75025l , 121393l , 196418l , 317811l , 514229l , 832040l , 1346269l , 2178309l , 3524578l , 5702887l , 9227465l , 14930352l , 24157817l , 39088169l , 63245986l , 102334155l , 165580141l , 267914296l , 433494437l , 701408733l , 1134903170l , 1836311903l , 2971215073l , 4807526976l , 7778742049l , 12586269025l , 20365011074l , 32951280099l , 53316291173l , 86267571272l , 139583862445l , 225851433717l , 365435296162l , 591286729879l , 956722026041l , 1548008755920l , 2504730781961l , 4052739537881l , 6557470319842l , 10610209857723l , 17167680177565l , 27777890035288l , 44945570212853l , 72723460248141l , 117669030460994l , 190392490709135l , 308061521170129l , 498454011879264l , 806515533049393l , 1304969544928657l , 2111485077978050l , 3416454622906707l , 5527939700884757l , 8944394323791464l , 14472334024676221l , 23416728348467685l , 37889062373143906l , 61305790721611591l , 99194853094755497l , 160500643816367088l , 259695496911122585l , 420196140727489673l , 679891637638612258l , 1100087778366101931l , 1779979416004714189l , 2880067194370816120l , 4660046610375530309l , 7540113804746346429l } ; public static final short MAX_ROPE_DEPTH = 96 ; public static final String SPACES = "                                                                                                                                                                                                          " ; public static Rope autoRebalance ( final Rope r ) { if ( r instanceof AbstractRope & & ( ( AbstractRope ) r ) . depth ( ) > MAX_ROPE_DEPTH ) { return rebalance ( r ) ; } else { return r ; } } public static Rope cat ( final CharSequence . . . c ) { Rope r = null ; for ( CharSequence a : c ) { if ( a = = null ) continue ; if ( ! ( a instanceof Rope ) ) a = Rope . build ( a ) ; r = ( r = = null ) ? ( Rope ) a : new ConcatenationRope ( r , ( Rope ) a ) ; } return r ; } final static CharArrayRope emptyCharArray = new CharArrayRope ( new char [ ] { } ) ; public static Rope catFast ( final CharSequence . . . c ) { Rope r = null ; for ( CharSequence a : c ) { if ( a = = null ) a = emptyCharArray ; if ( ! ( a instanceof Rope ) ) a = Rope . rope ( a ) ; r = ( r = = null ) ? ( Rope ) a : new FastConcatenationRope ( r , ( Rope ) a ) ; } return r ; } public static Rope cat ( final Rope left , final Rope right ) { if ( left . length ( ) = = 0 ) return right ; if ( right . length ( ) = = 0 ) return left ; if ( ( long ) left . length ( ) + right . length ( ) > Integer . MAX_VALUE ) throw new IllegalArgumentException ( " Left length= " + left . length ( ) + " , right length= " + right . length ( ) + " . Concatenation would overflow length field. " ) ; final int combineLength = 17 ; if ( left . length ( ) + right . length ( ) < combineLength ) { return new FlatCharSequenceRope ( left . toString ( ) + right . toString ( ) ) ; } if ( ! ( left instanceof ConcatenationRope ) ) { if ( right instanceof ConcatenationRope ) { final ConcatenationRope cRight = ( ConcatenationRope ) right ; if ( left . length ( ) + cRight . getLeft ( ) . length ( ) < combineLength ) return autoRebalance ( new ConcatenationRope ( new FlatCharSequenceRope ( left . toString ( ) + cRight . getLeft ( ) . toString ( ) ) , cRight . getRight ( ) ) ) ; } } if ( ! ( right instanceof ConcatenationRope ) ) { if ( left instanceof ConcatenationRope ) { final ConcatenationRope cLeft = ( ConcatenationRope ) left ; if ( right . length ( ) + cLeft . getRight ( ) . length ( ) < combineLength ) return autoRebalance ( new ConcatenationRope ( cLeft . getLeft ( ) , new FlatCharSequenceRope ( cLeft . getRight ( ) . toString ( ) + right . toString ( ) ) ) ) ; } } return autoRebalance ( new ConcatenationRope ( left , right ) ) ; } public static byte depth ( final Rope r ) { if ( r instanceof AbstractRope ) { return ( ( AbstractRope ) r ) . depth ( ) ; } else { return 0 ; } } public static boolean isBalanced ( final Rope r ) { final byte depth = depth ( r ) ; if ( depth > = FIBONACCI . length - 2 ) return false ; return ( FIBONACCI [ depth + 2 ] < = r . length ( ) ) ; } public static Rope rebalance ( final Rope r ) { final ArrayList < Rope > leafNodes = new ArrayList < > ( ) ; final ArrayDeque < Rope > toExamine = new ArrayDeque < > ( ) ; toExamine . add ( r ) ; while ( toExamine . size ( ) > 0 ) { final Rope x = toExamine . pop ( ) ; if ( x instanceof ConcatenationRope ) { toExamine . push ( ( ( ConcatenationRope ) x ) . getRight ( ) ) ; toExamine . push ( ( ( ConcatenationRope ) x ) . getLeft ( ) ) ; } else { leafNodes . add ( x ) ; } } Rope result = merge ( leafNodes , 0 , leafNodes . size ( ) ) ; return result ; } public static Rope merge ( ArrayList < Rope > leafNodes , int start , int end ) { int range = end - start ; switch ( range ) { case 1 : return leafNodes . get ( start ) ; case 2 : return new ConcatenationRope ( leafNodes . get ( start ) , leafNodes . get ( start + 1 ) ) ; default : int middle = start + ( range / 2 ) ; return new ConcatenationRope ( merge ( leafNodes , start , middle ) , merge ( leafNodes , middle , end ) ) ; } } public static void visualize ( final Rope r , final PrintStream out ) { visualize ( r , out , 0 ) ; } public static void visualize ( final Rope r , final PrintStream out , final int depth ) { if ( r instanceof FlatCharSequenceRope ) { out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; CharSequence seq = ( ( FlatCharSequenceRope ) r ) . sequence ; out . println ( " \" " + seq + " \"   " + System . identityHashCode ( seq ) ) ; } else if ( r instanceof FlatRope ) { out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; out . println ( " \" " + r + " \" " ) ; } if ( r instanceof SubstringRope ) { out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; out . println ( " substring  " + r . length ( ) + "   \" " + r + " \" " ) ; } if ( r instanceof ConcatenationRope ) { out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; out . println ( " concat[left] " ) ; visualize ( ( ( ConcatenationRope ) r ) . getLeft ( ) , out , depth + 1 ) ; out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; out . println ( " concat[right] " ) ; visualize ( ( ( ConcatenationRope ) r ) . getRight ( ) , out , depth + 1 ) ; } if ( r instanceof PrePostCharRope ) { PrePostCharRope p = ( PrePostCharRope ) r ; out . print ( SPACES . substring ( 0 , depth * 2 ) ) ; out . println ( " \ ' " + p . pre + " \ ' " ) ; Rope . visualize ( p . content , out , depth + 1 ) ; out . println ( " \ ' " + p . post + " \ ' " ) ; } } public static void stats ( final Rope r , final PrintStream out ) { int nonLeaf = 0 ; final ArrayList < Rope > leafNodes = new ArrayList < > ( ) ; final ArrayDeque < Rope > toExamine = new ArrayDeque < > ( ) ; toExamine . add ( r ) ; while ( toExamine . size ( ) > 0 ) { final Rope x = toExamine . pop ( ) ; if ( x instanceof ConcatenationRope ) { + + nonLeaf ; toExamine . push ( ( ( ConcatenationRope ) x ) . getRight ( ) ) ; toExamine . push ( ( ( ConcatenationRope ) x ) . getLeft ( ) ) ; } else { leafNodes . add ( x ) ; } } out . println ( " rope(length= " + r . length ( ) + " , leaf nodes= " + leafNodes . size ( ) + " , non-leaf nodes= " + nonLeaf + " , depth= " + depth ( r ) + " ) " ) ; } }
public void event ( Class event , Object [ ] arguments ) { if ( event = = CycleEnd . class ) {
default void parse ( String input , D destination ) { parse ( new StringReader ( input ) , destination ) ; }
public void keyEvent ( KeyEvent event ) { if ( isGWindow ) ( ( GWinApplet ) app ) . keyEvent ( event ) ; for ( GControl control : windowControls ) { if ( ( control . registeredMethods & KEY_METHOD ) = = KEY_METHOD )
protected void fireEvent ( final Iterable < EventHandler > handlers , final EventType eventType , final StatsKey key , final Object target ) { for ( final EventHandler handler : handlers ) { try {
public static void beforeClass ( ) throws Exception { utility = new HBaseTestingUtility ( ) ; utility . startMiniZKCluster ( ) ; utility . startMiniHBaseCluster ( 1 , 1 ) ; connection = utility . getConnection ( ) ; Contexts . initialize ( appConfig , Contexts . ExecutionMode . UNIT_TEST ) ; }
private Term parseAtomicTerm ( String s0 ) throws InvalidInputException { String s = s0 . trim ( ) ; if ( s . length ( ) = = 0 ) { throw new InvalidInputException ( " missing term " ) ; } Operator op = memory . getOperator ( s0 ) ; if ( op ! = null ) { return op ; } if ( s . contains ( "   " ) ) { throw new InvalidInputException ( " invalid term " ) ; } char c = s . charAt ( 0 ) ; if ( c = = Symbols . INTERVAL_PREFIX ) { return Interval . interval ( s ) ; } if ( containVar ( s ) ) { return new Variable ( s ) ;
public void onItemClick ( AdapterView < ? > adpaterView , View view , int position , long id ) { popupMenu . dismiss ( ) ; if ( currentSong = = null ) return ; final int action = ( ( PopupMenuItem ) adpaterView . getAdapter ( ) . getItem ( position ) ) . actionId ; Intent intent ; switch ( action ) { case POPUP_ALBUM :
public static boolean include ( String filename ) { return filename . startsWith ( " nal5.15 " ) ; }
public StatsKeyMatcher not ( ) { return new NegationMatcher ( this ) ; }
public void edge ( AbstractGraphVis < V , E > g , EdgeVis < V , E > e ) { e . thickness = 23 f ; e . color = gray ; }
public Iterable < Row > translate ( Row message ) { return Collections . < Row > singleton ( new RowWithSchema ( getProvidingSchema ( ) , " world " ) ) ; }
protected final void log ( final boolean bTerminated ) { if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( CAS2Info . NAME_VERSION +
public void add ( double value ) { sum - = window [ posWindow ] ; sum + = value ; window [ posWindow ] = value ; posWindow + + ; if ( posWindow = = SizeWindow ) { posWindow = 0 ; } if ( lenWindow < SizeWindow ) { lenWindow + + ;
public String toString ( ) { return " P2d( " + x + " , " + y + " ) " ; }
public void save ( @Nonnull final String sFilename , @Nonnull final char [ ] aPassword ) throws OpenAS2Exception { final OutputStream fOut = FileHelper . getOutputStream ( sFilename , EAppend . TRUNCATE ) ; save ( fOut , aPassword ) ; }
public void eat ( Body food ) { float x = ( float ) Math . random ( ) * sz - sz / 2f ; float y = ( float ) Math . random ( ) * sz - sz / 2f ; food . setTransform ( new Vec2 ( x * 2.0f , y * 2.0f ) , food . getAngle ( ) ) ; nar . addInput ( " <goal --> Food>. :|: " ) ; }
public OperationFuture < T > addListener ( OperationCompletionListener listener ) { super . addToListeners ( ( GenericCompletionListener ) listener ) ; return this ; }
public String toStringExternal ( ) { StringBuilder sb = new StringBuilder ( ) ; return appendString ( sb , true ) . toString ( ) ; }
public static void main ( String [ ] arg ) { NAR nar = new DiscretinuousBagNARBuilder ( true ) . setConceptBagSize ( 1024 ) . build ( ) ; nar . param ( ) . duration . set ( 10 ) ; nar . param ( ) . noiseLevel . set ( 10 ) ; nar . param ( ) . shortTermMemorySize . set ( 1 ) ; NARio nario = new NARio ( nar ) ; new NARSwing ( nar ) ;
protected void onResume ( ) { super . onResume ( ) ; myLogger . log ( Level . INFO , " onResume " ) ; try { updateTrackInfo ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } try { MPDApplication app = ( MPDApplication ) getApplication ( ) ;
private long mutateWithDefault ( Mutator t , String key , int by , long def , int exp ) { long rv = mutate ( t , key , by , def , exp ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreType . add , key , exp , String . valueOf ( def ) ) ; try { if ( f . get ( operationTimeout , TimeUnit . MILLISECONDS ) ) { rv = def ; } else { rv = mutate ( t , key , by , 0 , exp ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } catch ( TimeoutException e ) { throw new OperationTimeoutException ( " Timeout waiting to mutate or init " + "  value " , e ) ; } } return rv ; }
public int compareTo ( CostVertexPair p ) { if ( p = = null ) throw new NullPointerException ( " CostVertexPair 'p' must be non-NULL. " ) ; if ( this . cost < p . cost ) return - 1 ; if ( this . cost > p . cost ) return 1 ; return 0 ; }
void updatePartnership ( @Nonnull IMessage aMsg , boolean bOverwrite ) throws OpenAS2Exception ; void updatePartnership ( @Nonnull IMessageMDN aMdn , boolean bOverwrite ) throws OpenAS2Exception ; }
public String toString ( ) { return pre + content . toString ( ) + post ; }
public void stateChanged ( MPDStateChangedEvent event ) { MPDStatus status = event . getMpdStatus ( ) ; String state = status . getState ( ) ; if ( state ! = null ) {
public void testRetract ( ) throws InvalidTheoryException , MalformedGoalException { Prolog engine = new Prolog ( ) ; TestOutputListener listener = new TestOutputListener ( ) ; engine . addOutputListener ( listener ) ; engine . setTheory ( new Theory ( " insect(ant). insect(bee). " ) ) ; SolveInfo info = engine . solve ( " retract(insect(I)), write(I), retract(insect(bee)), fail. " ) ; assertFalse ( info . isSuccess ( ) ) ; assertEquals ( " antbee " , listener . output ) ;
ConfigWriter < W > createWriter ( ) ; ConfigParser < C , D > createParser ( ) ; C createConfig ( ) ; boolean supportsComments ( ) ; default boolean supportsType ( Class < ? > type ) { return InMemoryFormat . DEFAULT_PREDICATE . test ( type ) ; } default boolean isInMemory ( ) { return false ; } }
@Override public void actionPerformed ( ActionEvent e ) { addPlugin ( c ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @Override public void run ( ) {
public int numNonZeroEntries ( ) { int count = 0 ; for ( double element : this . doubleArray ) { if ( element ! = 0.0 ) { count + + ; } } return count ; }
public ServiceInfoImpl clone ( ) { ServiceInfoImpl serviceInfo = new ServiceInfoImpl ( this . getQualifiedNameMap ( ) , _port , _weight , _priority , _persistent , _text ) ; Inet6Address [ ] ipv6Addresses = this . getInet6Addresses ( ) ; for ( Inet6Address address : ipv6Addresses ) { serviceInfo . _ipv6Addresses . add ( address ) ; } Inet4Address [ ] ipv4Addresses = this . getInet4Addresses ( ) ; for ( Inet4Address address : ipv4Addresses ) { serviceInfo . _ipv4Addresses . add ( address ) ; } return serviceInfo ; }
public void addAll ( Collection < Music > c ) throws MPDServerException { for ( Music m : c ) this . mpd . getMpdConnection ( ) . queueCommand ( MPD_CMD_PLAYLIST_ADD , m . getFullpath ( ) ) ; this . mpd . getMpdConnection ( ) . sendCommandQueue ( ) ; this . refresh ( ) ; }
public LinkedList < String > listAlbums ( String artist ) throws MPDServerException { if ( mpdConnection = = null ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } String [ ] args = null ; if ( artist = = null ) { args = new String [ 1 ] ; } else { args = new String [ 2 ] ; args [ 1 ] = artist ; } args [ 0 ] = MPD_TAG_ALBUM ; List < String > list = mpdConnection . sendCommand ( MPD_CMD_LIST_TAG , args ) ; LinkedList < String > result = new LinkedList < String > ( ) ; for ( String line : list ) { String [ ] arr = line . split ( " :  " ) ; if ( arr . length > 1 ) result . add ( arr [ 1 ] ) ; } Collections . sort ( result ) ; return result ; }
NoopOperation noop ( OperationCallback cb ) ; DeleteOperation delete ( String key , OperationCallback operationCallback ) ; FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }
public void addEdit ( final int idx , final String streamUrlToAdd ) { final LayoutInflater factory = LayoutInflater . from ( getActivity ( ) ) ; final View view = factory . inflate ( R . layout . stream_dialog , null ) ; final EditText nameEdit = ( EditText ) view . findViewById ( R . id . name_edit ) ; final EditText urlEdit = ( EditText ) view . findViewById ( R . id . url_edit ) ; final int index = idx ; if ( index > = 0 & & index < mStreams . size ( ) ) { final Stream s = mStreams . get ( idx ) ; if ( null ! = nameEdit ) { nameEdit . setText ( s . getName ( ) ) ; } if ( null ! = urlEdit ) { urlEdit . setText ( s . getUrl ( ) ) ; } } else if ( streamUrlToAdd ! = null & & urlEdit ! = null ) { urlEdit . setText ( streamUrlToAdd ) ; } new AlertDialog . Builder ( getActivity ( ) ) . setTitle ( idx < 0 ? R . string . addStream : R . string . editStream )
public void test_$op_3_3 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch('$op'(600, yfx, Operator), error(instantiation_error, instantiation_error(Goal, ArgNo)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " $op " , new Int ( 600 ) , new Struct ( " yfx " ) , new Var ( " Operator " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 3 ) ; }
boolean hasWriteOp ( ) ; void addOp ( Operation op ) ; int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; }
public void paint ( Graphics _g ) { Graphics2D g = ( Graphics2D ) _g ; int pointCount = _currentGesture . size ( ) ; if ( pointCount < 2 ) { return ; } int lineColorIndex = 0 ; g . setColor ( lineColors [ lineColorIndex ] ) ; g . setStroke ( new BasicStroke ( 4 ) ) ; for ( int i = 0 ; i < pointCount - 1 ; i + + ) { PointCloudPoint p1 = _currentGesture . get ( i ) ;
public final int writeSome ( ) throws IOException { int wrote = channel . write ( wbuf ) ; assert wrote > = 0 : " Wrote negative bytes? " ; toWrite - = wrote ; assert toWrite > = 0 : " toWrite went negative after writing  " + wrote + "  bytes for  " + this ; getLogger ( ) . debug ( " Wrote %d bytes " , wrote ) ; return wrote ; }
protected double [ ] predict ( ) { if ( data = = null ) { return null ; } if ( predictedOutput = = null ) { predictedOutput = new double [ getPredictionSize ( ) ] ; } Sample lastSample = data . get ( data . size ( ) - 1 ) ; double error = NetTools . performForward ( this . net , lastSample ) ; net . output ( predictedOutput , 0 ) ; if ( normalizeOutputVector ) predictedOutput = normalize ( predictedOutput ) ; System . out . println ( " output:  " + Arrays . toString ( predictedOutput ) + "   " + error ) ; return predictedOutput ; }
private static boolean testSegmentTree ( ) { { if ( debug > 1 ) System . out . println ( " Segment Tree. " ) ; SegmentTree . Segment [ ] segments = new SegmentTree . Segment [ 4 ] ; segments [ 0 ] = new SegmentTree . Segment ( 0 , 1 , 0 , 0 , 0 ) ; segments [ 1 ] = new SegmentTree . Segment ( 1 , 0 , 1 , 0 , 0 ) ; segments [ 2 ] = new SegmentTree . Segment ( 2 , 0 , 0 , 1 , 0 ) ; segments [ 3 ] = new SegmentTree . Segment ( 3 , 0 , 0 , 0 , 1 ) ; SegmentTree tree = new SegmentTree ( segments ) ; SegmentTree . Query query = tree . query ( 0 , 3 ) ; if ( debug > 1 ) System . out . println ( query . quad1 + "   " + query . quad2 + "   " + query . quad3 + "   " + query . quad4 ) ; tree . update ( 1 , 0 , - 1 , 1 , 0 ) ; tree . update ( 2 , 0 , 1 , - 1 , 0 ) ; tree . update ( 3 , 1 , 0 , 0 , - 1 ) ; query = tree . query ( 2 , 3 ) ; if ( debug > 1 ) System . out . println ( query . quad1 + "   " + query . quad2 + "   " + query . quad3 + "   " + query . quad4 ) ; tree . update ( 0 , - 1 , 1 , 0 , 0 ) ; tree . update ( 1 , 0 , 0 , - 1 , 1 ) ; query = tree . query ( 0 , 2 ) ; if ( debug > 1 ) System . out . println ( query . quad1 + "   " + query . quad2 + "   " + query . quad3 + "   " + query . quad4 ) ; if ( debug > 1 ) System . out . println ( ) ; } return true ; }
< R > R bulkCommentedRead ( Function < ? super UnmodifiableCommentedConfig , R > action ) ; default void bulkCommentedRead ( Consumer < ? super UnmodifiableCommentedConfig > action ) { bulkCommentedRead ( config - > { action . accept ( config ) ; return null ; } ) ; } < R > R bulkCommentedUpdate ( Function < ? super CommentedConfig , R > action ) ; default void bulkCommentedUpdate ( Consumer < ? super CommentedConfig > action ) { bulkCommentedUpdate ( config - > { action . accept ( config ) ; return null ; } ) ; } @Override default < R > R bulkRead ( Function < ? super UnmodifiableConfig , R > action ) { return bulkCommentedRead ( action ) ; } @Override default < R > R bulkUpdate ( Function < ? super Config , R > action ) { return bulkCommentedUpdate ( action ) ; } @Override ConcurrentCommentedConfig createSubConfig ( ) ; }
public Concept conceptualize ( final Term term ) { if ( ! term . isConstant ( ) ) { return null ; } Concept concept = concept ( term ) ; if ( concept = = null ) { Concept newConcept = conceptProcessor . addConcept ( term , this ) ; if ( newConcept = = null ) { return null ; } else { logic . CONCEPT_NEW . commit ( term . getComplexity ( ) ) ; emit ( ConceptAdd . class , newConcept ) ; return newConcept ; } } return concept ; }
public void run ( ) { s . cells . click ( " StoneWall " , " " , " " ) ; }
void set ( int i , double d ) { v [ i ] = d ; }
public void addPoint ( float x , float y ) { data . add ( new PVector ( x , y ) ) ; if ( data . size ( ) > historySize ) data = data . subList ( Math . max ( 0 , data . size ( ) - historySize ) , data . size ( ) - 1 ) ; if ( lineChart = = null ) return ; lineChart . setData ( data ) ; redraw ( ) ; }
static SerializationException noSerializerFound ( Object value , Class < ? > valueClass , SerializerContext ctx ) { ConfigFormat < ? > format = ctx . configFormat ( ) ; String supportedStr ; if ( format = = null ) { supportedStr = " The current SerializerContext has no ConfigFormat. Is there a bug in the implementation of the chosen Config type? " ; } else if ( format . supportsType ( valueClass ) ) { supportedStr = " The value's type is supported by the ConfigFormat of the current SerializerContext. " ; } else { supportedStr = " The value's type is NOT supported by the ConfigFormat of the current SerializerContext. " ; } String ofTypeStr = valueClass = = null ? " " : "  of type  " + valueClass ; return new SerializationException ( " No suitable serializer found for value " + ofTypeStr + " :  " + value + " .  "
void gotData ( String key , int flags , long cas , byte [ ] data ) ; } }
public void debouncingInternals ( ) throws Exception { ScheduledExecutorService executor = Executors . newSingleThreadScheduledExecutor ( ) ; Duration debounceDuration = Duration . ofMillis ( 10 ) ; Duration debounceAndTolerance = debounceDuration . plusMillis ( 5 ) ; AtomicInteger callCounter = new AtomicInteger ( 0 ) ; DebouncedRunnable r = new DebouncedRunnable ( callCounter : : getAndIncrement , debounceDuration ) ; r . run ( executor ) ; assertEquals ( 0 , callCounter . get ( ) ) ; Thread . sleep ( debounceAndTolerance . toMillis ( ) ) ; assertEquals ( 1 , callCounter . get ( ) ) ; int n = 100 ; for ( int i = 0 ; i < n ; i + + ) { r . run ( executor ) ; } assertEquals ( 1 , callCounter . get ( ) ) ; Thread . sleep ( debounceAndTolerance . toMillis ( ) ) ; assertEquals ( 2 , callCounter . get ( ) ) ; }
protected void sendMDN ( @Nonnull final String sClientInfo , @Nonnull final IAS2HttpResponseHandler aResponseHandler , @Nonnull final AS2Message aMsg , @Nonnull final DispositionType aDisposition , @Nonnull final String sText ) { final boolean bMdnBlocked = aMsg . getPartnership ( ) . getAttribute ( CPartnershipIDs . PA_BLOCK_ERROR_MDN ) ! = null ; if ( ! bMdnBlocked ) {
public AbstractBag < Task > newNovelTaskBag ( Param p ) { return new ContinuousBag2 < > ( getTaskBufferSize ( ) , p . taskCycleForgetDurations , curve , randomRemoval ) ; }
public final String getAttributeAsStringRequired ( @Nonnull final String sKey ) throws AS2InvalidParameterException { final String sValue = m_aRWLock . readLockedGet ( ( ) - > attrs ( ) . getAsString ( sKey ) ) ; if ( sValue = = null ) throw new AS2InvalidParameterException ( " Parameter not found " , this , sKey , null ) ; return sValue ; }
public void randomChanged ( MPDRandomChangedEvent event ) { } @Override public void repeatChanged ( MPDRepeatChangedEvent event ) { } @Override public void stateChanged ( MPDStateChangedEvent event ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = oldStatus ) return ; if ( state = = MPDStatus . MPD_STATE_PLAYING ) { resumeStreaming ( ) ; } else { oldStatus = state ; stopStreaming ( ) ; } } } } @Override public void updateStateChanged ( MPDUpdateStateChangedEvent event ) { } @Override public void volumeChanged ( MPDVolumeChangedEvent event ) { } @Override public void onPrepared ( MediaPlayer mp ) { buffering = false ; oldStatus = " " ; showNotification ( ) ; mediaPlayer . start ( ) ; } @Override public void onCompletion ( MediaPlayer mp ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = MPDStatus . MPD_STATE_PLAYING ) { resumeStreaming ( ) ; } else { oldStatus = state ; stopForeground ( true ) ; } } } } @Override public void onBufferingUpdate ( MediaPlayer mp , int percent ) { Toast . makeText ( this , " Buf update " , Toast . LENGTH_SHORT ) . show ( ) ; } @Override public boolean onError ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public boolean onInfo ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public void connectionFailed ( String message ) { Toast . makeText ( this , " connectionFailed : " , Toast . LENGTH_SHORT ) . show ( ) ; } @Override public void connectionSucceeded ( String message ) { Toast . makeText ( this , " connectionSucceeded : " , Toast . LENGTH_SHORT ) . show ( ) ; } }
public void invalidCommand ( ) throws Exception { Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( MorphlineTranslator . ENCODING_KEY , " UTF-8 " ) ; configMap . put ( MorphlineTranslator . ENCODING_MSG , " UTF-8 " ) ; configMap . put ( MorphlineTranslator . MORPHLINE , getResourcePath ( MORPHLINE_FILE ) ) ; configMap . put ( MorphlineTranslator . MORPHLINE_ID , " invalid-command " ) ; configMap . put ( MorphlineTranslator . SCHEMA_CONFIG + " . " + ComponentFactory . TYPE_CONFIG_NAME , " flat " ) ; configMap . put ( MorphlineTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_NAMES_CONFIG , Lists . newArrayList ( " int " , " str " , " float " ) ) ; configMap . put ( MorphlineTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_TYPES_CONFIG , Lists . newArrayList ( " int " , " string " , " float " ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; translator . configure ( config ) ; Row raw = TestingMessageFactory . get ( " The Key " , DataTypes . StringType , " The Message " , DataTypes . StringType ) ; translator . translate ( raw ) ; }
boolean hasReadOp ( ) ; boolean hasWriteOp ( ) ; void addOp ( Operation op ) ; void insertOp ( Operation o ) ; int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; boolean isAuthenticated ( ) ; long lastReadDelta ( ) ; void completedRead ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }
private static boolean testHashMap ( ) { String mapName = " Probing HashMap " ; HashMap < Integer , String > map = new HashMap < Integer , String > ( HashMap . Type . PROBING , unsorted . length / 2 ) ; java . util . Map < Integer , String > jMap = map . toMap ( ) ; if ( ! testJavaMap ( jMap , Integer . class , mapName ) ) return false ; mapName = " Chaining HashMap " ; map = new HashMap < Integer , String > ( HashMap . Type . CHAINING , unsorted . length / 2 ) ; jMap = map . toMap ( ) ; if ( ! testJavaMap ( jMap , Integer . class , mapName ) ) return false ; return true ; }
public boolean remove ( C key ) { if ( root = = null ) return false ; Node < C > previous = null ; Node < C > node = root ; int length = ( key . length ( ) - 1 ) ; for ( int i = 0 ; i < = length ; i + + ) { char c = key . charAt ( i ) ; int index = node . childIndex ( c ) ; if ( index > = 0 ) { previous = node ; node = node . getChild ( index ) ; } else { return false ; } } if ( node . children . size ( ) > 0 ) { node . string = null ; } else { int index = previous . childIndex ( node . character ) ; previous . children . remove ( index ) ; while ( previous ! = null & & previous . children . size ( ) = = 0 ) { if ( previous . string ! = null ) { remove ( previous . string ) ; } else if ( previous . parent ! = null ) { int idx = previous . parent . childIndex ( previous . character ) ; if ( idx > = 0 ) previous . parent . children . remove ( idx ) ; } previous = previous . parent ; } } return true ; }
private static Object parseNumberOrDateTime ( CharacterInput input ) { CharsWrapper valueChars = input . readCharsUntil ( END_OF_VALUE ) ; if ( TemporalParser . shouldBeTemporal ( valueChars ) ) { return TemporalParser . parseTemporal ( valueChars ) ; } return parseNumber ( valueChars ) ; }
void stickerChanged ( MPDStatus mpdStatus ) ; void trackChanged ( MPDStatus mpdStatus , int oldTrack ) ; void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) ; }
public void onDestroyView ( ) { mLoadingView = null ; mLoadingTextView = null ; mNoResultView = null ; super . onDestroyView ( ) ; }
public NoopOperation noop ( OperationCallback cb ) { return new NoopOperationImpl ( cb ) ; }
private static int recursiveFind ( int value , int start , int end ) { if ( start = = end ) { int lastValue = sorted [ start ] ; if ( value = = lastValue ) return start ; return Integer . MAX_VALUE ; } int mid = start + ( ( value - sorted [ start ] ) * ( end - start ) ) / ( sorted [ end ] - sorted [ start ] ) ; if ( mid < 0 | | mid > end ) return Integer . MAX_VALUE ; int midValue = sorted [ mid ] ; if ( value = = midValue ) return mid ; if ( value > midValue ) { return recursiveFind ( value , mid + 1 , end ) ;
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }
public void output ( Class c , Object line ) { if ( c = = ERR . class ) { assertTrue ( path + "  ERR:  " + line , false ) ; } String s = line . toString ( ) ; s = s . trim ( ) ; if ( c = = ECHO . class ) { if ( s . startsWith ( " \" \ ' " ) ) { String expression = s . substring ( 2 , s . length ( ) - 1 ) ; expressions . add ( expression ) ; return ; } } if ( c = = OUT . class ) { out . add ( s ) ;
public void providerInClass ( ) throws Exception { testDefaultServers ( DefaultValueAnnotations1 : : new ) ; testDefaultServers ( DefaultValueAnnotations2 : : new ) ; testDefaultServers ( DefaultValueAnnotations3 : : new ) ;
@Override public void event ( Class event , Object [ ] a ) { if ( event ! = TaskDerived . class ) return ; Param p = memory . param ; Task task = ( Task ) a [ 0 ] ; if ( canAbbreviate ( task ) ) {
public void testInvalidInitialValueDouble ( ) { new AccumulatorRequest ( " hello " , Double . class , 10 ) ; }
public final KeyStore getKeyStoreFromCtor ( ) { return m_aCtorKeyStore ; }
public void test1 ( ) { final List < String > tests = new ArrayList < String > ( ) ; tests . add ( " BEE " ) ; tests . add ( " BEEN " ) ; tests . add ( " BEAST " ) ; tests . add ( " BELOW " ) ; tests . add ( " BEFORE " ) ; tests . add ( " BUT " ) ; tests . add ( " CAT " ) ; tests . add ( " BE " ) ; tests . add ( " B " ) ; tests . add ( " DAD " ) ; tests . add ( " APPLE " ) ; final TernarySearchTree < String > bst = new TernarySearchTree < String > ( ) ; bst . add ( null ) ; bst . add ( " " ) ; for ( String s : tests ) bst . add ( s ) ; bst . add ( null ) ; bst . add ( " " ) ; Assert . assertFalse ( bst . add ( " BE " ) ) ; Assert . assertFalse ( bst . contains ( null ) ) ; Assert . assertFalse ( bst . contains ( " " ) ) ; for ( String s : tests ) Assert . assertTrue ( bst . contains ( s ) ) ; Assert . assertFalse ( bst . contains ( null ) ) ; Assert . assertFalse ( bst . contains ( " " ) ) ; Assert . assertTrue ( bst . remove ( null ) = = null ) ; Assert . assertTrue ( bst . remove ( " " ) = = null ) ; for ( String s : tests ) Assert . assertTrue ( bst . remove ( s ) ! = null ) ; Assert . assertTrue ( bst . remove ( null ) = = null ) ; Assert . assertTrue ( bst . remove ( " " ) = = null ) ; }
public View onLayoutInflation ( Context context , View targetView , List < ? extends Item > items ) { targetView . findViewById ( R . id . track_artist ) . setVisibility ( mShowArtist ? View . VISIBLE : View . GONE ) ; return targetView ; }
public Set < String > keySet ( ) { return dataMap . keySet ( ) ; }
public void testSignWithAllAlgorithms ( ) throws Exception { final MimeBodyPart aPart = new MimeBodyPart ( ) ; aPart . setText ( " Hello world " ) ; for ( final ECryptoAlgorithmSign eAlgo : ECryptoAlgorithmSign . values ( ) ) {
private void readObject ( java . io . ObjectInputStream s ) throws java . io . IOException , ClassNotFoundException { s . defaultReadObject ( ) ; Comparator < ? super E > c = ( Comparator < ? super E > ) s . readObject ( ) ; IndexedTreeMap < E , Object > tm ; if ( c = = null ) tm = new IndexedTreeMap < > ( ) ; else tm = new IndexedTreeMap < > ( c ) ; m = tm ; int size = s . readInt ( ) ; tm . readTreeSet ( size , s , PRESENT ) ; }
private static void symmetricSymmetric ( final Sentence belief , final Sentence taskSentence , int figure , final NAL nal ) { Statement s1 = ( Statement ) belief . term ; Statement s2 = ( Statement ) taskSentence . term ; Term ut1 , ut2 ; Term rt1 , rt2 ; switch ( figure ) { case 11 : ut1 = s1 . getSubject ( ) ; ut2 = s2 . getSubject ( ) ; rt1 = s1 . getPredicate ( ) ; rt2 = s2 . getPredicate ( ) ; break ; case 12 : ut1 = s1 . getSubject ( ) ; ut2 = s2 . getPredicate ( ) ; rt1 = s1 . getPredicate ( ) ; rt2 = s2 . getSubject ( ) ; break ; case 21 : ut1 = s1 . getPredicate ( ) ; ut2 = s2 . getSubject ( ) ; rt1 = s1 . getSubject ( ) ; rt2 = s2 . getPredicate ( ) ; break ; case 22 : ut1 = s1 . getPredicate ( ) ; ut2 = s2 . getPredicate ( ) ; rt1 = s1 . getSubject ( ) ; rt2 = s2 . getSubject ( ) ; break ; default : throw new RuntimeException ( " Invalid figure:  " + figure ) ; } Term [ ] u = new Term [ ] { s1 , s2 } ; if ( Variables . unify ( VAR_INDEPENDENT , ut1 , ut2 , u ) ) {
StormStream createStream ( String piId ) { StormSpoutStream stream = new StormSpoutStream ( piId ) ; streams . add ( stream ) ; return stream ; }
void dragElems ( ) { } void checkSelect ( ) { double selection_distanceSq = selection_distance * selection_distance ; { } } } class Hamlib { void Init ( ) { noStroke ( ) ; hnav . Init ( ) ; hsim . Init ( ) ; } void mousePressed ( ) { hnav . mousePressed ( ) ; hsim . mousePressed ( ) ; } void mouseDragged ( ) { hnav . mouseDragged ( ) ; hsim . mouseDragged ( ) ; } void mouseReleased ( ) { hnav . mouseReleased ( ) ; hsim . mouseReleased ( ) ; } public void mouseMoved ( ) { } void keyPressed ( ) { hnav . keyPressed ( ) ; } void mouseScrolled ( ) { hnav . mouseScrolled ( ) ; } void Camera ( ) { hnav . Transform ( ) ; } synchronized void Update ( int r , int g , int b ) { if ( ! drawn ) { background ( r , g , b ) ; Camera ( ) ; hrend_DrawBegin ( ) ; drawit ( ) ; hrend_DrawEnd ( ) ; drawn = true ; } } } }
public void testOneArrivingOneExistingWhereArrivingSameTimeAsExistingWithSameValues ( ) { p = new EventTimeHistoryPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES , " " ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " hello " , 100L ) ) ; key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 0 ) ; }
public static < T extends Comparable < T > > void print ( BinaryHeapTree < T > tree ) { System . out . println ( getString ( tree . root , " " , true ) ) ; }
public void testComparePermutations ( ) { Integer [ ] numbers = { 4 , 2 } ; LinkedList < Integer > firstPermutation = new LinkedList < Integer > ( ) ; firstPermutation . add ( 4 ) ; firstPermutation . add ( 2 ) ; LinkedList < Integer > secondPermutation = new LinkedList < Integer > ( ) ; secondPermutation . add ( 2 ) ; secondPermutation . add ( 4 ) ; LinkedList < LinkedList < Integer > > allPermutations = new LinkedList < LinkedList < Integer > > ( ) ; allPermutations . add ( firstPermutation ) ; allPermutations . add ( secondPermutation ) ; List < List < Integer > > result = Permutations . getAllPermutations ( numbers ) ; assertTrue ( " allPermutations= " + allPermutations + "  result= " + result , allPermutations . equals ( result ) ) ; }
public static Term [ ] normalizeVariableNames ( String prefix , final Term [ ] s , final HashMap < Variable , Variable > map ) { boolean renamed = false ; Term [ ] t = s . clone ( ) ; char c = 'a' ; for ( int i = 0 ; i < t . length ; i + + ) { final Term term = t [ i ] ; if ( term instanceof Variable ) { Variable termV = ( Variable ) term ; Variable var ; var =   map . get ( termV ) ; if ( var = =   null ) { var =   new Variable ( termV . getType ( ) + String . valueOf ( map . size ( ) + 1 ) ) ; } if ( ! termV . equals ( var ) ) { t [ i ] = var ; renamed = true ; } map . put ( termV , var ) ; } else if ( term instanceof CompoundTerm ) { CompoundTerm ct = ( CompoundTerm ) term ; if ( ct . containVar ( ) ) { Term [ ] d = normalizeVariableNames ( prefix + Character . toString ( c ) , ct . term , map ) ; if ( d ! = ct . term ) { t [ i ] = ct . clone ( d , false ) ; renamed = true ; } } } c + + ; } if ( renamed ) { return t ;
public static void main ( String [ ] args ) throws Exception { experiments . clear ( ) ; for ( int i = 1 ; i < 15 ; i + + ) { NAR a = new DefaultNARBuilder ( ) . build ( ) ; a . param ( ) . termLinkRecordLength . set ( i ) ; score ( " termLinkRecordLength_ " + String . format ( " %03d " , i ) , a ) ; } report ( ) ; experiments . clear ( ) ; for ( int i = 1 ; i < 13 ; i + + ) { NAR a = new DefaultNARBuilder ( ) . build ( ) ; a . param ( ) . termLinkMaxMatched . set ( i ) ; score ( " termLinkMaxMatched_ " + String . format ( " %03d " , i ) , a ) ; } report ( ) ; experiments . clear ( ) ; for ( int i = 1 ; i < 13 ; i + + ) { NAR a = new DefaultNARBuilder ( ) . build ( ) ; a . param ( ) . termLinkMaxReasoned . set ( i ) ; score ( " termLinkMaxReasoned_ " + String . format ( " %03d " , i ) , a ) ; } report ( ) ;
public Map < String , Long > getTrackedFiles ( ) { if ( m_aTrackedFiles = = null ) m_aTrackedFiles = new HashMap < String , Long > ( ) ; return m_aTrackedFiles ; }
protected boolean validateNode ( Node < T > node ) { boolean bst = super . validateNode ( node ) ; if ( ! bst ) return false ; AVLNode < T > avlNode = ( AVLNode < T > ) node ; int balanceFactor = avlNode . getBalanceFactor ( ) ; if ( balanceFactor > 1 | | balanceFactor < - 1 ) { return false ; } if ( avlNode . isLeaf ( ) & & avlNode . height ! = 1 ) return false ; return true ; }
public ConfigFormat < ? > configFormat ( ) { return format ; }
private boolean move ( float xa , float ya ) { while ( xa > 8 ) { if ( ! move ( 8 , 0 ) ) return false ; xa - = 8 ; } while ( xa < - 8 ) { if ( ! move ( - 8 , 0 ) ) return false ; xa + = 8 ; } while ( ya > 8 ) { if ( ! move ( 0 , 8 ) ) return false ; ya - = 8 ; } while ( ya < - 8 ) { if ( ! move ( 0 , - 8 ) ) return false ; ya + = 8 ; } boolean collide = false ; if ( ya > 0 ) { if ( isBlocking ( x + xa - width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya , xa , 0 ) ) collide = true ; else if ( isBlocking ( x + xa - width , y + ya + 1 , xa , ya ) ) collide = true ; else if ( isBlocking ( x + xa + width , y + ya + 1 , xa , ya ) ) collide = true ; } if ( ya < 0 ) { if ( isBlocking ( x + xa , y + ya - height , xa , ya ) ) collide = true ; else if ( collide | | isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; else if ( collide | | isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; } if ( xa > 0 ) { if ( isBlocking ( x + xa + width , y + ya - height , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa + width , y + ya - height / 2 , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa + width , y + ya , xa , ya ) ) collide = true ; if ( avoidCliffs & & onGround & & ! world . level . isBlocking ( ( int ) ( ( x + xa + width ) / 16 ) , ( int ) ( ( y ) / 16 + 1 ) , xa , 1 ) ) collide = true ; } if ( xa < 0 ) { if ( isBlocking ( x + xa - width , y + ya - height , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa - width , y + ya - height / 2 , xa , ya ) ) collide = true ; if ( isBlocking ( x + xa - width , y + ya , xa , ya ) ) collide = true ; if ( avoidCliffs & & onGround & & ! world . level . isBlocking ( ( int ) ( ( x + xa - width ) / 16 ) , ( int ) ( ( y ) / 16 + 1 ) , xa , 1 ) ) collide = true ; } if ( collide ) {
public MimeBodyPart encrypt ( @Nonnull final MimeBodyPart aPart , @Nonnull final X509Certificate aX509Cert , @Nonnull final ECryptoAlgorithmCrypt eAlgorithm , @Nonnull @Nonempty final String sContentTransferEncoding ) throws GeneralSecurityException , SMIMEException , CMSException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( aX509Cert , " X509Cert " ) ; ValueEnforcer . notNull ( eAlgorithm , " Algorithm " ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " BCCryptoHelper.encrypt; X509 subject= " + aX509Cert . getSubjectX500Principal ( ) . getName ( ) + " ; algorithm= " + eAlgorithm ) ; aX509Cert . checkValidity ( ) ; final ASN1ObjectIdentifier aEncAlg = eAlgorithm . getOID ( ) ; final SMIMEEnvelopedGenerator aGen = new SMIMEEnvelopedGenerator ( ) ; aGen . addRecipientInfoGenerator ( new JceKeyTransRecipientInfoGenerator ( aX509Cert ) . setProvider ( m_sSecurityProviderName ) ) ; aGen . setContentTransferEncoding ( sContentTransferEncoding ) ; final OutputEncryptor aEncryptor = new JceCMSContentEncryptorBuilder ( aEncAlg ) . setProvider ( m_sSecurityProviderName ) . build ( ) ; final MimeBodyPart aEncData = aGen . generate ( aPart , aEncryptor ) ; return aEncData ; }
boolean putIn ( final E newItem ) ; boolean putBack ( final E oldItem ) ; int size ( ) ; E takeOut ( ) ; E pickOut ( final String key ) ; }
boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; @Nonnull KeyStore createNewKeyStore ( ) throws Exception ; @Nonnull KeyStore loadKeyStore ( @Nonnull InputStream aIS , @Nonnull char [ ] aPassword ) throws Exception ; @Nonnull KeyStore loadKeyStore ( @Nonnull String sFilename , @Nonnull char [ ] aPassword ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull String sDigest , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull String sAlgorithm ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey key , @Nonnull String sAlgorithm ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert ) throws Exception ; }
public void asMap ( ) { AbstractConfig config = new SimpleConfig ( type - > true ) ; config . setValue ( " a.b.c " , " value " ) ; config . setValue ( " pi " , Math . PI ) ; Map < String , Object > map = config . valueMap ( ) ; assert map . size ( ) = = config . size ( ) ; assert map . get ( " pi " ) instanceof Double ; assert ( ( double ) map . get ( " pi " ) ) = = Math . PI ; assert ! map . containsKey ( " a.b.c " ) ; assert map . get ( " a " ) instanceof Config ; Config a = ( Config ) map . get ( " a " ) ; assert a . size ( ) = = 1 ; assert a . < String > getValue ( " b.c " ) . equals ( " value " ) ; }
public void set ( T e ) { throw new UnsupportedOperationException ( " OperationNotSupported " ) ; }
private static boolean testRadixTrie ( ) { String mapName = " RadixTrie " ; RadixTrie < String , Integer > map = new RadixTrie < String , Integer > ( ) ; java . util . Map < String , Integer > jMap = map . toMap ( ) ; if ( ( validateStructure | | validateContents ) & & ! testMap ( map , Type . String , mapName ) ) return false ; if ( ! testMap ( jMap , Type . String , mapName ) ) return false ; return true ; }
public NAR init ( NAR n ) { for ( Operator o : DefaultOperators . get ( ) ) n . memory . addOperator ( o ) ; for ( Operator o : ExampleOperators . get ( ) ) n . memory . addOperator ( o ) ; n . addPlugin ( new DefaultTextPerception ( ) ) ; if ( pluginPlanner ! = null ) { n . addPlugin ( pluginPlanner ) ; } n . addPlugin ( new Anticipate ( ) ) ; if ( internalExperience = = Minimal ) { n . addPlugin ( new InternalExperience ( ) ) ; } else if ( internalExperience = = Full ) { n . addPlugin ( new FullInternalExperience ( ) ) ; n . addPlugin ( new Abbreviation ( ) ) ; n . addPlugin ( new Counting ( ) ) ; } return n ; }
public boolean contains ( K key ) ; public int size ( ) ; public boolean validate ( ) ; public java . util . Map < K , V > toMap ( ) ; }
protected boolean isUniqueByOcurrenceTime ( ) { return ( ( punctuation = = Symbols . JUDGMENT_MARK ) | | ( punctuation = = Symbols . QUESTION_MARK ) ) ; }
public void onItemClick ( final AdapterView < ? > adapterView , View v , final int position , long id ) { app . oMPDAsyncHelper . execAsync ( new Runnable ( ) { @Override
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; try { View view = parseDesignDocumentForView ( bucketName , designDocName , viewName , json ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( ViewFetcherCallback ) callback ) . gotData ( view ) ; callback . receivedStatus ( new OperationStatus ( true , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . toString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }
public static com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . MultipleExample parseFrom ( java . nio . ByteBuffer data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
public void testInputCoalesce ( ) throws Exception { Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( " input.type " , DummyInput . class . getName ( ) ) ; configMap . put ( " input.num.partitions " , 10 ) ; configMap . put ( " input.repartition.partitions " , 5 ) ; Config config = ConfigFactory . parseMap ( configMap ) ; BatchStep batchStep = new BatchStep ( " test " , config ) ; batchStep . runStep ( Sets . < Step > newHashSet ( ) ) ; Dataset < Row > df = batchStep . getData ( ) ; int numPartitions = df . javaRDD ( ) . getNumPartitions ( ) ; assertEquals ( numPartitions , 5 ) ; }
public void testMatches ( ) { Rope x1 = new FlatCharSequenceRope ( " 0123456789 " ) ; Rope x2 = new ConcatenationRope ( x1 , x1 ) ; assertTrue ( x2 . matches ( " 0.*9 " ) ) ; assertTrue ( x2 . matches ( Pattern . compile ( " 0.*9 " ) ) ) ; assertTrue ( x2 . matches ( " 0.*90.*9 " ) ) ; assertTrue ( x2 . matches ( Pattern . compile ( " 0.*90.*9 " ) ) ) ; }
public CommentedFileConfig build ( ) { return new SimpleCommentedFileConfig ( super . config , super . build ( ) ) ; }
public Map < Term , Integer > countTermRecursively ( Map < Term , Integer > map ) { if ( map = = null ) { map = new HashMap < Term , Integer > ( ) ; } return map ; }
protected void paintSyntaxLine ( Graphics gfx , TokenMarker tokenMarker , int line , Font defaultFont , Color defaultColor , int x , int y ) { textArea . getLineText ( currentLineIndex , currentLine ) ; currentLineTokens = tokenMarker . markTokens ( currentLine , currentLineIndex ) ; paintHighlight ( gfx , line , y ) ; gfx . setFont ( defaultFont ) ; gfx . setColor ( defaultColor ) ; y + = fm . getHeight ( ) ; x = SyntaxUtilities . paintSyntaxLine ( currentLine , currentLineTokens , styles , this , gfx , x , y ) ; if ( eolMarkers ) {
public static void logHandledException ( final Logger logger , final Throwable error , final String message , final Object . . . args ) { try { if ( Output = = null | | error = = null | | message = = null ) {
public boolean implementsMicroClusterer ( ) { return this . learner . implementsMicroClusterer ( ) ; }
public void commit ( ) { int len = trackers . length ; for ( int i = 0 ; i < len ; i + + ) { trackers [ i ] . stop ( ) ;
public void onOpen ( final WebSocket conn , ClientHandshake handshake ) { WebSocketImpl . DEBUG = WebSocket . DEBUG = WEBSOCKET_DEBUG ; System . out . println ( " Connect:  " + conn . getRemoteSocketAddress ( ) . getAddress ( ) . getHostAddress ( ) ) ; final NARConnection n = new NARConnection ( new NAR ( ) ) { @Override public void println ( String output ) { conn . send ( output ) ; } } ; socketSession . put ( conn , n ) ;
public LinkedList < String > listArtists ( ) throws MPDServerException { return this . listArtists ( false ) ; }
public StormStream createStream ( ) { return piSpout . createStream ( this . getName ( ) ) ; }
static void detachment ( Sentence mainSentence , Sentence subSentence , int side , DerivationContext nal ) { Statement statement = ( Statement ) mainSentence . term ; if ( ! ( statement instanceof Implication ) & & ! ( statement instanceof Equivalence ) ) { return ; } Term subject = statement . getSubject ( ) ; Term predicate = statement . getPredicate ( ) ; Term content ; Term term = subSentence . term ; if ( ( side = = 0 ) & & term . equals ( subject ) ) { content = predicate ; } else if ( ( side = = 1 ) & & term . equals ( predicate ) ) { content = subject ; } else { return ; } if ( ( content instanceof Statement ) & & ( ( Statement ) content ) . invalid ( ) ) { return ; } Sentence taskSentence = nal . getCurrentTask ( ) . sentence ; Sentence beliefSentence = nal . getCurrentBelief ( ) ; if ( beliefSentence = = null ) return ; int order = statement . getTemporalOrder ( ) ; boolean shiftedTimeForward = false ; if ( ( order ! = ORDER_NONE ) & & ( order ! = ORDER_INVALID ) & & ( ! taskSentence . isGoal ( ) ) & & ( ! taskSentence . isQuest ( ) ) ) { long baseTime = subSentence . getOccurenceTime ( ) ; if ( baseTime = = Stamp . ETERNAL ) { baseTime = nal . getTime ( ) ; } long inc = order * nal . mem ( ) . param . duration . get ( ) ; long time = ( side = = 0 ) ? baseTime + inc : baseTime - inc ; shiftedTimeForward = ( side = = 0 ) ; nal . getTheNewStamp ( ) . setOccurrenceTime ( time ) ; } TruthValue beliefTruth = beliefSentence . truth ; TruthValue truth1 = mainSentence . truth ; TruthValue truth2 = subSentence . truth ; TruthValue truth = null ; boolean strong = false ; BudgetValue budget ; if ( taskSentence . isQuestion ( ) ) { if ( statement instanceof Equivalence ) { budget = BudgetFunctions . backward ( beliefTruth , nal ) ; } else if ( side = = 0 ) { budget = BudgetFunctions . backwardWeak ( beliefTruth , nal ) ; } else { budget = BudgetFunctions . backward ( beliefTruth , nal ) ; } } else if ( taskSentence . isQuest ( ) ) { if ( statement instanceof Equivalence ) { budget = BudgetFunctions . backwardWeak ( beliefTruth , nal ) ; } else if ( side = = 0 ) { budget = BudgetFunctions . backward ( beliefTruth , nal ) ; } else { budget = BudgetFunctions . backwardWeak ( beliefTruth , nal ) ; } } else { if ( taskSentence . isGoal ( ) ) { if ( statement instanceof Equivalence ) { truth = TruthFunctions . desireStrong ( truth1 , truth2 ) ; strong = true ; } else if ( side = = 0 ) { truth = TruthFunctions . desireInd ( truth1 , truth2 ) ; } else { truth = TruthFunctions . desireDed ( truth1 , truth2 ) ; strong = true ; } } else { if ( statement instanceof Equivalence ) { truth = TruthFunctions . analogy ( truth2 , truth1 ) ; strong = true ; } else if ( side = = 0 ) { truth = TruthFunctions . deduction ( truth1 , truth2 ) ; strong = true ; } else { truth = TruthFunctions . abduction ( truth2 , truth1 ) ; } } budget = BudgetFunctions . forward ( truth , nal ) ; } if ( ! Variables . indepVarUsedInvalid ( content ) ) { boolean allowOverlap = taskSentence . isJudgment ( ) & & strong ;
public static double polevl ( double x , double coef [ ] , int N ) { double ans ; ans = coef [ 0 ] ; for ( int i = 1 ; i < = N ; i + + ) ans = ans * x + coef [ i ] ; return ans ; }
public void writeToParcel ( final Parcel dest , final int flags ) { dest . writeString ( getName ( ) ) ; dest . writeString ( sort ( ) ) ; }
public static MimeBodyPart secureMimeBodyPart ( @Nonnull final MimeBodyPart aSrcPart , @Nonnull final EContentTransferEncoding eCTE , @Nullable final ECompressionType eCompressionType , final boolean bCompressBeforeSign , @Nullable final Consumer < MimeBodyPart > aCompressBeforeSignCallback , @Nullable final ECryptoAlgorithmSign eSignAlgorithm , @Nullable final X509Certificate aSenderCert , @Nullable final PrivateKey aSenderKey , final boolean bIncludeCertificateInSignedContent , final boolean bUseRFC3851MICAlg , @Nullable final ECryptoAlgorithmCrypt eCryptAlgorithm , @Nullable final X509Certificate aReceiverCert ) throws Exception { ValueEnforcer . notNull ( aSrcPart , " SrcPart " ) ; ValueEnforcer . notNull ( eCTE , " ContentTransferEncoding " ) ; if ( eCompressionType ! = null ) { if ( bCompressBeforeSign ) ValueEnforcer . notNull ( aCompressBeforeSignCallback , " CompressBeforeSignCallback " ) ; } if ( eSignAlgorithm ! = null ) { ValueEnforcer . notNull ( aSenderCert , " SenderCert " ) ; ValueEnforcer . notNull ( aSenderKey , " SenderKey " ) ; } if ( eCryptAlgorithm ! = null ) { ValueEnforcer . notNull ( aReceiverCert , " ReceiverCert " ) ; } MimeBodyPart aDataBP = aSrcPart ; _log ( aDataBP , " source " ) ; if ( eCompressionType ! = null & & bCompressBeforeSign ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Compressing outbound message before signing... " ) ; aDataBP = compressMimeBodyPart ( aDataBP , eCompressionType , eCTE ) ; _log ( aDataBP , " compressBeforeSign " ) ; aCompressBeforeSignCallback . accept ( aDataBP ) ; } if ( eSignAlgorithm ! = null ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Signing outbound message... " ) ; aDataBP = AS2Helper . getCryptoHelper ( ) . sign ( aDataBP , aSenderCert , aSenderKey , eSignAlgorithm , bIncludeCertificateInSignedContent , bUseRFC3851MICAlg , eCTE ) ; _log ( aDataBP , " signed " ) ; } if ( eCompressionType ! = null & & ! bCompressBeforeSign ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Compressing outbound message after signing... " ) ; aDataBP = compressMimeBodyPart ( aDataBP , eCompressionType , eCTE ) ; _log ( aDataBP , " compressAfterSign " ) ; } if ( eCryptAlgorithm ! = null ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Encrypting outbound message... " ) ; aDataBP = AS2Helper . getCryptoHelper ( ) . encrypt ( aDataBP , aReceiverCert , eCryptAlgorithm , eCTE ) ; _log ( aDataBP , " encrypted " ) ; } return aDataBP ; }
public boolean isConnected ( ) { return mpdConnection ! = null & & mpdConnection . isConnected ( ) & & mpdIdleConnection ! = null & & mpdIdleConnection . isConnected ( ) & & mpdStatusConnection ! = null & & mpdStatusConnection . isConnected ( ) ; }
public static void loadDefaultOperators ( Memory memory ) { memory . registerOperator ( new Sample ( " ^sample " ) ) ;
boolean isCancelled ( ) ; boolean hasErrored ( ) ; OperationException getException ( ) ; OperationCallback getCallback ( ) ; void cancel ( ) ; State getState ( ) ; ByteBuffer getBuffer ( ) ; void writeComplete ( ) ; ReadType getReadType ( ) ; void initialize ( ) ; void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; void handleLine ( String line ) ; }
< T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
private boolean loadStyle_FromSketch ( String style ) { File styleFolder = new File ( winApp . dataPath ( style ) ) ; if ( ! styleFolder . exists ( ) ) styleFolder = new File ( winApp . sketchPath ( style ) ) ; if ( ! styleFolder . exists ( ) ) return false ; int fcount = 0 ; String [ ] names = new String [ ] { " centre. " , " end_left. " , " end_right. " , " handle. " , " handle_mouseover. " } ; PImage [ ] images = new PImage [ names . length ] ; File [ ] fileList = styleFolder . listFiles ( ) ; for ( int i = 0 ; i < names . length ; i + + ) { for ( File f : fileList ) { String filename = f . getName ( ) ; if ( filename . startsWith ( names [ i ] ) ) { images [ i ] = winApp . loadImage ( style + " / " + filename ) ; fcount + + ; } } } if ( fcount ! = names . length ) return false ; centre = images [ 0 ] ; leftEnd = images [ 1 ] ; rightEnd = images [ 2 ] ; thumb = images [ 3 ] ; thumb_mouseover = images [ 4 ] ; return true ; }
private static String parsePlaylist ( String data , String key , List < String > handlers ) { String [ ] lines = data . split ( " ( \ r \ n| \ n| \ r) " ) ; for ( String line : lines ) { if ( line . toLowerCase ( ) . startsWith ( key ) ) { for ( String handler : handlers ) { String protocol = handler + " :// " ; int index = line . indexOf ( protocol ) ; if ( index > - 1 & & index < 7 ) { return line . replace ( " \ n " , " " ) . replace ( " \ r " , " " ) . substring ( index ) ; } } } } return null ; }
int size ( ) ; default boolean isEmpty ( ) { return size ( ) = = 0 ; } Map < String , Object > valueMap ( ) ; Set < ? extends Entry > entrySet ( ) ; interface Entry { String getKey ( ) ; < T > T getValue ( ) ; } }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; Bucket bucket = ( Bucket ) o ; if ( ! name . equals ( bucket . name ) ) return false ; if ( ! nodes . equals ( bucket . nodes ) ) return false ; if ( ! vbuckets . equals ( bucket . vbuckets ) ) return false ; return true ; }
static void resemblance ( final Term term1 , final Term term2 , final Sentence belief , final Sentence sentence , final int figure , final DerivationContext nal ) { if ( Statement . invalidStatement ( term1 , term2 ) ) { return ; } final int order1 = belief . term . getTemporalOrder ( ) ; final int order2 = sentence . term . getTemporalOrder ( ) ; int order = resemblanceOrder ( order1 , order2 , figure ) ; if ( order = = ORDER_INVALID ) { return ; } final Statement st = ( Statement ) belief . term ; TruthValue truth = null ; final BudgetValue budget ; if ( sentence . isQuestion ( ) | | sentence . isQuest ( ) ) { budget = BudgetFunctions . backward ( belief . truth , nal ) ; } else { if ( sentence . isGoal ( ) ) { truth = TruthFunctions . desireStrong ( sentence . truth , belief . truth ) ; } else { truth = TruthFunctions . resemblance ( belief . truth , sentence . truth ) ; } budget = BudgetFunctions . forward ( truth , nal ) ; } final boolean higherOrder = ( belief . term . isHigherOrderStatement ( ) | | sentence . term . isHigherOrderStatement ( ) ) ; final boolean bothHigherOrder = ( belief . term . isHigherOrderStatement ( ) & & sentence . term . isHigherOrderStatement ( ) ) ; if ( ! bothHigherOrder & & higherOrder ) { if ( belief . term . isHigherOrderStatement ( ) ) { order = belief . term . getTemporalOrder ( ) ; } else if ( sentence . term . isHigherOrderStatement ( ) ) { order = sentence . term . getTemporalOrder ( ) ; } } final Statement s = Statement . make ( higherOrder ? NativeOperator . EQUIVALENCE : NativeOperator . SIMILARITY , term1 , term2 , order ) ; nal . doublePremiseTask ( s , truth , budget , false , false ) ; if ( Parameters . BREAK_NAL_HOL_BOUNDARY & & ! sentence . term . hasVarIndep ( ) & & ( st instanceof Equivalence ) & & order1 = = order2 & & belief . term . isHigherOrderStatement ( ) & & sentence . term . isHigherOrderStatement ( ) ) {
public void testGetNotString ( ) { assertNull ( cacheMap . get ( new Object ( ) ) ) ; }
public NativeOperator operator ( ) { return NativeOperator . INTERSECTION_EXT ; }
public boolean isProbing ( ) { return this . _localHost . isProbing ( ) ; }
public void initDynamicComponent ( @Nonnull final IAS2Session aSession , @Nullable final IStringMap aParameters ) throws AS2Exception { super . initDynamicComponent ( aSession , aParameters ) ; if ( attrs ( ) . containsKey ( ATTR_POLLING_INTERVAL_SECONDS ) ) {
public static IMessageMDN createMDN ( @Nonnull final IAS2Session aSession , @Nonnull final AS2Message aMsg , @Nonnull final DispositionType aDisposition , @Nonnull final String sText ) throws Exception { ValueEnforcer . notNull ( aSession , " AS2Session " ) ; ValueEnforcer . notNull ( aMsg , " AS2Message " ) ; ValueEnforcer . notNull ( aDisposition , " Disposition " ) ; ValueEnforcer . notNull ( sText , " Text " ) ; final AS2MessageMDN aMDN = new AS2MessageMDN ( aMsg ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . AS2_VERSION , CAS2Header . DEFAULT_AS2_VERSION ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . DATE , AS2DateHelper . getFormattedDateNow ( CAS2Header . DEFAULT_DATE_FORMAT ) ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . SERVER , CAS2Info . NAME_VERSION ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . MIME_VERSION , CAS2Header . DEFAULT_MIME_VERSION ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . AS2_FROM , aMsg . partnership ( ) . getReceiverAS2ID ( ) ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . AS2_TO , aMsg . partnership ( ) . getSenderAS2ID ( ) ) ; aMDN . partnership ( ) . setSenderAS2ID ( aMDN . getHeader ( CHttpHeader . AS2_FROM ) ) ; aMDN . partnership ( ) . setReceiverAS2ID ( aMDN . getHeader ( CHttpHeader . AS2_TO ) ) ; aMDN . partnership ( ) . setSenderX509Alias ( aMsg . partnership ( ) . getReceiverX509Alias ( ) ) ; aMDN . partnership ( ) . setReceiverX509Alias ( aMsg . partnership ( ) . getSenderX509Alias ( ) ) ; try { aSession . getPartnershipFactory ( ) . updatePartnership ( aMDN , true ) ; } catch ( final PartnershipNotFoundException ex ) { } aMDN . headers ( ) . setHeader ( CHttpHeader . FROM , aMsg . partnership ( ) . getReceiverEmail ( ) ) ; final String sSubject = aMDN . partnership ( ) . getMDNSubject ( ) ; if ( sSubject ! = null ) { aMDN . headers ( ) . setHeader ( CHttpHeader . SUBJECT , new MessageParameters ( aMsg ) . format ( sSubject ) ) ; } else { aMDN . headers ( ) . setHeader ( CHttpHeader . SUBJECT , " Your Requested MDN Response " ) ; } final String sCTE = aMsg . partnership ( ) . getContentTransferEncodingSend ( EContentTransferEncoding . AS2_DEFAULT . getID ( ) ) ; aMDN . headers ( ) . addHeader ( CHttpHeader . CONTENT_TRANSFER_ENCODING , sCTE ) ; aMDN . setText ( new MessageParameters ( aMsg ) . format ( sText ) ) ; aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_REPORTING_UA , CAS2Info . NAME_VERSION + " @ " + aMsg . attrs ( ) . getAsString ( CNetAttribute . MA_DESTINATION_IP ) + " : " + aMsg . attrs ( ) . getAsString ( CNetAttribute . MA_DESTINATION_PORT ) ) ; aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_ORIG_RECIPIENT , " rfc822;  " + aMsg . getHeader ( CHttpHeader . AS2_TO ) ) ; aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_FINAL_RECIPIENT , " rfc822;  " + aMsg . partnership ( ) . getReceiverAS2ID ( ) ) ; aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_ORIG_MESSAGEID , aMsg . getHeader ( CHttpHeader . MESSAGE_ID ) ) ; aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_DISPOSITION , aDisposition . getAsString ( ) ) ; final String sDispositionOptions = aMsg . getHeader ( CHttpHeader . DISPOSITION_NOTIFICATION_OPTIONS ) ; final DispositionOptions aDispositionOptions = DispositionOptions . createFromString ( sDispositionOptions ) ; MIC aMIC = null ; if ( aDispositionOptions . getMICAlgCount ( ) > 0 ) { final boolean bIncludeHeadersInMIC = aMsg . partnership ( ) . getSigningAlgorithm ( ) ! = null | | aMsg . partnership ( ) . getEncryptAlgorithm ( ) ! = null | | aMsg . partnership ( ) . getCompressionType ( ) ! = null ; aMIC = getCryptoHelper ( ) . calculateMIC ( aMsg . getData ( ) , aDispositionOptions . getFirstMICAlg ( ) , bIncludeHeadersInMIC ) ; } aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_MIC , aMIC . getAsAS2String ( ) ) ; boolean bSignMDN = false ; boolean bIncludeCertificateInSignedContent = false ; if ( aDispositionOptions . getProtocol ( ) ! = null ) { if ( aDispositionOptions . isProtocolRequired ( ) | | aDispositionOptions . hasMICAlg ( ) ) { bSignMDN = true ; final ETriState eIncludeCertificateInSignedContent = aMsg . partnership ( ) . getIncludeCertificateInSignedContent ( ) ; if ( eIncludeCertificateInSignedContent . isDefined ( ) ) { bIncludeCertificateInSignedContent = eIncludeCertificateInSignedContent . getAsBooleanValue ( ) ; } else { bIncludeCertificateInSignedContent = aSession . isCryptoSignIncludeCertificateInBodyPart ( ) ; } } } final boolean bUseOldRFC3851MicAlgs = aMsg . partnership ( ) . isRFC3851MICAlgs ( ) ; createMDNData ( aSession , aMDN , bSignMDN , bIncludeCertificateInSignedContent , aDispositionOptions . getFirstMICAlg ( ) , bUseOldRFC3851MicAlgs ) ; aMDN . updateMessageID ( ) ; aMsg . setMDN ( aMDN ) ; return aMDN ; }
public StructType getSchema ( ) throws Exception { StructType schema = ( ( StreamInput ) getInput ( ) ) . getSchema ( ) ; return schema ; }
public void onReset ( ) { } public void onPulled ( float percentagePulled ) { } public void onRefreshStarted ( ) { } public void onReleaseToRefresh ( ) { } public void onRefreshMinimized ( ) { } public abstract boolean showHeaderView ( ) ; public abstract boolean hideHeaderView ( ) ; public void onConfigurationChanged ( Activity activity , Configuration newConfig ) { } }
private IdentifiedTerm identifyTerm ( int priority , Term term , int offset ) { map ( term , offset ) ; return new IdentifiedTerm ( priority , term ) ; }
public void run ( ) { setZoom ( 0.5f ) ; setPanY ( - 200 f ) ; setPanX ( - getWidth ( ) ) ; camera . timeScale = 7f ; repaint ( ) ;
public abstract JmDNS getDNS ( ) ; public abstract String getType ( ) ; public abstract String getName ( ) ; public abstract ServiceInfo getInfo ( ) ; @Override public ServiceEvent clone ( ) { try { return ( ServiceEvent ) super . clone ( ) ; } catch ( CloneNotSupportedException exception ) { return null ; } } }
private void concludeMeasurement ( ) { logger . info ( " last event is received! " ) ; logger . info ( " total count: {} " , this . totalCount ) ; String learningCurveSummary = this . toString ( ) ; logger . info ( learningCurveSummary ) ; long experimentEnd = System . nanoTime ( ) ; long totalExperimentTime = TimeUnit . SECONDS . convert ( experimentEnd - experimentStart , TimeUnit . NANOSECONDS ) ; logger . info ( " total evaluation time: {} seconds for {} instances " , totalExperimentTime , totalCount ) ; if ( immediateResultStream ! = null ) { immediateResultStream . println ( " # COMPLETED " ) ;
public static void perfNAL ( final String path , final int extraCycles , int repeats , int warmups ) { } public static double perfNAL ( final NAR n , final String path , final int extraCycles , int repeats , int warmups , boolean gc ) { final String example = NALTest . getExample ( path ) ; Performance p = new Performance ( path , repeats , warmups , gc ) { long totalCycles ; @Override public void init ( ) { System . out . print ( name + " :  " ) ; totalCycles = 0 ; } @Override public void run ( boolean warmup ) { n . reset ( ) ; n . addInput ( example ) ; n . step ( 1 ) ; n . finish ( extraCycles ) ; totalCycles + = n . memory . getCycleTime ( ) ; } @Override public Performance print ( ) { super . print ( ) ; System . out . print ( " ,  " + df . format ( getCycleTimeMS ( ) / totalCycles * 1000.0 ) + "  uS/cycle,  " + ( ( ( float ) totalCycles ) / ( warmups + repeats ) ) + "  cycles/run " ) ; return this ; } @Override public Performance printCSV ( boolean finalComma ) { super . printCSV ( true ) ; System . out . print ( df . format ( getCycleTimeMS ( ) / totalCycles * 1000.0 ) + " ,  " + ( ( ( float ) totalCycles ) / ( warmups + repeats ) ) ) ; if ( finalComma ) System . out . print ( " ,  " ) ; return this ; } } ; p . print ( ) ; System . out . println ( ) ; return p . getCycleTimeMS ( ) ; } public static void test ( NAR n ) { int repeats = 1 ; int warmups = 0 ; int extraCycles = 5000 ; Collection c = NALTest . params ( ) ; double totalTime = 0 ; for ( Object o : c ) { String examplePath = ( String ) ( ( Object [ ] ) o ) [ 0 ] ; totalTime + = perfNAL ( n , examplePath , extraCycles , repeats , warmups , true ) ; } System . out . println ( " \ n \ nTotal mean runtime (ms):  " + totalTime ) ; } public static void main ( String [ ] args ) { NAR nc = new Curve ( ) . build ( ) ; test ( nc ) ; NAR nd = new Default ( ) . build ( ) ; test ( nd ) ; } }
public ViewFuture query ( View view , Query query ) { String queryString = query . toString ( ) ; String params = ( queryString . length ( ) > 0 ) ? " &reduce=false " : " ?reduce=false " ; String uri = view . getURI ( ) + queryString + params ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final ViewFuture crv = new ViewFuture ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new DocsOperationImpl ( request , new DocsCallback ( ) { ViewResponseWithDocs vr = null ; @Override public void receivedStatus ( OperationStatus status ) { if ( vr ! = null ) { Collection < String > ids = new LinkedList < String > ( ) ; Iterator < RowWithDocs > itr = vr . iterator ( ) ; while ( itr . hasNext ( ) ) { ids . add ( itr . next ( ) . getId ( ) ) ; } crv . set ( vr , asyncGetBulk ( ids ) , status ) ; } else { crv . set ( null , null , status ) ; } } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseWithDocs response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }
public int hashCode ( ) { return ( int ) Double . doubleToLongBits ( begin ) ^ ( int ) Double . doubleToLongBits ( end )
public static void main ( String [ ] args ) { int repeats = 2 ; int warmups = 1 ; int maxConcepts = 2000 ; int extraCycles = 2048 ; int randomExtraCycles = 512 ; NAR n = new DiscretinuousBagNARBuilder ( ) . setConceptBagSize ( maxConcepts ) . build ( ) ; Collection c = NALTest . params ( ) ; while ( true ) { for ( Object o : c ) {
public boolean remove ( T value ) { Node < T > node = findNode ( value ) ; if ( node = = null ) return false ; Node < T > prev = node . getPrev ( 0 ) ; Node < T > next = node . getNext ( 0 ) ; if ( prev = = null ) { if ( next ! = null ) { node . value = next . value ; next . value = value ; node = next ; } else { head = null ; } } int levels = node . next . length ; for ( int i = levels - 1 ; i > = 0 ; i - - ) { prev = node . getPrev ( i ) ; next = node . getNext ( i ) ; if ( prev ! = null ) prev . setNext ( i , next ) ; if ( next ! = null ) next . setPrev ( i , prev ) ; } size - - ; return true ; }
public void randomChanged ( boolean random ) { } @Override public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } @Override public void onAudioFocusChange ( int focusChange ) { if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS_TRANSIENT ) { mediaPlayer . setVolume ( 0.2f , 0.2f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_GAIN ) { mediaPlayer . setVolume ( 1f , 1f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS ) { stopStreaming ( ) ; } } }
public EChange setSigningAlgorithm ( @Nullable final ECryptoAlgorithmSign eValue ) { return setSigningAlgorithm ( eValue = = null ? null : eValue . getID ( ) ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . SentQuest p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . SentGoal p , A arg ) ; } }
String getLoggingText ( ) ; @Nonnull DataHistory getHistory ( ) ; String getProtocol ( ) ; boolean isRequestingMDN ( ) ; boolean isRequestingAsynchMDN ( ) ; }
public void copyFrom ( @Nonnull final Partnership aPartnership ) { ValueEnforcer . notNull ( aPartnership , " Partnership " ) ; if ( aPartnership ! = this ) {
public abstract int size ( ) ; public static < T > Queue < T > createQueue ( QueueType type ) { switch ( type ) { case ArrayQueue : return new ArrayQueue < T > ( ) ; default : return new LinkedQueue < T > ( ) ; } } public static class ArrayQueue < T > extends Queue < T > { private static final int GROW_IN_CHUNK_SIZE = 1000 ; private static final int SHRINK_IN_CHUNK_SIZE = 1000 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int nextIndex = 0 ; private int firstIndex = 0 ; @Override public void enqueue ( T value ) { if ( nextIndex > = array . length ) { array = Arrays . copyOfRange ( array , firstIndex , nextIndex + GROW_IN_CHUNK_SIZE ) ; firstIndex = 0 ; } array [ nextIndex + + ] = value ; } @Override public T dequeue ( ) { if ( ( nextIndex - firstIndex ) < 0 ) return null ; T t = array [ firstIndex ] ; array [ firstIndex + + ] = null ; if ( ( nextIndex - firstIndex ) = = 0 ) { nextIndex = 0 ; firstIndex = 0 ; } else if ( ( array . length - nextIndex ) > = SHRINK_IN_CHUNK_SIZE ) { array = Arrays . copyOfRange ( array , firstIndex , nextIndex ) ; nextIndex = nextIndex - firstIndex ; firstIndex = 0 ; } return t ; } @Override public boolean contains ( T value ) { for ( int i = firstIndex ; i < nextIndex ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public int size ( ) { return nextIndex - firstIndex ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = nextIndex - 1 ; i > = firstIndex ; i - - ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } public static class LinkedQueue < T > extends Queue < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; public LinkedQueue ( ) { head = null ; tail = null ; size = 0 ; } @Override public void enqueue ( T value ) { enqueue ( new Node < T > ( value ) ) ; } private void enqueue ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > oldHead = head ; head = node ; node . next = oldHead ; oldHead . prev = node ; } size + + ; } @Override public T dequeue ( ) { T result = null ; if ( tail ! = null ) { result = tail . value ; Node < T > prev = tail . prev ; if ( prev ! = null ) { prev . next = null ; tail = prev ; } else { head = null ; tail = null ; } size - - ; } return result ; } @Override public boolean contains ( T value ) { if ( head = = null ) return false ; Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . next ; } return false ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . next ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > prev = null ; private Node < T > next = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( prev ! = null ) ? prev . value : " NULL " ) + "  next= " + ( ( next ! = null ) ? next . value : " NULL " ) ; } } } }
public static int dedExeOrder ( int order1 , int order2 ) { int order = ORDER_INVALID ; if ( ( order1 = = order2 ) | | ( order2 = = TemporalRules . ORDER_NONE ) ) { order = order1 ; } else if ( ( order1 = = TemporalRules . ORDER_NONE ) | | ( order1 = = TemporalRules . ORDER_CONCURRENT ) ) { order = order2 ; } else if ( order2 = = TemporalRules . ORDER_CONCURRENT ) { order = order1 ; } return order ; }
public String toString ( ) { final StringBuilder builder = new StringBuilder ( ) ; for ( Vertex < T > v : allVertices ) builder . append ( v . toString ( ) ) ; return builder . toString ( ) ; }
public static Statement make ( final Statement statement , final Term subj , final Term pred , int order , final Memory memory ) { if ( statement instanceof Inheritance ) { return Inheritance . make ( subj , pred , memory ) ; } if ( statement instanceof Similarity ) { return Similarity . make ( subj , pred , memory ) ; } if ( statement instanceof Implication ) { return Implication . make ( subj , pred , order , memory ) ; } if ( statement instanceof Equivalence ) { return Equivalence . make ( subj , pred , order , memory ) ; } throw new RuntimeException ( " Unrecognized type for Statement.make:  " + statement . getClass ( ) . getSimpleName ( ) + " , subj= " + subj + " , pred= " + pred + " , order= " + order ) ; }
public boolean matches ( final String regex ) { return Pattern . matches ( regex , this . getForSequentialAccess ( ) ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( super . toString ( ) ) . append ( "   " ) ; builder . append ( " Set= " ) . append ( set ) ; return builder . toString ( ) ; }
protected void onShowing ( boolean showing ) { if ( showing ) { nar . memory . event . on ( Events . FrameEnd . class , this ) ;
public static void main ( String [ ] arg ) { NAR nar = new DiscretinuousBagNARBuilder ( ) . simulationTime ( ) . build ( ) ; nar . param ( ) . noiseLevel . set ( 0 ) ; int memCyclesPerFrame = 200 ; float fps = 40 f ; gameRate = 1.0f / fps ; NARio nario = new NARio ( nar ) ; new NARSwing ( nar ) ; nar . startFPS ( fps , memCyclesPerFrame , 1f ) ;
public abstract boolean remove ( T value ) ; public abstract boolean contains ( T value ) ; public abstract T get ( int index ) ; public abstract int size ( ) ; public static < T > List < T > createList ( ListType type ) { switch ( type ) { case ArrayList : return new ArrayList < T > ( ) ; default : return new LinkedList < T > ( ) ; } } public static class LinkedList < T > extends List < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; @Override public void add ( T value ) { add ( new Node < T > ( value ) ) ; } private void add ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > prev = tail ; prev . nextNode = node ; node . previousNode = prev ; tail = node ; } size + + ; } @Override public boolean remove ( T value ) { Node < T > node = head ; while ( node ! = null & & ( ! node . value . equals ( value ) ) ) { node = node . nextNode ; } if ( node = = null ) return false ; if ( node . equals ( tail ) ) tail = node . previousNode ; Node < T > prev = node . previousNode ; Node < T > next = node . nextNode ; if ( prev ! = null & & next ! = null ) { prev . nextNode = next ; next . previousNode = prev ; } else if ( prev ! = null & & next = = null ) { prev . nextNode = null ; } else if ( prev = = null & & next ! = null ) { next . previousNode = null ; head = next ; } else { head = null ; } size - - ; return true ; } @Override public boolean contains ( T value ) { Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . nextNode ; } return false ; } @Override public T get ( int index ) { T result = null ; Node < T > node = head ; int i = 0 ; while ( node ! = null & & i < index ) { node = node . nextNode ; i + + ; } if ( node ! = null ) result = node . value ; return result ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . nextNode ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > previousNode = null ; private Node < T > nextNode = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( previousNode ! = null ) ? previousNode . value : " NULL " ) + "  next= " + ( ( nextNode ! = null ) ? nextNode . value : " NULL " ) ; } } } public static class ArrayList < T > extends List < T > { private static final int GROW_IN_CHUNK_SIZE = 50 ; private static final int SHRINK_IN_CHUNK_SIZE = 50 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int size = 0 ; @Override public void add ( T value ) { if ( size > = array . length ) { T [ ] temp = Arrays . copyOf ( array , size + GROW_IN_CHUNK_SIZE ) ; temp [ size + + ] = value ; array = temp ; } else { array [ size + + ] = value ; } } @Override public boolean remove ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) { for ( int j = i + 1 ; j < size ; j + + ) { array [ j - 1 ] = array [ j ] ; } array [ - - size ] = null ; if ( array . length - size > = SHRINK_IN_CHUNK_SIZE ) { T [ ] temp = Arrays . copyOf ( array , size ) ; array = temp ; } return true ; } } return false ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public T get ( int index ) { if ( index > = size ) return null ; return array [ index ] ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i + + ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } }
public void executedTask ( final Operation operation ) { Task opTask = operation . getTask ( ) ; logic . TASK_EXECUTED . commit ( opTask . budget . getPriority ( ) ) ; TruthValue truth = new TruthValue ( 1f , 0.9999f ) ; Stamp stamp = new Stamp ( this , Tense . Present ) ; Sentence sentence = new Sentence ( operation , Symbols . JUDGMENT_MARK , truth , stamp ) ; Task task = new Task ( sentence , opTask . budget , operation . getTask ( ) ) ; task . setCause ( operation ) ; addNewTask ( task , " Executed " ) ; }
public void ok ( ) { if ( psp . getTable ( ) . getEditorComponent ( ) ! = null ) psp . getTable ( ) . commitEditing ( ) ; super . ok ( ) ; } ;
private void learnStory ( ArrayList < Scene > scenesToLearn ) { nar . addInput ( " <meta-stop --> meta-info>. :|: " ) ; nar . step ( 1 ) ; for ( Scene iteratorScene : scenesToLearn ) { String narseseOfActions = convertActionItemsToNarsese ( iteratorScene . actionItems ) ; nar . addInput ( narseseOfActions + " . :|: " ) ; nar . step ( STEPS_BETWEEN ) ; translateTextIntoTemporalNarseseAndLearn ( iteratorScene . textAsString ) ; nar . step ( STEPS_BETWEENACTIONS ) ; } nar . step ( STEPS_BETWEENSCENES - STEPS_BETWEENACTIONS ) ; }
public void implicitKeyInsertTests ( ) { final int [ ] data = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; final MyTreap < Integer > treap = new MyTreap < Integer > ( ) ; for ( int i = 0 ; i < data . length ; i + + ) { Integer d = data [ i ] ; treap . add ( i , d ) ; } String inOrder = toString ( Integer . class , treap . inOrder ( ) ) ; Assert . assertTrue ( inOrder . equals ( " 1 2 3 4 5 6 7 8  " ) ) ; }
public void testReverseIterator ( ) { FlatCharSequenceRope r1 = new FlatCharSequenceRope ( " 01234 " ) ; ReverseRope r2 = new ReverseRope ( r1 ) ; SubstringRope r3 = new SubstringRope ( r1 , 0 , 3 ) ; ConcatenationRope r4 = new ConcatenationRope ( new ConcatenationRope ( r1 , r2 ) , r3 ) ; Iterator < Character > x = r1 . reverseIterator ( ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '4' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '3' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '2' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '1' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '0' , ( char ) x . next ( ) ) ; assertFalse ( x . hasNext ( ) ) ; x = r1 . reverseIterator ( 4 ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '0' , ( char ) x . next ( ) ) ; assertFalse ( x . hasNext ( ) ) ; x = r2 . reverseIterator ( ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '0' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '1' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '2' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '3' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '4' , ( char ) x . next ( ) ) ; assertFalse ( x . hasNext ( ) ) ; x = r2 . reverseIterator ( 4 ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '4' , ( char ) x . next ( ) ) ; assertFalse ( x . hasNext ( ) ) ; x = r3 . reverseIterator ( ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '2' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '1' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '0' , ( char ) x . next ( ) ) ; assertFalse ( x . hasNext ( ) ) ; x = r3 . reverseIterator ( 1 ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '1' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '0' , ( char ) x . next ( ) ) ; assertFalse ( x . hasNext ( ) ) ; x = r4 . reverseIterator ( ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '2' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '1' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '0' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '0' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '1' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '2' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '3' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '4' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '4' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '3' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '2' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '1' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '0' , ( char ) x . next ( ) ) ; assertFalse ( x . hasNext ( ) ) ; x = r4 . reverseIterator ( 7 ) ; assertEquals ( ( char ) '4' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '4' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '3' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '2' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '1' , ( char ) x . next ( ) ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '0' , ( char ) x . next ( ) ) ; assertFalse ( x . hasNext ( ) ) ; x = r4 . reverseIterator ( 12 ) ; assertTrue ( x . hasNext ( ) ) ; assertEquals ( ( char ) '0' , ( char ) x . next ( ) ) ; assertFalse ( x . hasNext ( ) ) ; x = r4 . reverseIterator ( 13 ) ; assertFalse ( x . hasNext ( ) ) ;
protected boolean areAttributesEqual ( final StatsKey other ) { Class < ? > keyClass = other . getClass ( ) ; if ( keyClass = = SingleAttributeStatsKey . class ) { return ( ( AbstractStatsKey ) other ) . areAttributesEqual ( this ) ; } return attributes . equals ( other . getAttributes ( ) ) ; }
public static final CharSequence n2 ( final float x ) { if ( ( x < 0 ) | | ( x > 1.0f ) ) throw new IllegalStateException ( " Invalid value for Texts.n2 " ) ; int hundredths = ( int ) hundredths ( x ) ; switch ( hundredths ) { case 100 : return " 1.00 " ; case 99 : return " 0.99 " ; case 90 : return " 0.90 " ; case 0 : return " 0.00 " ; } if ( hundredths > 9 ) { int tens = hundredths / 10 ;
public void assertNotEmptySerialize ( ) { var nullObj = new AssertNotEmpty ( ) ; nullObj . name = null ; assertNull ( serialize ( nullObj ) . get ( " name " ) ) ; var emptyValObj = new AssertNotEmpty ( ) ; emptyValObj . name = " " ; assertThrows ( SerdeAssertException . class , ( ) - > serialize ( emptyValObj ) ) ; var obj = new AssertNotEmpty ( ) ; obj . name = " n " ; assertEquals ( " n " , serialize ( obj ) . get ( " name " ) ) ; }
public void testDelete ( ) { ( new DeleteOperationImpl ( " key " , null ) ) . toString ( ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( super . toString ( ) ) ; return sb . toString ( ) ; }
public void timeOut ( ) { timedout = true ; }
protected static void fireTaskLink ( final DerivationContext nal , int termLinks ) { final Task task = nal . currentTaskLink . getTarget ( ) ; nal . setCurrentTerm ( nal . currentConcept . term ) ; nal . setCurrentTaskLink ( nal . currentTaskLink ) ; nal . setCurrentBeliefLink ( null ) ; nal . setCurrentTask ( task ) ; nal . memory . emotion . adjustBusy ( nal . currentTaskLink . getPriority ( ) , nal . currentTaskLink . getDurability ( ) , nal ) ; if ( nal . currentTaskLink . type = = TermLink . TRANSFORM ) { nal . setCurrentBelief ( null ) ; RuleTables . transformTask ( nal . currentTaskLink , nal ) ; } else { while ( termLinks > 0 ) { final TermLink termLink = nal . currentConcept . selectTermLink ( nal . currentTaskLink , nal . memory . time ( ) , nal . narParameters ) ; if ( termLink = = null ) { break ; } fireTermlink ( termLink , nal ) ; nal . currentConcept . returnTermLink ( termLink ) ; termLinks - - ; } } nal . memory . emit ( Events . ConceptFire . class , nal ) ;
private static Term findCommonTerm1 ( Term tested , Term containedTest , Term commonTerm , boolean enableSpecialCase , boolean enableRetCommonTerm ) { Term resultCommonTerm = commonTerm ; if ( tested . containsTermRecursively ( containedTest ) ) { resultCommonTerm = containedTest ; } if ( enableRetCommonTerm & & resultCommonTerm = = null ) { resultCommonTerm = retCommonTerm ( tested , containedTest , enableSpecialCase ) ; } return resultCommonTerm ; }
public abstract String getParameter ( String sKey ) throws InvalidParameterException ; public void setParameters ( @Nonnull final String sEncodedParams ) throws InvalidParameterException { final StringTokenizer aParams = new StringTokenizer ( sEncodedParams , " =, " , false ) ; while ( aParams . hasMoreTokens ( ) ) { final String sKey = aParams . nextToken ( ) . trim ( ) ; if ( ! aParams . hasMoreTokens ( ) ) throw new InvalidParameterException ( " Invalid value " , this , sKey , null ) ; final String sValue = aParams . nextToken ( ) ; setParameter ( sKey , sValue ) ; } } public void setParameters ( @Nullable final String sFormat , @Nullable final String sDelimiters , @Nonnull final String sValue ) throws OpenAS2Exception { final List < String > aKeys = StringHelper . getExploded ( ',' , sFormat ) ; final StringTokenizer aValueTokens = new StringTokenizer ( sValue , sDelimiters , false ) ; for ( final String sKey : aKeys ) { if ( ! aValueTokens . hasMoreTokens ( ) ) throw new OpenAS2Exception ( " Invalid value: Format= " + sFormat + " , value= " + sValue ) ; if ( sKey . length ( ) > 0 ) setParameter ( sKey , aValueTokens . nextToken ( ) ) ; } } public static String parse ( @Nonnull final String sFormat , @Nonnull final AbstractParameterParser aParser ) throws InvalidParameterException { return aParser . format ( sFormat ) ; } @Nonnull public String format ( @Nonnull final String sFormat ) throws InvalidParameterException { final StringBuilder aResult = new StringBuilder ( ) ; for ( int nNext = 0 ; nNext < sFormat . length ( ) ; + + nNext ) { int nPrev = nNext ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) { aResult . append ( sFormat . substring ( nPrev , sFormat . length ( ) ) ) ; break ; } if ( nNext > nPrev ) aResult . append ( sFormat . substring ( nPrev , nNext ) ) ; nPrev = nNext + 1 ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) throw new InvalidParameterException ( " Invalid key (missing closing $) " ) ; if ( nNext = = nPrev ) aResult . append ( " $ " ) ; else aResult . append ( getParameter ( sFormat . substring ( nPrev , nNext ) ) ) ; } return aResult . toString ( ) ; } }
public void updateField ( ) { if ( playing = = COMPUTER ) status . setText ( " Thinking " ) ; else status . setText ( " Play " ) ; Boolean winner = null ; for ( int p = 1 ; p < = 2 ; p + + ) { for ( int [ ] h : howToWin ) { if ( field [ h [ 0 ] ] ! = p ) continue ; if ( field [ h [ 1 ] ] ! = p ) continue ; if ( field [ h [ 2 ] ] ! = p ) continue ; winner = p = = 1 ? HUMAN : COMPUTER ; } } if ( winner = = null ) { String s = " " ;
public AttributeSplitSuggestion getBestEvaluatedSplitSuggestion ( SplitCriterion criterion , double [ ] preSplitDist , int attIndex , boolean binaryOnly ) { return searchForBestSplitOption ( this . root1 , null , null , null , null , false , criterion , preSplitDist , attIndex ) ;
public void write ( final Writer out , final int offset , final int length ) throws IOException { if ( offset < 0 | | offset + length > this . length ( ) ) { throw new IndexOutOfBoundsException ( " Rope index out of bounds: " + ( offset < 0 ? offset : offset + length ) ) ; } if ( this . sequence instanceof String ) { out . write ( ( ( String ) this . sequence ) . substring ( offset , offset + length ) ) ; return ; } for ( int j = offset ; j < offset + length ; + + j ) { out . write ( this . sequence . charAt ( j ) ) ;
@Override public void event ( Class event , Object [ ] args ) { onProcessed ( ( Task ) args [ 0 ] , ( NAL ) args [ 1 ] ) ; }
private static final boolean contains ( int value , int [ ] array ) { for ( int i : array ) { if ( i = = value ) return true ; } return false ; }
public Object visit ( TrmProd p , LoanParser arg ) { ArrayList < Term > ts = new ArrayList < Term > ( ) ; Iterator < com . googlecode . opennars . parser . loan . Loan . Absyn . Term > iter = p . listterm_ . iterator ( ) ; while ( iter . hasNext ( ) ) { Term t = ( Term ) iter . next ( ) . accept ( this , arg ) ; ts . add ( t ) ; } return CompoundTerm . make ( Symbols . PRODUCT_OPERATOR , ts , memory ) ; }
static final TruthValue desireWeak ( final TruthValue v1 , final TruthValue v2 ) { final float f1 = v1 . getFrequency ( ) ; final float f2 = v2 . getFrequency ( ) ; final float c1 = v1 . getConfidence ( ) ; final float c2 = v2 . getConfidence ( ) ; final float f = and ( f1 , f2 ) ; final float c = and ( c1 , c2 , f2 , w2c ( 1.0f ) ) ; return new TruthValue ( f , c ) ; }
public void start ( ) { this . psp . sendInstances ( inputStream , numInstanceSent ) ; }
protected static void fireTaskLink ( final DerivationContext nal , int termLinks ) { final Task task = nal . currentTaskLink . getTarget ( ) ; nal . setCurrentTerm ( nal . currentConcept . term ) ; nal . setCurrentTaskLink ( nal . currentTaskLink ) ; nal . setCurrentBeliefLink ( null ) ; nal . setCurrentTask ( task ) ; if ( nal . memory . emotion ! = null ) { nal . memory . emotion . adjustBusy ( nal . currentTaskLink . getPriority ( ) , nal . currentTaskLink . getDurability ( ) , nal ) ; } Concept taskConcept = nal . memory . concept ( task . getTerm ( ) ) ; if ( taskConcept ! = null ) { ProcessGoal . bestReactionForGoal ( taskConcept , nal , task . sentence . projection ( nal . time . time ( ) , nal . time . time ( ) , nal . memory ) , task ) ; } if ( nal . currentTaskLink . type = = TermLink . TRANSFORM ) { nal . setCurrentBelief ( null ) ; RuleTables . transformTask ( nal . currentTaskLink , nal ) ; } else { while ( termLinks > 0 ) { final TermLink termLink = nal . currentConcept . selectTermLink ( nal . currentTaskLink , nal . time . time ( ) , nal . narParameters ) ; if ( termLink = = null ) { break ; } fireTermlink ( termLink , nal ) ; nal . currentConcept . returnTermLink ( termLink ) ; termLinks - - ; } } nal . memory . emit ( Events . ConceptFire . class , nal ) ;
public void setAttributes ( @Nullable final IStringMap aAttributes ) { m_aAttributes . clear ( ) ; addAttributes ( aAttributes ) ; }
public static Term make ( Term term1 , Term term2 , Memory memory ) { TreeSet set ; if ( term1 instanceof Disjunction ) { set = new TreeSet ( ( ( CompoundTerm ) term1 ) . cloneComponents ( ) ) ; if ( term2 instanceof Disjunction ) set . addAll ( ( ( CompoundTerm ) term2 ) . cloneComponents ( ) ) ; else set . add ( ( Term ) term2 . clone ( ) ) ; } else if ( term2 instanceof Disjunction ) { set = new TreeSet ( ( ( CompoundTerm ) term2 ) . cloneComponents ( ) ) ; set . add ( ( Term ) term1 . clone ( ) ) ; } else { set = new TreeSet ( ) ; set . add ( ( Term ) term1 . clone ( ) ) ; set . add ( ( Term ) term2 . clone ( ) ) ; } return make ( set , memory ) ; }
public void moveByPosition ( final int from , final int to ) throws IOException , MPDException { mConnection . sendCommand ( MPD_CMD_PLAYLIST_MOVE , Integer . toString ( from ) , Integer . toString ( to ) ) ;
public void addStartKnowledge ( ) { nar . addInput ( " <goal --> reached>! %1.0;0.99% " ) ; for ( int [ ] h : howToWin ) { int a = h [ 0 ] ; int b = h [ 1 ] ; int c = h [ 2 ] ; nar . addInput ( " <(&|,(^addO, " + a + " ),<input --> succeeded>,(^addO, " + b + " ),<input --> succeeded>,(^addO, " + c + " ),<input --> succeeded>) =/> <goal --> reached>>. " ) ; } nar . addInput ( " <goal --> reached>! %1.0;0.99% " ) ; nar . addInput ( " (&/,<#1 --> field>,(^addO,#1))! " ) ; nar . addInput ( " (^addO,0)! %1.0;0.7% " ) ; nar . addInput ( " (^addO,1)! %1.0;0.7% " ) ; nar . addInput ( " (^addO,2)! %1.0;0.7% " ) ; nar . addInput ( " (^addO,3)! %1.0;0.7% " ) ; nar . addInput ( " (^addO,4)! %1.0;0.7% " ) ; nar . addInput ( " (^addO,5)! %1.0;0.7% " ) ; nar . addInput ( " (^addO,6)! %1.0;0.7% " ) ; nar . addInput ( " (^addO,7)! %1.0;0.7% " ) ; nar . addInput ( " (^addO,8)! %1.0;0.7% " ) ; nar . addInput ( " <0 --> field>. " ) ; nar . addInput ( " <1 --> field>. " ) ; nar . addInput ( " <2 --> field>. " ) ; nar . addInput ( " <3 --> field>. " ) ; nar . addInput ( " <4 --> field>. " ) ; nar . addInput ( " <5 --> field>. " ) ; nar . addInput ( " <6 --> field>. " ) ; nar . addInput ( " <7 --> field>. " ) ; nar . addInput ( " <8 --> field>. " ) ; nar . addInput ( " <input --> succeeded>! " ) ; nar . addInput ( " (--,<input --> failed>)! " ) ;
public void missingField ( ) throws Exception { Dataset < Row > source = createTestDataframe ( ) ; List < String > inListLiteral = Arrays . asList ( " 1 " , " 2 " , " 3 " ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " df1 " , source ) ; Config config = ConfigFactory . empty ( ) . withValue ( InListDeriver . INLIST_STEP_CONFIG , ConfigValueFactory . fromAnyRef ( " df1 " ) ) . withValue ( InListDeriver . INLIST_VALUES_CONFIG , ConfigValueFactory . fromIterable ( inListLiteral ) ) . withoutPath ( InListDeriver . INLIST_FIELD_CONFIG ) ; InListDeriver deriver = new InListDeriver ( ) ; assertNoValidationFailures ( deriver , config ) ; deriver . configure ( config ) ; thrown . expect ( RuntimeException . class ) ; thrown . expectMessage ( " parameter should be specified " ) ; deriver . derive ( dependencies ) ; }
public String escape ( String x ) { return x . replaceAll ( " : " , " \ u25B8 " ) . replaceAll ( "   " , " \ u2581 " ) . replaceAll ( " # " , " \ u25B8 " )
public boolean $call_1 ( Term goal ) throws PrologError { goal = goal . getTerm ( ) ; if ( goal instanceof Var ) throw PrologError . instantiation_error ( engineManager , 1 ) ; if ( ! isCallable ( goal ) ) throw PrologError . type_error ( engineManager , 1 , " callable " , goal ) ; goal = convertTermToGoal ( goal ) ; if ( goal = = null ) throw PrologError . type_error ( engineManager , 1 , " callable " , goal ) ; engineManager . identify ( goal ) ; engineManager . pushSubGoal ( ClauseInfo . extractBody ( goal ) ) ; return true ; }
public void setParameter ( final String sKey , final String sValue ) throws InvalidParameterException { throw new InvalidParameterException ( " Set not supported " , this , sKey , sValue ) ; }
public void init ( ) throws OpenAS2Exception { } @Nonnull @ReturnsMutableCopy public ICommonsMap < String , ICommand > getAllCommands ( ) { return m_aCommands . getClone ( ) ; } @Nullable public ICommand getCommand ( final String name ) { return m_aCommands . get ( name ) ; } public boolean isTerminated ( ) { return m_bTerminated ; } @UnsupportedOperation public void processCommand ( ) throws OpenAS2Exception { throw new OpenAS2Exception ( " super class method call, not initialized correctly " ) ; } public void addCommands ( @Nonnull final ICommandRegistry aCommandRegistry ) { ValueEnforcer . notNull ( aCommandRegistry , " CommandRegistry " ) ; m_aCommands . putAll ( aCommandRegistry . getAllCommands ( ) ) ; } public void terminate ( ) { m_bTerminated = true ; } }
public Concept nameToConcept ( String name ) { return concepts . get ( name ) ; }
public void testDontIgnoreNulls ( ) { StructType schema = new StructType ( new StructField [ ] { new StructField ( " name " , DataTypes . StringType , false , Metadata . empty ( ) ) , new StructField ( " nickname " , DataTypes . StringType , false , Metadata . empty ( ) ) , new StructField ( " age " , DataTypes . IntegerType , false , Metadata . empty ( ) ) , new StructField ( " candycrushscore " , DataTypes . createDecimalType ( ) , false , Metadata . empty ( ) ) } ) ; Map < String , Object > configMap = new HashMap < > ( ) ; configMap . put ( RangeRowRule . FIELDS_CONFIG , Lists . newArrayList ( " age " ) ) ; configMap . put ( RangeRowRule . FIELD_TYPE_CONFIG , " int " ) ; configMap . put ( RangeRowRule . RANGE_CONFIG , Lists . newArrayList ( 0 , 105 ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; RangeRowRule rule = new RangeRowRule ( ) ; rule . configure ( " agerange " , config ) ; Row row1 = new RowWithSchema ( schema , " Ian " , " Ian " , null , new BigDecimal ( " 0.00 " ) ) ; assertFalse ( " Row should not pass rule " , rule . check ( row1 ) ) ; }
String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bAllowCertificateInBodyPart ) throws Exception ; }
final void sendSimpleMpdCommand ( final String command ) { new Thread ( new Runnable ( ) {
private void writeString ( CharSequence cs ) { output . write ( '"' ) ; final int length = cs . length ( ) ; for ( int i = 0 ; i < length ; i + + ) { char c = cs . charAt ( i ) ; int escapeIndex = Utils . arrayIndexOf ( TO_ESCAPE , c ) ; if ( escapeIndex ! = - 1 ) { char escaped = ESCAPED [ escapeIndex ] ; output . write ( '\\' ) ; output . write ( escaped ) ; } else { output . write ( c ) ; } } output . write ( '"' ) ; }
public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } @Override public void playlistChanged ( MPDStatus mpdStatus , int oldPlaylistVersion ) { } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { prevMpdState = " " ; showNotification ( ) ; } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = prevMpdState ) return ; if ( state = = MPDStatus . MPD_STATE_PLAYING ) { isPaused = false ; beginStreaming ( ) ; isPlaying = true ; } else { prevMpdState = state ; isPlaying = false ; stopStreaming ( ) ; } } } } @Override public void repeatChanged ( boolean repeating ) { } @Override public void randomChanged ( boolean random ) { } @Override public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } @Override public void onAudioFocusChange ( int focusChange ) { if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS_TRANSIENT ) { mediaPlayer . setVolume ( 0.2f , 0.2f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_GAIN ) { mediaPlayer . setVolume ( 1f , 1f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS ) { stop ( ) ; } } }
private < T > JavaDStream < T > repartition ( JavaDStream < T > stream ) { int numPartitions = config . getInt ( REPARTITION_NUM_PARTITIONS_PROPERTY ) ; return stream . repartition ( numPartitions ) ; }
protected CommandResult execute ( final IAliasedCertificateFactory certFx , final Object [ ] params ) throws AS2Exception { if ( params . length < 1 ) return new CommandResult ( ECommandResultType . TYPE_INVALID_PARAM_COUNT , getUsage ( ) ) ; final String sAlias = params [ 0 ] . toString ( ) ; final X509Certificate cert = certFx . getCertificate ( sAlias ) ; return new CommandResult ( ECommandResultType . TYPE_OK , cert . toString ( ) ) ; }
public void testMinHeap ( ) { TestData data = Utils . generateTestData ( 100 ) ; String aNameMin = " Min-Heap [array] " ; BinaryHeap . BinaryHeapArray < Integer > aHeapMin = new BinaryHeap . BinaryHeapArray < Integer > ( BinaryHeap . Type . MIN ) ; Collection < Integer > aCollectionMin = aHeapMin . toCollection ( ) ; assertTrue ( HeapTest . testHeap ( BinaryHeap . Type . MIN , aHeapMin , Type . Integer , aNameMin , data . unsorted , data . sorted , data . invalid ) ) ; assertTrue ( JavaCollectionTest . testCollection ( aCollectionMin , Type . Integer , aNameMin , data . unsorted , data . sorted , data . invalid ) ) ; String tNameMin = " Min-Heap [tree] " ; BinaryHeap . BinaryHeapTree < Integer > tHeapMin = new BinaryHeap . BinaryHeapTree < Integer > ( BinaryHeap . Type . MIN ) ; Collection < Integer > tCollectionMin = tHeapMin . toCollection ( ) ; assertTrue ( HeapTest . testHeap ( BinaryHeap . Type . MIN , tHeapMin , Type . Integer , tNameMin , data . unsorted , data . sorted , data . invalid ) ) ; assertTrue ( JavaCollectionTest . testCollection ( tCollectionMin , Type . Integer , tNameMin , data . unsorted , data . sorted , data . invalid ) ) ;
public void actionPerformed ( ActionEvent ae ) { nlpGui . previousScenePressed ( ) ; }
public static int readChunkLen ( @Nonnull @WillNotClose final InputStream aIS ) throws IOException { int nRes = 0 ; boolean bHeadersStarted = false ; for ( ; ; ) { int ch = aIS . read ( ) ; if ( ch < 0 ) throw new EOFException ( ) ; if ( ch = = '\n' ) break ; if ( ch > = 'a' & & ch < = 'f' ) ch - = ( 'a' - 10 ) ; else if ( ch > = 'A' & & ch < = 'F' ) ch - = ( 'A' - 10 ) ; else if ( ch > = '0' & & ch < = '9' ) ch - = '0' ; else if ( ch = = ';' ) bHeadersStarted = true ; else { LOGGER . warn ( " Found unsupported character  " + _debugChar ( ch ) + "  when trying to read HTTP chunk length " ) ; continue ; } if ( ! bHeadersStarted ) nRes = ( nRes * 16 ) + ch ; } return nRes ; }
public final String getSignAlgoID ( ) { return m_eSignAlgo = = null ? null : m_eSignAlgo . getID ( ) ; }
public static byte [ ] readData ( final Socket s , final IMessage msg ) throws IOException , MessagingException { byte [ ] data = null ; final BufferedInputStream in = new BufferedInputStream ( s . getInputStream ( ) ) ; final String [ ] request = readRequest ( in ) ; msg . setAttribute ( MA_HTTP_REQ_TYPE , request [ 0 ] ) ; msg . setAttribute ( MA_HTTP_REQ_URL , request [ 1 ] ) ; msg . setHeaders ( new InternetHeaders ( in ) ) ; final DataInputStream dataIn = new DataInputStream ( in ) ; if ( msg . getHeader ( " Content-Length " ) = = null ) { final String transfer_encoding = msg . getHeader ( " Transfer-Encoding " ) ; if ( transfer_encoding ! = null ) { if ( transfer_encoding . replaceAll ( " \\ s+ " , " " ) . equalsIgnoreCase ( " chunked " ) ) { int length = 0 ; for ( ; ; ) { int blocklen = 0 ; for ( ; ; ) { int ch = dataIn . readByte ( ) ; if ( ch = = '\n' ) break ; if ( ch > = 'a' & & ch < = 'f' ) ch - = ( 'a' - 10 ) ; else if ( ch > = 'A' & & ch < = 'F' ) ch - = ( 'A' - 10 ) ; else if ( ch > = '0' & & ch < = '9' ) ch - = '0' ; else continue ; blocklen = ( blocklen * 16 ) + ch ; } if ( blocklen = = 0 ) break ; final int newlen = length + blocklen ; final byte [ ] newdata = new byte [ newlen ] ; if ( length > 0 ) System . arraycopy ( data , 0 , newdata , 0 , length ) ; dataIn . readFully ( newdata , length , blocklen ) ; data = newdata ; length = newlen ; while ( dataIn . readByte ( ) ! = '\n' ) { } } msg . setHeader ( " Content-Length " , new Integer ( length ) . toString ( ) ) ; } else { HTTPUtil . sendHTTPResponse ( s . getOutputStream ( ) , HttpURLConnection . HTTP_LENGTH_REQUIRED , false ) ; throw new IOException ( " Transfer-Encoding unimplemented:  " + transfer_encoding ) ; } } else if ( msg . getHeader ( " Content-Length " ) = = null ) { HTTPUtil . sendHTTPResponse ( s . getOutputStream ( ) , HttpURLConnection . HTTP_LENGTH_REQUIRED , false ) ; throw new IOException ( " Content-Length missing " ) ; } } else { final int contentSize = Integer . parseInt ( msg . getHeader ( " Content-Length " ) ) ; data = new byte [ contentSize ] ; dataIn . readFully ( data ) ; } return data ; }
public void configure ( ) { Map < String , Object > configMap = new HashMap < > ( ) ; configMap . put ( ProtobufTranslator . CONFIG_DESCRIPTOR_FILEPATH , TestProtobufTranslator . class . getResource ( SINGLE_EXAMPLE ) . getPath ( ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; ProtobufTranslator translator = new ProtobufTranslator ( ) ; translator . configure ( config ) ; }
private static < T extends Comparable < T > > int add ( int length , T element , T [ ] unsorted ) { int i = length ; unsorted [ length + + ] = element ; T e = unsorted [ i ] ; int parentIndex = ( ( i - 1 ) / 2 ) ; T parent = unsorted [ parentIndex ] ; while ( e . compareTo ( parent ) > 0 ) { swap ( parentIndex , i , unsorted ) ; i = parentIndex ; e = unsorted [ i ] ; parentIndex = ( ( i - 1 ) / 2 ) ; parent = unsorted [ parentIndex ] ; } return length ; }
public boolean onPreferenceClick ( Preference pref ) { CheckBoxPreference prefCB = ( CheckBoxPreference ) pref ; MPD oMPD = app . oMPDAsyncHelper . oMPD ; try { if ( prefCB . getKey ( ) . equals ( " random " ) ) oMPD . setRandom ( prefCB . isChecked ( ) ) ; if ( prefCB . getKey ( ) . equals ( " repeat " ) ) oMPD . setRepeat ( prefCB . isChecked ( ) ) ; return prefCB . isChecked ( ) ; } catch ( MPDServerException e ) { e . printStackTrace ( ) ; } return false ; }
public void testInterval ( ) { AtomicDuration dur5 = new AtomicDuration ( 5 ) ; assertTrue ( dur5 . getSubDurationLog ( ) = = Math . log ( 5 ) ) ; assertTrue ( dur5 . get ( ) = = 5 ) ; Interval i1 = Interval . intervalTime ( 1 , dur5 ) ; assertTrue ( i1 . magnitude = = 0 ) ; assertTrue ( i1 . name ( ) . toString ( ) . equals ( " +1 " ) ) ; assertTrue ( i1 . getTime ( dur5 ) = = 1 ) ; Interval i2 = Interval . intervalTime ( 2 , dur5 ) ; assertTrue ( i2 . magnitude = = 0 ) ; assertTrue ( i2 . name ( ) . toString ( ) . equals ( " +1 " ) ) ; assertEquals ( i2 . getTime ( dur5 ) , 1 ) ; Interval i5 = Interval . intervalTime ( 5 , dur5 ) ; assertTrue ( i5 . magnitude = = 1 ) ; assertTrue ( i5 . name ( ) . toString ( ) . equals ( " +2 " ) ) ; assertTrue ( i5 . getTime ( dur5 ) = = 5 ) ;
public void testUnpackedLong ( ) { assertEquals ( " [0, 0, 0, 0, 0, 0, 0, 1] " , Arrays . toString ( new TranscoderUtils ( false ) . encodeLong ( 1 ) ) ) ;
public static void main ( String [ ] args ) { List < String > tmpArgs = new ArrayList < String > ( Arrays . asList ( args ) ) ; parseArguments ( tmpArgs ) ; args = tmpArgs . toArray ( new String [ 0 ] ) ; StringBuilder cliString = new StringBuilder ( ) ; for ( int i = 0 ; i < args . length ; i + + ) { cliString . append ( "   " ) . append ( args [ i ] ) ; } logger . debug ( " Command line string = {} " , cliString . toString ( ) ) ; System . out . println ( " Command line string =  " + cliString . toString ( ) ) ; Task task = null ; try { task = ( Task ) ClassOption . cliStringToObject ( cliString . toString ( ) , Task . class , null ) ; logger . info ( " Sucessfully instantiating {} " , task . getClass ( ) . getCanonicalName ( ) ) ; } catch ( Exception e ) { logger . error ( " Fail to initialize the task " , e ) ; System . out . println ( " Fail to initialize the task " + e ) ; return ; } task . setFactory ( new SamzaComponentFactory ( ) ) ; task . init ( ) ; String hdfsPath = null ; if ( ! isLocal ) { Path path = FileSystems . getDefault ( ) . getPath ( jarPackagePath ) ; hdfsPath = uploadJarToHDFS ( path . toFile ( ) ) ; if ( hdfsPath = = null ) { System . out . println ( " Fail uploading JAR file  \" " + path . toAbsolutePath ( ) . toString ( ) + " \"  to HDFS. " ) ; return ; } } SamzaEngine . getEngine ( ) . setLocalMode ( isLocal ) . setZooKeeper ( zookeeper ) . setKafka ( kafka ) . setKafkaBatchSize ( kafkaBatchSize ) . setYarnPackage ( hdfsPath ) . setKafkaProducerType ( kafkaProducerType ) . setConfigHome ( yarnConfHome ) . setAMMemory ( amMem ) . setContainerMemory ( containerMem ) . setPiPerContainerRatio ( piPerContainer ) . setKryoRegisterFile ( kryoRegisterFile ) ; SamzaEngine . submitTopology ( ( SamzaTopology ) task . getTopology ( ) ) ;
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenu . ContextMenuInfo menuInfo ) { AdapterContextMenuInfo info = ( AdapterContextMenuInfo ) menuInfo ; menu . setHeaderTitle ( items . get ( ( int ) info . id ) . toString ( ) ) ; android . view . MenuItem addItem = menu . add ( ContextMenu . NONE , ADD , 0 , getResources ( ) . getString ( irAdd ) ) ; addItem . setOnMenuItemClickListener ( this ) ; android . view . MenuItem addAndReplaceItem = menu . add ( ContextMenu . NONE , ADDNREPLACE , 0 , R . string . addAndReplace ) ; addAndReplaceItem . setOnMenuItemClickListener ( this ) ; android . view . MenuItem addAndPlayItem = menu . add ( ContextMenu . NONE , ADDNPLAY , 0 , R . string . addAndPlay ) ; addAndPlayItem . setOnMenuItemClickListener ( this ) ; if ( R . string . addPlaylist ! = irAdd ) { int id = ADD_TO_PLAYLIST ;
public void testMultipleKeyFieldNames ( ) throws Exception { StructType ordersSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " order_id " , DataTypes . IntegerType , true ) , DataTypes . createStructField ( " product_name " , DataTypes . StringType , true ) , DataTypes . createStructField ( " customer_first " , DataTypes . StringType , true ) , DataTypes . createStructField ( " customer_last " , DataTypes . StringType , true ) ) ) ; StructType customersSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " customer_first " , DataTypes . StringType , true ) , DataTypes . createStructField ( " customer_last " , DataTypes . StringType , true ) , DataTypes . createStructField ( " state " , DataTypes . StringType , true ) ) ) ; List < Row > orderRows = Lists . newArrayList ( ) ; orderRows . add ( RowFactory . create ( 1000 , " Envelopes " , " Jane " , " Smith " ) ) ; orderRows . add ( RowFactory . create ( 1001 , " Stamps " , " Jane " , " Smith " ) ) ; orderRows . add ( RowFactory . create ( 1002 , " Pens " , " Jane " , " Smith " ) ) ; orderRows . add ( RowFactory . create ( 1003 , " Paper " , " Jane " , " Bloggs " ) ) ; List < Row > customerRows = Lists . newArrayList ( ) ; customerRows . add ( RowFactory . create ( " Jane " , " Smith " , " NY " ) ) ; customerRows . add ( RowFactory . create ( " Jane " , " Bloggs " , " CA " ) ) ; Dataset < Row > orders = Contexts . getSparkSession ( ) . createDataFrame ( orderRows , ordersSchema ) ; Dataset < Row > customers = Contexts . getSparkSession ( ) . createDataFrame ( customerRows , customersSchema ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " orders " , orders ) ; dependencies . put ( " customers " , customers ) ; Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( NestDeriver . NEST_FROM_CONFIG_NAME , " orders " ) ; configMap . put ( NestDeriver . NEST_INTO_CONFIG_NAME , " customers " ) ; configMap . put ( NestDeriver . KEY_FIELD_NAMES_CONFIG_NAME , Lists . newArrayList ( " customer_first " , " customer_last " ) ) ; configMap . put ( NestDeriver . NESTED_FIELD_NAME_CONFIG_NAME , " orders " ) ; Config config = ConfigFactory . parseMap ( configMap ) ; NestDeriver deriver = new NestDeriver ( ) ; assertNoValidationFailures ( deriver , config ) ; deriver . configure ( config ) ; Dataset < Row > nested = deriver . derive ( dependencies ) ; assertEquals ( nested . count ( ) , 2 ) ; List < Row > smith = nested . where ( " customer_first = 'Jane' AND customer_last = 'Smith' " ) . collectAsList ( ) ; assertEquals ( smith . size ( ) , 1 ) ; Row smithRow = smith . get ( 0 ) ; assertEquals ( smithRow . getList ( smithRow . fieldIndex ( " orders " ) ) . size ( ) , 3 ) ; List < Row > bloggs = nested . where ( " customer_first = 'Jane' AND customer_last = 'Bloggs' " ) . collectAsList ( ) ; assertEquals ( bloggs . size ( ) , 1 ) ; Row bloggsRow = bloggs . get ( 0 ) ; assertEquals ( bloggsRow . getList ( bloggsRow . fieldIndex ( " orders " ) ) . size ( ) , 1 ) ; }
private double normalizeActualClassValue ( Instance inst ) { double meanY = perceptronsumY / perceptronYSeen ; double sdY = computeSD ( squaredperceptronsumY , perceptronsumY , perceptronYSeen ) ; double normalizedY ; if ( sdY > SD_THRESHOLD ) { normalizedY = ( inst . classValue ( ) - meanY ) / sdY ; } else { normalizedY = inst . classValue ( ) - meanY ; } return normalizedY ; }
public void draw ( ) { if ( ! visible ) return ; updateBuffer ( ) ; winApp . pushStyle ( ) ; winApp . pushMatrix ( ) ; applyTransform ( ) ; winApp . pushMatrix ( ) ; winApp . translate ( - halfWidth , - halfHeight ) ; winApp . imageMode ( PApplet . CORNER ) ; if ( alphaLevel < 255 ) winApp . tint ( TINT_FOR_ALPHA , alphaLevel ) ; winApp . image ( buffer , 0 , 0 ) ; if ( focusIsWith = = this & & showCaret & & endTLHI ! = null ) { float [ ] cinfo = endTLHI . tli . layout . getCaretInfo ( endTLHI . thi ) ; float x_left = - ptx + cinfo [ 0 ] ; float y_top = - pty + endTLHI . tli . yPosInPara ; float y_bot = y_top - cinfo [ 3 ] + cinfo [ 5 ] ; if ( x_left > = 0 & & x_left < = tw & & y_top > = 0 & & y_bot < = th ) { winApp . strokeWeight ( 1.5f ) ; winApp . stroke ( palette [ 12 ] ) ; winApp . line ( tx + x_left , ty + Math . max ( 0 , y_top ) , tx + x_left , ty + Math . min ( th , y_bot ) ) ; } } winApp . popMatrix ( ) ; if ( children ! = null ) { for ( GAbstractControl c : children ) c . draw ( ) ; } winApp . popMatrix ( ) ; winApp . popStyle ( ) ; }
public void mouseExited ( MouseEvent e ) { xTile = - 1 ; yTile = - 1 ; repaint ( ) ; }
private void testIntervalSegmentTree ( java . util . List < SegmentTree . Data . IntervalData < String > > segments ) { DynamicSegmentTree < SegmentTree . Data . IntervalData < String > > tree = new DynamicSegmentTree < SegmentTree . Data . IntervalData < String > > ( segments ) ; SegmentTree . Data . IntervalData < String > query = tree . query ( 2 ) ; assertTrue ( " Segment tree query error. query=2 result= " + query , tree , collectionsEqual ( query . getData ( ) , Arrays . asList ( RED ) ) ) ; query = tree . query ( 4 ) ; assertTrue ( " Segment tree query error. query=4 result= " + query , tree , collectionsEqual ( query . getData ( ) , Arrays . asList ( RED , ORANGE , GREEN ) ) ) ; query = tree . query ( 9 ) ; assertTrue ( " Segment tree query error. query=9 result= " + query , tree , collectionsEqual ( query . getData ( ) , Arrays . asList ( GREEN , DARK_GREEN , BLUE , PURPLE ) ) ) ; query = tree . query ( 1 , 16 ) ; assertTrue ( " Segment tree query error. query=1->16 result= " + query , tree , collectionsEqual ( query . getData ( ) , Arrays . asList ( RED , ORANGE , GREEN , DARK_GREEN , BLUE , PURPLE , BLACK ) ) ) ; query = tree . query ( 7 , 14 ) ; assertTrue ( " Segment tree query error. query=7->14 result= " + query , tree , collectionsEqual ( query . getData ( ) , Arrays . asList ( GREEN , DARK_GREEN , BLUE , PURPLE , BLACK ) ) ) ; query = tree . query ( 14 , 15 ) ; assertTrue ( " Segment tree query error. query=14->15 result= " + query , tree , collectionsEqual ( query . getData ( ) , Arrays . asList ( PURPLE , BLACK ) ) ) ; }
public Object visit ( URICur p , LoanParser arg ) { String pre = ( String ) p . nsprefix_ . accept ( this , arg ) ; URI u = arg . getNamespaces ( ) . get ( pre ) ; return u . resolve ( p . ident_ ) ; }
public boolean containsKey ( final Object key ) { return getEntry ( key ) ! = null ; }
@Override public String toString ( ) { return " type " ; } }
static FileConfigBuilder < Config > builder ( File file ) { return builder ( file . toPath ( ) ) ; }
public void onServletInit ( @Nonnull final ICommonsMap < String , String > aInitParams ) throws ServletException { try { m_aSession = createAS2Session ( aInitParams ) ; m_aReceiver = m_aSession . getMessageProcessor ( ) . getModuleOfClass ( AS2ServletReceiverModule . class ) ; if ( m_aReceiver = = null ) throw new ServletException ( " Failed to retrieve AS2ReceiverModule which is a mandatory module! Please ensure your configuration file contains at least the module ' " + AS2ServletReceiverModule . class . getName ( ) + " ' " ) ; } catch ( final OpenAS2Exception ex ) { throw new ServletException ( " Failed to init AS2 configuration " , ex ) ; } s_aLogger . info ( " Successfully initialized AS2 configuration " ) ; }
public void playlistChanged ( final MPDStatus mpdStatus , final int oldPlaylistVersion ) { if ( mCurrentSong ! = null & & mCurrentSong . isStream ( ) | | mpdStatus . isState ( MPDStatus . STATE_STOPPED ) ) {
public boolean onPreDraw ( ) { if ( coverHelper ! = null ) coverHelper . setCachedCoverMaxSize ( coverArt . getMeasuredHeight ( ) ) ; return true ; }
public static String subst ( String result , String match , String subst ) { Pattern p = Pattern . compile ( match ) ; Matcher m = p . matcher ( result ) ; if ( m . find ( ) ) { result = m . replaceFirst ( subst ) ; } return result ; }
public static Deriver create ( Config config ) throws Exception { if ( ! config . hasPath ( TYPE_CONFIG_NAME ) ) { throw new RuntimeException ( " Deriver type not specified " ) ; } String deriverType = config . getString ( TYPE_CONFIG_NAME ) ; Deriver deriver ; switch ( deriverType ) { case " sql " : deriver = new SQLDeriver ( ) ; break ; case " passthrough " : deriver = new PassthroughDeriver ( ) ; break ; case " nest " : deriver = new NestDeriver ( ) ; break ; default : Class < ? > clazz = Class . forName ( deriverType ) ; Constructor < ? > constructor = clazz . getConstructor ( ) ; deriver = ( Deriver ) constructor . newInstance ( ) ; } deriver . configure ( config ) ; return deriver ; }
private static final void showComparison ( ) { System . out . println ( " Algorithm \ t \ t \ tRandom \ tSorted \ tReverse Sorted " ) ; if ( showInsertion ) { int i = 0 ; System . out . println ( " Insertion sort \ t \ t \ t " + insertionResults [ i + + ] + " \ t " + insertionResults [ i + + ] + " \ t " + insertionResults [ i + + ] ) ; } if ( showBubble ) { int i = 0 ; System . out . println ( " Bubble sort \ t \ t \ t " + bubbleResults [ i + + ] + " \ t " + bubbleResults [ i + + ] + " \ t " + bubbleResults [ i + + ] ) ; } if ( showShell ) { int i = 0 ; System . out . println ( " Shell sort \ t \ t \ t " + shellResults [ i + + ] + " \ t " + shellResults [ i + + ] + " \ t " + shellResults [ i + + ] ) ; } if ( showMerge ) { int i = 0 ; System . out . println ( " Merge sort \ t \ t \ t " + mergeResults [ i + + ] + " \ t " + mergeResults [ i + + ] + " \ t " + mergeResults [ i + + ] ) ; } if ( showQuick ) { int i = 0 ; System . out . println ( " Quicksort with first as pivot \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] ) ; System . out . println ( " Quicksort with middle as pivot \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] ) ; System . out . println ( " Quicksort with random as pivot \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] ) ; } if ( showHeap ) { int i = 0 ; System . out . println ( " Heap sort \ t \ t \ t " + heapResults [ i + + ] + " \ t " + heapResults [ i + + ] + " \ t " + heapResults [ i + + ] ) ; } if ( showCounting ) { int i = 0 ; System . out . println ( " Counting sort \ t \ t \ t " + countingResults [ i + + ] + " \ t " + countingResults [ i + + ] + " \ t " + countingResults [ i + + ] ) ; } if ( showRadix ) { int i = 0 ; System . out . println ( " Radix sort \ t \ t \ t " + radixResults [ i + + ] + " \ t " + radixResults [ i + + ] + " \ t " + radixResults [ i + + ] ) ; } if ( showAmericanFlag ) { int i = 0 ;
public void init ( ) throws IOReactorException { Thread t = new Thread ( new Runnable ( ) { public void run ( ) { try { connMgr . execute ( ) ; } catch ( InterruptedIOException ex ) { getLogger ( ) . error ( " I/O reactor Interrupted " ) ; } catch ( IOException e ) { getLogger ( ) . error ( " I/O error:  " + e . getMessage ( ) ) ; e . printStackTrace ( ) ; } getLogger ( ) . info ( " Couchbase I/O reactor terminated " ) ; } } ) ; t . start ( ) ; }
protected CoderResult implFlush ( ByteBuffer out ) { return encoder . flush ( out ) ; }
private double cloudDistance ( PointCloud reference , double start ) { ArrayList < PointCloudPoint > pts1 = _points ; ArrayList < PointCloudPoint > pts2 = reference . _points ; if ( pts1 . size ( ) ! = pts2 . size ( ) ) { throw new IllegalArgumentException ( " Both point clouds must contain the same number of points " ) ; } double pointCount = ( double ) pts1 . size ( ) ; boolean matched [ ] = new boolean [ ( int ) pointCount ] ; for ( int k = 0 ; k < pointCount ; k + + ) { matched [ k ] = false ; } double sum = 0 ; double i = start ; do { int index = - 1 ; double min = Double . POSITIVE_INFINITY ; for ( int j = 0 ; j < matched . length ; j + + ) { if ( ! matched [ j ] ) { double d = PointCloudUtils . distance ( pts1 . get ( ( int ) i ) , pts2 . get ( j ) ) ; if ( d < min ) { min = d ; index = j ; } } } matched [ index ] = true ; double weight = 1.0 - ( ( i - start + pointCount ) % pointCount ) / pointCount ; sum + = weight * min ; i = ( i + 1.0 ) % pointCount ; } while ( i ! = start ) ; return sum ; }
static void writeTableName ( List < String > name , CharacterOutput output , TomlWriter writer ) { writeTableName ( name , output , writer , TABLE_NAME_BEGIN , TABLE_NAME_END ) ; }
public static Term make ( final ArrayList < Term > argument , final short index , final Memory memory ) { String name = makeImageName ( Operator . IMAGE_INT , argument , index ) ; Term t = memory . nameToTerm ( name ) ; return ( t ! = null ) ? t : new ImageInt ( name , argument , index ) ; }
< T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
protected void testNAL ( final String path ) { @Deprecated int minCycles = 50 ; NAR . resetStatics ( ) ; final NAR n = newNAR ( ) ; final List < String > expressions = new ArrayList ( 2 ) ; out . clear ( ) ; new TextOutput ( n ) { @Override public void output ( Class channel , Object signal ) { if ( channel = = Output . ERR . class ) { if ( signal instanceof Exception ) { ( ( Throwable ) signal ) . printStackTrace ( ) ; ; } assertTrue ( path + "  ERR:  " + signal , false ) ; } if ( channel = = Output . ECHO . class ) { String e = signal . toString ( ) ; if ( e . startsWith ( " \" \ ' " ) ) { String expression = e . substring ( 2 , e . length ( ) - 1 ) ; expressions . add ( expression ) ; } } else if ( channel = = OUT . class ) { String s = getOutputString ( channel , signal , true , true , n ) ; out . add ( s ) ; } } } ; n . addInput ( getExample ( path ) ) ; n . finish ( minCycles ) ; js . put ( " test " , this ) ; js . put ( " out " , out ) ; try { js . eval ( " function outputMustContain(x) { return test.outputContains(x); }; " ) ; } catch ( ScriptException ex ) { System . err . println ( ex . toString ( ) ) ; } if ( expressions . isEmpty ( ) ) { assertTrue ( path + "  contains no expressions to evaluate " , false ) ; } for ( String e : expressions ) { try { Object result = js . eval ( e ) ; if ( result instanceof Boolean ) { boolean r = ( Boolean ) result ; if ( ! r ) { String failMsg = path + " :  " + e + "  FAIL @  " + + n . getTime ( ) + " , output lines= " + out . size ( ) ; System . out . println ( failMsg ) ; printOutputSummary ( ) ; System . out . println ( ) ; assertTrue ( failMsg , r ) ; } } } catch ( Exception x ) { assertTrue ( path + " :  " + x . toString ( ) + " :  " , false ) ; } } if ( testPerformance ) { perfNAL ( path , 0 , performanceIterations , 1 ) ;
private void _sendViaHTTP ( @Nonnull final AS2Message aMsg , @Nonnull final DispositionType aDisposition ) throws OpenAS2Exception , IOException , MessagingException , HttpResponseException { final IMessageMDN aMdn = aMsg . getMDN ( ) ; final String sUrl = aMsg . getAsyncMDNurl ( ) ; final boolean bOutput = true ; final boolean bInput = true ; final boolean bUseCaches = false ; final EHttpMethod eRequestMethod = EHttpMethod . POST ; final HttpURLConnection aConn = getConnection ( sUrl , bOutput , bInput , bUseCaches , eRequestMethod , getSession ( ) . getHttpProxy ( ) ) ; try ( final IHTTPOutgoingDumper aOutgoingDumper = HTTPHelper . getHTTPOutgoingDumper ( aMsg ) ) {
protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { if ( mFixedSide = = FIXED_HEIGHT_INT ) { super . onMeasure ( heightMeasureSpec , heightMeasureSpec ) ;
long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public void testApplyPlannedMutations ( ) throws Exception { Table table = connection . getTable ( TableName . valueOf ( TABLE ) ) ; Config config = ConfigUtils . configFromResource ( " /hbase/hbase-output-test.conf " ) . getConfig ( " output " ) ; config = config . withValue ( " zookeeper " , ConfigValueFactory . fromAnyRef ( " localhost: " + utility . getZkCluster ( ) . getClientPort ( ) ) ) ; HBaseOutput output = new HBaseOutput ( ) ; output . configure ( config ) ; List < PlannedRow > records = createPlannedMutations ( ) ; scanAndCountTable ( table , 0 ) ; output . applyRandomMutations ( records ) ; HBaseSerde serde = HBaseUtils . getSerde ( config ) ; scanAndCountTable ( table , INPUT_ROWS * 4 ) ; List < Result > results = scanAndReturnTable ( table ) ; for ( Result result : results ) { Row row = serde . convertFromResult ( result ) ; assertEquals ( 6 , row . schema ( ) . length ( ) ) ; for ( int i = 0 ; i < 6 ; i + + ) { assertNotNull ( row . get ( i ) ) ; } } for ( PlannedRow record : records ) { record . setMutationType ( MutationType . DELETE ) ; } output . applyRandomMutations ( records ) ; scanAndCountTable ( table , 0 ) ; }
public void getByFullKey ( ) throws Exception { truncate ( ) ; RandomOutput zkOutput = new ZooKeeperOutput ( ) ; zkOutput . configure ( config ) ; Row row1 = new RowWithSchema ( schema , " hello " , 100 , 1000L , true , 1.0f , - 1.0 ) ; Row row2 = new RowWithSchema ( schema , " world " , - 100 , - 1000L , false , - 1.0f , 1.0 ) ; List < PlannedRow > upsertPlan = Lists . newArrayList ( new PlannedRow ( row1 , MutationType . UPSERT ) , new PlannedRow ( row2 , MutationType . UPSERT ) ) ; zkOutput . applyRandomMutations ( upsertPlan ) ; Row filter = new RowWithSchema ( keySchema , " hello " , 100 , 1000L ) ; List < Row > filters = Lists . newArrayList ( filter ) ; List < Row > rows = Lists . newArrayList ( zkOutput . getExistingForFilters ( filters ) ) ; assertEquals ( rows . size ( ) , 1 ) ; assertEquals ( rows . get ( 0 ) , row1 ) ; }
private int peek ( ) throws IOException { reader . mark ( 1 ) ; int result = reader . read ( ) ; reader . reset ( ) ; return result ; }
Rule ShortFloat ( ) { return Number ( ) ; }
protected void onCreate ( Bundle arg0 ) { super . onCreate ( arg0 ) ; setContentView ( R . layout . albums_activity ) ; }
public Builder splitConfidence ( double splitConfidence ) { this . splitConfidence = splitConfidence ; return this ; }
public void testQuerySetRangeEnd ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; ViewFuture future = client . asyncQuery ( view , query . setRangeEnd ( " end " ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }
public void updatePartnership ( final IMessageMDN aMdn , final boolean bOverwrite ) throws OpenAS2Exception { final Partnership aPartnership = getPartnership ( aMdn . partnership ( ) ) ; aMdn . partnership ( ) . copyFrom ( aPartnership ) ; }
public DeleteOperation delete ( String key , long cas , DeleteOperation . Callback operationCallback ) { return new DeleteOperationImpl ( key , cas , operationCallback ) ; }
protected void paintHighlight ( Graphics gfx , int line , int y ) { if ( line > = textArea . getSelectionStartLine ( ) & & line < = textArea . getSelectionEndLine ( ) ) paintLineHighlight ( gfx , line , y ) ; if ( highlights ! = null ) highlights . paintHighlight ( gfx , line , y ) ; if ( bracketHighlight & & line = = textArea . getBracketLine ( ) ) paintBracketHighlight ( gfx , line , y ) ; if ( line = = textArea . getCaretLine ( ) ) paintCaret ( gfx , line , y ) ;
public void read1 ( ) throws Exception { } @Test public void readTwoChunkBuffer ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " 2 \ r \ n12 \ r \ n1 \ na \ r \ n0 \ r \ n " . getBytes ( ) ) ; byte [ ] buf = new byte [ 3 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( buf , 0 , buf . length ) ; assertEquals ( " Read two chunk: 3 chars read " , 3 , ret ) ; assertEquals ( " Read one Chunk: corect data returned " , " 12a " , new String ( buf ) ) ; } @Test public void readTwoChunkBufferMultipleReads ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " 2 \ r \ n12 \ r \ n1 \ na \ r \ n0 \ r \ n " . getBytes ( ) ) ; byte [ ] buf = new byte [ 3 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( buf , 0 , 1 ) ; assertEquals ( " Read two chunk-1: 1 chars read " , 1 , ret ) ; assertEquals ( " Read one Chunk-1: correct data returned " , '1' , buf [ 0 ] ) ; ret = cIS . read ( buf , 0 , 1 ) ; assertEquals ( " Read two chunk-1: 1 chars read " , 1 , ret ) ; assertEquals ( " Read one Chunk-1: correct data returned " , '2' , buf [ 0 ] ) ; ret = cIS . read ( buf , 0 , 1 ) ; assertEquals ( " Read two chunk-1: 1 chars read " , 1 , ret ) ; assertEquals ( " Read one Chunk-1: correct data returned " , 'a' , buf [ 0 ] ) ; } @Test public void readTwoChunkByteMultipleReads ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " 2 \ r \ n12 \ r \ n1 \ na \ r \ n0 \ r \ n " . getBytes ( ) ) ; byte [ ] buf = new byte [ 3 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( ) ; assertEquals ( " Read one Chunk-1: correct data returned " , '1' , ret ) ; ret = cIS . read ( ) ; assertEquals ( " Read one Chunk-1: correct data returned " , '2' , ret ) ; ret = cIS . read ( ) ; assertEquals ( " Read one Chunk-1: correct data returned " , 'a' , ret ) ; } }
public int lastIndexOf ( final Object object ) { Integer lastIndexOf = null ; synchronized ( mLOCK ) { cleanPhantomReferences ( ) ; int index = mSize - 1 ; for ( final ListIterator < T > itr = listIterator ( mSize ) ; itr . hasPrevious ( ) ; ) { final Object value = itr . previous ( ) ; if ( object = = value | | ( object ! = null & & object . equals ( value ) ) ) { lastIndexOf = Integer . valueOf ( index ) ; break ; } index - - ; } if ( lastIndexOf = = null ) { lastIndexOf = Integer . valueOf ( - 1 ) ; } } return lastIndexOf . intValue ( ) ; }
private static void runBatch ( Set < Step > steps ) throws Exception { LOG . debug ( " Started batch for steps: {} " , StepUtils . stepNamesAsString ( steps ) ) ; Set < Future < Void > > offMainThreadSteps = Sets . newHashSet ( ) ; Set < Step > refactoredSteps = null ; while ( ! StepUtils . allStepsSubmitted ( steps ) ) { LOG . debug ( " Not all steps have been submitted " ) ; for ( final Step step : steps ) { LOG . debug ( " Looking into step:  " + step . getName ( ) ) ; if ( step instanceof BatchStep ) { LOG . debug ( " Step is batch " ) ; BatchStep batchStep = ( BatchStep ) step ; if ( ! batchStep . hasSubmitted ( ) ) { LOG . debug ( " Step has not been submitted " ) ; final Set < Step > dependencies = StepUtils . getDependencies ( step , steps ) ; if ( StepUtils . allStepsSubmitted ( dependencies ) ) { LOG . debug ( " Step dependencies have been submitted, running step off main thread " ) ; Future < Void > offMainThreadStep = runStepOffMainThread ( batchStep , dependencies , threadPool ) ; offMainThreadSteps . add ( offMainThreadStep ) ; } else { LOG . debug ( " Step dependencies have not been submitted " ) ; } } else { LOG . debug ( " Step has been submitted " ) ; } } else if ( step instanceof StreamingStep ) { LOG . debug ( " Step is streaming " ) ; } else if ( step instanceof RefactorStep ) { LOG . debug ( " Step is a refactor step " ) ; RefactorStep refactorStep = ( RefactorStep ) step ; if ( ! refactorStep . hasSubmitted ( ) ) { LOG . debug ( " Step has not been submitted " ) ; final Set < Step > dependencies = StepUtils . getDependencies ( step , steps ) ; if ( StepUtils . allStepsSubmitted ( dependencies ) ) { LOG . debug ( " Step dependencies have submitted, refactoring steps " ) ; refactoredSteps = refactorStep . refactor ( steps ) ; LOG . debug ( " Steps refactored " ) ; break ; } else { LOG . debug ( " Step dependencies have not been submitted " ) ; } } else { LOG . debug ( " Step has been submitted " ) ; } } else { throw new RuntimeException ( " Unknown step class type:  " + step . getClass ( ) . getName ( ) ) ; } LOG . debug ( " Finished looking into step:  " + step . getName ( ) ) ; } awaitAllOffMainThreadsFinished ( offMainThreadSteps ) ; offMainThreadSteps . clear ( ) ; if ( refactoredSteps ! = null ) { steps = refactoredSteps ; refactoredSteps = null ; } } LOG . debug ( " Finished batch for steps: {} " , StepUtils . stepNamesAsString ( steps ) ) ; }
public Object clone ( ) { return new DifferenceInt ( name , ( ArrayList < Term > ) cloneList ( components ) , isConstant ( ) , complexity ) ; }
public Iterator < Character > reverseIterator ( final int start ) { if ( start < 0 | | start > this . length ( ) ) throw new IndexOutOfBoundsException ( " Rope index out of range:  " + start ) ; if ( start > = this . right . length ( ) ) { return this . left . reverseIterator ( start - this . right . length ( ) ) ;
default public double mean ( ) { long h = hits ( ) ; if ( h = = 0 ) return 0 ; return ( sum ( ) / h ) ; }
void restore ( DataSet dataSet ) ; void track ( Sensor tracker , long now ) ; void update ( Sensor tracker , long now ) ; void clear ( ) ; }
public void onDestroy ( ) { SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( getActivity ( ) ) ; settings . unregisterOnSharedPreferenceChangeListener ( this ) ; myLogger . log ( Level . INFO , " onDestroy " ) ; super . onDestroy ( ) ; }
public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; registerForContextMenu ( list ) ; UpdateList ( ) ; getActivity ( ) . setTitle ( R . string . streams ) ; }
public boolean isSameEntry ( DNSEntry entry ) { return super . isSameEntry ( entry ) & & ( entry instanceof Pointer ) & & this . sameValue ( ( Pointer ) entry ) ;
public void mapColumnIdFromCursor ( Cursor cursor ) { columnIds = new HashMap < String , Integer > ( ) ; columnIds . put ( COL_ID , - 1 ) ; columnIds . put ( COL_NAME , - 1 ) ; columnIds . put ( COL_HOSTNAME , - 1 ) ; columnIds . put ( COL_PORT , - 1 ) ; columnIds . put ( COL_PASSWORD , - 1 ) ; columnIds . put ( COL_STREAMING_HOSTNAME , - 1 ) ; columnIds . put ( COL_STREAMING_PORT , - 1 ) ; columnIds . put ( COL_STREAMING_SUFFIX , - 1 ) ; columnIds . put ( COL_MUSIC_PATH , - 1 ) ; columnIds . put ( COL_COVER_FILENAME , - 1 ) ; columnIds . put ( COL_USE_DATABASE_CACHE , - 1 ) ; fillColumnMap ( cursor , columnIds ) ; }
public void missingAvroLiteral ( ) throws Exception { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( FileSystemInput . FORMAT_CONFIG , " csv " ) ; paramMap . put ( FileSystemInput . PATH_CONFIG , FileSystemInput . class . getResource ( CSV_DATA ) . getPath ( ) ) ; paramMap . put ( FileSystemInput . AVRO_LITERAL_CONFIG , " " ) ; config = ConfigFactory . parseMap ( paramMap ) ; FileSystemInput fileSystemInput = new FileSystemInput ( ) ; fileSystemInput . configure ( config ) ; }
protected CharSequence makeName ( ) { return id ; }
public void onConceptNew ( Concept concept ) { append ( " Concept Created:  " + concept ) ; }
public int getAlbumCount ( final String artist , final boolean useAlbumArtistTag ) throws IOException , MPDException { return listAlbums ( artist , useAlbumArtistTag ) . size ( ) ; }
public boolean isOmitIntermediateLevels ( ) { return hideRedundantLevels ; }
public void deletePlaylist ( String name ) throws MPDServerException { mpdConnection . sendCommand ( " rm " , new String [ ] { name } ) ; }
Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
public Cause newImplicationEdge ( final Term source , final Term target , Item i , final Sentence parent ) { if ( source . equals ( target ) ) return null ; Cause c = new Cause ( source , target , parent ) ; try { addEdge ( source , target , c ) ; addComponents ( parent , c ) ; } catch ( IllegalArgumentException wc ) { return null ; } return c ; }
Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public String toString ( ) { return " value= " + value + "  above= " + ( ( above ! = null ) ? above . value : " NULL " ) + "  below= " + ( ( below ! = null ) ? below . value : " NULL " ) ; }
public static String stepNamesAsString ( Set < ? extends Step > steps ) { StringBuilder sb = new StringBuilder ( ) ; for ( Step step : steps ) { sb . append ( step . getName ( ) ) ; sb . append ( " ,  " ) ; } if ( sb . length ( ) > 0 ) { sb . setLength ( sb . length ( ) - " ,  " . length ( ) ) ; } return sb . toString ( ) ; }
static String annotToString ( Annotation annotation ) { return annotation . toString ( ) . replace ( " @com.electronwill.nightconfig.core.serde.annotations. " , " @ " ) ; }
public void initDynamicComponent ( @Nonnull final IAS2Session session , @Nullable final IStringMap parameters ) throws AS2Exception { } @Nonnull public BufferedReader getReader ( ) { return m_aReader ; } @Nonnull public BufferedWriter getWriter ( ) { return m_aWriter ; } @Override public void run ( ) { try { while ( true ) processCommand ( ) ; } catch ( final AS2Exception ex ) { LOGGER . error ( " Error running command processor  " + CAS2Info . NAME_VERSION , ex ) ; } } @Override public void processCommand ( ) throws AS2Exception { try { final String sLine = readLine ( ) ; if ( sLine ! = null ) { final CommandTokenizer aTokenizer = new CommandTokenizer ( sLine ) ; if ( aTokenizer . hasMoreTokens ( ) ) { final String sCommandName = aTokenizer . nextToken ( ) . toLowerCase ( Locale . US ) ; if ( sCommandName . equals ( EXIT_COMMAND ) ) { terminate ( ) ; } else { final ICommonsList < String > aParams = new CommonsArrayList < > ( ) ; while ( aTokenizer . hasMoreTokens ( ) ) { aParams . add ( aTokenizer . nextToken ( ) ) ; } final ICommand aCommand = getCommand ( sCommandName ) ; if ( aCommand ! = null ) { final CommandResult aResult = aCommand . execute ( aParams . toArray ( ) ) ; if ( aResult . getType ( ) . isSuccess ( ) ) { writeLine ( aResult . toString ( ) ) ; } else { writeLine ( COMMAND_ERROR ) ; writeLine ( aResult . getResultAsString ( ) ) ; } } else { writeLine ( COMMAND_NOT_FOUND + " >  " + sCommandName ) ; writeLine ( " List of commands: " ) ; writeLine ( EXIT_COMMAND ) ; for ( final String sCurCmd : getAllCommands ( ) . keySet ( ) ) writeLine ( sCurCmd ) ; } } } write ( PROMPT ) ; } else { ThreadHelper . sleep ( 100 ) ; } } catch ( final IOException ex ) { throw WrappedAS2Exception . wrap ( ex ) ; } } @Nullable public String readLine ( ) throws IOException { final BufferedReader aReader = getReader ( ) ; return StringHelper . trim ( aReader . readLine ( ) ) ; } public void write ( final String text ) throws IOException { final BufferedWriter aWriter = getWriter ( ) ; aWriter . write ( text ) ; aWriter . flush ( ) ; } public void writeLine ( final String line ) throws IOException { final BufferedWriter aWriter = getWriter ( ) ; aWriter . write ( line + " \ r \ n " ) ; aWriter . flush ( ) ; } }
public static DataRecorder [ ] lockingIfNeeded ( final DataRecorder [ ] dataRecorders ) { return lockingIfNeeded ( dataRecorders , null ) ; }
public abstract DataFrame derive ( DataFrame input ) ; public static Deriver deriverFor ( Properties props ) throws Exception { String deriverName = props . getProperty ( " deriver " ) ; Properties deriverProps = PropertiesUtils . prefixProperties ( props , " deriver. " ) ; Deriver deriver = null ; if ( deriverName . equals ( " sql " ) ) { deriver = new SQLDeriver ( deriverProps ) ; } else { Class < ? > clazz = Class . forName ( deriverName ) ; Constructor < ? > constructor = clazz . getConstructor ( ) ; deriver = ( Deriver ) constructor . newInstance ( deriverProps ) ; } return deriver ; } }
public void savePlaylist ( final String file ) throws MPDServerException { try { removePlaylist ( file ) ; } catch ( final MPDServerException ignored ) { } mMPD . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_SAVE , file ) ; }
void clearRefreshableViews ( ) { mRefreshableViews . clear ( ) ; }
public MimeBodyPart verify ( @Nonnull final MimeBodyPart aPart , @Nullable final X509Certificate aX509Cert ) throws GeneralSecurityException , IOException , MessagingException , CMSException , OperatorCreationException , SMIMEException { if ( ! isSigned ( aPart ) ) throw new GeneralSecurityException ( " Content-Type indicates data isn't signed:  " + aPart . getContentType ( ) ) ; final MimeMultipart aMainPart = ( MimeMultipart ) aPart . getContent ( ) ; final SMIMESignedParser aSignedParser = new SMIMESignedParser ( new JcaDigestCalculatorProviderBuilder ( ) . build ( ) , aMainPart ) ; X509Certificate aRealX509Cert = aX509Cert ; final Collection < ? > aContainedCerts = aSignedParser . getCertificates ( ) . getMatches ( null ) ; if ( ! aContainedCerts . isEmpty ( ) ) { if ( aContainedCerts . size ( ) > 1 ) s_aLogger . warn ( " Signed part contains  " + aContainedCerts . size ( ) + "  certificates - using the first one! " ) ; final X509CertificateHolder aCertHolder = ( ( X509CertificateHolder ) ContainerHelper . getFirstElement ( aContainedCerts ) ) ; final X509Certificate aCert = new JcaX509CertificateConverter ( ) . setProvider ( BouncyCastleProvider . PROVIDER_NAME ) . getCertificate ( aCertHolder ) ; if ( aX509Cert ! = null & & ! aX509Cert . equals ( aCert ) ) s_aLogger . warn ( " Provided certificate  " + aX509Cert + "  differs from retrieved certficate:  " + aCert ) ; aRealX509Cert = aCert ; } if ( aRealX509Cert = = null ) throw new GeneralSecurityException ( " No certificate provided and none found in the message! " ) ; final SignerInformationVerifier aSIV = new JcaSimpleSignerInfoVerifierBuilder ( ) . setProvider ( BouncyCastleProvider . PROVIDER_NAME ) . build ( aRealX509Cert . getPublicKey ( ) ) ; for ( final Object aSigner : aSignedParser . getSignerInfos ( ) . getSigners ( ) ) { final SignerInformation aSignerInfo = ( SignerInformation ) aSigner ; if ( ! aSignerInfo . verify ( aSIV ) ) throw new SignatureException ( " Verification failed " ) ; } return aSignedParser . getContent ( ) ; }
public static void compute_first_sets ( ) throws internal_error { boolean change = true ; Enumeration n ; Enumeration p ; non_terminal nt ; production prod ; terminal_set prod_first ; while ( change ) {
public int getResendItemCount ( ) { return m_aRWLock . readLocked ( m_aItems : : size ) ; }
public void setup ( ) { try { Thread . sleep ( 100 ) ; } catch ( InterruptedException ex ) { } frameRate ( this . frameRateFPS ) ;
public static void main ( String [ ] args ) throws Exception { LOG . info ( " Envelope application started " ) ; Config config = ConfigUtils . configFromPath ( args [ 0 ] ) ; if ( args . length = = 2 ) { config = ConfigUtils . applySubstitutions ( config , args [ 1 ] ) ; } LOG . info ( " Configuration loaded " ) ; Runner . run ( config ) ; }
private static void writeBasicChar ( int c , CharacterOutput output ) { switch ( c ) { case '\\' :
private void testInvalidNotAComment ( ) { String toml = " value = 'literal string' this is not a real comment " ; parseAndPrint ( toml ) ; }
private static < K , V > boolean addInOrderAndRemoveInReverseOrder ( java . util . Map < K , V > map , Type keyType , String name , Integer [ ] data , Integer invalid ) { for ( int i = 0 ; i < data . length ; i + + ) { Integer item = data [ i ] ; K k = null ; V v = null ; if ( keyType = = Type . Integer ) { k = ( K ) item ; v = ( V ) String . valueOf ( item ) ; } else if ( keyType = = Type . String ) { k = ( K ) String . valueOf ( item ) ; v = ( V ) item ; } map . put ( k , v ) ; } K invalidKey = null ; if ( keyType = = Type . Integer ) { invalidKey = ( K ) invalid ; } else if ( keyType = = Type . String ) { invalidKey = ( K ) String . valueOf ( invalid ) ; } boolean contains = map . containsKey ( invalidKey ) ; V removed = map . remove ( invalidKey ) ; if ( contains | | ( removed ! = null ) ) { System . err . println ( name + "  sorted invalidity check. contains= " + contains + "  removed= " + removed ) ; return false ; } for ( Integer item : data ) { K k = null ; if ( keyType = = Type . Integer ) { k = ( K ) item ; } else if ( keyType = = Type . String ) { k = ( K ) String . valueOf ( item ) ; } map . containsKey ( k ) ; } for ( int i = data . length - 1 ; i > = 0 ; i - - ) { Integer item = data [ i ] ; K k = null ; if ( keyType = = Type . Integer ) { k = ( K ) item ; } else if ( keyType = = Type . String ) { k = ( K ) String . valueOf ( item ) ; } removed = map . remove ( k ) ; if ( removed = = null ) { System . err . println ( name + "  unsorted invalidity check. removed= " + removed ) ; return false ; } } if ( ! testMapEntrySet ( map , keyType , data ) ) return false ; if ( ! map . isEmpty ( ) ) { System . err . println ( name + "  sorted isEmpty() failed. " ) ; Utils . handleError ( map ) ; return false ; } if ( map . size ( ) ! = 0 ) { System . err . println ( name + "  sorted size() failed. " ) ; Utils . handleError ( map ) ; return false ; } return true ; }
public void testRowKeyFor ( ) { Config goodConfig = ConfigUtils . configFromResource ( " /hbase/hbase-output.conf " ) . getConfig ( " output " ) ; List < String > rowKeys = HBaseUtils . rowKeyFor ( goodConfig ) ; assertEquals ( 2 , rowKeys . size ( ) ) ; assertEquals ( " symbol " , rowKeys . get ( 0 ) ) ; assertEquals ( " transacttime " , rowKeys . get ( 1 ) ) ; }
protected String description ( ) { return " querying service " ; }
private static Collection < String > extractImageUrls ( final String releaseJson ) { final JSONObject jsonRootObject ; final JSONArray jsonArray ; String imageUrl ; JSONObject jsonObject ; final Collection < String > imageUrls = new ArrayList < > ( ) ; try { jsonRootObject = new JSONObject ( releaseJson ) ; if ( jsonRootObject . has ( " images " ) ) { jsonArray = jsonRootObject . getJSONArray ( " images " ) ; for ( int i = 0 ; i < jsonArray . length ( ) ; i + + ) { jsonObject = jsonArray . getJSONObject ( i ) ; if ( jsonObject . has ( " resource_url " ) ) { imageUrl = jsonObject . getString ( " resource_url " ) ; imageUrls . add ( imageUrl ) ; } } } } catch ( final Exception e ) { if ( CoverManager . DEBUG ) { Log . e ( TAG , " Failed to get release image URLs from Discogs. " , e ) ; } } return imageUrls ; }
public void notifyQueueIsFull ( ) { lock . lock ( ) ; try { isPaused = true ;
public void testGroupingConjunctions ( ) throws InvalidTheoryException , MalformedGoalException { Prolog engine = new Prolog ( ) ; engine . setTheory ( new Theory ( " g1. g2. " ) ) ; SolveInfo info = engine . solve ( " (g1, g2), (g3, g4). " ) ; assertFalse ( info . isSuccess ( ) ) ; engine . setTheory ( new Theory ( " g1. g2. g3. g4. " ) ) ; info = engine . solve ( " (g1, g2), (g3, g4). " ) ; assertTrue ( info . isSuccess ( ) ) ; }
public void addOperations ( final Map < MemcachedNode , Operation > ops ) { for ( Map . Entry < MemcachedNode , Operation > me : ops . entrySet ( ) ) { final MemcachedNode node = me . getKey ( ) ; Operation o = me . getValue ( ) ; o . setHandlingNode ( node ) ; o . initialize ( ) ; node . addOp ( o ) ; addedQueue . offer ( node ) ; } Selector s = selector . wakeup ( ) ; assert s = = selector : " Wakeup returned the wrong selector. " ; }
public void step ( TestbedSettings settings ) { super . step ( settings ) ; addTextLine ( " This demonstrates a soft distance joint. " ) ; addTextLine ( " Press: (b) to delete a body, (j) to delete a joint " ) ; }
protected final void setPartners ( @Nonnull final PartnerMap aPartners ) { m_aRWLock . writeLock ( ) . lock ( ) ; try {
public void onChanged ( ) { cancel ( ) ; }
public boolean run ( Integer [ ] unsorted , Integer [ ] sorted , String input ) { this . input = input ; if ( ! testJavaCollection ( tCollectionMin , Integer . class , name , unsorted , sorted , input ) ) return false ; return true ; }
public void testQuickSorts ( ) { Integer [ ] result = QuickSort . sort ( QuickSort . PIVOT_TYPE . FIRST , unsorted . clone ( ) ) ; assertTrue ( " Quick sort pivot firt unsorted error. result= " + print ( result ) , check ( result ) ) ; result = QuickSort . sort ( QuickSort . PIVOT_TYPE . FIRST , sorted . clone ( ) ) ; assertTrue ( " Quick sort pivot firt sorted error. result= " + print ( result ) , check ( result ) ) ; result = QuickSort . sort ( QuickSort . PIVOT_TYPE . FIRST , reverse . clone ( ) ) ; assertTrue ( " Quick sort pivot firt reverse error. result= " + print ( result ) , check ( result ) ) ; result = QuickSort . sort ( QuickSort . PIVOT_TYPE . MIDDLE , unsorted . clone ( ) ) ; assertTrue ( " Quick sort pivot middle unsorted error. result= " + print ( result ) , check ( result ) ) ; result = QuickSort . sort ( QuickSort . PIVOT_TYPE . MIDDLE , sorted . clone ( ) ) ; assertTrue ( " Quick sort pivot middle sorted error. result= " + print ( result ) , check ( result ) ) ; result = QuickSort . sort ( QuickSort . PIVOT_TYPE . MIDDLE , reverse . clone ( ) ) ; assertTrue ( " Quick sort pivot middle reverse error. result= " + print ( result ) , check ( result ) ) ; result = QuickSort . sort ( QuickSort . PIVOT_TYPE . RANDOM , unsorted . clone ( ) ) ; assertTrue ( " Quick sort pivot random unsorted error. result= " + print ( result ) , check ( result ) ) ; result = QuickSort . sort ( QuickSort . PIVOT_TYPE . RANDOM , sorted . clone ( ) ) ; assertTrue ( " Quick sort pivot random sorted error. result= " + print ( result ) , check ( result ) ) ; result = QuickSort . sort ( QuickSort . PIVOT_TYPE . RANDOM , reverse . clone ( ) ) ; assertTrue ( " Quick sort pivot random reverse error. result= " + print ( result ) , check ( result ) ) ; }
private static void initializeBatchJob ( ) { SparkConf sparkConf = getSparkConfiguration ( INSTANCE . config , INSTANCE . mode ) ; if ( ! sparkConf . contains ( " spark.master " ) ) { LOG . warn ( " Spark master not provided, instead using local mode " ) ; sparkConf . setMaster ( " local[*] " ) ; } if ( ! sparkConf . contains ( " spark.app.name " ) ) { LOG . warn ( " Spark application name not provided, instead using empty string " ) ; sparkConf . setAppName ( " " ) ; } SparkSession . Builder sparkSessionBuilder = SparkSession . builder ( ) ; if ( enablesHiveSupport ( ) ) { sparkSessionBuilder . enableHiveSupport ( ) ; } INSTANCE . ss = sparkSessionBuilder . config ( sparkConf ) . getOrCreate ( ) ; }
public static void emit_warn ( String message ) { System . err . println ( " Warning at  " + current_line + " ( " + current_position + " ):  " + message ) ; warning_count + + ; }
public void testPipe ( ) { NAR source = new DefaultNARBuilder ( ) . build ( ) ; NAR target = new DefaultNARBuilder ( ) . build ( ) ; new SentencePipe ( source , target ) { @Override public Sentence process ( Sentence s ) { sentencesProcessed + + ; return s ; } } ; StringWriter sw = new StringWriter ( ) ; final String sourceLinePrefix = " Source:  " ; new TextOutput ( source , sw ) . setLinePrefix ( sourceLinePrefix ) ; new TextOutput ( target , sw ) . setLinePrefix ( " Target:  " ) ; source . addInput ( " <a --> b>. " ) ; source . addInput ( " <a --> b>? " ) ; assert ( target . memory . concepts . size ( ) = = 0 ) ; source . finish ( 8 ) ; assert ( sentencesProcessed > 0 ) ; target . finish ( 8 ) ; String swBuffer = sw . getBuffer ( ) . toString ( ) ; assert ( swBuffer . length ( ) > 0 ) ; assert ( swBuffer . contains ( sourceLinePrefix ) ) ;
public void onDetach ( ) { coverHelper = null ; super . onDetach ( ) ; }
public void testParsing ( ) throws OpenAS2Exception { DispositionOptions aDO = DispositionOptions . createFromString ( " signed-receipt-protocol=optional,pkcs7-signature; signed-receipt-micalg=optional,sha1,md5 " ) ; assertNotNull ( aDO ) ; assertEquals ( " optional " , aDO . getProtocolImportance ( ) ) ; assertEquals ( " pkcs7-signature " , aDO . getProtocol ( ) ) ; assertEquals ( " optional " , aDO . getMICAlgImportance ( ) ) ; assertEquals ( " sha1, md5 " , aDO . getMICAlgAsString ( ) ) ; assertEquals ( " signed-receipt-protocol=optional, pkcs7-signature; signed-receipt-micalg=optional, sha1, md5 " , aDO . getAsString ( ) ) ; aDO = DispositionOptions . createFromString ( " signed-receipt-protocol=required,pkcs7-signature; signed-receipt-micalg=required,sha1 " ) ; assertNotNull ( aDO ) ; assertEquals ( " required " , aDO . getProtocolImportance ( ) ) ; assertEquals ( " pkcs7-signature " , aDO . getProtocol ( ) ) ; assertEquals ( " required " , aDO . getMICAlgImportance ( ) ) ; assertEquals ( " sha1 " , aDO . getMICAlgAsString ( ) ) ; assertEquals ( " signed-receipt-protocol=required, pkcs7-signature; signed-receipt-micalg=required, sha1 " , aDO . getAsString ( ) ) ; aDO = DispositionOptions . createFromString ( "    signed-receipt-protocol   =   required   ,   pkcs7-signature   ;   signed-receipt-micalg   =   required   ,   sha1 " ) ; assertNotNull ( aDO ) ; assertEquals ( " required " , aDO . getProtocolImportance ( ) ) ; assertEquals ( " pkcs7-signature " , aDO . getProtocol ( ) ) ; assertEquals ( " required " , aDO . getMICAlgImportance ( ) ) ; assertEquals ( " sha1 " , aDO . getMICAlgAsString ( ) ) ; assertEquals ( " signed-receipt-protocol=required, pkcs7-signature; signed-receipt-micalg=required, sha1 " , aDO . getAsString ( ) ) ; aDO = DispositionOptions . createFromString ( " signed-receipt-protocol=required,pkcs7-signature " ) ; assertNotNull ( aDO ) ; assertEquals ( " required " , aDO . getProtocolImportance ( ) ) ; assertEquals ( " pkcs7-signature " , aDO . getProtocol ( ) ) ; assertNull ( aDO . getMICAlgImportance ( ) ) ; assertNull ( aDO . getMICAlgAsString ( ) ) ; assertEquals ( " signed-receipt-protocol=required, pkcs7-signature " , aDO . getAsString ( ) ) ; aDO = DispositionOptions . createFromString ( " signed-receipt-micalg=required, sha1, md5 " ) ; assertNotNull ( aDO ) ; assertNull ( aDO . getProtocolImportance ( ) ) ; assertNull ( aDO . getProtocol ( ) ) ; assertEquals ( " required " , aDO . getMICAlgImportance ( ) ) ; assertEquals ( " sha1, md5 " , aDO . getMICAlgAsString ( ) ) ; assertEquals ( " signed-receipt-micalg=required, sha1, md5 " , aDO . getAsString ( ) ) ; aDO = DispositionOptions . createFromString ( " signed-receipt-micalg=required, sha512 " ) ; assertNotNull ( aDO ) ; assertNull ( aDO . getProtocolImportance ( ) ) ; assertNull ( aDO . getProtocol ( ) ) ; assertEquals ( " required " , aDO . getMICAlgImportance ( ) ) ; assertEquals ( " sha512 " , aDO . getMICAlgAsString ( ) ) ; assertEquals ( " signed-receipt-micalg=required, sha512 " , aDO . getAsString ( ) ) ; aDO = DispositionOptions . createFromString ( " signed-receipt-micalg=required, foo, bla, sha512, zuzu, ,, , , lol, md5, md4, 9876 " ) ; assertNotNull ( aDO ) ; assertNull ( aDO . getProtocolImportance ( ) ) ; assertNull ( aDO . getProtocol ( ) ) ; assertEquals ( " required " , aDO . getMICAlgImportance ( ) ) ; assertEquals ( " sha512, md5 " , aDO . getMICAlgAsString ( ) ) ; assertEquals ( " signed-receipt-micalg=required, sha512, md5 " , aDO . getAsString ( ) ) ; aDO = DispositionOptions . createFromString ( " signed-receipt-micalg=required, bla " ) ; assertNotNull ( aDO ) ; assertNull ( aDO . getProtocolImportance ( ) ) ; assertNull ( aDO . getProtocol ( ) ) ; assertEquals ( " required " , aDO . getMICAlgImportance ( ) ) ; assertNull ( aDO . getMICAlgAsString ( ) ) ; assertEquals ( " " , aDO . getAsString ( ) ) ; }
public TermLink selectTermLink ( final TaskLink taskLink , final long time ) { maintainDisappointedAnticipations ( ) ; int toMatch = Parameters . TERM_LINK_MAX_MATCHED ; for ( int i = 0 ; ( i < toMatch ) & & ( termLinks . size ( ) > 0 ) ; i + + ) { final TermLink termLink = termLinks . takeNext ( ) ; if ( termLink = = null ) break ; if ( taskLink . novel ( termLink , time ) ) { return termLink ; } returnTermLink ( termLink ) ; } return null ;
public void startPlay ( EntityObserver entityObserver , boolean showLinks ) { this . entityObserver = entityObserver ; entityObserver . startPlay ( this , showLinks ) ; entityObserver . post ( displayContent ( ) ) ; if ( showLinks ) { taskLinks . addBagObserver ( entityObserver . createBagObserver ( ) , " Task Links in  " + term ) ;
protected boolean compareIDs ( final Map < String , String > ids , final Map < String , String > compareTo ) { if ( ids . isEmpty ( ) ) { return false ; } for ( final Map . Entry < String , String > currentId : ids . entrySet ( ) ) { final String currentValue = currentId . getValue ( ) ; final String compareValue = compareTo . get ( currentId . getKey ( ) ) ; if ( ! EqualsUtils . equals ( currentValue , compareValue ) ) return false ; } return true ; }
float deg ( float radval ) { return radval / ( 2 * PI ) * 360 ; }
public boolean removeAll ( Collection < ? > c ) { return internalCollection . removeAll ( new TransformingCollection ( c , searchTransformation , o - > o , searchTransformation ) ) ;
public void testSign_QuotedPrintable ( ) throws Exception { final MimeBodyPart aPart = new MimeBodyPart ( ) ; aPart . setText ( " Hello world " , StandardCharsets . ISO_8859_1 . name ( ) ) ; final MimeBodyPart aSigned = AS2Helper . getCryptoHelper ( ) . sign ( aPart , ( X509Certificate ) PKE . getCertificate ( ) , PKE . getPrivateKey ( ) , ECryptoAlgorithmSign . DIGEST_SHA_256 , false , false , false , EContentTransferEncoding . QUOTED_PRINTABLE ) ; assertNotNull ( aSigned ) ; final String sBoundary = AS2HttpHelper . parseContentType ( aSigned . getContentType ( ) ) . getParameter ( " boundary " ) ; assertNotNull ( sBoundary ) ; final NonBlockingByteArrayOutputStream aBAOS = new NonBlockingByteArrayOutputStream ( ) ; aSigned . writeTo ( aBAOS ) ; final String sExpectedStart = " Content-Type: multipart/signed; protocol= \" application/pkcs7-signature \" ; micalg=sha-256;  \ r \ n " + " \ tboundary= \" " + sBoundary + " \" \ r \ n " + " \ r \ n " + " -- " + sBoundary + " \ r \ n " + " Content-Type: text/plain; charset=ISO-8859-1 \ r \ n " + " Content-Transfer-Encoding: 7bit \ r \ n " + " \ r \ n " + " Hello world \ r \ n " + " -- " + sBoundary + " \ r \ n " + " Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data \ r \ n " + " Content-Transfer-Encoding: quoted-printable \ r \ n " + " Content-Disposition: attachment; filename= \" smime.p7s \" \ r \ n " + " Content-Description: S/MIME Cryptographic Signature \ r \ n " + " \ r \ n " + " 0=80=06=09*=86H=86=F7 \ r \ n " + " =01=07=02=A0=800=80=02=01=011 \ r \ n " + " 0=0B=06=09`=86H=01e=03=04=02=010=80=06=09*=86H=86=F7 \ r \ n " + " =01=07=01=00=001=82=02=A40=82=02=A0=02=01=010=81=C30=81=BA1#0!=06=09*=86H= \ r \ n " + " =86=F7 \ r \ n " + " =01=09=01=16=14service@mendelson.de1=0B0=09=06=03U=04=06=13=02DE1=0F0 \ r \ n " + " =06=03U=04=08=0C=06Berlin1=0F0 \ r \ n " + " =06=03U=04=07=0C=06Berlin1 \" 0 =06=03U=04 \ r \ n " + " =0C=19mendelson-e-commerce GmbH1!0=1F=06=03U=04=0B=0C=18Do not use in produ= \ r \ n " + " ction1=1D0=1B=06=03U=04=03=0C=14mendelson test key 3=02=04Z*[=1C0=0B=06=09`= \ r \ n " + " =86H=01e=03=04=02=01=A0=81=B40=18=06=09*=86H=86=F7 \ r \ n " + " =01=09=031=0B=06=09*=86H=86=F7 \ r \ n " + " =01=07=010=1C=06=09*=86H=86=F7 \ r \ n " + " =01=09=051=0F=17 \ r \ n " ; final String sExpectedEnd = " \ r \ n " + " -- " + sBoundary + " -- \ r \ n " ; final String sReal = aBAOS . getAsString ( StandardCharsets . ISO_8859_1 ) ; assertTrue ( sReal . startsWith ( sExpectedStart ) ) ; assertTrue ( sReal . endsWith ( sExpectedEnd ) ) ; }
public static com . google . protobuf . Internal . EnumLiteMap < EnumExample > internalGetValueMap ( ) { return internalValueMap ; }
BlockingQueue < Operation > createWriteOperationQueue ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; boolean isDaemon ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; }
private static boolean runTests ( ) { testIndex = 0 ; testNumber + + ; System . out . println ( " Generating data. " ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Array= " ) ; unsorted = new Integer [ ARRAY_SIZE ] ; java . util . Set < Integer > set = new java . util . HashSet < Integer > ( ) ; for ( int i = 0 ; i < ARRAY_SIZE ; i + + ) { Integer j = RANDOM . nextInt ( RANDOM_SIZE ) ; boolean found = true ; while ( found ) { if ( set . contains ( j ) ) { j = RANDOM . nextInt ( RANDOM_SIZE ) ; } else { unsorted [ i ] = j ; set . add ( j ) ; found = false ; } } unsorted [ i ] = j ; builder . append ( j ) . append ( ',' ) ; } set . clear ( ) ; set = null ; builder . append ( '\n' ) ; string = builder . toString ( ) ; if ( debug > 1 ) System . out . println ( string ) ; sorted = Arrays . copyOf ( unsorted , unsorted . length ) ; Arrays . sort ( sorted ) ; System . out . println ( " Generated data. " ) ; boolean passed = true ; passed = testJavaRedBlackIntegerTree ( ) ; if ( ! passed ) { System . err . println ( " Java Red-Black [Integer] failed. " ) ; return false ; } passed = testRedBlackTree ( ) ; if ( ! passed ) { System . err . println ( " Red-Black Tree failed. " ) ; return false ; } passed = testAVLTree ( ) ; if ( ! passed ) { System . err . println ( " AVL Tree failed. " ) ; return false ; } passed = testSplayTree ( ) ; if ( ! passed ) { System . err . println ( " Splay Tree failed. " ) ; return false ; } passed = testBTree ( ) ; if ( ! passed ) { System . err . println ( " B-Tree failed. " ) ; return false ; } passed = testTreap ( ) ; if ( ! passed ) { System . err . println ( " Treap failed. " ) ; return false ; } passed = testBST ( ) ; if ( ! passed ) { System . err . println ( " BST failed. " ) ; return false ; } passed = testJavaRedBlackStringTree ( ) ; if ( ! passed ) { System . err . println ( " Java Red-Black [String] failed. " ) ; return false ; } passed = testTrie ( ) ; if ( ! passed ) { System . err . println ( " Trie failed. " ) ; return false ; } passed = testPatriciaTrie ( ) ; if ( ! passed ) { System . err . println ( " Patricia Trie failed. " ) ; return false ; } passed = testJavaMinHeap ( ) ; if ( ! passed ) { System . err . println ( " Java Min-Heap failed. " ) ; return false ; } passed = testMinHeap ( ) ; if ( ! passed ) { System . err . println ( " Min-Heap failed. " ) ; return false ; } passed = testJavaMaxHeap ( ) ; if ( ! passed ) { System . err . println ( " Java Max-Heap failed. " ) ; return false ; } passed = testMaxHeap ( ) ; if ( ! passed ) { System . err . println ( " Max-Heap failed. " ) ; return false ; } passed = testJavaArrayList ( ) ; if ( ! passed ) { System . err . println ( " Java List failed. " ) ; return false ; } passed = testArrayList ( ) ; if ( ! passed ) { System . err . println ( " List failed. " ) ; return false ; } passed = testJavaLinkedList ( ) ; if ( ! passed ) { System . err . println ( " Java List failed. " ) ; return false ; } passed = testLinkedList ( ) ; if ( ! passed ) { System . err . println ( " List failed. " ) ; return false ; } passed = testJavaSkipList ( ) ; if ( ! passed ) { System . err . println ( " Java's Skip List failed. " ) ; return false ; } passed = testSkipList ( ) ; if ( ! passed ) { System . err . println ( " Skip List failed. " ) ; return false ; } passed = testJavaArrayQueue ( ) ; if ( ! passed ) { System . err . println ( " Java Queue failed. " ) ; return false ; } passed = testArrayQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } passed = testJavaLinkedQueue ( ) ; if ( ! passed ) { System . err . println ( " Java Queue failed. " ) ; return false ; } passed = testLinkedQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } passed = testJavaStack ( ) ; if ( ! passed ) { System . err . println ( " Java Stack failed. " ) ; return false ; } passed = testArrayStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } passed = testLinkedStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } passed = testJavaHashMap ( ) ; if ( ! passed ) { System . err . println ( " Java Hash Map failed. " ) ; return false ; } passed = testHashMap ( ) ; if ( ! passed ) { System . err . println ( " Hash Map failed. " ) ; return false ; } passed = testJavaTreeMap ( ) ; if ( ! passed ) { System . err . println ( " Java Tree Map failed. " ) ; return false ; } passed = testTreeMap ( ) ; if ( ! passed ) { System . err . println ( " Tree Map failed. " ) ; return false ; } passed = testTrieMap ( ) ; if ( ! passed ) { System . err . println ( " Trie Map failed. " ) ; return false ; } passed = testRadixTrie ( ) ; if ( ! passed ) { System . err . println ( " Radix Trie failed. " ) ; return false ; } if ( debugTime & & debugMemory ) { String results = getTestResults ( testNumber , testNames , testResults ) ; System . out . println ( results ) ; } passed = testCompactSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Compact Suffix Trie failed. " ) ; return false ; } passed = testGraph ( ) ; if ( ! passed ) { System . err . println ( " Graph failed. " ) ; return false ; } passed = testIntervalTree ( ) ; if ( ! passed ) { System . err . println ( " Interval Tree failed. " ) ; return false ; } passed = testKdTree ( ) ; if ( ! passed ) { System . err . println ( " k-d Tree Tree failed. " ) ; return false ; } passed = testMatrix ( ) ; if ( ! passed ) { System . err . println ( " Matrix failed. " ) ; return false ; } passed = testQuadTree ( ) ; if ( ! passed ) { System . err . println ( " QuadTree failed. " ) ; return false ; } passed = testSegmentTree ( ) ; if ( ! passed ) { System . err . println ( " Segment Tree failed. " ) ; return false ; } passed = testSuffixTree ( ) ; if ( ! passed ) { System . err . println ( " Suffix Tree failed. " ) ; return false ; } passed = testSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Suffix Trie failed. " ) ; return false ; } return true ; }
public List < Album > getAlbums ( final Artist artist , final boolean sortByYear , final boolean trackCountNeeded ) throws IOException , MPDException { List < Album > albums = getAlbums ( artist , sortByYear , trackCountNeeded , false ) ; if ( artist ! = null & & ! artist . isUnknown ( ) ) { albums = Item . merged ( albums , getAlbums ( artist , sortByYear , trackCountNeeded , true ) ) ; } return albums ; }
private static void initializeBatchJob ( ) { SparkConf sparkConf = getSparkConfiguration ( INSTANCE . config ) ; String applicationName = INSTANCE . config . getString ( APPLICATION_NAME_PROPERTY ) ; sparkConf . setAppName ( applicationName ) ; INSTANCE . jsc = new JavaSparkContext ( sparkConf ) ; }
private void dragView ( int x , int y ) { if ( mRemoveMode = = SLIDE ) { float alpha = 1.0f ; int width = mDragView . getWidth ( ) ; if ( x > width / 2 ) { alpha = ( ( float ) ( width - x ) ) / ( width / 2 ) ; } mWindowParams . alpha = alpha ; } if ( mRemoveMode = = FLING ) { mWindowParams . x = x ; } mWindowParams . y = y - mDragPoint + mCoordOffset ; mWindowManager . updateViewLayout ( mDragView , mWindowParams ) ; }
protected void addAlbumPaths ( List < Album > albums ) { if ( albums = = null | | albums . size ( ) = = 0 ) { return ; } for ( Album a : albums ) { try {
public void playlistChanged ( MPDStatus mpdStatus , int oldPlaylistVersion ) { } @Override public void randomChanged ( boolean random ) { } @Override public void repeatChanged ( boolean repeating ) { } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Log . d ( TAG , " StreamingService.stateChanged() " ) ; Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; final String state = mpdStatus . getState ( ) ; if ( state = = null | | state . equals ( prevMpdState ) ) { return ; } isPlaying = MPDStatus . MPD_STATE_PLAYING . equals ( state ) ; prevMpdState = state ; if ( isPlaying ) { beginStreaming ( ) ; } else { stopStreaming ( ) ; } } private void stopStreaming ( ) { Log . d ( TAG , " StreamingService.stopStreaming() " ) ; prevMpdState = " " ; if ( mediaPlayer = = null ) { return ; } mediaPlayer . stop ( ) ; sendIntent ( NotificationService . ACTION_STREAMING_END , NotificationService . class ) ; } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { Log . d ( TAG , " StreamingService.trackChanged() " ) ; prevMpdState = " " ; } @Override public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } }
public void testIgnore ( ) throws AS2InvalidParameterException { final AS2Message aMsg = new AS2Message ( ) ; aMsg . headers ( ) . addHeader ( " message-id " , " 12345 " ) ; aMsg . partnership ( ) . setSenderAS2ID ( " s1 " ) ; aMsg . partnership ( ) . setReceiverAS2ID ( " r1 " ) ; final CompositeParameters aParams = new CompositeParameters ( true ) . add ( " msg " , new MessageParameters ( aMsg ) ) ; assertEquals ( " sender.as2_id, receiver.as2_id, headers.message-id " , aParams . format ( " sender.as2_id, receiver.as2_id, headers.message-id " ) ) ; assertEquals ( " s1, r1, 12345 " , aParams . format ( " $msg.sender.as2_id$, $msg.receiver.as2_id$, $msg.headers.message-id$ " ) ) ; assertEquals ( " " , aParams . format ( " $dummy$ " ) ) ; assertEquals ( " any " , aParams . format ( " any$dummy$ " ) ) ; assertEquals ( " any " , aParams . format ( " $dummy$any " ) ) ; assertEquals ( " foobar " , aParams . format ( " foo$dummy$bar " ) ) ; }
public void testBackfill ( ) throws Exception { if ( TestConfig . isMembase ( ) ) { TapClient tc =
protected void add ( Item item , String playlist ) { try { app . oMPDAsyncHelper . oMPD . addToPlaylist ( playlist , ( Artist ) item ) ;
public void timeOut ( ) ; public boolean isTimedOut ( ) ; public boolean isTimedOut ( long ttlMillis ) ; public boolean isTimedOutUnsent ( ) ; }
public void onCoverNotFound ( final CoverInfo coverInfo ) { obtainMessage ( EVENT_COVER_NOT_FOUND , coverInfo ) . sendToTarget ( ) ; }
@Override public AtomicInteger deserialize ( JsonElement je , Type type , JsonDeserializationContext jdc ) throws JsonParseException { return new AtomicInteger ( je . getAsInt ( ) ) ; }
public void testOverflowingInputQueue ( ) throws Exception { runOverflowTest ( new byte [ ] { 1 } ) ; }
MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; BlockingQueue < Operation > createOperationQueue ( ) ; BlockingQueue < Operation > createReadOperationQueue ( ) ; BlockingQueue < Operation > createWriteOperationQueue ( ) ; long getOpQueueMaxBlockTime ( ) ; ExecutorService getListenerExecutorService ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; boolean isDaemon ( ) ; boolean useNagleAlgorithm ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; int getReadBufSize ( ) ; HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; MetricType enableMetrics ( ) ; MetricCollector getMetricCollector ( ) ; }
private static boolean runTests ( ) { System . out . println ( " Generating data. " ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Array= " ) ; unsorted = new Integer [ ARRAY_SIZE ] ; for ( int i = 0 ; i < unsorted . length ; i + + ) { Integer j = RANDOM . nextInt ( unsorted . length * 10 ) ; boolean found = true ; while ( found ) { found = false ; for ( int k = 0 ; k < i ; k + + ) { int l = unsorted [ k ] ; if ( j = = l ) { found = true ; j = RANDOM . nextInt ( unsorted . length * 10 ) ; break ; } } } unsorted [ i ] = j ; builder . append ( j ) . append ( ',' ) ; } builder . append ( '\n' ) ; string = builder . toString ( ) ; if ( debug ) System . out . println ( string ) ; System . out . println ( " Generated data. " ) ; boolean passed = true ; long before = 0 L ; long after = 0 L ; before = System . currentTimeMillis ( ) ; passed = testHeap ( ) ; if ( ! passed ) { System . err . println ( " Heap failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Heap time =  " + ( after - before ) + "  ms " ) ; passed = testBST ( ) ; if ( ! passed ) { System . err . println ( " BST failed. " ) ; return false ; } passed = testGraph ( ) ; if ( ! passed ) { System . err . println ( " Graph failed. " ) ; return false ; } before = System . currentTimeMillis ( ) ; passed = testHashMap ( ) ; if ( ! passed ) { System . err . println ( " Hash Map failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Hash Map time =  " + ( after - before ) + "  ms " ) ; before = System . currentTimeMillis ( ) ; passed = testLinkedList ( ) ; if ( ! passed ) { System . err . println ( " Linked List failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Linked List time =  " + ( after - before ) + "  ms " ) ; passed = testMatrix ( ) ; if ( ! passed ) { System . err . println ( " Matrix failed. " ) ; return false ; } before = System . currentTimeMillis ( ) ; passed = testPatriciaTrie ( ) ; if ( ! passed ) { System . err . println ( " Patricia Trie failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Patricia Trie time =  " + ( after - before ) + "  ms " ) ; before = System . currentTimeMillis ( ) ; passed = testQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Queue time =  " + ( after - before ) + "  ms " ) ; before = System . currentTimeMillis ( ) ; passed = testRadixTree ( ) ; if ( ! passed ) { System . err . println ( " Radix Tree failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Radix Tree time =  " + ( after - before ) + "  ms " ) ; passed = testSegmentTree ( ) ; if ( ! passed ) { System . err . println ( " Segment Tree failed. " ) ; return false ; } before = System . currentTimeMillis ( ) ; passed = testSkipList ( ) ; if ( ! passed ) { System . err . println ( " Skip List failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Skip List time =  " + ( after - before ) + "  ms " ) ; before = System . currentTimeMillis ( ) ; passed = testSplayTree ( ) ; if ( ! passed ) { System . err . println ( " Splay Tree failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Splay Tree time =  " + ( after - before ) + "  ms " ) ; before = System . currentTimeMillis ( ) ; passed = testStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Stack time =  " + ( after - before ) + "  ms " ) ; passed = testSuffixTree ( ) ; if ( ! passed ) { System . err . println ( " Suffix Tree failed. " ) ; return false ; } passed = testSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Suffix Trie failed. " ) ; return false ; } before = System . currentTimeMillis ( ) ; passed = testTreap ( ) ; if ( ! passed ) { System . err . println ( " Treap failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Treap time =  " + ( after - before ) + "  ms " ) ; before = System . currentTimeMillis ( ) ; passed = testTrie ( ) ; if ( ! passed ) { System . err . println ( " Trie failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Trie time =  " + ( after - before ) + "  ms " ) ; before = System . currentTimeMillis ( ) ; passed = testTrieMap ( ) ; if ( ! passed ) { System . err . println ( " Trie Map failed. " ) ; return false ; } after = System . currentTimeMillis ( ) ; if ( debugTime ) System . out . println ( " Trie Map time =  " + ( after - before ) + "  ms " ) ; if ( debugTime ) System . out . println ( ) ; return true ; }
public Builder clearSint64 ( ) { sint64_ = 0 L ; onChanged ( ) ; return this ; }
private void advance ( ) { while ( idx < size ) { while ( + + bit < BITS )
public Dataset < Row > derive ( Map < String , Dataset < Row > > dependencies ) throws Exception { String query ; if ( config . hasPath ( QUERY_LITERAL_CONFIG_NAME ) ) { query = config . getString ( QUERY_LITERAL_CONFIG_NAME ) ; } else if ( config . hasPath ( QUERY_FILE_CONFIG_NAME ) ) { query = hdfsFileAsString ( config . getString ( QUERY_FILE_CONFIG_NAME ) ) ; } else { throw new RuntimeException ( " SQL deriver query not provided. Use ' " + QUERY_LITERAL_CONFIG_NAME + " ' or ' " + QUERY_FILE_CONFIG_NAME + " '. " ) ; } Dataset < Row > derived = Contexts . getSparkSession ( ) . sql ( query ) ; return derived ; }
public boolean canHandle ( @Nonnull final String sAction , final IMessage aMsg , final Map < String , Object > aOptions ) { return sAction . equals ( IProcessorResenderModule . DO_RESEND ) ; }
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { TestChamber . executed = true ; System . out . println ( " Executed:  " + this ) ; if ( args [ 0 ] . toString ( ) . equals ( " 1 " ) ) { jButton2 . setText ( " O " ) ; field [ 0 ] = 2 ; } if ( args [ 0 ] . toString ( ) . equals ( " 2 " ) ) { jButton5 . setText ( " O " ) ; field [ 1 ] = 2 ; } if ( args [ 0 ] . toString ( ) . equals ( " 3 " ) ) { jButton8 . setText ( " O " ) ; field [ 2 ] = 2 ; } if ( args [ 0 ] . toString ( ) . equals ( " 4 " ) ) { jButton3 . setText ( " O " ) ; field [ 3 ] = 2 ; } if ( args [ 0 ] . toString ( ) . equals ( " 5 " ) ) { jButton6 . setText ( " O " ) ; field [ 4 ] = 2 ; } if ( args [ 0 ] . toString ( ) . equals ( " 6 " ) ) { jButton9 . setText ( " O " ) ; field [ 5 ] = 2 ; } if ( args [ 0 ] . toString ( ) . equals ( " 7 " ) ) { jButton4 . setText ( " O " ) ; field [ 6 ] = 2 ; } if ( args [ 0 ] . toString ( ) . equals ( " 8 " ) ) { jButton7 . setText ( " O " ) ; field [ 7 ] = 2 ; } if ( args [ 0 ] . toString ( ) . equals ( " 9 " ) ) { jButton10 . setText ( " O " ) ; field [ 8 ] = 2 ; } check_field ( ) ; return null ; }
public < C extends ControlSensor > C add ( C s ) { inputs . add ( s ) ; return s ; }
private void readSettings ( SharedPreferences settings , String wifiSSID ) { String sServer = " " ; if ( wifiSSID ! = null ) { if ( wifiSSID . trim ( ) . equals ( " " ) ) { wifiSSID = null ; } } sServer = settings . getString ( getStringWithSSID ( " hostname " , wifiSSID ) , " " ) . trim ( ) ; int iPort , iPortStreaming ; try { iPort = Integer . parseInt ( settings . getString ( getStringWithSSID ( " port " , wifiSSID ) , Integer . toString ( DEFAULT_MPD_PORT ) ) . trim ( ) ) ; } catch ( NumberFormatException e ) { iPort = DEFAULT_MPD_PORT ; } try { iPortStreaming = Integer . parseInt ( settings . getString ( getStringWithSSID ( " portStreaming " , wifiSSID ) , Integer . toString ( DEFAULT_STREAMING_PORT ) ) . trim ( ) ) ; } catch ( NumberFormatException e ) { iPortStreaming = DEFAULT_STREAMING_PORT ; } String sServerStreaming = settings . getString ( getStringWithSSID ( " hostnameStreaming " , wifiSSID ) , " " ) . trim ( ) ; if ( sServerStreaming . equals ( " " ) ) { sServerStreaming = null ; } String sPassword = settings . getString ( getStringWithSSID ( " password " , wifiSSID ) , " " ) . trim ( ) ; oMPDAsyncHelper . setConnectionInfo ( sServer , iPort , sPassword , sServerStreaming , iPortStreaming ) ; }
private static void put ( ConfigObject typesafeConfig , Config destination , ParsingMode parsingMode ) { for ( Map . Entry < String , ConfigValue > entry : typesafeConfig . entrySet ( ) ) { List < String > path = ConfigUtil . splitPath ( entry . getKey ( ) ) ;
public void setFilename ( @Nullable final String sFilename ) { putIn ( ATTR_FILENAME , sFilename ) ; }
public void testReadHttpRequestRegularMessage ( ) throws Exception { final IAS2HttpResponseHandler mockedResponseHandler = ( nHttpResponseCode , aHeaders , aData ) - > { } ; NonBlockingByteArrayInputStream is = new NonBlockingByteArrayInputStream ( m_sRegularMessage . getBytes ( ) ) ; AS2Message aMsg = new AS2Message ( ) ; aMsg . attrs ( ) . putIn ( ATTR_LARGE_FILE_SUPPORT_ON , false ) ; IAS2InputStreamProvider mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; final DataSource resRegular = HTTPHelper . readHttpRequest ( mockStreamProvider , mockedResponseHandler , aMsg ) ; is = new NonBlockingByteArrayInputStream ( m_sRegularMessage . getBytes ( ) ) ; aMsg = new AS2Message ( ) ; aMsg . attrs ( ) . putIn ( ATTR_LARGE_FILE_SUPPORT_ON , true ) ; mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; final DataSource resStream = HTTPHelper . readHttpRequest ( mockStreamProvider , mockedResponseHandler , aMsg ) ; assertTrue ( " Compare regular and stream read " , _compareLineByLine ( resRegular . getInputStream ( ) , resStream . getInputStream ( ) ) ) ;
private void unset ( int position ) { bitmap & = ~ ( 1 < < position ) ; }
public boolean onTouchEvent ( MotionEvent event ) { int action = event . getAction ( ) ; if ( action = = MotionEvent . ACTION_DOWN | | action = = MotionEvent . ACTION_MOVE ) { float x_mouse = event . getX ( ) - padding ; float width = getWidth ( ) - 2 * padding ; int progress = Math . round ( ( float ) getMax ( ) * ( x_mouse / width ) ) ; if ( progress < 0 ) progress = 0 ; this . setProgress ( progress ) ; if ( listener ! = null ) listener . onProgressChanged ( this , progress ) ; } return true ; }
public void removeLayer ( LayerDraw l ) { layers . remove ( l ) ; }
public void asyncForgeTest ( ) throws URISyntaxException { Path forgeTestResource = Path . of ( getClass ( ) . getResource ( " /forge_test.toml " ) . toURI ( ) ) ; FileConfig fileConfig = FileConfig . builder ( forgeTestResource ) . async ( ) . build ( ) ; fileConfig . load ( ) ; System . out . println ( " loaded:  " + fileConfig ) ; checkForgeTestContent ( fileConfig ) ; fileConfig . load ( ) ; checkForgeTestContent ( fileConfig ) ; fileConfig . close ( ) ; checkForgeTestContent ( fileConfig ) ; }
public static double gauss ( ) { double nextGaussian = random . nextGaussian ( ) ; return nextGaussian ; }
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public abstract void doStop ( ) throws OpenAS2Exception ; public boolean canHandle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) { return false ; } public void handle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) throws OpenAS2Exception { throw new OpenAS2UnsupportedException ( " Active modules don't handle anything by default " ) ; } public void forceStop ( final Exception aCause ) { new ForcedStopException ( aCause ) . terminate ( ) ; try { stop ( ) ; } catch ( final OpenAS2Exception ex ) { ex . terminate ( ) ; } } private void _setRunning ( final boolean bRunning ) { m_bRunning = bRunning ; } public void start ( ) throws OpenAS2Exception { _setRunning ( true ) ; doStart ( ) ; } public void stop ( ) throws OpenAS2Exception { _setRunning ( false ) ; doStop ( ) ; } @Override public String toString ( ) { return ToStringGenerator . getDerived ( super . toString ( ) ) . append ( " running " , m_bRunning ) . toString ( ) ; } }
public void event ( Class event , Object [ ] arguments ) { if ( arguments . length > 0 ) { synchronized ( items ) {
private static void initDefaultParsers ( ) { defaultParsers . add ( new TextReaction ( ) { final static String inputPrefix = Symbols . INPUT_LINE + ':' ; @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { try { input = input . trim ( ) ; if ( input . startsWith ( inputPrefix ) ) { input = input . substring ( inputPrefix . length ( ) ) ; } input = input . trim ( ) ; int cycles = Integer . parseInt ( input ) ; nar . output ( IN . class , cycles ) ; nar . step ( cycles ) ; return true ; } catch ( NumberFormatException e ) { return false ; } } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { if ( input . equals ( Symbols . RESET_COMMAND ) ) { nar . reset ( ) ; return true ; } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { if ( ! nar . isWorking ( ) ) { if ( input . equals ( Symbols . STOP_COMMAND ) ) { nar . output ( Output . OUT . class , " stopping. " ) ; nar . setWorking ( false ) ; return true ; } } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { if ( nar . isWorking ( ) ) { if ( input . equals ( Symbols . START_COMMAND ) ) { nar . setWorking ( true ) ; nar . output ( Output . OUT . class , " starting. " ) ; return true ; } } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { if ( input . indexOf ( Symbols . SILENCE_COMMAND ) = = 0 ) { String [ ] p = input . split ( " = " ) ; if ( p . length = = 2 ) { int silenceLevel = Integer . parseInt ( p [ 1 ] ) ; nar . param . setSilenceLevel ( silenceLevel ) ; nar . output ( Output . OUT . class , " Silence level:  " + silenceLevel ) ; } return true ; } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { char c = input . charAt ( 0 ) ; if ( c = = Symbols . URL_INCLUDE_MARK ) { try { new TextInput ( nar , new URL ( input . substring ( 1 ) ) ) ; } catch ( IOException ex ) { nar . output ( ERR . class , ex ) ; } return true ; } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override public boolean react ( NAR nar , String input , TextReaction lastHandler ) { char c = input . charAt ( 0 ) ; if ( c = = Symbols . ECHO_MARK ) { String echoString = input . substring ( 1 ) ; nar . output ( Output . ECHO . class , '\"' + echoString + '\"' ) ; return true ; } return false ; } } ) ; defaultParsers . add ( new TextReaction ( ) { @Override
void writeByte ( int value ) { this . write ( value & 0xFF ) ; }
public AbstractBag < Concept , Term > newConceptBag ( Param p ) { return new Bag ( getConceptBagLevels ( ) , getConceptBagSize ( ) ) ; }
public void fixupOps ( ) { if ( sk ! = null & & sk . isValid ( ) ) { int iops = getSelectionOps ( ) ;
protected boolean validateNode ( Node < T > node ) { RedBlackNode < T > rbNode = ( RedBlackNode < T > ) node ; if ( rbNode . isLeaf ( ) ) { if ( rbNode . color = = Color . Red ) return false ; return true ; } else if ( rbNode . color = = Color . Red ) { RedBlackNode < T > lesser = ( RedBlackNode < T > ) rbNode . lesser ; if ( lesser . color = = Color . Red ) return false ; RedBlackNode < T > greater = ( RedBlackNode < T > ) rbNode . greater ; if ( greater . color = = Color . Red ) return false ; } boolean lesserCheck = true ; if ( rbNode . lesser ! = null ) { if ( rbNode . value ! = null & & rbNode . lesser . value ! = null ) { lesserCheck = rbNode . lesser . value . compareTo ( rbNode . value ) < = 0 ; } if ( lesserCheck ) lesserCheck = validateNode ( rbNode . lesser ) ; } if ( ! lesserCheck ) return false ; boolean greaterCheck = true ; if ( rbNode . greater ! = null ) { if ( rbNode . value ! = null & & rbNode . greater . value ! = null ) { greaterCheck = rbNode . greater . value . compareTo ( rbNode . value ) > 0 ; } if ( greaterCheck ) greaterCheck = validateNode ( rbNode . greater ) ; } return greaterCheck ; }
public Map < String , T > get ( ) throws InterruptedException , ExecutionException { try { return get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ;
abstract public NovelTaskBag newNovelTaskBag ( Param p ) ; public NAR build ( ) { Param p = newParam ( ) ; Operator [ ] operators = DefaultOperators . get ( ) ; Memory m = new Memory ( p , newConceptBag ( p ) , newNovelTaskBag ( p ) , this , operators ) ; return new NAR ( m ) ; } }
private void configureTab ( Tab tab , int position ) { final TabImpl tabi = ( TabImpl ) tab ; final ActionBar . TabListener callback = tabi . getCallback ( ) ; if ( callback = = null ) { throw new IllegalStateException ( " Action Bar Tab must have a Callback " ) ; } tabi . setPosition ( position ) ; mTabs . add ( position , tabi ) ; final int count = mTabs . size ( ) ; for ( int i = position + 1 ; i < count ; i + + ) { mTabs . get ( i ) . setPosition ( i ) ;
protected void insertInOrder ( Vector vector , FaceFrame faceframe ) { int i ; for ( i = 0 ; i < vector . size ( ) ; i + + ) if ( faceframe . getTime ( ) < = ( ( FaceFrame ) vector . elementAt ( i ) ) . getTime ( ) ) break ; vector . insertElementAt ( faceframe , i ) ; }
public void testLongestIncreasingSubsequence ( ) { ArrayList < int [ ] > sequences = new ArrayList < int [ ] > ( ) ; ArrayList < int [ ] > sequencesLis = new ArrayList < int [ ] > ( ) ; sequences . add ( new int [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ) ; sequencesLis . add ( new int [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ) ; sequences . add ( new int [ ] { 0 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 9 } ) ; sequencesLis . add ( new int [ ] { 0 , 1 , 2 , 9 } ) ; sequences . add ( new int [ ] { 0 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 9 } ) ; sequencesLis . add ( new int [ ] { 0 , 1 , 2 , 9 } ) ; sequences . add ( new int [ ] { 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 7 } ) ; sequencesLis . add ( new int [ ] { 7 } ) ; sequences . add ( new int [ ] { 8 } ) ; sequencesLis . add ( new int [ ] { 8 } ) ; sequences . add ( new int [ ] { 172 , 191 , 179 , 185 , 188 } ) ; sequencesLis . add ( new int [ ] { 172 , 179 , 185 , 188 } ) ; sequences . add ( new int [ ] { 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 } ) ; sequencesLis . add ( new int [ ] { 1 , 2 , 3 } ) ; sequences . add ( new int [ ] { 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 } ) ; sequencesLis . add ( new int [ ] { 0 , 1 , 3 , 7 , 11 , 15 } ) ; assertTrue ( " Longest increasing subsequence error. Sequences size= " + sequences . size ( ) + "  SequencesList size: " + sequencesLis . size ( ) , sequences . size ( ) = = sequencesLis . size ( ) ) ; for ( int i = 0 ; i < sequences . size ( ) ; + + i ) { int [ ] resultSequence = LongestIncreasingSubsequence . getLongestIncreasingSubsequence ( sequences . get ( i ) ) ;
protected static boolean compareMap ( final Map < String , String > searchIds , final Map < String , String > partnerIds ) { if ( searchIds . isEmpty ( ) ) return false ; for ( final Map . Entry < String , String > searchEntry : searchIds . entrySet ( ) ) { final String searchKey = searchEntry . getKey ( ) ; final String searchValue = searchEntry . getValue ( ) ; final String partnerValue = partnerIds . get ( searchKey ) ; if ( ! EqualsUtils . equals ( searchValue , partnerValue ) ) return false ; } return true ; }
public void setTempSharedFileInputStream ( @Nullable final TempSharedFileInputStream aTempSharedFileInputStream ) { m_TempSharedFileInputStream = aTempSharedFileInputStream ; }
public static String convertToReservedCharacters ( String input ) { if ( input = = null | | input = = " " ) return " " ; input = input . replaceAll ( " &gt; " , " > " ) ; input = input . replaceAll ( " &lt; " , " < " ) ; return input ; }
public void deletePlaylist ( String name ) throws MPDServerException { mpdConnection . sendCommand ( " rm " , new String [ ] { name } ) ; }
final public void updateStatus ( Iterable < String > response ) { resetValues ( ) ; for ( String line : response ) { String [ ] lines = line . split ( " :  " ) ;
public void writeToParcel ( final Parcel dest , final int flags ) { dest . writeString ( getName ( ) ) ; dest . writeString ( sortText ( ) ) ; }
public IntervalData < O > query ( long index ) { IntervalData < O > results = null ; if ( index < center ) { for ( IntervalData < O > data : overlap ) { if ( data . start > index ) break ; IntervalData < O > temp = data . query ( index ) ; if ( results = = null & & temp ! = null ) results = temp ; else if ( temp ! = null ) results . combined ( temp ) ; } } else if ( index > = center ) { Set < IntervalData < O > > overlapEnd = new TreeSet < IntervalData < O > > ( endComparator ) ; overlapEnd . addAll ( overlap ) ; for ( IntervalData < O > data : overlapEnd ) { if ( data . end < index ) break ; IntervalData < O > temp = data . query ( index ) ; if ( results = = null & & temp ! = null ) results = temp ; else if ( temp ! = null ) results . combined ( temp ) ; } } if ( index < center ) { if ( left ! = null ) { IntervalData < O > temp = left . query ( index ) ; if ( results = = null & & temp ! = null ) results = temp ; else if ( temp ! = null ) results . combined ( temp ) ; } } else if ( index > = center ) { if ( right ! = null ) { IntervalData < O > temp = right . query ( index ) ; if ( results = = null & & temp ! = null ) results = temp ; else if ( temp ! = null ) results . combined ( temp ) ; } } return results ; }
public void testLong ( ) throws Exception { assertEquals ( 923 , tc . decode ( tc . encode ( 923L ) ) . longValue ( ) ) ; }
public BlockingQueue < Operation > createOperationQueue ( ) { return opQueueFactory = = null ? super . createOperationQueue ( ) : opQueueFactory . create ( ) ;
public void drawSolidCircle ( Vec2 center , float radius , Vec2 axis , Color3f color ) { Graphics2D g = getGraphics ( ) ; saveState ( g ) ; transformGraphics ( g , center ) ; g . setStroke ( stroke ) ; Color f = new Color ( color . x , color . y , color . z , .4f ) ; Color s = new Color ( color . x , color . y , color . z , 1f ) ; g . scale ( radius , radius ) ; g . setColor ( f ) ; g . fill ( circle ) ; g . setColor ( s ) ; g . draw ( circle ) ; g . rotate ( MathUtils . atan2 ( axis . y , axis . x ) ) ; if ( axis ! = null ) { g . drawLine ( 0 , 0 , 1 , 0 ) ; } restoreState ( g ) ; }
void writeIndent ( CharacterOutput output ) { for ( int i = 0 ; i < currentIndentLevel ; i + + ) { output . write ( indent ) ;
public void removeCertificate ( final String sAlias ) throws CertificateException { try {
public void add ( final FilesystemTreeEntry music , boolean replace , boolean play ) throws MPDServerException { final Runnable r = new Runnable ( ) { @Override public void run ( ) { try { if ( music instanceof Music ) { getPlaylist ( ) . add ( music ) ; } else if ( music instanceof PlaylistFile ) { getPlaylist ( ) . load ( music . getFullpath ( ) ) ; } } catch ( MPDServerException e ) { e . printStackTrace ( ) ; } } } ; add ( r , replace , play ) ; }
public void initTest ( boolean deserialized ) { m_bodies = new Body [ e_maxBodies ] ; m_userData = new Integer [ e_maxBodies ] ; m_polygons = new PolygonShape [ 4 ] ; { BodyDef bd = new BodyDef ( ) ; Body ground = getWorld ( ) . createBody ( bd ) ; EdgeShape shape = new EdgeShape ( ) ; shape . set ( new Vec2 ( - 40.0f , 0.0f ) , new Vec2 ( 40.0f , 0.0f ) ) ; ground . createFixture ( shape , 0.0f ) ; } { Vec2 vertices [ ] = new Vec2 [ 3 ] ; vertices [ 0 ] = new Vec2 ( - 0.5f , 0.0f ) ; vertices [ 1 ] = new Vec2 ( 0.5f , 0.0f ) ; vertices [ 2 ] = new Vec2 ( 0.0f , 1.5f ) ; m_polygons [ 0 ] = new PolygonShape ( ) ; m_polygons [ 0 ] . set ( vertices , 3 ) ; } { Vec2 vertices [ ] = new Vec2 [ 3 ] ; vertices [ 0 ] = new Vec2 ( - 0.1f , 0.0f ) ; vertices [ 1 ] = new Vec2 ( 0.1f , 0.0f ) ; vertices [ 2 ] = new Vec2 ( 0.0f , 1.5f ) ; m_polygons [ 1 ] = new PolygonShape ( ) ; m_polygons [ 1 ] . set ( vertices , 3 ) ; } { float w = 1.0f ; float b = w / ( 2.0f + MathUtils . sqrt ( 2.0f ) ) ; float s = MathUtils . sqrt ( 2.0f ) * b ; Vec2 vertices [ ] = new Vec2 [ 8 ] ; vertices [ 0 ] = new Vec2 ( 0.5f * s , 0.0f ) ; vertices [ 1 ] = new Vec2 ( 0.5f * w , b ) ; vertices [ 2 ] = new Vec2 ( 0.5f * w , b + s ) ; vertices [ 3 ] = new Vec2 ( 0.5f * s , w ) ; vertices [ 4 ] = new Vec2 ( - 0.5f * s , w ) ; vertices [ 5 ] = new Vec2 ( - 0.5f * w , b + s ) ; vertices [ 6 ] = new Vec2 ( - 0.5f * w , b ) ; vertices [ 7 ] = new Vec2 ( - 0.5f * s , 0.0f ) ; m_polygons [ 2 ] = new PolygonShape ( ) ; m_polygons [ 2 ] . set ( vertices , 8 ) ; } { m_polygons [ 3 ] = new PolygonShape ( ) ; m_polygons [ 3 ] . setAsBox ( 0.5f , 0.5f ) ; } { m_circle = new CircleShape ( ) ; m_circle . m_radius = 0.5f ; } { m_edge = new EdgeShape ( ) ; m_edge . set ( new Vec2 ( - 1.0f , 0.0f ) , new Vec2 ( 1.0f , 0.0f ) ) ; } m_bodyIndex = 0 ; m_angle = 0.0f ; m_mode = Mode . e_closest ; }
public void testConnFactoryWithoutOpFactory ( ) throws Exception { try { client = new MemcachedClient ( new DefaultConnectionFactory ( ) {
public JavaDStream < Row > getDStream ( ) throws Exception { Map < String , String > kafkaParams = Maps . newHashMap ( ) ; String brokers = config . getString ( BROKERS_CONFIG_NAME ) ; kafkaParams . put ( " metadata.broker.list " , brokers ) ; String topics = config . getString ( TOPICS_CONFIG_NAME ) ; Set < String > topicsSet = Sets . newHashSet ( topics . split ( Pattern . quote ( " , " ) ) ) ; String encoding = config . getString ( ENCODING_CONFIG_NAME ) ; addCustomParams ( kafkaParams ) ; Config translatorConfig = config . getConfig ( " translator " ) ; JavaStreamingContext jssc = Contexts . getJavaStreamingContext ( ) ; JavaDStream < Row > dStream = null ; if ( encoding . equals ( " string " ) ) { JavaPairDStream < String , String > stringDStream = KafkaUtils . createDirectStream ( jssc , String . class , String . class , StringDecoder . class , StringDecoder . class , kafkaParams , topicsSet ) ; dStream = stringDStream . flatMap ( new TranslateFunction < String > ( translatorConfig ) ) ; } else if ( encoding . equals ( " bytearray " ) ) { JavaPairDStream < byte [ ] , byte [ ] > byteArrayDStream = KafkaUtils . createDirectStream ( jssc , byte [ ] . class , byte [ ] . class , DefaultDecoder . class , DefaultDecoder . class , kafkaParams , topicsSet ) ; dStream = byteArrayDStream . flatMap ( new TranslateFunction < byte [ ] > ( translatorConfig ) ) ; } else { throw new RuntimeException ( " Invalid Kafka input encoding type. Valid types are 'string' and 'bytearray'. " ) ; } return dStream ; }
private CountDownLatch broadcastOp ( BroadcastOpFactory of , Collection < MemcachedNode > nodes , boolean checkShuttingDown ) { if ( checkShuttingDown & & shuttingDown ) { throw new IllegalStateException ( " Shutting down " ) ; } return conn . broadcastOperation ( of , nodes ) ; }
public void keysOnly ( ) { message . setFlags ( TapRequestFlag . KEYS_ONLY ) ; }
public void onUpdate ( RemoteViews views , Context context , AppWidgetManager appWidgetManager , int [ ] appWidgetIds ) { Log . v ( TAG , " Enter onUpdate " ) ; linkButtons ( context , views ) ; pushUpdate ( context , appWidgetIds , views ) ; Intent updateIntent = new Intent ( context , WidgetHelperService . class ) ; updateIntent . setAction ( WidgetHelperService . CMD_UPDATE_WIDGET ) ; updateIntent . putExtra ( AppWidgetManager . EXTRA_APPWIDGET_IDS , appWidgetIds ) ; context . startService ( updateIntent ) ; }
abstract public int size ( ) ; abstract public E takeOut ( boolean removeFromNameTable ) ; abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } protected int forgetRate ( ) { if ( forgettingRate ! = null ) { return forgettingRate . get ( ) ; } return - 1 ; } protected void forget ( final E x ) { int r = forgetRate ( ) ; if ( r > 0 ) { BudgetFunctions . forget ( x . budget , r , RELATIVE_THRESHOLD ) ; } } public final boolean putBack ( final E oldItem , final boolean insertIntoNameTable ) { forget ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public final boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( boolean forget ) { final E x = takeOut ( false ) ; if ( x ! = null ) { if ( forget ) { forget ( x ) ; } boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else { return null ; } } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( CharSequence key ) ; }
public Data copy ( ) { final Set < O > listCopy = new TreeSet < O > ( ) ; listCopy . addAll ( set ) ; return new IntervalData < O > ( start , end , listCopy ) ; }
public void write ( final String text ) throws IOException { final BufferedWriter aWriter = getWriter ( ) ; aWriter . write ( text ) ; aWriter . flush ( ) ; }
private void add ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > prev = tail ; prev . next = node ; node . prev = prev ; tail = node ; } size + + ; }
public static boolean include ( String filename ) { return filename . startsWith ( " nal1.0.nal " ) ; }
public void test1 ( ) { int N = 8 ; double [ ] x = randomArray ( N , 1.0 , 0 ) ; double [ ] y = randomArray ( N , 1.0 , 0 ) ; NAR n = new NAR ( ) ; new TextOutput ( n , System . out ) ; new Number1DInput ( n , " x " , x ) ; new Number1DInput ( n , " y " , y ) ; n . run ( 5000 ) ; Assert . assertTrue ( true ) ; }
public String [ ] getCoverUrl ( AlbumInfo albumInfo ) throws Exception { String response ; JSONObject jsonRootObject ; JSONArray jsonArray ; String coverUrl ; JSONObject jsonObject ; try { response = executeGetRequest ( " https://itunes.apple.com/search?term= " + albumInfo . getAlbum ( ) + "   " + albumInfo . getArtist ( ) + " &limit=5&media=music&entity=album " ) ; jsonRootObject = new JSONObject ( response ) ; jsonArray = jsonRootObject . getJSONArray ( " results " ) ; for ( int i = 0 ; i < jsonArray . length ( ) ; i + + ) { jsonObject = jsonArray . getJSONObject ( i ) ; coverUrl = jsonObject . getString ( " artworkUrl100 " ) ; if ( coverUrl ! = null ) { return new String [ ] { coverUrl . replace ( " 100x100 " , " 600x600 " ) } ; } } } catch ( final Exception e ) { Log . e ( TAG , " Failed to get cover URL from  " + getName ( ) , e ) ; } return new String [ 0 ] ; }
public void receivedStatus ( OperationStatus status ) { rv . set ( status . isSuccess ( ) , status ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . NSPrefix1 p , A arg ) { return visitDefault ( p , arg ) ; } public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . NSPrefix2 p , A arg ) { return visitDefault ( p , arg ) ; }
EChange removePartner ( @Nullable String sPartnerName ) throws OpenAS2Exception ; @Nullable IStringMap getPartnerOfName ( @Nullable String sPartnerName ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllPartnerNames ( ) ; @Nonnull @ReturnsMutableCopy List < ? extends IStringMap > getAllPartners ( ) ; @Nonnull IPartnerMap getPartnerMap ( ) ; void addPartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nonnull EChange removePartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nonnull Partnership getPartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nullable Partnership getPartnershipByName ( @Nullable String sName ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllPartnershipNames ( ) ; @Nonnull @ReturnsMutableCopy List < Partnership > getAllPartnerships ( ) ; @Nonnull IPartnershipMap getPartnershipMap ( ) ; void updatePartnership ( @Nonnull IMessage aMsg , boolean bOverwrite ) throws OpenAS2Exception ; void updatePartnership ( @Nonnull IMessageMDN aMdn , boolean bOverwrite ) throws OpenAS2Exception ; }
ObserveOperation observe ( String key , long casId , int index , ObserveOperation . Callback operationCallback ) ; FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; ReplicaGetOperation replicaGet ( String key , int index , ReplicaGetOperation . Callback callback ) ; ReplicaGetsOperation replicaGets ( String key , int index , ReplicaGetsOperation . Callback callback ) ; GetlOperation getl ( String key , int exp , GetlOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; StatsOperation keyStats ( String key , StatsOperation . Callback cb ) ; MutatorOperation mutate ( Mutator m , String key , long by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; TouchOperation touch ( String key , int expiration , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
protected String make_declaration ( String labelname , String stack_type , int offset ) { String ret ; if ( emit . lr_values ( ) ) ret = " \ t \ tint  " + labelname + " left = ((java_cup.runtime.Symbol) " + emit . pre ( " stack " ) + " .elementAt( " + emit . pre ( " top " ) + " - " + offset + " )).left; \ n " + " \ t \ tint  " + labelname + " right = ((java_cup.runtime.Symbol) " + emit . pre ( " stack " ) + " .elementAt( " + emit . pre ( " top " ) + " - " + offset + " )).right; \ n " ; else ret = " " ; return ret + " \ t \ t " + stack_type + "   " + labelname + "  = ( " + stack_type + " )(( " + " java_cup.runtime.Symbol)  " + emit . pre ( " stack " ) + " .elementAt( " + emit . pre ( " top " )
public DeleteOperation delete ( String key , long cas , DeleteOperation . Callback cb ) { throw new UnsupportedOperationException ( " Delete with CAS is not supported  " + " for ASCII protocol " ) ;
public void applySubstitute ( HashMap < Term , Term > subs ) { Term t1 , t2 ; for ( int i = 0 ; i < size ( ) ; i + + ) { t1 = componentAt ( i ) ; t2 = subs . get ( t1 ) ; if ( t2 ! = null ) { components . set ( i , ( Term ) t2 . clone ( ) ) ; } else if ( t1 instanceof CompoundTerm ) { ( ( CompoundTerm ) t1 ) . applySubstitute ( subs ) ; } } if ( this . isCommutative ( ) ) { TreeSet < Term > s = new TreeSet < > ( components ) ; components = new ArrayList < > ( s ) ; } name = makeName ( ) ; }
public ConfigParser < Config , Config > createParser ( ) { throw new UnsupportedOperationException ( " In memory configurations aren't mean to be  " + " parsed. " ) ;
public void missingPath ( ) throws Exception { config = ConfigFactory . parseString ( FileSystemInput . PATH_CONFIG + " : null " ) . withFallback ( config ) ; FileSystemInput fileSystemInput = new FileSystemInput ( ) ; fileSystemInput . configure ( config ) ; }
public static Nar LoadFromFile ( final String name ) throws IOException , ClassNotFoundException , IllegalAccessException , ParseException , ParserConfigurationException , SAXException , NoSuchMethodException , InstantiationException , InvocationTargetException { final FileInputStream inStream = new FileInputStream ( name ) ; final ObjectInputStream stream = new ObjectInputStream ( inStream ) ; final Nar ret = ( Nar ) stream . readObject ( ) ; ret . memory . event = new EventEmitter ( ) ; ret . plugins = new ArrayList < > ( ) ; ret . sensoryChannels = new HashMap < > ( ) ; List < Plugin > pluginsToAdd = ConfigReader . loadParamsFromFileAndReturnPlugins ( ret . loadedFromResources , ret . usedConfigFilePath , ret , ret . narParameters ) ; for ( Plugin p : pluginsToAdd ) { ret . addPlugin ( p ) ; } return ret ; }
public abstract void setParameter ( @Nonnull String sKey , @Nonnull String sValue ) throws AS2InvalidParameterException ; @Nullable public abstract String getParameter ( @Nonnull String sKey ) throws AS2InvalidParameterException ; public void setParameters ( @Nonnull final String sEncodedParams ) throws AS2InvalidParameterException { final StringTokenizer aParams = new StringTokenizer ( sEncodedParams , " =, " , false ) ; while ( aParams . hasMoreTokens ( ) ) { final String sKey = aParams . nextToken ( ) . trim ( ) ; if ( ! aParams . hasMoreTokens ( ) ) throw new AS2InvalidParameterException ( " Invalid value " , this , sKey , null ) ; final String sValue = aParams . nextToken ( ) ; setParameter ( sKey , sValue ) ; } } public void setParameters ( @Nullable final String sFormat , @Nullable final String sDelimiters , @Nonnull final String sValue ) throws AS2Exception { final ICommonsList < String > aKeys = StringHelper . getExploded ( ',' , sFormat ) ; final StringTokenizer aValueTokens = new StringTokenizer ( sValue , sDelimiters , false ) ; for ( final String sKey : aKeys ) { if ( ! aValueTokens . hasMoreTokens ( ) ) throw new AS2Exception ( " Invalid value: Format= " + sFormat + " , value= " + sValue ) ; if ( sKey . length ( ) > 0 ) setParameter ( sKey , aValueTokens . nextToken ( ) ) ; } } @Nonnull public String format ( @Nullable final String sFormat ) throws AS2InvalidParameterException { if ( LOGGER . isTraceEnabled ( ) ) LOGGER . trace ( " Formatting ' " + sFormat + " ' " ) ; final StringBuilder aSB = new StringBuilder ( ) ; if ( sFormat ! = null ) for ( int nNext = 0 ; nNext < sFormat . length ( ) ; + + nNext ) { int nPrev = nNext ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) { aSB . append ( sFormat . substring ( nPrev , sFormat . length ( ) ) ) ; break ; } if ( nNext > nPrev ) { aSB . append ( sFormat . substring ( nPrev , nNext ) ) ; } nPrev = nNext + 1 ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) throw new AS2InvalidParameterException ( " Invalid key (missing closing $) " ) ; if ( nNext = = nPrev ) aSB . append ( '$' ) ; else { final String sParameterName = sFormat . substring ( nPrev , nNext ) ; aSB . append ( getParameter ( sParameterName ) ) ; } } if ( LOGGER . isTraceEnabled ( ) ) LOGGER . trace ( " Formatted value is now ' " + aSB . toString ( ) + " ' " ) ; return aSB . toString ( ) ; } @Override public String toString ( ) { return new ToStringGenerator ( this ) . getToString ( ) ; } }
public Term clone ( ) { Term t = new Term ( ) ; if ( term_indices ! = null ) { t . term_indices = term_indices . clone ( ) ; t . index_variable = index_variable ; } t . name = name ( ) ; return t ; }
public void run ( ) { while ( true ) { if ( logging )
private static MPDCommand nextCommand ( ) { return new MPDCommand ( MPDCommand . MPD_CMD_NEXT ) ; }
public boolean doesSubStringExist ( C sequence ) { char [ ] chars = sequence . toString ( ) . toCharArray ( ) ; int length = chars . length ; PatriciaTrie . Node < C > current = tree . root ; int index = 0 ; for ( int i = 0 ; i < length ; i + + ) { int innerStringLength = ( current . string ! = null ) ? current . string . length ( ) : 0 ; char c = chars [ i ] ; if ( innerStringLength > index ) { boolean inThis = current . partOfThis ( c , index + + ) ; if ( ! inThis ) return false ; } else { int idx = current . childIndex ( c ) ; if ( idx < 0 ) return false ; current = current . getChild ( idx ) ; index = 1 ; } } return true ; }
public void step ( final int cycles ) { if ( thread ! = null ) { stepLater ( cycles ) ; return ; } running = true ; for ( int i = 0 ; i < cycles ; i + + ) { tick ( ) ; } running = false ; }
static void abdIndCom ( final Term term1 , final Term term2 , final Sentence sentence1 , final Sentence sentence2 , final int figure , final NAL nal ) { if ( Statement . invalidStatement ( term1 , term2 ) | | Statement . invalidPair ( term1 , term2 ) ) { return ; } int order1 = sentence1 . term . getTemporalOrder ( ) ; int order2 = sentence2 . term . getTemporalOrder ( ) ; int order = abdIndComOrder ( order1 , order2 ) ; if ( order = = ORDER_INVALID ) { return ; } Statement taskContent = ( Statement ) sentence1 . term ; TruthValue truth1 = null ; TruthValue truth2 = null ; TruthValue truth3 = null ; BudgetValue budget1 , budget2 , budget3 ; TruthValue value1 = sentence1 . truth ; TruthValue value2 = sentence2 . truth ; if ( sentence1 . isQuestion ( ) ) { budget1 = BudgetFunctions . backward ( value2 , nal ) ; budget2 = BudgetFunctions . backwardWeak ( value2 , nal ) ; budget3 = BudgetFunctions . backward ( value2 , nal ) ; } else if ( sentence1 . isQuest ( ) ) { budget1 = BudgetFunctions . backwardWeak ( value2 , nal ) ; budget2 = BudgetFunctions . backward ( value2 , nal ) ; budget3 = BudgetFunctions . backwardWeak ( value2 , nal ) ; } else { if ( sentence1 . isGoal ( ) ) { truth1 = TruthFunctions . desireStrong ( value1 , value2 ) ; truth2 = TruthFunctions . desireWeak ( value2 , value1 ) ; truth3 = TruthFunctions . desireStrong ( value1 , value2 ) ; } else { truth1 = TruthFunctions . abduction ( value1 , value2 ) ; truth2 = TruthFunctions . abduction ( value2 , value1 ) ; truth3 = TruthFunctions . comparison ( value1 , value2 ) ; } budget1 = BudgetFunctions . forward ( truth1 , nal ) ; budget2 = BudgetFunctions . forward ( truth2 , nal ) ; budget3 = BudgetFunctions . forward ( truth3 , nal ) ; } nal . doublePremiseTask ( Statement . make ( taskContent , term1 , term2 , order ) , truth1 , budget1 , false , false ) ; nal . doublePremiseTask ( Statement . make ( taskContent , term2 , term1 , reverseOrder ( order ) ) , truth2 , budget2 , false , false ) ; nal . doublePremiseTask ( Statement . makeSym ( taskContent , term1 , term2 , order ) , truth3 , budget3 , false , false ) ; if ( Parameters . BREAK_NAL_HOL_BOUNDARY & & order1 = = order2 & & taskContent . isHigherOrderStatement ( ) ) { / *
public void startServiceInfoResolver ( ServiceInfoImpl info ) ; public void startServiceResolver ( String type ) ; public void startTypeResolver ( ) ; }
@Override public void onFinished ( ) { concepts . putIn ( currentConcept ) ; }
public void addInput ( String text ) { text = text . trim ( ) ; final Narsese narsese = new Narsese ( this ) ; if ( addMultiLineInput ( text ) ) { return ; } if ( text . startsWith ( " \ ' " ) | | text . startsWith ( " // " ) | | text . trim ( ) . length ( ) < = 0 ) return ; if ( addCommand ( text ) ) { return ; } final Task task ; try { task = narsese . parseTask ( text ) ; } catch ( final InvalidInputException e ) { throw new IllegalStateException ( " Invalid input:  " + text , e ) ; } final Term t = task . getTerm ( ) ; if ( t ! = null & & t instanceof Inheritance ) { final Term predicate = ( ( Inheritance ) t ) . getPredicate ( ) ; if ( this . sensoryChannels . containsKey ( predicate ) ) { final Inheritance inh = ( Inheritance ) task . sentence . term ; final SetExt subj = ( SetExt ) inh . getSubject ( ) ; if ( subj . term [ 0 ] . term_indices = = null ) { final String variable = subj . toString ( ) . split ( " \\ [ " ) [ 0 ] ; final String [ ] vals = subj . toString ( ) . split ( " \\ [ " ) [ 1 ] . split ( " \\ ] " ) [ 0 ] . split ( " , " ) ; final double height = Double . parseDouble ( vals [ 0 ] ) ; final double width = Double . parseDouble ( vals [ 1 ] ) ; final int wval = ( int ) Math . round ( ( width + 1.0f ) / 2.0f * ( this . sensoryChannels . get ( predicate ) . width - 1 ) ) ; final int hval = ( int ) Math . round ( ( ( height + 1.0f ) / 2.0f * ( this . sensoryChannels . get ( predicate ) . height - 1 ) ) ) ; final String ev = task . sentence . isEternal ( ) ? "   " : "  :|:  " ; final String newInput = " < " + variable + " [ " + hval + " , " + wval + " ]} -->  " + predicate + " > " + task . sentence . punctuation + ev + task . sentence . truth . toString ( ) ; this . emit ( OutputHandler . IN . class , task ) ; this . addInput ( newInput ) ; return ; } this . sensoryChannels . get ( predicate ) . addInput ( task , this ) ; return ; } } this . memory . inputTask ( this , task ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmEquiv p , A arg ) { return visitDefault ( p , arg ) ; } public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmImpPred p , A arg ) { return visitDefault ( p , arg ) ; }
public void actionPerformed ( ActionEvent evt ) { JEditTextArea textArea = getTextArea ( evt ) ; String str = evt . getActionCommand ( ) ; int repeatCount = textArea . getInputHandler ( ) . getRepeatCount ( ) ; if ( textArea . isEditable ( ) ) {
public String toString ( ) { final StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Cost =  " ) . append ( cost ) . append ( " \ n " ) ; for ( Edge < T > e : path ) builder . append ( " \ t " ) . append ( e ) ; return builder . toString ( ) ; }
protected MimeBodyPart secure ( final IMessage aMsg ) throws Exception { MimeBodyPart aDataBP = aMsg . getData ( ) ; final Partnership aPartnership = aMsg . getPartnership ( ) ; final boolean bEncrypt = aPartnership . getAttribute ( CPartnershipIDs . PA_ENCRYPT ) ! = null ; final boolean bSign = aPartnership . getAttribute ( CPartnershipIDs . PA_SIGN ) ! = null ; if ( bEncrypt | | bSign ) { final ICertificateFactory aCertFactory = getSession ( ) . getCertificateFactory ( ) ; if ( bSign ) { final X509Certificate aSenderCert = aCertFactory . getCertificate ( aMsg , Partnership . PTYPE_SENDER ) ; final PrivateKey aSenderKey = aCertFactory . getPrivateKey ( aMsg , aSenderCert ) ; final String sAlgorithm = aPartnership . getAttribute ( CPartnershipIDs . PA_SIGN ) ; aDataBP = AS2Util . getCryptoHelper ( ) . sign ( aDataBP , aSenderCert , aSenderKey , sAlgorithm ) ; final DataHistoryItem aHistoryItem = new DataHistoryItem ( aDataBP . getContentType ( ) ) ; aMsg . getHistory ( ) . addItem ( aHistoryItem ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " signed data " + aMsg . getLoggingText ( ) ) ; } if ( bEncrypt ) { final String sAlgorithm = aPartnership . getAttribute ( CPartnershipIDs . PA_ENCRYPT ) ; final X509Certificate aReceiverCert = aCertFactory . getCertificate ( aMsg , Partnership . PTYPE_RECEIVER ) ; aDataBP = AS2Util . getCryptoHelper ( ) . encrypt ( aDataBP , aReceiverCert , sAlgorithm ) ; final DataHistoryItem aHistoryItem = new DataHistoryItem ( aDataBP . getContentType ( ) ) ; aMsg . getHistory ( ) . addItem ( aHistoryItem ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " encrypted data " + aMsg . getLoggingText ( ) ) ; } } return aDataBP ; }
protected synchronized boolean load ( ) { File file = new File ( mFilesDir , getFilename ( ) + ( GZIP ? " .gz " : " " ) ) ; if ( ! file . exists ( ) ) { return false ; } Log . d ( TAG , " Loading  " + file ) ; ObjectInputStream restore ; boolean loaded_ok = false ; try { if ( GZIP ) { restore = new ObjectInputStream ( new GZIPInputStream ( new FileInputStream ( file ) ) ) ; } else { restore = new ObjectInputStream ( new FileInputStream ( file ) ) ; } mLastUpdate = ( Date ) restore . readObject ( ) ; mAlbumDetails = ( HashMap < String , AlbumDetails > ) restore . readObject ( ) ; mAlbumSet = ( Set < List < String > > ) restore . readObject ( ) ; restore . close ( ) ; makeUniqueAlbumSet ( ) ; loaded_ok = true ; } catch ( final FileNotFoundException ignored ) { } catch ( final Exception e ) { Log . e ( TAG , " Exception. " , e ) ; } if ( loaded_ok ) { Log . d ( TAG , cacheInfo ( ) ) ; } else { Log . d ( TAG , " Error on load " ) ; } return loaded_ok ; }
public void collectData ( final StatsSession session , final DataSet dataSet ) { List < Range > ranges = rangeList . getRanges ( ) ; final int rangeCount = ranges . size ( ) ; for ( int i = 0 ; i < rangeCount ; i + + ) { dataSet . setField ( ranges . get ( i ) . getName ( ) , hits [ i ] . get ( ) ) ;
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitURI p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitInt p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitDbl p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitString p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitTrue p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitFalse p , A arg ) ; } }
GetOperation get ( String key , GetOperation . Callback callback ) ; GetlOperation getl ( String key , int exp , GetlOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; StatsOperation keyStats ( String key , StatsOperation . Callback cb ) ; MutatorOperation mutate ( Mutator m , String key , long by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; KeyedOperation touch ( String key , int expiration , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
public void store ( String cacheEntryName , InputStream inputStream , long expirationDate ) { try { InputStreamReader reader = new InputStreamReader ( inputStream ) ;
public void testAgeRangeInt ( ) { StructType schema = new StructType ( new StructField [ ] { new StructField ( " name " , DataTypes . StringType , false , Metadata . empty ( ) ) , new StructField ( " nickname " , DataTypes . StringType , false , Metadata . empty ( ) ) , new StructField ( " age " , DataTypes . IntegerType , false , Metadata . empty ( ) ) , new StructField ( " candycrushscore " , DataTypes . createDecimalType ( ) , false , Metadata . empty ( ) ) } ) ; Map < String , Object > configMap = new HashMap < > ( ) ; configMap . put ( RangeRowRule . FIELDS_CONFIG , Lists . newArrayList ( " age " ) ) ; configMap . put ( RangeRowRule . FIELD_TYPE_CONFIG , " int " ) ; configMap . put ( RangeRowRule . RANGE_CONFIG , Lists . newArrayList ( 0 , 105 ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; RangeRowRule rule = new RangeRowRule ( ) ; assertNoValidationFailures ( rule , config ) ; rule . configure ( config ) ; rule . configureName ( " agerange " ) ; Row row1 = new RowWithSchema ( schema , " Ian " , " Ian " , 34 , new BigDecimal ( " 0.00 " ) ) ; assertTrue ( " Row should pass rule " , rule . check ( row1 ) ) ; Row row2 = new RowWithSchema ( schema , " Webster1 " , " Websta1 " , 110 , new BigDecimal ( " 450.10 " ) ) ; assertFalse ( " Row should not pass rule " , rule . check ( row2 ) ) ; Row row3 = new RowWithSchema ( schema , " " , " Ian1 " , 106 , new BigDecimal ( " 450.10 " ) ) ; assertFalse ( " Row should not pass rule " , rule . check ( row3 ) ) ; Row row4 = new RowWithSchema ( schema , " First Last " , " Ian Last " , 105 , new BigDecimal ( " 450.10 " ) ) ; assertTrue ( " Row should pass rule " , rule . check ( row4 ) ) ; }
protected OutputStream openPendingInfoStreamForWriting ( @Nonnull final AS2Message aMsg , @Nonnull @Nonempty final String sMsgFilename ) throws AS2Exception { final String sPendingMDNInfoFolder = AS2IOHelper . getSafeFileAndFolderName ( getSession ( ) . getMessageProcessor ( ) . getPendingMDNInfoFolder ( ) ) ; if ( StringHelper . hasNoText ( sPendingMDNInfoFolder ) ) { LOGGER . error ( " The pending MDN info folder is not properly configured. Cannot store async MDN data. " ) ; return null ; } final File aPendingInfoFile = new File ( sPendingMDNInfoFolder + FilenameHelper . UNIX_SEPARATOR_STR + sMsgFilename ) ; LOGGER . info ( " Saving original MIC and message id information into file ' " + aPendingInfoFile . getAbsolutePath ( ) + " ' " + aMsg . getLoggingText ( ) ) ; return FileHelper . getOutputStream ( aPendingInfoFile ) ; }
public Stm visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmConj p , A arg ) { Stm stm_1 = p . stm_1 . accept ( this , arg ) ; Stm stm_2 = p . stm_2 . accept ( this , arg ) ; return new com . googlecode . opennars . parser . loan . Loan . Absyn . StmConj ( stm_1 , stm_2 ) ; }
protected void queryRange ( AxisAlignedBoundingBox range , List < XY > pointsInRange ) { if ( ! aabb . intersectsBox ( range ) ) return ; if ( isLeaf ( ) ) { for ( XY xyPoint : points ) { if ( range . containsPoint ( xyPoint ) ) pointsInRange . add ( xyPoint ) ; } return ; } northWest . queryRange ( range , pointsInRange ) ; northEast . queryRange ( range , pointsInRange ) ; southWest . queryRange ( range , pointsInRange ) ; southEast . queryRange ( range , pointsInRange ) ; }
final public static Term make ( final Term [ ] argList , final Memory memory ) { return make ( argList , TemporalRules . ORDER_NONE , memory ) ; }
public boolean isRequestingMDN ( ) { final Partnership aPartnership = getPartnership ( ) ; final boolean bRequesting = aPartnership . getAttribute ( CPartnershipIDs . PA_AS2_MDN_TO ) ! = null | | aPartnership . getAttribute ( CPartnershipIDs . PA_AS2_MDN_OPTIONS ) ! = null ; if ( bRequesting ) return true ; final boolean bRequested = getHeader ( CAS2Header . HEADER_DISPOSITION_NOTIFICATION_TO ) ! = null | | getHeader ( CAS2Header . HEADER_DISPOSITION_NOTIFICATION_OPTIONS ) ! = null ; return bRequested ; }
default public void commit ( DataContainer d , Memory m ) { } public void setCyclesSinceLastUpdate ( long cyclesSinceLastUpdate ) ; abstract public void setActive ( boolean b ) ; }
public void event ( final Class channel , final Object . . . arg ) { if ( channel = = ConceptBeliefAdd . class ) { Concept c = ( Concept ) arg [ 0 ] ;
protected void markAsChanged ( ) throws OpenAS2Exception { } @Nonnull @OverridingMethodsMustInvokeSuper public Partnership getPartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { ValueEnforcer . notNull ( aPartnership , " Partnership " ) ; return m_aRWLock . readLockedThrowing ( ( IThrowingCallable < Partnership , OpenAS2Exception > ) ( ) - > { Partnership aRealPartnership = m_aPartnerships . getPartnershipByName ( aPartnership . getName ( ) ) ; if ( aRealPartnership = = null ) { aRealPartnership = m_aPartnerships . getPartnershipByID ( aPartnership . getAllSenderIDs ( ) , aPartnership . getAllReceiverIDs ( ) ) ; } if ( aRealPartnership = = null ) throw new PartnershipNotFoundException ( aPartnership ) ; return aRealPartnership ; } ) ; } @Nullable public Partnership getPartnershipByName ( @Nullable final String sName ) { return m_aRWLock . readLocked ( ( ) - > m_aPartnerships . getPartnershipByName ( sName ) ) ; } @Nonnull @ReturnsMutableCopy public ICommonsSet < String > getAllPartnershipNames ( ) { return m_aRWLock . readLocked ( ( ) - > m_aPartnerships . getAllPartnershipNames ( ) ) ; } @Nonnull @ReturnsMutableCopy public ICommonsList < Partnership > getAllPartnerships ( ) { return m_aRWLock . readLocked ( ( ) - > m_aPartnerships . getAllPartnerships ( ) ) ; } @Nonnull public IPartnershipMap getPartnershipMap ( ) { return m_aRWLock . readLocked ( ( ) - > m_aPartnerships ) ; } protected final void setPartnerships ( @Nonnull final PartnershipMap aPartnerships ) throws OpenAS2Exception { m_aRWLock . writeLockedThrowing ( ( ) - > { m_aPartnerships . setPartnerships ( aPartnerships ) ; markAsChanged ( ) ; } ) ; } @Nonnull public final EChange addPartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { return m_aRWLock . writeLockedThrowing ( ( ) - > { if ( m_aPartnerships . addPartnership ( aPartnership ) . isUnchanged ( ) ) return EChange . UNCHANGED ; markAsChanged ( ) ; return EChange . CHANGED ; } ) ; } @Nonnull public final EChange removePartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { return m_aRWLock . writeLockedThrowing ( ( ) - > { if ( m_aPartnerships . removePartnership ( aPartnership ) . isUnchanged ( ) ) return EChange . UNCHANGED ; markAsChanged ( ) ; return EChange . CHANGED ; } ) ; } public final void updatePartnership ( @Nonnull final IMessage aMsg , final boolean bOverwrite ) throws OpenAS2Exception { ValueEnforcer . notNull ( aMsg , " Message " ) ; final Partnership aPartnership = getPartnership ( aMsg . getPartnership ( ) ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Updating partnership  " + aPartnership ) ; aMsg . getPartnership ( ) . copyFrom ( aPartnership ) ; if ( bOverwrite ) { final String sSubject = aPartnership . getSubject ( ) ; if ( sSubject ! = null ) { aMsg . setSubject ( new MessageParameters ( aMsg ) . format ( sSubject ) ) ; } } } public final void updatePartnership ( @Nonnull final IMessageMDN aMdn , final boolean bOverwrite ) throws OpenAS2Exception { ValueEnforcer . notNull ( aMdn , " MessageMDN " ) ; final Partnership aPartnership = getPartnership ( aMdn . getPartnership ( ) ) ; aMdn . getPartnership ( ) . copyFrom ( aPartnership ) ; } @Override public String toString ( ) { return ToStringGenerator . getDerived ( super . toString ( ) ) . append ( " Partnerships " , m_aPartnerships ) . toString ( ) ; } }
public void testToRowValueBoolean ( ) { DataType field = DataTypes . BooleanType ; assertEquals ( " Invalid Boolean " , true , RowUtils . toRowValue ( true , field ) ) ; assertEquals ( " Invalid 'true' " , true , RowUtils . toRowValue ( " true " , field ) ) ; assertEquals ( " Invalid 'true' " , true , RowUtils . toRowValue ( " TrUe " , field ) ) ; assertEquals ( " Invalid 'false' " , false , RowUtils . toRowValue ( " false " , field ) ) ; assertEquals ( " Invalid 'false' " , false , RowUtils . toRowValue ( " FaLsE " , field ) ) ; try { RowUtils . toRowValue ( 123 , field ) ;
public static boolean simultaneous ( GenericRecord first , GenericRecord second , String timestampFieldName ) { return compareTimestamp ( first , second , timestampFieldName ) = = 0 ; }
public void testInitWithSingleFileAndExtension ( ) { writeSimpleFiles ( BASE_DIR , " txt " , 1 ) ; streamSource . init ( config , BASE_DIR + " /1.txt " , " txt " ) ; assertEquals ( " Size of filePaths is not correct. " , 1 , streamSource . getFilePathListSize ( ) , 0 ) ; String fn = streamSource . getFilePathAt ( 0 ) ; assertTrue ( " Incorrect file in filePaths. " , fn . equals ( BASE_DIR + " /1.txt " ) | | fn . equals ( hdfsURI + BASE_DIR + " 1.txt " ) ) ; }
private void shrink ( ) { int shrinkSize = array . length > > 1 ; T [ ] temp = ( T [ ] ) new Object [ shrinkSize ] ; int adjLast = lastIndex % array . length ; int endIndex = ( lastIndex > array . length ) ? array . length : lastIndex ; if ( adjLast < = firstIndex ) { System . arraycopy ( array , 0 , temp , array . length - firstIndex , adjLast ) ; } System . arraycopy ( array , firstIndex , temp , 0 , endIndex - firstIndex ) ; array = null ; array = temp ; lastIndex = ( lastIndex - firstIndex ) ; firstIndex = 0 ; }
private void jButton10ActionPerformed ( java . awt . event . ActionEvent evt ) { jButton10 . setText ( " X " ) ; }
private void applyGridBagLayout ( JScrollPane textScrollPane ) { GridBagLayout gridbag = new GridBagLayout ( ) ; GridBagConstraints c = new GridBagConstraints ( ) ; setLayout ( gridbag ) ; c . ipadx = 3 ; c . ipady = 3 ; c . insets = new Insets ( 5 , 5 , 5 , 5 ) ; c . fill = GridBagConstraints . BOTH ; c . gridwidth = GridBagConstraints . REMAINDER ; c . weightx = 1.0 ; c . weighty = 1.0 ; gridbag . setConstraints ( textScrollPane , c ) ; add ( textScrollPane ) ; c . weighty = 0.0 ; c . gridwidth = 1 ; gridbag . setConstraints ( valueLabel , c ) ; add ( valueLabel ) ; gridbag . setConstraints ( valueBar , c ) ; add ( valueBar ) ; gridbag . setConstraints ( playButton , c ) ; add ( playButton ) ; gridbag . setConstraints ( stopButton , c ) ; add ( stopButton ) ; gridbag . setConstraints ( closeButton , c ) ; add ( closeButton ) ; }
public void removeViewAt ( int index ) { throw new UnsupportedOperationException ( " removeViewAt(int) is not supported in AdapterView " ) ; }
public void onUpdate ( float frac , float smoothFrac ) { float f = 1f - smoothFrac ; final int firstVis = getFirstVisiblePosition ( ) ; View item = getChildAt ( mFirstPos - firstVis ) ; ViewGroup . LayoutParams lp ; int blank ; if ( mUseRemoveVelocity ) { float dt = ( float ) ( SystemClock . uptimeMillis ( ) - mStartTime ) / 1000 ; if ( dt = = 0 ) return ; float dx = mRemoveVelocityX * dt ; int w = getWidth ( ) ; mRemoveVelocityX + = ( mRemoveVelocityX > 0 ? 1 : - 1 ) * dt * w ; mFloatLocX + = dx ; mFloatLoc . x = ( int ) mFloatLocX ; if ( mFloatLocX < w & & mFloatLocX > - w ) { mStartTime = SystemClock . uptimeMillis ( ) ; doDragFloatView ( true ) ; return ; } } if ( item ! = null ) { if ( mFirstChildHeight = = - 1 ) { mFirstChildHeight = getChildHeight ( mFirstPos , item , false ) ; mFirstStartBlank = ( float ) ( item . getHeight ( ) - mFirstChildHeight ) ; } blank = Math . max ( ( int ) ( f * mFirstStartBlank ) , 1 ) ; lp = item . getLayoutParams ( ) ; lp . height = mFirstChildHeight + blank ; item . setLayoutParams ( lp ) ; } if ( mSecondPos ! = mFirstPos ) { item = getChildAt ( mSecondPos - firstVis ) ;
void onCorrect ( CorrectionAction action , List < String > path , Object incorrectValue , Object correctedValue ) ; } public enum CorrectionAction { ADD , REPLACE , REMOVE } private static final class ValueSpec { private final Supplier < ? > defaultValueSupplier ; private final Predicate < Object > validator ; private ValueSpec ( Object defaultValue , Predicate < Object > validator ) { this ( new DumbSupplier < > ( Objects . requireNonNull ( defaultValue , " The default value must not be null. " ) ) , validator ) ; } private ValueSpec ( Supplier < ? > defaultValueSupplier , Predicate < Object > validator ) { this . defaultValueSupplier = Objects . requireNonNull ( defaultValueSupplier , " The supplier of the default value must not be null. " ) ; this . validator = Objects . requireNonNull ( validator , " The validator must not be null. " ) ; } } private static final class DumbSupplier < T > implements Supplier < T > { private final T value ; private DumbSupplier ( T value ) { this . value = value ; } @Override public T get ( ) { return value ; } } }
public void stop ( ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPD mpd = app . oMPDAsyncHelper . oMPD ; try { mpd . stop ( ) ; } catch ( MPDServerException e ) { Logger . global . log ( Level . WARNING , e . getMessage ( ) ) ; } stopStreaming ( ) ; die ( ) ; }
public static < T extends Comparable < T > > T [ ] sort ( T [ ] unsorted ) { sort ( 0 , unsorted . length , unsorted ) ; return unsorted ; }
public InputStream getInputStream ( ) throws OpenAS2Exception , IOException { if ( m_aCloseableHttpResponse = = null ) throw new OpenAS2Exception ( " No response as message was yet sent " ) ; return m_aCloseableHttpResponse . getEntity ( ) . getContent ( ) ; }
public void unsetActivity ( Activity activity ) { connectionLocks . remove ( activity ) ; checkMonitorNeeded ( ) ; checkConnectionNeeded ( ) ; if ( currentActivity = = activity ) currentActivity = null ;
private static void decomposeCompound ( final CompoundTerm compound , final Term component , final Term term1 , final int index , final boolean compoundTask , final int order , final DerivationContext nal ) { if ( ( compound instanceof Statement ) | | ( compound instanceof ImageExt ) | | ( compound instanceof ImageInt ) ) { return ; } Term term2 = reduceComponents ( compound , component , nal . mem ( ) ) ; if ( term2 = = null ) { return ; } long delta = 0 ; while ( ( term2 instanceof Conjunction ) & & ( ( ( CompoundTerm ) term2 ) . term [ 0 ] instanceof Interval ) ) { final Interval interval = ( Interval ) ( ( CompoundTerm ) term2 ) . term [ 0 ] ; delta + = interval . time ; term2 = ( ( CompoundTerm ) term2 ) . setComponent ( 0 , null , nal . mem ( ) ) ; } final Task task = nal . getCurrentTask ( ) ; final Sentence sentence = task . sentence ; final Sentence belief = nal . getCurrentBelief ( ) ; final Statement oldContent = ( Statement ) task . getTerm ( ) ; final TruthValue v1 = compoundTask ? sentence . truth : belief . truth ; final TruthValue v2 = compoundTask ? belief . truth : sentence . truth ; final Term content = Statement . make ( oldContent , index = = 0 ? term1 : term2 , index = = 0 ? term2 : term1 , order ) ; if ( content = = null ) { return ; } TruthValue truth = null ; if ( index = = 0 ) { if ( oldContent instanceof Inheritance ) { truth = lookupTruthOrNull ( v1 , v2 , compound instanceof IntersectionExt , EnumType . REDUCECONJUNCTION , compound instanceof IntersectionInt , EnumType . REDUCEDISJUNCTION , compound instanceof SetInt & & component instanceof SetInt , EnumType . REDUCECONJUNCTION , compound instanceof SetExt & & component instanceof SetExt , EnumType . REDUCEDISJUNCTION ) ; if ( truth = = null & & compound instanceof DifferenceExt ) { if ( compound . term [ 0 ] . equals ( component ) ) { truth = reduceDisjunction ( v2 , v1 ) ; } else { truth = reduceConjunctionNeg ( v1 , v2 ) ; } } } else if ( oldContent instanceof Implication ) { if ( compound instanceof Conjunction ) { truth = reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof Disjunction ) { truth = reduceDisjunction ( v1 , v2 ) ; } } } else { if ( oldContent instanceof Inheritance ) { truth = lookupTruthOrNull ( v1 , v2 , compound instanceof IntersectionInt , EnumType . REDUCECONJUNCTION , compound instanceof IntersectionExt , EnumType . REDUCEDISJUNCTION , compound instanceof SetExt & & component instanceof SetExt , EnumType . REDUCECONJUNCTION , compound instanceof SetInt & & component instanceof SetInt , EnumType . REDUCEDISJUNCTION ) ; if ( truth = = null & & compound instanceof DifferenceInt ) { if ( compound . term [ 1 ] . equals ( component ) ) { truth = reduceDisjunction ( v2 , v1 ) ; } else { truth = reduceConjunctionNeg ( v1 , v2 ) ; } } } else if ( oldContent instanceof Implication ) { if ( compound instanceof Disjunction ) { truth = reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof Conjunction ) { truth = reduceDisjunction ( v1 , v2 ) ; } } } if ( truth ! = null ) { final BudgetValue budget = BudgetFunctions . compoundForward ( truth , content , nal ) ;
public List < String > listAlbumArtists ( Genre genre ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; List < String > response = mpdConnection . sendCommand ( MPD_CMD_LIST_TAG , MPD_TAG_ALBUM_ARTIST , MPD_TAG_GENRE , genre . getName ( ) ) ; ArrayList < String > result = new ArrayList < String > ( ) ; for ( String s : response ) { String name = s . substring ( " albumartist:  " . length ( ) ) ; if ( name . length ( ) > 0 ) result . add ( name ) ; } Collections . sort ( result ) ; return result ; }
public final void connect ( String server , int port , String password ) throws MPDServerException , UnknownHostException { InetAddress address = InetAddress . getByName ( server ) ; connect ( address , port , password ) ; }
public void propertyChange ( PropertyChangeEvent evt ) { automenta . vivisect . swing . property . propertysheet . Property prop = ( automenta . vivisect . swing . property . propertysheet . Property ) evt . getSource ( ) ; prop . writeToObject ( instance ) ;
public List < Album > getAlbums ( final Artist artist , final boolean sortByYear , final boolean trackCountNeeded , final boolean useAlbumArtist ) throws IOException , MPDException { final List < Album > albums ; if ( artist = = null ) { albums = getAllAlbums ( trackCountNeeded ) ; } else { final List < String > albumNames = listAlbums ( artist . getName ( ) , useAlbumArtist ) ; albums = new ArrayList < > ( albumNames . size ( ) ) ; if ( ! albumNames . isEmpty ( ) ) { for ( final String album : albumNames ) { albums . add ( new Album ( album , artist , useAlbumArtist ) ) ; } if ( ! useAlbumArtist ) { fixAlbumArtists ( albums ) ; } if ( trackCountNeeded | | sortByYear ) { getAlbumDetails ( albums , sortByYear ) ; } if ( ! sortByYear ) { addAlbumPaths ( albums ) ; } Collections . sort ( albums ) ; } } return albums ; }
public static Rope build ( final char [ ] sequence ) { return new CharArrayRope ( sequence ) ; }
String getFilename ( ) ; default void setPassword ( @Nonnull final char [ ] aPassword ) { setPassword ( new String ( aPassword ) ) ; } void setPassword ( @Nullable String sPassword ) ; @Nullable char [ ] getPassword ( ) ; void setSaveChangesToFile ( boolean bSaveChangesToFile ) ; boolean isSaveChangesToFile ( ) ; default void load ( ) throws AS2Exception { load ( getFilename ( ) , getPassword ( ) ) ; } default void load ( @Nonnull final String sFilename , @Nonnull final char [ ] aPassword ) throws AS2Exception { InputStream aFIS = null ; try { aFIS = KeyStoreHelper . getResourceProvider ( ) . getInputStream ( sFilename ) ; if ( aFIS = = null ) throw new AS2Exception ( " Failed to to open input stream from ' " + sFilename + " ' " ) ; } catch ( final RuntimeException ex ) { throw new AS2Exception ( " Failed to to open input stream from ' " + sFilename + " ' " , ex ) ; } load ( aFIS , aPassword ) ; } void load ( @Nonnull InputStream aIS , @Nonnull char [ ] aPassword ) throws AS2Exception ; default void save ( ) throws AS2Exception { save ( getFilename ( ) , getPassword ( ) ) ; } default void save ( @Nonnull final String sFilename , @Nonnull final char [ ] aPassword ) throws AS2Exception { final OutputStream fOut = FileHelper . getOutputStream ( new File ( sFilename ) , EAppend . TRUNCATE ) ; if ( fOut = = null ) throw new AS2Exception ( " Failed to to open output stream to ' " + sFilename + " ' " ) ; save ( fOut , aPassword ) ; } void save ( @Nonnull OutputStream aOS , @Nonnull char [ ] aPassword ) throws AS2Exception ; }
protected void rotateLeft ( Node < T > node ) { Position parentPosition = null ; Node < T > parent = node . parent ; if ( parent ! = null ) { if ( node . equals ( parent . lesser ) ) { parentPosition = Position . LEFT ; } else { parentPosition = Position . RIGHT ; } } Node < T > greater = node . greater ; node . greater = null ; Node < T > lesser = greater . lesser ; greater . lesser = node ; node . parent = greater ; node . greater = lesser ; if ( lesser ! = null ) lesser . parent = node ; if ( parent ! = null & & parentPosition ! = null ) { if ( parentPosition = = Position . LEFT ) {
void setHeaders ( InternetHeaders aHeaders ) ; InternetHeaders getHeaders ( ) ; void setHistory ( DataHistory aHistory ) ; DataHistory getHistory ( ) ; void setMessage ( IMessage aMessage ) ; IMessage getMessage ( ) ; void setMessageID ( String sMessageID ) ; String getMessageID ( ) ; void setPartnership ( Partnership aPartnership ) ; Partnership getPartnership ( ) ; void setText ( String sText ) ; String getText ( ) ; void addHeader ( String sKey , String sValue ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; }
public CharSequence toString ( NAR nar , boolean showStamp ) { CharSequence contentName = content . name ( ) ; final long t = nar . memory . getTime ( ) ; final String tenseString = ( ( punctuation = = Symbols . JUDGMENT_MARK ) | | ( punctuation = = Symbols . QUESTION_MARK ) ) ? stamp . getTense ( t ) : " " ; final String truthString = ( truth ! = null ) ? truth . toStringBrief ( ) : null ; CharSequence stampString = showStamp ? stamp . name ( ) : null ; int stringLength = contentName . length ( ) + tenseString . length ( ) + 1 + 1 ; if ( truth ! = null ) { stringLength + = truthString . length ( ) ; } if ( showStamp ) { stringLength + = stampString . length ( ) ; } final TextBuilder buffer = new TextBuilder ( stringLength ) . append ( contentName ) . append ( contentName ) . append ( punctuation ) ; if ( tenseString . length ( ) > 0 ) buffer . append ( ' ' ) . append ( tenseString ) ; if ( truth ! = null ) buffer . append ( ' ' ) . append ( truthString ) ; if ( showStamp ) buffer . append ( ' ' ) . append ( stampString ) ; return buffer ; }
public int hashCode ( ) { return this . getListener ( ) . hashCode ( ) ; }
public boolean contains ( C key ) { if ( root = = null ) return false ; Node < C > n = root ; int length = ( key . length ( ) - 1 ) ; for ( int i = 0 ; i < = length ; i + + ) { char c = key . charAt ( i ) ; int index = n . childIndex ( c ) ; if ( index > = 0 ) { n = n . getChild ( index ) ; } else { return false ; } } return ( n . string ! = null ) ; }
public final boolean hasWriteOp ( ) { return ! ( optimizedOp = = null & & writeQ . isEmpty ( ) ) ; }
void setContentType ( @Nullable String sContentType ) ; @Nullable String getContentDisposition ( ) ; void setContentDisposition ( @Nullable String sContentDisposition ) ; @Nullable String getSubject ( ) ; void setSubject ( @Nullable String sSubject ) ; @Nullable MimeBodyPart getData ( ) ; void setData ( @Nonnull MimeBodyPart aData ) ; @Nullable IMessageMDN getMDN ( ) ; void setMDN ( @Nullable IMessageMDN aMDN ) ; @Nonnull @Nonempty String getLoggingText ( ) ; String getProtocol ( ) ; boolean isRequestingMDN ( ) ; boolean isRequestingAsynchMDN ( ) ; }
public int compareTo ( Number o ) { return ( new java . lang . Long ( value ) ) . compareTo ( o . longValue ( ) ) ; }
public double reward ( ) { double dx = abs ( x - lastX ) ; double dy = abs ( y - lastY ) ; lastX = x ; lastY = y ; return dx + dy ; }
public void chainRemove ( final Term t ) { if ( t = = null ) throw new RuntimeException ( " Chain must contain non-null items " ) ; if ( chainIsNullOrEmpty ( ) ) return ; ensureChain ( ) ; derivationChain . remove ( t ) ; name = null ; }
private void addToSubtree ( Node subtreeRoot , Node node ) { addAsBinarySearchTree ( subtreeRoot , node ) ; System . out . println ( " Added  " + node . key + " \ n " + this . toString ( ) ) ; heapify ( node ) ; System . out . println ( " Heapify  " + node . key + " \ n " + this . toString ( ) ) ; }
public static < T extends Comparable < T > > boolean testTree ( ITree < T > tree , Class < T > type , String name , Integer [ ] data , Integer _invalid ) { for ( int i = 0 ; i < data . length ; i + + ) { Integer value = data [ i ] ; T item = Utils . parseT ( value , type ) ; boolean added = tree . add ( item ) ; if ( ! tree . validate ( ) | | ( tree . size ( ) ! = i + 1 ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( tree ) ; return false ; } if ( ! added | | ! tree . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists but has been added. " ) ; Utils . handleError ( tree ) ; return false ; } } T invalidItem = Utils . parseT ( _invalid , type ) ; boolean contains = tree . contains ( invalidItem ) ; T removed = tree . remove ( invalidItem ) ; if ( contains | | removed ! = null ) { System . err . println ( name + "  invalidity check. contains= " + contains + "  removed= " + removed ) ; Utils . handleError ( tree ) ; return false ; } int size = tree . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { Integer value = data [ i ] ; T item = Utils . parseT ( value , type ) ; removed = tree . remove ( item ) ; if ( ! tree . validate ( ) | | ( tree . size ( ) ! = data . length - ( i + 1 ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( tree ) ; return false ; } if ( removed = = null | | tree . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists but it has been removed. " ) ; Utils . handleError ( tree ) ; return false ; } } int quarter = data . length / 4 ; int half = data . length / 2 ; for ( int i = 0 ; i < half ; i + + ) { Integer value = data [ i ] ; T item = Utils . parseT ( value , type ) ; boolean added = tree . add ( item ) ; if ( ! tree . validate ( ) | | ( tree . size ( ) ! = i + 1 ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( tree ) ; return false ; } if ( ! added | | ! tree . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists but has been added. " ) ; Utils . handleError ( tree ) ; return false ; } } for ( int i = ( half - 1 ) ; i > = quarter ; i - - ) { Integer value = data [ i ] ; T item = Utils . parseT ( value , type ) ; removed = tree . remove ( item ) ; if ( ! tree . validate ( ) | | ( tree . size ( ) ! = i ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( tree ) ; return false ; } if ( removed = = null | | tree . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists but it has been remove. " ) ; Utils . handleError ( tree ) ; return false ; } } for ( int i = quarter ; i < data . length ; i + + ) { Integer value = data [ i ] ; T item = Utils . parseT ( value , type ) ; boolean added = tree . add ( item ) ; if ( ! tree . validate ( ) | | ( tree . size ( ) ! = i + 1 ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( tree ) ; return false ; } if ( ! added | | ! tree . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists but has been added. " ) ; Utils . handleError ( tree ) ; return false ; } } for ( int i = data . length - 1 ; i > = 0 ; i - - ) { Integer value = data [ i ] ; T item = Utils . parseT ( value , type ) ; removed = tree . remove ( item ) ; if ( ! tree . validate ( ) | | ( tree . size ( ) ! = i ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( tree ) ; return false ; } if ( removed = = null | | tree . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists but it has been remove. " ) ; Utils . handleError ( tree ) ; return false ; } } if ( tree . size ( ) ! = 0 ) { System . err . println ( name + "  YIKES!! a size mismatch. " ) ; Utils . handleError ( tree ) ; return false ; } return true ; }
Certificate getCertificate ( String alias ) throws CertificateException ; void setCertificate ( String alias , Certificate cert ) throws CertificateException ; String getAlias ( Certificate cert ) throws CertificateException ; void removeCertificate ( String alias ) throws CertificateException ; void clearCertificates ( ) throws CertificateException ; Key getKey ( String alias , char [ ] password ) throws CertificateException ; void setKey ( String alias , Key key , char [ ] password ) throws CertificateException ; }
public void convertToRowMissingColumnNotNullable ( final @Mocked RowUtils utils ) throws Exception { Record record = new Record ( ) ; record . put ( " foo " , " one " ) ; StructType schema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " field1 " , DataTypes . StringType , false ) ) ) ; try { MorphlineUtils . convertToRow ( schema , record ) ; fail ( " Did not throw a RuntimeException " ) ; } catch ( Exception e ) { assertThat ( e . getMessage ( ) , JUnitMatchers . containsString ( " Error converting Record " ) ) ; } new Verifications ( ) { { RowUtils . toRowValue ( any , ( DataType ) any ) ; times = 0 ;
public boolean onPrepareActionMode ( final ActionMode mode , final Menu menu ) { actionMode = mode ; controller . setSortEnabled ( false ) ; return false ; }
public void testGetThreadWithIndexOutOfPoolSize ( ) { ThreadsEngine . setNumberThreads ( numThreads ) ; for ( int i = 0 ; i < numThreads + 3 ; i + + ) { assertNotNull ( " ExecutorService is not initialized correctly. " , ThreadsEngine . getThreadWithIndex ( i ) ) ;
public void configure ( Config config ) { Config outputConfig = config . getConfig ( OUTPUT_CONFIG ) ; this . randomOutput = ( RandomOutput ) OutputFactory . create ( outputConfig , true ) ; boolean allEventsEnabled = ConfigUtils . getOrElse ( config , LOG_ALL_EVENTS_CONFIG , false ) ; handledEventTypes = CoreEventTypes . getAllCoreEventTypes ( ) ; if ( ! allEventsEnabled ) { handledEventTypes . removeAll ( CoreEventTypes . getHighPerformanceImpactCoreEventTypes ( ) ) ;
private static void checkNotNull ( Field field , Object value ) { if ( value = = null ) { throw new InvalidValueException ( " Invalid null value for field %s " , field ) ;
public void testSubmitTopology ( ) { ThreadsEngine . submitTopology ( topology , delay , numThreads ) ; new Verifications ( ) { { topology . start ( delay ) ; times = 1 ; } } ; assertEquals ( " Number of threads is not set correctly. " , numThreads , ThreadsEngine . getNumberThreads ( ) , 0 ) ;
public void testDelimitedWithNullSerialization ( ) { StructType structType = SchemaUtils . structTypeFor ( Lists . newArrayList ( " field1 " , " field2 " , " field3 " ) , Lists . newArrayList ( " string " , " int " , " boolean " ) ) ; Row row = new RowWithSchema ( structType , null , 1 , false ) ; Map < String , String > configs = Maps . newHashMap ( ) ; configs . put ( DelimitedSerializer . FIELD_DELIMITER_CONFIG_NAME , " || " ) ; configs . put ( DelimitedSerializer . USE_FOR_NULL_CONFIG_NAME , " BANG " ) ; Serializer < Row > serializer = new DelimitedSerializer ( ) ; serializer . configure ( configs , false ) ; byte [ ] serialized = serializer . serialize ( " test " , row ) ; serializer . close ( ) ; assertEquals ( new String ( serialized ) , " BANG||1||false " ) ; }
private static boolean testJavaRedBlackStringTree ( ) { String aName = " Java's Red-Black Tree [String] " ; java . util . TreeSet < String > aCollection = new java . util . TreeSet < String > ( ) ; if ( ! testJavaCollection ( aCollection , Type . String , aName ) ) return false ; return true ; }
public abstract String getParameter ( @Nonnull String sKey ) throws InvalidParameterException ; public void setParameters ( @Nonnull final String sEncodedParams ) throws InvalidParameterException { final StringTokenizer aParams = new StringTokenizer ( sEncodedParams , " =, " , false ) ; while ( aParams . hasMoreTokens ( ) ) { final String sKey = aParams . nextToken ( ) . trim ( ) ; if ( ! aParams . hasMoreTokens ( ) ) throw new InvalidParameterException ( " Invalid value " , this , sKey , null ) ; final String sValue = aParams . nextToken ( ) ; setParameter ( sKey , sValue ) ; } } public void setParameters ( @Nullable final String sFormat , @Nullable final String sDelimiters , @Nonnull final String sValue ) throws OpenAS2Exception { final List < String > aKeys = StringHelper . getExploded ( ',' , sFormat ) ; final StringTokenizer aValueTokens = new StringTokenizer ( sValue , sDelimiters , false ) ; for ( final String sKey : aKeys ) { if ( ! aValueTokens . hasMoreTokens ( ) ) throw new OpenAS2Exception ( " Invalid value: Format= " + sFormat + " , value= " + sValue ) ; if ( sKey . length ( ) > 0 ) setParameter ( sKey , aValueTokens . nextToken ( ) ) ; } } @Nonnull public String format ( @Nonnull final String sFormat ) throws InvalidParameterException { if ( s_aLogger . isTraceEnabled ( ) ) s_aLogger . trace ( " Formatting ' " + sFormat + " ' " ) ; final StringBuilder aSB = new StringBuilder ( ) ; for ( int nNext = 0 ; nNext < sFormat . length ( ) ; + + nNext ) { int nPrev = nNext ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) { aSB . append ( sFormat . substring ( nPrev , sFormat . length ( ) ) ) ; break ; } if ( nNext > nPrev ) aSB . append ( sFormat . substring ( nPrev , nNext ) ) ; nPrev = nNext + 1 ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) throw new InvalidParameterException ( " Invalid key (missing closing $) " ) ; if ( nNext = = nPrev ) aSB . append ( '$' ) ; else aSB . append ( getParameter ( sFormat . substring ( nPrev , nNext ) ) ) ; } if ( s_aLogger . isTraceEnabled ( ) ) s_aLogger . trace ( " Formatted value is now ' " + aSB . toString ( ) + " ' " ) ; return aSB . toString ( ) ; } @Override public String toString ( ) { return new ToStringGenerator ( this ) . toString ( ) ; } }
public void paint ( Graphics g ) { super . paint ( g ) ; if ( ! painted ) { painted = true ;
public void update ( final boolean addNextPoint ) { if ( ! updateDoubleBuffer ( ) ) return ; Graphics2D g = ( Graphics2D ) image . getGraphics ( ) ; if ( renderHints = = null ) { renderHints = new RenderingHints ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; renderHints . put ( RenderingHints . KEY_RENDERING , RenderingHints . VALUE_RENDER_QUALITY ) ; renderHints . put ( RenderingHints . KEY_TEXT_ANTIALIASING , RenderingHints . VALUE_TEXT_ANTIALIAS_ON ) ; } g . setRenderingHints ( renderHints ) ; int width = getWidth ( ) ; int height = getHeight ( ) ; g . clearRect ( 0 , 0 , width , height ) ; int numCharts = data . size ( ) ; int y = yOffset ; int verticalPadding = 2 ; int h = ( int ) ( yScale * ( ( float ) height ) / ( ( float ) numCharts ) ) ; if ( xPoints = = null ) { xPoints = new int [ historySize + 2 ] ; yPoints = new int [ historySize + 2 ] ; } float xp = getWidth ( ) ; float dx = ( float ) Math . ceil ( ( ( float ) getWidth ( ) ) / ( ( float ) historySize ) ) ; for ( int i = 0 ; i < historySize ; i + + ) { xPoints [ i + 1 ] = ( int ) Math . round ( xp ) ; xp - = dx ; } xPoints [ 0 ] = xPoints [ 1 ] ; xPoints [ xPoints . length - 1 ] = xPoints [ xPoints . length - 2 ] = 0 ; for ( final String f : data . keySet ( ) ) { if ( y + h < 0 ) { y + = h ; continue ; } TimeSeriesChart ch = charts . get ( f ) ; if ( ch = = null ) { ch = addChart ( f ) ; } if ( addNextPoint ) { Object value = data . get ( f ) ; if ( value instanceof Double ) { ch . push ( ( ( Number ) value ) . doubleValue ( ) ) ; } if ( value instanceof Float ) { ch . push ( ( ( Number ) value ) . doubleValue ( ) ) ; } if ( value instanceof Integer ) { ch . push ( ( ( Number ) value ) . doubleValue ( ) ) ; } } g . setPaint ( ch . getColor ( ) ) ; double min = ch . min ; double max = ch . max ; if ( ! Double . isFinite ( min ) ) min = 0 ; if ( ! Double . isFinite ( max ) ) max = min ; double range = max - min ; if ( range = = 0 ) { range = 1 ; max + = 0.5 ; min - = 0.5 ; } int n = 0 ; double firstValue = 0 ; for ( Double d : ch ) { if ( n = = 0 ) firstValue = d ; d = ( d - min ) / ( range ) ; int p = h - ( int ) ( d * ( h - verticalPadding ) ) ; if ( p < 0 ) p = 0 ; if ( p > h ) p = h ; yPoints [ ( n + + ) + 1 ] = y + p ; } Arrays . fill ( yPoints , n , xPoints . length - 1 , y + h ) ; yPoints [ 0 ] = yPoints [ xPoints . length - 1 ] = y + h ; g . fillPolygon ( xPoints , yPoints , xPoints . length ) ; g . setPaint ( Color . WHITE ) ; g . setFont ( monofontLarge ) ; g . drawString ( f , 0 , y + 25 ) ; if ( h > 25 ) { g . setFont ( monofontSmall ) ; g . drawString ( "   current= " + firstValue + " , min= " + min + " , max= " + max , 0 , y + 20 + 18 ) ; } y + = h ; if ( y > = height ) break ; } Graphics localGraphics = getGraphics ( ) ; localGraphics . drawImage ( image , 0 , 0 , null ) ; g . dispose ( ) ; localGraphics . dispose ( ) ;
protected List < Task > execute ( nars . operator . Operation operation , Term [ ] args , Memory memory ) { if ( args . length ! = 3 ) { return null ; } Term prologInterpreterKey = args [ 0 ] ; String theoryName = args [ 1 ] . name ( ) . toString ( ) ; String theoryPath = PrologQueryOperator . getStringOfTerm ( args [ 2 ] ) ; Prolog prologInterpreter = PrologTheoryUtility . getOrCreatePrologContext ( prologInterpreterKey , context ) ; BooleanHolder theoryInCache = new BooleanHolder ( false ) ; CachedTheory foundCachedTheory = context . getCachedTheoryIfCached ( theoryName , theoryInCache ) ; String theoryContent ; if ( theoryInCache . value ) { theoryContent = foundCachedTheory . content ; } else { FileInputStream theoryFile ; try { theoryFile = new FileInputStream ( theoryPath ) ; } catch ( FileNotFoundException exception ) { return null ; } try { theoryContent = Utilities . readStringFromInputStream ( theoryFile ) ; } catch ( IOException exception ) { return null ; } context . theoryCache . put ( theoryName , new CachedTheory ( theoryContent ) ) ; } try { prologInterpreter . addTheory ( new Theory ( theoryContent ) ) ; } catch ( InvalidTheoryException exception ) { return null ; } memory . output ( Prolog . class , prologInterpreterKey + " = " + theoryPath ) ; return null ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmProp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInPp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmOp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmTrm p , A arg ) ; } }
private static boolean runTests ( ) { testIndex = 0 ; testNumber + + ; System . out . println ( " Generating data. " ) ; StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Array= " ) ; unsorted = new Integer [ ARRAY_SIZE ] ; java . util . Set < Integer > set = new java . util . HashSet < Integer > ( ) ; for ( int i = 0 ; i < ARRAY_SIZE ; i + + ) { Integer j = RANDOM . nextInt ( RANDOM_SIZE ) ; boolean found = true ; while ( found ) { if ( set . contains ( j ) ) { j = RANDOM . nextInt ( RANDOM_SIZE ) ; } else { unsorted [ i ] = j ; set . add ( j ) ; found = false ; } } unsorted [ i ] = j ; builder . append ( j ) . append ( ',' ) ; } set . clear ( ) ; set = null ; builder . append ( '\n' ) ; string = builder . toString ( ) ; if ( debug > 1 ) System . out . println ( string ) ; sorted = Arrays . copyOf ( unsorted , unsorted . length ) ; Arrays . sort ( sorted ) ; System . out . println ( " Generated data. " ) ; boolean passed = true ; passed = testJavaRedBlackIntegerTree ( ) ; if ( ! passed ) { System . err . println ( " Java Red-Black [Integer] failed. " ) ; return false ; } passed = testRedBlackTree ( ) ; if ( ! passed ) { System . err . println ( " Red-Black Tree failed. " ) ; return false ; } passed = testAVLTree ( ) ; if ( ! passed ) { System . err . println ( " AVL Tree failed. " ) ; return false ; } passed = testSplayTree ( ) ; if ( ! passed ) { System . err . println ( " Splay Tree failed. " ) ; return false ; } passed = testBTree ( ) ; if ( ! passed ) { System . err . println ( " B-Tree failed. " ) ; return false ; } passed = testTreap ( ) ; if ( ! passed ) { System . err . println ( " Treap failed. " ) ; return false ; } passed = testBST ( ) ; if ( ! passed ) { System . err . println ( " BST failed. " ) ; return false ; } passed = testJavaRedBlackStringTree ( ) ; if ( ! passed ) { System . err . println ( " Java Red-Black [String] failed. " ) ; return false ; } passed = testTrie ( ) ; if ( ! passed ) { System . err . println ( " Trie failed. " ) ; return false ; } passed = testPatriciaTrie ( ) ; if ( ! passed ) { System . err . println ( " Patricia Trie failed. " ) ; return false ; } passed = testJavaMinHeap ( ) ; if ( ! passed ) { System . err . println ( " Java Min-Heap failed. " ) ; return false ; } passed = testMinHeap ( ) ; if ( ! passed ) { System . err . println ( " Min-Heap failed. " ) ; return false ; } passed = testJavaMaxHeap ( ) ; if ( ! passed ) { System . err . println ( " Java Max-Heap failed. " ) ; return false ; } passed = testMaxHeap ( ) ; if ( ! passed ) { System . err . println ( " Max-Heap failed. " ) ; return false ; } passed = testJavaArrayList ( ) ; if ( ! passed ) { System . err . println ( " Java List failed. " ) ; return false ; } passed = testArrayList ( ) ; if ( ! passed ) { System . err . println ( " List failed. " ) ; return false ; } passed = testJavaLinkedList ( ) ; if ( ! passed ) { System . err . println ( " Java List failed. " ) ; return false ; } passed = testLinkedList ( ) ; if ( ! passed ) { System . err . println ( " List failed. " ) ; return false ; } passed = testSkipList ( ) ; if ( ! passed ) { System . err . println ( " Skip List failed. " ) ; return false ; } passed = testJavaArrayQueue ( ) ; if ( ! passed ) { System . err . println ( " Java Queue failed. " ) ; return false ; } passed = testArrayQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } passed = testJavaLinkedQueue ( ) ; if ( ! passed ) { System . err . println ( " Java Queue failed. " ) ; return false ; } passed = testLinkedQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } passed = testJavaStack ( ) ; if ( ! passed ) { System . err . println ( " Java Stack failed. " ) ; return false ; } passed = testArrayStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } passed = testLinkedStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } passed = testJavaHashMap ( ) ; if ( ! passed ) { System . err . println ( " Java Hash Map failed. " ) ; return false ; } passed = testHashMap ( ) ; if ( ! passed ) { System . err . println ( " Hash Map failed. " ) ; return false ; } passed = testJavaTreeMap ( ) ; if ( ! passed ) { System . err . println ( " Java Tree Map failed. " ) ; return false ; } passed = testTreeMap ( ) ; if ( ! passed ) { System . err . println ( " Tree Map failed. " ) ; return false ; } passed = testTrieMap ( ) ; if ( ! passed ) { System . err . println ( " Trie Map failed. " ) ; return false ; } passed = testRadixTrie ( ) ; if ( ! passed ) { System . err . println ( " Radix Trie failed. " ) ; return false ; } if ( debugTime & & debugMemory ) { String results = getTestResults ( testNumber , testNames , testResults ) ; System . out . println ( results ) ; } passed = testCompactSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Compact Suffix Trie failed. " ) ; return false ; } passed = testGraph ( ) ; if ( ! passed ) { System . err . println ( " Graph failed. " ) ; return false ; } passed = testIntervalTree ( ) ; if ( ! passed ) { System . err . println ( " Interval Tree failed. " ) ; return false ; } passed = testKdTree ( ) ; if ( ! passed ) { System . err . println ( " k-d Tree Tree failed. " ) ; return false ; } passed = testMatrix ( ) ; if ( ! passed ) { System . err . println ( " Matrix failed. " ) ; return false ; } passed = testQuadTree ( ) ; if ( ! passed ) { System . err . println ( " QuadTree failed. " ) ; return false ; } passed = testSegmentTree ( ) ; if ( ! passed ) { System . err . println ( " Segment Tree failed. " ) ; return false ; } passed = testSuffixTree ( ) ; if ( ! passed ) { System . err . println ( " Suffix Tree failed. " ) ; return false ; } passed = testSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Suffix Trie failed. " ) ; return false ; } return true ; }
private static String findMappingFromHypernym ( String synset ) { ArrayList rels = ( ArrayList ) WordNet . wn . relations . get ( synset ) ; if ( rels ! = null ) { for ( Object rel : rels ) { AVPair avp = ( AVPair ) rel ; if ( avp . attribute . equals ( " hypernym " ) | | avp . attribute . equals ( " instance hypernym " ) ) { String mappingChar ; if ( avp . attribute . equals ( " instance hypernym " ) ) { mappingChar = " @ " ; } else { mappingChar = " + " ; } String targetSynset = avp . value ; String targetSUMO = WordNet . wn . getSUMOMapping ( targetSynset ) ; if ( targetSUMO ! = null & & ! " " . equals ( targetSUMO ) ) { if ( targetSUMO . charAt ( targetSUMO . length ( ) - 1 ) = = '[' ) { mappingChar = " [ " ; } if ( Character . isUpperCase ( targetSUMO . charAt ( 2 ) ) ) { return " &% " + getBareSUMOTerm ( targetSUMO ) + mappingChar ; } else { String candidate = findMappingFromHypernym ( targetSynset ) ; if ( candidate ! = null & & ! " " . equals ( candidate ) ) { return candidate ; } } } } } } return null ; }
public void readPastEOS ( ) throws Exception { try ( final InputStream empty = new NonBlockingByteArrayInputStream ( " 3 \ n123 \ r \ n0 \ r \ n " . getBytes ( ) ) ; final ChunkedInputStream cIS = new ChunkedInputStream ( empty ) )
@Override public boolean hasVarQuery ( ) { return isQueryVariable ( ) ; }
public void testSuffixArray ( ) { String string = " aasfaasdsadasdfasdasdasdasfdasfassdfas " ; SuffixArray suffixArrayBuilder = new SuffixArray ( string ) ; SuffixTree < String > suffixTree = new SuffixTree < String > ( string ) ; Set < String > suffixSet = suffixTree . getSuffixes ( ) ; ArrayList < Integer > suffixArray = suffixArrayBuilder . getSuffixArray ( ) ; int i = 0 ; for ( String suffix : suffixSet ) { String substring = string . substring ( suffixArray . get ( i + + ) ) ;
public synchronized void clear ( ) { dynamicDBase = new ClauseDatabase ( ) ; }
@Override public void run ( ) { s . cells . click ( " Turret " , " " , " " ) ; } } ) ;
public void removeFromPlaylist ( String playlistName , Integer pos ) throws MPDServerException { getMpdConnection ( ) . sendCommand ( MPDCommand . MPD_CMD_PLAYLIST_DEL , playlistName , Integer . toString ( pos ) ) ;
public static void main ( String [ ] args ) { int capacityPerLevel = 10 ; int repeats = 3 ; int warmups = 1 ; double totalDiff = 0 ; double totalTimeA = 0 , totalTimeB = 0 ; final int iterations = 1 ; for ( float insertRatio = 0.1f ; insertRatio < = 1.0f ; insertRatio + = 0.2f ) { for ( int levels = 1 ; levels < = 500 ; levels + = 10 ) { final int bagCapacity = levels * capacityPerLevel ; int randomAccesses = 64 * bagCapacity ; final int _levels = levels ; double a = 0 , b = 0 ; a = compare ( " A " , new BagBuilder ( ) { @Override public AbstractBag newBag ( ) { return new ContinuousBag2 < Item > ( bagCapacity , forgetRate , new ContinuousBag2 . DefaultBagCurve ( ) , true ) ; } } , iterations , randomAccesses , insertRatio , repeats , warmups ) ; b = compare ( " B " , new BagBuilder ( ) { @Override public AbstractBag newBag ( ) { return new ContinuousBag < Item > ( bagCapacity , forgetRate , true ) ; } } , iterations , randomAccesses , insertRatio , repeats , warmups ) ; System . out . print ( insertRatio + " ,  " + levels + " ,  " + bagCapacity + " ,  " ) ; System . out . println ( ( a - b ) / ( ( a + b ) / 2.0 ) ) ; totalDiff + = ( a - b ) ; totalTimeA + = a ; totalTimeB + = b ; } } if ( totalDiff > 0 ) System . out . print ( " B faster:  " ) ; else System . out . print ( " A faster:  " ) ; System . out . println ( " total difference (ms):  " + totalDiff ) ; System . out . println ( "   A time= " + totalTimeA ) ; System . out . println ( "   B time= " + totalTimeB ) ;
Map < String , IDynamicComponent > getComponents ( ) ; IPartnershipFactory getPartnershipFactory ( ) throws ComponentNotFoundException ; IProcessor getProcessor ( ) throws ComponentNotFoundException ; }
public static Operator [ ] get ( NAR nar ) { Javascript js = new Javascript ( ) ; js . setEnabled ( nar , true ) ; return new Operator [ ] {
X509Certificate getCertificate ( @Nonnull IMessage aMsg , @Nullable ECertificatePartnershipType ePartnershipType ) throws OpenAS2Exception ; @Nullable X509Certificate getCertificateOrNull ( @Nonnull IMessage aMsg , @Nullable ECertificatePartnershipType ePartnershipType ) throws OpenAS2Exception ; @Nonnull PrivateKey getPrivateKey ( @Nullable IMessage aMsg , @Nullable X509Certificate aCert ) throws OpenAS2Exception ; @Nonnull X509Certificate getCertificate ( @Nonnull IMessageMDN aMDN , @Nullable ECertificatePartnershipType ePartnershipType ) throws OpenAS2Exception ; @Nullable X509Certificate getCertificateOrNull ( @Nonnull IMessageMDN aMDN , @Nullable ECertificatePartnershipType ePartnershipType ) throws OpenAS2Exception ; @Nonnull PrivateKey getPrivateKey ( @Nullable IMessageMDN aMDN , @Nullable X509Certificate aCert ) throws OpenAS2Exception ; }
public IntervalData < O > copy ( ) { Set < O > listCopy = new TreeSet < O > ( ) ; listCopy . addAll ( set ) ; return new IntervalData < O > ( start , end , listCopy ) ; }
public void addAllAttributes ( @Nullable final IStringMap aAttributes ) { m_aAttributes . addAttributes ( aAttributes ) ; }
public void testReadMDNIssue97 ( ) throws Exception { final String sPrefix = " mdn/issue97 " ; final IReadableResource aHeaderRes = new ClassPathResource ( sPrefix + " .header " ) ; assertTrue ( aHeaderRes . exists ( ) ) ; final IReadableResource aPayloadRes = new ClassPathResource ( sPrefix + " .payload " ) ; assertTrue ( aPayloadRes . exists ( ) ) ; if ( false ) { final IReadableResource aCertRes = new ClassPathResource ( sPrefix + " .pem " ) ; assertTrue ( aCertRes . exists ( ) ) ; } final HttpHeaderMap aHeaders = new HttpHeaderMap ( ) ; try ( NonBlockingBufferedReader aBR = new NonBlockingBufferedReader ( aHeaderRes . getReader ( StandardCharsets . ISO_8859_1 ) ) ) { String s ; while ( ( s = aBR . readLine ( ) ) ! = null ) { final int i = s . indexOf ( ':' ) ; final String sName = s . substring ( 0 , i ) . trim ( ) ; final String sValue = s . substring ( i + 1 ) . trim ( ) ; aHeaders . addHeader ( sName , sValue ) ; } } if ( false ) assertEquals ( " <MOKOsi42435716cf621589dnode1POP000046@sfgt1.unix.fina.hr> " , aHeaders . getFirstHeaderValue ( " Message-ID " ) ) ; final AS2Message aMsg = new AS2Message ( ) ; final IMessageMDN aMDN = new AS2MessageMDN ( aMsg ) ; aMDN . headers ( ) . addAllHeaders ( aHeaders ) ; final MimeBodyPart aPart = new MimeBodyPart ( AS2HttpHelper . getAsInternetHeaders ( aMDN . headers ( ) ) , StreamHelper . getAllBytes ( aPayloadRes ) ) ; assertNotNull ( aPart ) ; aMsg . getMDN ( ) . setData ( aPart ) ; final ICryptoHelper aCryptoHelper = AS2Helper . getCryptoHelper ( ) ; assertFalse ( aCryptoHelper . isSigned ( aPart ) ) ; assertFalse ( aCryptoHelper . isEncrypted ( aPart ) ) ; assertFalse ( aCryptoHelper . isCompressed ( aPart . getContentType ( ) ) ) ; try ( final AS2ResourceHelper aResHelper = new AS2ResourceHelper ( ) ) {
public boolean updateSettings ( ) { MPD . setSortByTrackNumber ( settings . getBoolean ( " albumTrackSort " , MPD . sortByTrackNumber ( ) ) ) ; MPD . setSortAlbumsByYear ( settings . getBoolean ( " sortAlbumsByYear " , MPD . sortAlbumsByYear ( ) ) ) ; MPD . setShowAlbumTrackCount ( settings . getBoolean ( " showAlbumTrackCount " , MPD . showAlbumTrackCount ( ) ) ) ; oMPDAsyncHelper . setUseCache ( settings . getBoolean ( " useLocalAlbumCache " , false ) ) ; return updateConnectionSettings ( ) ; }
public void load ( final String file ) throws MPDServerException { mMPD . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_LOAD , file ) ; }
public abstract void openLogFile ( ) ; public abstract void closeLogFile ( ) ; public abstract boolean isLogging ( ) ; }
public void insertTaskLink ( TaskLink taskLink ) { BudgetValue taskBudget = taskLink . getBudget ( ) ; taskLinks . putIn ( taskLink ) ; memory . activateConcept ( this , taskBudget ) ; }
void recycleAllViews ( ) { final int childCount = getChildCount ( ) ; final IcsAbsSpinner . RecycleBin recycleBin = mRecycler ; final int position = mFirstPosition ; for ( int i = 0 ; i < childCount ; i + + ) { View v = getChildAt ( i ) ;
public void addPath ( final List < Cause > p , final double cost ) { double newScore = ( p . size ( ) / cost ) ; if ( ( this . bestPath = = null ) | | ( score < newScore ) ) { this . bestPath = p . toArray ( new Cause [ p . size ( ) ] ) ;
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Center= " ) . append ( center ) ; builder . append ( "  Set= " ) . append ( overlap ) ; return builder . toString ( ) ; }
public static Rope cat ( CharSequence . . . c ) { Rope r = null ; for ( CharSequence a : c ) { if ( ! ( a instanceof Rope ) ) a = Rope . build ( a ) ; if ( r = = null ) { r = ( Rope ) a ; } else { r = new ConcatenationRope ( r , ( Rope ) a ) ; } } return r ; }
private boolean addCommand ( final String text ) { if ( text . startsWith ( " ** " ) ) { this . reset ( ) ; return true ; } else if ( text . startsWith ( " *decisionthreshold= " ) ) { final Double value = Double . valueOf ( text . split ( " decisionthreshold= " ) [ 1 ] ) ; param . decisionThreshold . set ( value ) ; return true ; } else if ( text . startsWith ( " *volume= " ) ) { final Integer value = Integer . valueOf ( text . split ( " volume= " ) [ 1 ] ) ; param . noiseLevel . set ( value ) ; return true ; } if ( StringUtils . isNumeric ( text ) ) { final Integer retVal = Integer . parseInt ( text ) ;
public static IParser createParser ( IOperatorManager op , String theory ) { return new Parser ( ( OperatorManager ) op , theory ) ; }
private E intoBase ( E newItem ) { E oldItem = null ; int inLevel = getLevel ( newItem ) ; if ( size ( ) > capacity ) { int outLevel = 0 ; while ( itemTableEmpty [ outLevel ] ) { outLevel + + ; } if ( outLevel > inLevel ) { return newItem ; } else { oldItem = takeOutFirst ( outLevel ) ; } } itemTable [ inLevel ] . add ( newItem ) ; itemTableEmpty [ inLevel ] = false ; mass + = ( inLevel + 1 ) ; refresh ( ) ; return oldItem ; }
private void processTask ( ) { Task task ; int counter = newTasks . size ( ) ; while ( counter - - > 0 ) { task = ( Task ) newTasks . remove ( 0 ) ; if ( task . getSentence ( ) . isInput ( ) | | ( termToConcept ( task . getContent ( ) ) ! = null ) ) immediateProcess ( task ) ; else taskBuffer . putIn ( task ) ; } task = ( Task ) taskBuffer . takeOut ( ) ; if ( task ! = null ) immediateProcess ( task ) ;
public void enqueueStringMessage ( String queue , String key , String message ) { } @Override public Schema getSchema ( ) throws Exception { return Translator . translatorFor ( props ) . getSchema ( ) ; } }
public void volumeChanged ( final MPDStatus mpdStatus , final int oldVolume ) { } }
public int closestIndex ( double p ) { int r ; int s = size ( ) ; for ( r = 0 ; r < resolution ; r + + ) { if ( index [ r ] > p ) { break ; } } if ( r > resolution - 1 ) { r = resolution - 1 ; } int q = r - 1 ; if ( q = = - 1 ) { q = 0 ; } double vq = index [ q ] ; double vr = index [ r ] ; double qr ; if ( p < vq ) { qr = q ; } else if ( p > vr ) { qr = r ; } else { double dq = p - vq ; double dr = vr - p ; double t = dq + dr ; if ( t = = 0 ) { qr = q ; } else { dq / = t ; dr / = t ; qr = ( ( 1.0 - dq ) * q + ( 1.0 - dr ) * r ) ; } } int i = ( int ) Math . floor ( qr * ( ( double ) s ) / ( resolution - 1 ) ) ; if ( i < 0 ) { i = 0 ; } if ( i > = s ) { i = s - 1 ; } return i ; }
public void wordChars ( int low , int hi ) { if ( low < 0 ) low = 0 ; if ( hi > = ctype . length ) hi = ctype . length - 1 ; while ( low < = hi ) ctype [ low + + ] | = CT_ALPHA ;
protected float scaleValueToAngle ( float v ) { float a = startAng + v * ( endAng - startAng ) ; return a ; }
public void testGet ( ) { StructField field1 = DataTypes . createStructField ( " field1 " , DataTypes . StringType , true ) ; StructField field2 = DataTypes . createStructField ( " field2 " , DataTypes . IntegerType , true ) ; StructField field3 = DataTypes . createStructField ( " field3 " , DataTypes . FloatType , true ) ; StructType schema = DataTypes . createStructType ( Lists . newArrayList ( field1 , field2 , field3 ) ) ; Row row = new RowWithSchema ( schema , " hello " , 1 , 2.0 ) ; assertEquals ( RowUtils . get ( row , " field1 " ) , " hello " ) ; assertEquals ( RowUtils . get ( row , " field2 " ) , 1 ) ; assertEquals ( RowUtils . get ( row , " field3 " ) , 2.0 ) ; }
public Builder setRepeatingEnum ( int index , com . cloudera . labs . envelope . translate . ProtobufSingleMessage . SingleExample . EnumExample value ) { if ( value = = null ) { throw new NullPointerException ( ) ; } ensureRepeatingEnumIsMutable ( ) ; repeatingEnum_ . set ( index , value . getNumber ( ) ) ; onChanged ( ) ; return this ; }
public void undo ( ) throws CannotUndoException { super . undo ( ) ; select ( start , end ) ; }
public void testSparkPassthroughGood ( ) { Config config = ConfigUtils . configFromPath ( this . getClass ( ) . getResource ( RESOURCES_PATH + " /spark-passthrough-good.conf " ) . getPath ( ) ) ; Contexts . closeSparkSession ( true ) ; Contexts . initialize ( config , false ) ; SparkConf sparkConf = Contexts . getSparkSession ( ) . sparkContext ( ) . getConf ( ) ; assertTrue ( sparkConf . contains ( " spark.driver.allowMultipleContexts " ) ) ; assertEquals ( " true " , sparkConf . get ( " spark.driver.allowMultipleContexts " ) ) ; assertTrue ( sparkConf . contains ( " spark.master " ) ) ; assertEquals ( " local[1] " , sparkConf . get ( " spark.master " ) ) ; }
public void processNovelTask ( NarParameters narParameters ) { final Task task = novelTasks . takeNext ( ) ; if ( task ! = null ) { localInference ( task , narParameters ) ;
public void testNoCarryForwardWhenNull ( ) { p = new EventTimeHistoryPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES , " " ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , null , 200L ) ) ; key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 2 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " startdate " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " enddate " ) , 199L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " value " ) , null ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " startdate " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " enddate " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES ) ; }
public void testAppendRaw ( ) throws Exception { String kvps = " field3=100.9---field6=---field7=true---field2=-99.8---field1=hello---field4=-1---field5=120 " ; Config config = ConfigFactory . empty ( ) . withValue ( KVPTranslator . FIELD_NAMES_CONFIG_NAME , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " field1 " , " field2 " , " field3 " , " field4 " , " field5 " , " field6 " , " field7 " ) ) ) . withValue ( KVPTranslator . FIELD_TYPES_CONFIG_NAME , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " string " , " float " , " double " , " int " , " long " , " int " , " boolean " ) ) ) . withValue ( KVPTranslator . KVP_DELIMITER_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( " --- " ) ) . withValue ( KVPTranslator . FIELD_DELIMITER_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( " = " ) ) . withValue ( TranslatorUtils . APPEND_RAW_ENABLED_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( true ) ) ; Translator < String , String > t = new KVPTranslator ( ) ; t . configure ( config ) ; Row r = t . translate ( " testkey " , kvps ) . iterator ( ) . next ( ) ; assertEquals ( r . length ( ) , 9 ) ; assertEquals ( r . get ( 0 ) , " hello " ) ; assertEquals ( r . get ( 1 ) , - 99.8f ) ; assertEquals ( r . get ( 2 ) , 100.9d ) ; assertEquals ( r . get ( 3 ) , - 1 ) ; assertEquals ( r . get ( 4 ) , 120L ) ; assertEquals ( r . get ( 5 ) , null ) ; assertEquals ( r . get ( 6 ) , true ) ; assertEquals ( r . get ( 7 ) , " testkey " ) ; assertEquals ( r . get ( 8 ) , kvps ) ; }
public void testOneArrivingOneExistingWhereArrivingSameTimeAsExistingWithDifferentValues ( ) { p = new BitemporalHistoryPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , FAR_FUTURE_MILLIS , 1L , FAR_FUTURE_MILLIS , CURRENT_FLAG_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 100L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 2 ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . UPDATE ) ; assertEquals ( planned . get ( 1 ) . getMutationType ( ) , MutationType . INSERT ) ; Long systemStart1 = ( Long ) RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemstart " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemstart " ) , 1L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemend " ) , RowUtils . precedingTimestamp ( systemStart1 ) ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_YES ) ; }
public abstract String getName ( ) ; public abstract ServiceInfo getInfo ( ) ; @Override public ServiceEvent clone ( ) { try { return ( ServiceEvent ) super . clone ( ) ; } catch ( CloneNotSupportedException exception ) { return null ; } } }
public void testRunWithDelay ( ) { topology . addEntrancePi ( entrancePi ) ; new Expectations ( ) { { entrancePi . injectNextEvent ( ) ; result = true ; times = 5 ; entrancePi . injectNextEvent ( ) ; result = false ; times = 1 ; } } ; topology . run ( delay ) ; new Verifications ( ) { {
protected static void destroySortalTypeCache ( ) { if ( SORTAL_TYPE_CACHE ! = null ) { System . out . println ( " INFO in Formula.destroySortalTypeCache() " ) ; System . out . println ( "   Clearing  " + SORTAL_TYPE_CACHE . size ( ) + "  entries " ) ; SORTAL_TYPE_CACHE . clear ( ) ; } SORTAL_TYPE_CACHE = null ; return ; }
public void run ( ) { mBackPressExitCount = 0 ; }
public void activatedTask ( final BudgetValue budget , final Sentence sentence , final Sentence candidateBelief ) { final Task task = new Task ( sentence , budget , currentTask , sentence , candidateBelief ) ; if ( sentence . isQuestion ( ) ) { final float s = task . budget . summary ( ) ; final float minSilent = nar . param . getSilenceLevel ( ) / 100.0f ; if ( s > minSilent ) { nar . output ( OUT . class , task . getSentence ( ) ) ; } } addNewTask ( task , " Activated " ) ; }
public GetOperation get ( String key , Callback callback ) { return new GetOperationImpl ( key , callback ) ; }
public boolean hasLastUpdatedField ( ) { return getLastUpdatedFieldName ( ) ! = null ; }
protected Node < T > addValue ( T id ) { Node < T > nodeToReturn = super . addValue ( id ) ; AVLNode < T > nodeAdded = ( AVLNode < T > ) nodeToReturn ; nodeAdded . updateHeight ( ) ; balanceAfterInsert ( nodeAdded ) ; nodeAdded = ( AVLNode < T > ) nodeAdded . parent ; while ( nodeAdded ! = null ) { int h1 = nodeAdded . height ; nodeAdded . updateHeight ( ) ; balanceAfterInsert ( nodeAdded ) ; int h2 = nodeAdded . height ; if ( h1 = = h2 ) break ; nodeAdded = ( AVLNode < T > ) nodeAdded . parent ; } return nodeToReturn ; }
public void configure ( Config config ) { } @Override public void run ( Map < String , Dataset < Row > > dependencies ) { runCount + + ; if ( runCount = = 3 ) { throw new RuntimeException ( " Crash! " ) ; } } } }
public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; registerForContextMenu ( list ) ; UpdateList ( ) ; getActivity ( ) . setTitle ( getResources ( ) . getString ( R . string . playlists ) ) ; }
public void onPageSelected ( int position ) { if ( activity ! = null ) { activity . pageChanged ( position ) ;
protected void onInit ( ) { logger . info ( " DoTaskApp onInit " ) ; try { System . err . println ( ) ; System . err . println ( Globals . getWorkbenchInfoString ( ) ) ; System . err . println ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } S4ComponentFactory factory = new S4ComponentFactory ( ) ; factory . setApp ( this ) ; logger . debug ( " PARAMETERS {} " , evalTask ) ; List < String > parameters = new ArrayList < String > ( ) ; parameters . addAll ( Arrays . asList ( evalTask . split ( " : " ) ) ) ; String [ ] args = parameters . toArray ( new String [ 0 ] ) ; Option [ ] extraOptions = new Option [ ] { } ; StringBuilder cliString = new StringBuilder ( ) ; for ( int i = 0 ; i < args . length ; i + + ) { cliString . append ( "   " ) . append ( args [ i ] ) ; } try { task = ( Task ) ClassOption . cliStringToObject ( cliString . toString ( ) , Task . class , extraOptions ) ;
public void testRedBlackTree ( ) { TestData data = Utils . generateTestData ( 1000 ) ; String bstName = " Red-Black Tree " ; RedBlackTree < Integer > bst = new RedBlackTree < Integer > ( ) ; Collection < Integer > bstCollection = bst . toCollection ( ) ; assertTrue ( TreeTest . testTree ( bst , Type . Integer , bstName , data . unsorted , data . invalid ) ) ; assertTrue ( JavaCollectionTest . testCollection ( bstCollection , Type . Integer , bstName , data . unsorted , data . sorted ) ) ;
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }
public boolean addControls ( Focusable . . . controls ) { boolean result = false ; for ( Focusable control : controls ) result | = addControl ( control ) ; return result ; }
public boolean retainAll ( Collection < ? > c ) { synchronized ( mLOCK ) { boolean changed = false ;
public boolean equals ( Object obj ) { if ( ! ( obj instanceof EnumValues ) ) { return false ; } EnumValues o = ( EnumValues ) obj ; return Objects . equals ( enumStr , o . enumStr ) ; }
public void testReverseCharsInString ( ) { String string = " ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz " ; String check = " zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA " ; String result = StringFunctions . reverseWithStringConcat ( string ) ; assertTrue ( " Reverse With String Concat error. expect= " + check + "  got= " + result , check . equals ( result ) ) ; result = StringFunctions . reverseWithStringBuilder ( string ) ; assertTrue ( " Reverse With String String Builder error. expect= " + check + "  got= " + result , check . equals ( result ) ) ; result = StringFunctions . reverseWithStringBuilderBuiltinMethod ( string ) ; assertTrue ( " Reverse With Built-in error. expect= " + check + "  got= " + result , check . equals ( result ) ) ; result = StringFunctions . reverseWithSwaps ( string ) ; assertTrue ( " Reverse With Swaps error. expect= " + check + "  got= " + result , check . equals ( result ) ) ; result = StringFunctions . reverseWithXOR ( string ) ; assertTrue ( " Reverse With XOR error. expect= " + check + "  got= " + result , check . equals ( result ) ) ; }
void processTogglePlaybackRequest ( ) { new AsyncTask < MPDApplication , Void , Boolean > ( ) { @Override
boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isCompressed ( @Nonnull String sContentType ) throws OpenAS2Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm , @Nonnull @Nonempty String sContentTransferEncoding ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt , boolean bLargeFileOn ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
public CachedData encode ( Object o ) { throw new RuntimeException ( " Not implemented. " ) ; } } ;
abstract protected Term function ( Memory memory , Term [ ] x ) ; @Deprecated abstract protected Term getRange ( ) ; @Override protected List < Task > execute ( Operation operation , final Term [ ] args , final Memory m ) { final int numArgs = args . length - 1 ; if ( numArgs < 1 ) { throw new IllegalStateException ( " Requires at least 1 arguments " ) ; } if ( numArgs < 2 ) { throw new IllegalStateException ( " Requires at least 2 arguments " ) ; } final Term lastTerm = args [ numArgs ] ; final boolean variable = lastTerm instanceof Variable ; if ( ! variable ) { throw new IllegalStateException ( " output can not be specified " ) ; } final int numParam = numArgs - 1 ; final Term [ ] x = new Term [ numParam ] ; System . arraycopy ( args , 1 , x , 0 , numParam ) ; final Term y ; y = function ( m , x ) ; if ( y = = null ) { return null ; } final Variable var = new Variable ( " $1 " ) ; operation = ( Operation ) operation . setComponent ( 0 , ( ( CompoundTerm ) operation . getSubject ( ) ) . setComponent ( numArgs , y , m ) , m ) ; final float confidence = m . narParameters . DEFAULT_JUDGMENT_CONFIDENCE ; if ( variable ) { final Sentence s = new Sentence ( operation , Symbols . JUDGMENT_MARK , new TruthValue ( 1.0f , m . narParameters . DEFAULT_JUDGMENT_CONFIDENCE , m . narParameters ) , new Stamp ( m ) ) ; final BudgetValue budgetForNewTask = new BudgetValue ( m . narParameters . DEFAULT_JUDGMENT_PRIORITY , m . narParameters . DEFAULT_FEEDBACK_DURABILITY , truthToQuality ( s . getTruth ( ) ) , m . narParameters ) ; final Task newTask = new Task ( s , budgetForNewTask , Task . EnumType . INPUT ) ; return Lists . newArrayList ( newTask ) ; } else { return null ; } } public float equals ( final Term a , final Term b ) { return a . equals ( b ) ? 1.0f : 0.0f ; } }
private static void checkInvalidSeparator ( char sep , String key , TomlParser parser ) { if ( ! Toml . isKeyValueSeparator ( sep , parser . isLenientWithSeparators ( ) ) ) { throw new ParsingException (
public static HostnameVerifier createHostnameVerifier ( ) { return new HostnameVerifierVerifyAll ( ) ; }
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; if ( icicle ! = null ) init ( ( Album ) icicle . getParcelable ( EXTRA_ALBUM ) ) ;
protected void feelMotion ( ) { float xa = torso . getAngularVelocity ( ) ; float angleScale = 1.50f ; float a = ( float ) ( Math . log ( Math . abs ( xa * angleScale ) + 1f ) ) ; float maxAngleVelocityFelt = 0.8f ; if ( a > maxAngleVelocityFelt ) { a = maxAngleVelocityFelt ; } if ( a < 0.1 ) { feltAngularVelocity . set ( " $0.50;0.20$ <0 --> feltAngularMotion>. :|: %1.00;0.90% " ) ; } else { String direction ; String da = Texts . n1 ( a ) ; if ( xa < 0 ) { direction = " -1 " ; } else { direction = " 1 " ; } feltAngularVelocity . set ( " $0.50;0.20$ <(*, " + da + " , " + direction + " ) --> feltAngularMotion>. :|: " ) ; } float h = torso . getAngle ( ) % ( MathUtils . TWOPI ) ; if ( h < 0 ) { h + = MathUtils . TWOPI ; } h / = MathUtils . TWOPI ; String dh = " a " + ( int ) ( h * 18 ) ; feltOrientation . set ( " $0.50;0.20$ < " + dh + "  --> feltOrientation>. :|: " ) ; float speed = Math . abs ( torso . getLinearVelocity ( ) . length ( ) / 20 f ) ; if ( speed > 0.9f ) { speed = 0.9f ; } String sp = Texts . n1 ( speed ) ; feltSpeed . set ( " $0.50;0.20$ < " + sp + "  --> feltSpeed>. :|: " ) ;
public void onFinish ( NARGraph g ) { if ( includeSyntax > 0 ) { for ( final Term a : terms ) { if ( a instanceof CompoundTerm ) { CompoundTerm c = ( CompoundTerm ) a ; g . addVertex ( c . operator ( ) ) ; g . addEdge ( c . operator ( ) , c , new TermType ( ) ) ; if ( includeSyntax - 1 > 0 ) recurseTermComponents ( g , c , includeSyntax - 1 ) ; } } } if ( includeTermContent ) { for ( final Term a : terms ) { for ( final Term b : terms ) { if ( a = = b ) continue ; if ( a . containComponent ( b ) ) { g . addEdge ( a , b , new TermContent ( ) ) ; } if ( b . containComponent ( a ) ) { g . addEdge ( b , a , new TermContent ( ) ) ; } } } } if ( includeDerivations & & includeBeliefs ) { for ( final Entry < Sentence , Term > s : sentenceTerms . entrySet ( ) ) {
public final boolean onError ( final MediaPlayer mp , final int what , final int extra ) { Log . d ( TAG , " StreamingService.onError() " ) ; final int maxError = 4 ; if ( mErrorIterator > 0 ) { Log . d ( TAG , " Error occurred while streaming, this is try # " + mErrorIterator + " , will attempt up to  " + maxError + "  times. " ) ; } if ( mErrorIterator > maxError ) { stopSelf ( ) ; } mPreparingStreaming = false ; windDownResources ( STREAMING_STOP ) ; mErrorIterator + = 1 ; return true ; }
public void shutdown ( ) { synchronized ( omap ) { for ( Map . Entry < Operation , TapConnectionProvider > me : omap . entrySet ( ) ) {
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
protected String description ( ) { return " querying type " ; }
public boolean isCanceled ( ) ; public boolean isClosing ( ) ; public boolean isClosed ( ) ; public boolean waitForAnnounced ( long timeout ) ; public boolean waitForCanceled ( long timeout ) ; }
public void openLoadFile ( ) { FileDialog dialog = new FileDialog ( ( Dialog ) null , " Load experience " , FileDialog . LOAD ) ; dialog . setVisible ( true ) ; String directoryName = dialog . getDirectory ( ) ; String fileName = dialog . getFile ( ) ; String filePath = directoryName + fileName ; try { nar . addInput ( new TextInput ( new File ( filePath ) ) ) ;
public void output ( final String o ) { final ArrayList < String > l = new ArrayList ( ) ; l . add ( o ) ; output ( l ) ; }
public void stateChanged ( final MPDStatus mpdStatus , final int oldState ) { if ( activity ! = null & & mpdStatus ! = null ) { updateStatus ( mpdStatus ) ;
boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public static Schema schemaFor ( List < String > fieldNames , List < String > fieldTypes ) { FieldAssembler < Schema > assembler = SchemaBuilder . record ( " t " ) . fields ( ) ; for ( int i = 0 ; i < fieldNames . size ( ) ; i + + ) { String fieldName = compatibleFieldName ( fieldNames . get ( i ) ) ; String fieldType = fieldTypes . get ( i ) ; switch ( fieldType ) { case " string " : assembler = assembler . optionalString ( fieldName ) ; break ; case " float " : assembler = assembler . optionalFloat ( fieldName ) ; break ; case " double " : assembler = assembler . optionalDouble ( fieldName ) ; break ; case " int " : assembler = assembler . optionalInt ( fieldName ) ; break ; case " long " : assembler = assembler . optionalLong ( fieldName ) ; break ; case " boolean " : assembler = assembler . optionalBoolean ( fieldName ) ; break ; default : throw new RuntimeException ( " Unsupported provided field type:  " + fieldType ) ; } } return assembler . endRecord ( ) ; }
public Bag < Task , Sentence > newNovelTaskBag ( Param p ) { return new CurveBag < Task , Sentence > ( getNovelTaskBagSize ( ) , curve , randomRemoval ) ; }
public void drawit ( ) { if ( updating ) return ; if ( graph = = null ) return ; Set edges = graph . edgeSet ( ) ; if ( edges ! = null ) { for ( E edge : graph . edgeSet ( ) ) { try { if ( edge = = null ) continue ; int rgb = edgeColor ( edge ) ; float linkWeight = edgeWeight ( edge ) ; stroke ( rgb , 230 f ) ; strokeWeight ( linkWeight ) ; V sourceVertex = graph . getEdgeSource ( edge ) ; if ( sourceVertex = = null ) continue ; mxGeometry sourcePoint = graphAdapter . getCellGeometry ( graphAdapter . getVertexToCellMap ( ) . get ( sourceVertex ) ) ; V targetVertex = graph . getEdgeTarget ( edge ) ; mxGeometry targetPoint = graphAdapter . getCellGeometry ( graphAdapter . getVertexToCellMap ( ) . get ( targetVertex ) ) ; if ( ( sourcePoint = = null ) | | ( targetPoint = = null ) ) continue ; float x1 = ( float ) sourcePoint . getCenterY ( ) ; float y1 = ( float ) sourcePoint . getCenterX ( ) ; float x2 = ( float ) targetPoint . getCenterY ( ) ; float y2 = ( float ) targetPoint . getCenterX ( ) ; float cx = ( x1 + x2 ) / 2.0f ; float cy = ( y1 + y2 ) / 2.0f ; drawArrow ( x1 , y1 , x2 , y2 ) ; text ( t ( edge . toString ( ) ) , cx , cy ) ; } catch ( Exception e ) { } } } strokeWeight ( 0 ) ; for ( V vertex : graph . vertexSet ( ) ) { Object cell = graphAdapter . getVertexToCellMap ( ) . get ( vertex ) ;
default String removeComment ( String path ) { return removeComment ( split ( path , '.' ) ) ; }
public void writeTo ( @Nonnull final OutputStream aOS ) throws IOException { try ( final OutputStream aDebugOS = aOutgoingDumper ! = null ? aOutgoingDumper . getDumpOS ( aOS ) : aOS ; final OutputStream aEncodedOS = eCTE ! = null ? AS2IOHelper . getContentTransferEncodingAwareOutputStream ( aDebugOS ,
public static NAR build ( Class < ? extends Build > g , Param p ) { try { return build ( g . newInstance ( ) , p ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return null ; }
protected void updateHttpHeaders ( @Nonnull final IAS2HttpHeaderWrapper aConn , @Nonnull final IMessage aMsg ) { final Partnership aPartnership = aMsg . partnership ( ) ; aMsg . headers ( ) . forEachSingleHeader ( aConn : : setHttpHeader ) ; aConn . setHttpHeader ( CHttpHeader . CONNECTION , CAS2Header . DEFAULT_CONNECTION ) ; aConn . setHttpHeader ( CHttpHeader . USER_AGENT , CAS2Header . DEFAULT_USER_AGENT ) ; aConn . setHttpHeader ( CHttpHeader . DATE , AS2DateHelper . getFormattedDateNow ( CAS2Header . DEFAULT_DATE_FORMAT ) ) ; aConn . setHttpHeader ( CHttpHeader . MESSAGE_ID , aMsg . getMessageID ( ) ) ; aConn . setHttpHeader ( CHttpHeader . MIME_VERSION , CAS2Header . DEFAULT_MIME_VERSION ) ; aConn . setHttpHeader ( CHttpHeader . CONTENT_TYPE , aMsg . getContentType ( ) ) ; aConn . setHttpHeader ( CHttpHeader . AS2_VERSION , CAS2Header . DEFAULT_AS2_VERSION ) ; aConn . setHttpHeader ( CHttpHeader . RECIPIENT_ADDRESS , aPartnership . getAS2URL ( ) ) ; aConn . setHttpHeader ( CHttpHeader . AS2_FROM , aPartnership . getSenderAS2ID ( ) ) ; aConn . setHttpHeader ( CHttpHeader . AS2_TO , aPartnership . getReceiverAS2ID ( ) ) ; aConn . setHttpHeader ( CHttpHeader . SUBJECT , aMsg . getSubject ( ) ) ; aConn . setHttpHeader ( CHttpHeader . FROM , aPartnership . getSenderEmail ( ) ) ; aConn . setHttpHeader ( CHttpHeader . CONTENT_TRANSFER_ENCODING , aMsg . getHeader ( CHttpHeader . CONTENT_TRANSFER_ENCODING ) ) ; final String sDispTo = aPartnership . getAS2MDNTo ( ) ; if ( sDispTo ! = null ) aConn . setHttpHeader ( CHttpHeader . DISPOSITION_NOTIFICATION_TO , sDispTo ) ; final String sDispositionNotificationOptions = aPartnership . getAS2MDNOptions ( ) ; if ( sDispositionNotificationOptions ! = null ) aConn . setHttpHeader ( CHttpHeader . DISPOSITION_NOTIFICATION_OPTIONS , sDispositionNotificationOptions ) ; final String sReceiptDeliveryOption = aPartnership . getAS2ReceiptDeliveryOption ( ) ; if ( sReceiptDeliveryOption ! = null ) aConn . setHttpHeader ( CHttpHeader . RECEIPT_DELIVERY_OPTION , sReceiptDeliveryOption ) ; final String sContententDisposition = aMsg . getContentDisposition ( ) ; if ( sContententDisposition ! = null ) aConn . setHttpHeader ( CHttpHeader . CONTENT_DISPOSITION , sContententDisposition ) ;
public void testSign_QuotedPrintable ( ) throws Exception { final MimeBodyPart aPart = new MimeBodyPart ( ) ; aPart . setText ( " Hello world " , StandardCharsets . ISO_8859_1 . name ( ) ) ; final MimeBodyPart aSigned = AS2Helper . getCryptoHelper ( ) . sign ( aPart , ( X509Certificate ) PKE . getCertificate ( ) , PKE . getPrivateKey ( ) , ECryptoAlgorithmSign . DIGEST_SHA_256 , false , false , EContentTransferEncoding . QUOTED_PRINTABLE . getID ( ) ) ; assertNotNull ( aSigned ) ; final String sBoundary = AS2HttpHelper . parseContentType ( aSigned . getContentType ( ) ) . getParameter ( " boundary " ) ; assertNotNull ( sBoundary ) ; final NonBlockingByteArrayOutputStream aBAOS = new NonBlockingByteArrayOutputStream ( ) ; aSigned . writeTo ( aBAOS ) ; final String sExpectedStart = " Content-Type: multipart/signed; protocol= \" application/pkcs7-signature \" ; micalg=sha-256;  \ r \ n " + " \ tboundary= \" " + sBoundary + " \" \ r \ n " + " \ r \ n " + " -- " + sBoundary + " \ r \ n " + " Content-Type: text/plain; charset=ISO-8859-1 \ r \ n " + " Content-Transfer-Encoding: 7bit \ r \ n " + " \ r \ n " + " Hello world \ r \ n " + " -- " + sBoundary + " \ r \ n " + " Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data \ r \ n " + " Content-Transfer-Encoding: quoted-printable \ r \ n " + " Content-Disposition: attachment; filename= \" smime.p7s \" \ r \ n " + " Content-Description: S/MIME Cryptographic Signature \ r \ n " + " \ r \ n " + " 0=80=06=09*=86H=86=F7 \ r \ n " + " =01=07=02=A0=800=80=02=01=011=0F0 \ r \ n " + " =06=09`=86H=01e=03=04=02=01=05=000=80=06=09*=86H=86=F7 \ r \ n " + " =01=07=01=00=001=82=02=1B0=82=02=17=02=01=010=81=B70=81=AE1&0$=06=09*=86H= \ r \ n " + " =86=F7 \ r \ n " + " =01=09=01=16=17rosettanet@mendelson.de1=0B0=09=06=03U=04=06=13=02DE1=0F0 \ r \ n " + " =06=03U=04=08=13=06Berlin1=0F0 \ r \ n " + " =06=03U=04=07=13=06Berlin1 \" 0 =06=03U=04 \ r \ n " + " =13=19mendelson-e-commerce GmbH1 \" 0 =06=03U=04=0B=13=19mendelson-e-commerce = \ r \ n " + " GmbH1 \ r \ n " + " 0=0B=06=03U=04=03=13=04mend=02=04C=8E=FD=BB0 \ r \ n " + " =06=09`=86H=01e=03=04=02=01=05=00=A0=81=B60=18=06=09*=86H=86=F7 \ r \ n " + " =01=09=031=0B=06=09*=86H=86=F7 \ r \ n " + " =01=07=010=1C=06=09*=86H=86=F7 \ r \ n " + " =01=09=051=0F=17 \ r \ n " ; final String sExpectedEnd = " \ r \ n " + " -- " + sBoundary + " -- \ r \ n " ; final String sReal = aBAOS . getAsString ( StandardCharsets . ISO_8859_1 ) ; assertTrue ( sReal . startsWith ( sExpectedStart ) ) ; assertTrue ( sReal . endsWith ( sExpectedEnd ) ) ; }
private void dismissSuggestions ( ) { mQueryTextView . dismissDropDown ( ) ; }
public String getParameter ( final String sKey ) throws InvalidParameterException { final StringTokenizer aKeyParts = new StringTokenizer ( sKey , " . " , false ) ; final String sParserID = aKeyParts . nextToken ( ) ; final AbstractParameterParser aParser = getParameterParsers ( ) . get ( sParserID ) ; if ( aParser ! = null ) { if ( ! aKeyParts . hasMoreTokens ( ) ) throw new InvalidParameterException ( " Invalid key format " , this , sKey , null ) ; final StringBuilder aKeyBuf = new StringBuilder ( aKeyParts . nextToken ( ) ) ; while ( aKeyParts . hasMoreTokens ( ) ) aKeyBuf . append ( '.' ) . append ( aKeyParts . nextToken ( ) ) ; if ( s_aLogger . isTraceEnabled ( ) ) s_aLogger . trace ( " Nested getParameter:  " + ClassHelper . getClassLocalName ( aParser ) + "  with ' " + aKeyBuf . toString ( ) + " ' " ) ; return aParser . getParameter ( aKeyBuf . toString ( ) ) ; } if ( ! getIgnoreMissingParsers ( ) ) throw new InvalidParameterException ( " Invalid area in key " , this , sKey , null ) ; return " " ; }
public void load ( ) { if ( closed ) { throw new IllegalStateException ( " This FileConfig is closed, cannot load(). " ) ; } if ( reloadFilter = = null ) { config . bulkCommentedUpdate ( config - > { parser . parse ( nioPath , config , parsingMode , nefAction , charset ) ; } ) ; } else { Config newConfig = parser . parse ( nioPath , nefAction , charset ) ; CommentedConfig newCC = CommentedConfig . fake ( newConfig ) ; if ( reloadFilter . acceptNewVersion ( newCC ) ) { config . replaceContentBy ( newCC ) ; } } loadListener . run ( ) ; }
public static int colorHSB ( float hue , float saturation , float brightness , float alpha ) { return Color . HSBtoRGB ( hue , saturation , brightness ) | ( ( int ) ( 255 f * alpha ) < < 24 ) ; }
public void draw ( Timeline2DCanvas l , float y , float timeScale , float yScale ) { yScale * = height ; float screenyHi = l . screenY ( l . cycleStart * timeScale , y ) ; float screenyLo = l . screenY ( l . cycleStart * timeScale , y + yScale ) ; updateRange ( l ) ; l . stroke ( 127 ) ; l . strokeWeight ( 0.5f ) ; l . line ( l . cycleStart * timeScale , y + yScale , l . cycleEnd * timeScale , y + yScale ) ; l . line ( l . cycleStart * timeScale , y , l . cycleEnd * timeScale , y ) ; drawData ( l , timeScale , yScale , y ) ; drawOverlay ( l , screenyLo , screenyHi ) ;
public static CharSequence yarn ( final CharSequence . . . components ) { int totalLen = 0 ; int total = 0 ; CharSequence lastNonNull = null ; for ( final CharSequence s : components ) { if ( s ! = null ) { totalLen + = s . length ( ) ; total + + ; lastNonNull = s ; } } if ( total = = 0 ) { return null ; } if ( total = = 1 ) { return lastNonNull . toString ( ) ; } final StringBuilder sb = new StringBuilder ( totalLen ) ; for ( final CharSequence s : components ) { if ( s ! = null ) { sb . append ( s ) ; } } return sb ; }
static void analogy ( final Term subj , final Term pred , final Sentence asym , final Sentence sym , final int figure , final DerivationContext nal ) { if ( Statement . invalidStatement ( subj , pred ) ) { return ; } final int order1 = asym . term . getTemporalOrder ( ) ; final int order2 = sym . term . getTemporalOrder ( ) ; final int order = analogyOrder ( order1 , order2 , figure ) ; if ( order = = ORDER_INVALID ) { return ; } final Statement st = ( Statement ) asym . term ; TruthValue truth = null ; final BudgetValue budget ; final Sentence sentence = nal . getCurrentTask ( ) . sentence ; final CompoundTerm taskTerm = ( CompoundTerm ) sentence . term ; if ( sentence . isQuestion ( ) | | sentence . isQuest ( ) ) { if ( taskTerm . isCommutative ( ) ) { if ( asym . truth = = null ) { return ; } budget = BudgetFunctions . backwardWeak ( asym . truth , nal ) ; } else { if ( sym . truth = = null ) { return ; } budget = BudgetFunctions . backward ( sym . truth , nal ) ; } } else { if ( sentence . isGoal ( ) ) { truth = TruthFunctions . lookupTruthFunctionByBoolAndCompute ( taskTerm . isCommutative ( ) , TruthFunctions . EnumType . DESIREWEAK , TruthFunctions . EnumType . DESIRESTRONG , asym . truth , sym . truth ) ; } else { truth = TruthFunctions . analogy ( asym . truth , sym . truth ) ; } budget = BudgetFunctions . forward ( truth , nal ) ; } nal . doublePremiseTask ( Statement . make ( st , subj , pred , order ) , truth , budget , false , false ) ; }
public Iterator < E > iterator ( ) { return items . descendingIterator ( ) ; }
public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { return inflater . inflate ( R . layout . files , container , false ) ; }
public boolean contains ( Object o ) { return m . containsKey ( o ) ; }
public int hashCode ( ) { return 31 * ( int ) ( this . index + this . sum . hashCode ( ) ) ; }
public Operation tapCustom ( String id , RequestMessage message , String keyFilter , String valueFilter ) throws ConfigurationException , IOException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . tapCustom ( id , message , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; return op ; }
public void testSequence2 ( ) { setupNodes ( 4 ) ; assertSequence ( " noelani " , 2 , 1 , 3 , 0 ) ; }
private static boolean testTrieMap ( ) { { if ( debug ) System . out . println ( " Trie Map. " ) ; TrieMap < String , Integer > trieMap = new TrieMap < String , Integer > ( ) ; for ( int i : unsorted ) { String string = String . valueOf ( i ) ; trieMap . put ( string , i ) ; boolean exists = trieMap . contains ( string ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + string + "  doesn't exist. " ) ; handleError ( trieMap ) ; return false ; } } if ( debug ) System . out . println ( trieMap . toString ( ) ) ; for ( int i : unsorted ) { String string = String . valueOf ( i ) ; trieMap . remove ( string ) ; boolean exists = trieMap . contains ( string ) ; if ( exists ) { System . err . println ( " YIKES!!  " + string + "  still exists. " ) ; handleError ( trieMap ) ; return false ; } } if ( debug ) System . out . println ( ) ; } return true ; }
boolean isIndependentVariable ( ) { return getType ( ) = = VAR_INDEPENDENT ; }
public Row convertFromResult ( Result result ) { Object [ ] values = new Object [ schema . length ( ) ] ; byte [ ] rowKey = result . getRow ( ) ; int index = 0 ; for ( int i = 0 ; i < rowColumns . size ( ) ; i + + ) { ColumnDef def = columns . get ( rowColumns . get ( i ) ) ; index + = addColumnValue ( rowKey , index , rowKey . length , values , def . type , schema . fieldIndex ( def . name ) , keySeparator , i = = rowColumns . size ( ) - 1 ) ; if ( i < rowColumns . size ( ) - 1 ) { index + = keySeparator . length ; } } for ( Cell cell : result . listCells ( ) ) { String cellName = Bytes . toString ( cell . getQualifierArray ( ) , cell . getQualifierOffset ( ) , cell . getQualifierLength ( ) ) ; ColumnDef def = columns . get ( cellName ) ; values [ schema . fieldIndex ( def . name ) ] = getColumnValue ( cell . getValueArray ( ) , cell . getValueOffset ( ) , cell . getValueLength ( ) , def . type ) ; } return new RowWithSchema ( schema , values ) ; }
public void testCASPrependSuccess ( ) throws Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . prepend ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " estest " , client . get ( key ) ) ; }
public boolean equals ( final Object that ) { if ( that instanceof Sentence ) { final Sentence t = ( Sentence ) that ; return content . equals ( content ) & & punctuation = = t . punctuation & & truth . equals ( truth ) & & stamp . equals ( stamp ) ; } return false ; }
protected DNSOutgoing createOugoing ( ) { return new DNSOutgoing ( DNSConstants . FLAGS_QR_QUERY ) ; }
public void remove ( ) { queue . remove ( last ) ; }
Partnership getPartnershipByID ( @Nonnull IStringMap aSenderIDs , @Nonnull IStringMap aReceiverIDs ) ; @Nonnull @ReturnsMutableCopy ICommonsSet < String > getAllPartnershipNames ( ) ; @Nonnull @ReturnsMutableCopy ICommonsList < Partnership > getAllPartnerships ( ) ; }
public void initDynamicComponent ( @Nonnull final IAS2Session session , @Nullable final IStringMap parameters ) throws AS2Exception { super . initDynamicComponent ( session , parameters ) ; if ( getName ( ) = = null ) setName ( getDefaultName ( ) ) ; if ( getDescription ( ) = = null ) setDescription ( getDefaultDescription ( ) ) ; if ( getUsage ( ) = = null ) setUsage ( getDefaultUsage ( ) ) ;
public Concept addConcept ( final Term term , final Memory memory ) { Concept concept = conceptBuilder . newConcept ( term , memory ) ; Concept removed = concepts . putIn ( concept ) ; if ( removed = = null ) { } else if ( removed = = concept ) { memory . emit ( ConceptRemove . class , concept ) ; return null ; } else if ( removed ! = null ) { memory . emit ( ConceptRemove . class , removed ) ; } memory . logic . CONCEPT_ADD . commit ( term . getComplexity ( ) ) ; memory . emit ( Events . ConceptAdd . class , concept ) ; return concept ; }
public ViewResponse queryAndExcludeDocs ( View view , Query query ) { try { return asyncQueryAndExcludeDocs ( view , query ) . get ( ) ;
double valueSparse ( int i ) ; boolean isMissingSparse ( int p1 ) ; double [ ] toDoubleArray ( ) ; Attribute classAttribute ( ) ; int classIndex ( ) ; boolean classIsMissing ( ) ; double classValue ( ) ; int numClasses ( ) ; void setClassValue ( double d ) ; Instance copy ( ) ; void setDataset ( Instances dataset ) ; Instances dataset ( ) ; String toString ( ) ; }
public void onMenuModeChange ( MenuBuilder menu ) { if ( mCallback = = null ) { return ; } invalidate ( ) ; mContextView . showOverflowMenu ( ) ; }
public List < ? > serialize ( Object arrayValue , SerializerContext ctx ) { int size = Array . getLength ( arrayValue ) ; List < Object > res = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i + + ) { Object element = Array . get ( arrayValue , i ) ; Object serialized = ctx . serializeValue ( element ) ; res . add ( serialized ) ; } return res ; }
public void readTextWithTranslator ( ) throws Exception { Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( FileSystemInput . FORMAT_CONFIG , FileSystemInput . TEXT_FORMAT ) ; configMap . put ( FileSystemInput . PATH_CONFIG , FileSystemInput . class . getResource ( TEXT_DATA ) . getPath ( ) ) ; configMap . put ( " translator.type " , KVPTranslator . class . getName ( ) ) ; configMap . put ( " translator.delimiter.kvp " , " , " ) ; configMap . put ( " translator.delimiter.field " , " = " ) ; configMap . put ( " translator.schema.type " , " flat " ) ; configMap . put ( " translator.schema.field.names " , Lists . newArrayList ( " a " , " b " , " c " ) ) ; configMap . put ( " translator.schema.field.types " , Lists . newArrayList ( " integer " , " string " , " boolean " ) ) ; config = ConfigFactory . parseMap ( configMap ) ; FileSystemInput formatInput = new FileSystemInput ( ) ; assertNoValidationFailures ( formatInput , config ) ; formatInput . configure ( config ) ; List < Row > results = formatInput . read ( ) . collectAsList ( ) ; assertEquals ( 2 , results . size ( ) ) ; assertTrue ( results . contains ( RowFactory . create ( 1 , " hello " , true ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( 2 , " world " , false ) ) ) ; }
public void testCompressedStringNotSmaller ( ) throws Exception { String s1 = " This is a test simple string that will not be compressed. " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( 0 , cd . getFlags ( ) ) ; assertTrue ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; }
public void testReplaceCancellation ( ) throws Exception { tryCancellation ( client . replace ( " x " , 3 , " y " ) ) ; }
public CharsWrapper readCharUntil ( char [ ] stop ) { CharsWrapper . Builder builder = new CharsWrapper . Builder ( 10 ) ; char c = readChar ( ) ; while ( ! Utils . arrayContains ( stop , c ) ) { builder . append ( c ) ; c = readChar ( ) ; } next = c ; return builder . build ( ) ; }
public void testUpserts ( ) throws Exception { truncate ( ) ; RandomOutput zkOutput = new ZooKeeperOutput ( ) ; zkOutput . configure ( config ) ; Row row1 = new RowWithSchema ( schema , " hello " , 100 , 1000L , true , 1.0f , - 1.0 ) ; Row row2 = new RowWithSchema ( schema , " world " , - 100 , - 1000L , false , - 1.0f , 1.0 ) ; List < Row > plan = Lists . newArrayList ( PlannerUtils . setMutationType ( row1 , MutationType . UPSERT ) , PlannerUtils . setMutationType ( row2 , MutationType . UPSERT ) ) ; zkOutput . applyRandomMutations ( plan ) ; Row filter1 = new RowWithSchema ( keySchema , " hello " , 100 , 1000L ) ; Row filter2 = new RowWithSchema ( keySchema , " world " , - 100 , - 1000L ) ; List < Row > filters = Lists . newArrayList ( filter1 , filter2 ) ; List < Row > rows = Lists . newArrayList ( zkOutput . getExistingForFilters ( filters ) ) ; assertEquals ( rows . size ( ) , 2 ) ; assertTrue ( rows . contains ( row1 ) ) ; assertTrue ( rows . contains ( row2 ) ) ; }
public KeyStore createNewKeyStore ( ) throws KeyStoreException , NoSuchProviderException { return KeyStore . getInstance ( " PKCS12 " , BouncyCastleProvider . PROVIDER_NAME ) ; }
public void testTwoMatched ( ) { List < Graph . Edge < Integer > > edges = new ArrayList < Graph . Edge < Integer > > ( ) ; { edges . add ( new Graph . Edge < Integer > ( 1 , v_a1 , v_b1 ) ) ; edges . add ( new Graph . Edge < Integer > ( 1 , v_a1 , v_b3 ) ) ; edges . add ( new Graph . Edge < Integer > ( 1 , v_a2 , v_b2 ) ) ; edges . add ( new Graph . Edge < Integer > ( 1 , v_a3 , v_b2 ) ) ; } final Graph < Integer > graph = new Graph < Integer > ( vertices , edges ) ; TurboMatching . MatchingResult < Integer > matchingResult = TurboMatching . getMaximumMatching ( graph ) ; assertTrue ( matchingResult . getSize ( ) = = 2 ) ; assertTrue ( matchingResult . getMate ( ) . containsKey ( v_a1 ) ) ; assertTrue ( matchingResult . getMate ( ) . containsKey ( v_b2 ) ) ; assertTrue ( matchingResult . getMate ( ) . containsValue ( v_a1 ) ) ; assertTrue ( matchingResult . getMate ( ) . containsValue ( v_b2 ) ) ; }
protected void loadPlaceholder ( CoverAsyncHelper coverHelper ) { coverHelper . obtainMessage ( CoverAsyncHelper . EVENT_COVER_NOT_FOUND ) . sendToTarget ( ) ; }
protected Node < T > removeValue ( T value ) { Node < T > nodeToRemoved = this . getNode ( value ) ; if ( nodeToRemoved ! = null ) { Node < T > replacementNode = this . getReplacementNode ( nodeToRemoved ) ; replaceNodeWithNode ( nodeToRemoved , replacementNode ) ; } return nodeToRemoved ; }
public boolean greaterThan ( final BudgetValue other ) { return ( getPriority ( ) - other . getPriority ( ) > Parameters . BUDGET_THRESHOLD ) & & ( getDurability ( ) - other . getDurability ( ) > Parameters . BUDGET_THRESHOLD ) & &
public void authenticate ( final String [ ] mechs , final CallbackHandler cbh ) throws OperationException { final ConcurrentHashMap < MemcachedNode , OperationStatus > statuses = new ConcurrentHashMap < MemcachedNode , OperationStatus > ( ) ; Collection < MemcachedNode > todo = new ArrayList < MemcachedNode > ( conn . getLocator ( ) . getAll ( ) ) ; BroadcastOpFactory bfact = new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { final OperationCallback cb = new OperationCallback ( ) { public void receivedStatus ( OperationStatus status ) { statuses . put ( n , status ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; if ( statuses . containsKey ( n ) ) { OperationStatus priorStatus = statuses . remove ( n ) ; return opFact . saslStep ( mechs , priorStatus . getMessage ( ) , n . toString ( ) , null , cbh , cb ) ; } else { return opFact . saslAuth ( mechs , n . toString ( ) , null , cbh , cb ) ; } } } ; boolean done = false ; while ( ! done ) { CountDownLatch blatch = broadcastOp ( bfact , todo ) ;
public JPanel showCategory ( Object category ) { String title = category . toString ( ) ; SwingLogTextM p = getLogPanel ( category ) ; int columnWidth = 400 ; SwingLogPanel . setConsoleStyle ( p , true ) ; JPanel x = new JPanel ( new BorderLayout ( ) ) ; JMenuBar headerMenu = new JMenuBar ( ) ; JMenu m = new JMenu ( p . label ) ; m . add ( new JMenuItem ( " Statement List " ) ) ; m . add ( new JMenuItem ( " Log " ) ) ; m . add ( new JMenuItem ( " Concept List " ) ) ; m . add ( new JMenuItem ( " Concept Cloud " ) ) ; m . add ( new JMenuItem ( " Concepts Network " ) ) ; m . add ( new JMenuItem ( " Statements Network " ) ) ; m . add ( new JMenuItem ( " Truth vs. Confidence " ) ) ; m . addSeparator ( ) ; m . add ( new JButton ( " Priority + " ) ) ; m . add ( new JButton ( " Priority - " ) ) ; m . addSeparator ( ) ; m . add ( new JMenuItem ( " Close " ) ) ; headerMenu . add ( m ) ; x . add ( headerMenu , BorderLayout . NORTH ) ; JPanel ioTextWrap = new JPanel ( new BorderLayout ( ) ) ; ioTextWrap . add ( p ) ; x . add ( new JScrollPane ( ioTextWrap ) , BorderLayout . CENTER ) ; x . setMinimumSize ( new Dimension ( columnWidth , 0 ) ) ; x . setMaximumSize ( new Dimension ( columnWidth , Integer . MAX_VALUE / 2 ) ) ; x . setPreferredSize ( new Dimension ( columnWidth , 0 ) ) ; x . validate ( ) ; content . add ( x ) ; SwingUtilities . invokeLater ( new Runnable ( ) { @Override public void run ( ) { revalidate ( ) ; repaint ( ) ; } } ) ; return x ; }
Term nextTerm ( boolean endNeeded ) throws Exception ; int getCurrentLine ( ) ; int getCurrentOffset ( ) ; int [ ] offsetToRowColumn ( int offset ) ; }
public static void main ( String [ ] args ) throws Exception { NAR n = new Default ( ) . setConceptBagSize ( 16192 ) . build ( ) ; ( n . param ) . noiseLevel . set ( 40 ) ; KIFInput k = new KIFInput ( " /home/me/sigma/KBs/Merge.kif " ) ; k . setIncludeSubclass ( true ) ; k . setIncludeInstance ( true ) ; k . setIncludeSubrelation ( true ) ; k . setIncludeRelatedInternalConcept ( true ) ; k . start ( ) ; n . addInput ( k ) ; n . run ( 1 ) ; new NARSwing ( n ) ;
public static double score ( int maxCycles , NAR n ) { Parameters . DEBUG = false ; double s ; try { s = NALTestScore . score ( n , maxCycles ) ; } catch ( Throwable e ) { if ( Parameters . DEBUG ) e . printStackTrace ( ) ; return 0 ; } return s ;
public abstract String getName ( ) ; public String info ( ) { return toString ( ) ; } public boolean isUnknown ( ) { return getName ( ) . isEmpty ( ) ; } public String mainText ( ) { return getName ( ) ; } public boolean nameEquals ( final Item o ) { return getName ( ) . equals ( o . getName ( ) ) ; } public String sortText ( ) { return getName ( ) . toLowerCase ( Locale . getDefault ( ) ) ; } @Override public String toString ( ) { return mainText ( ) ; } }
private byte [ ] download ( String textUrl ) { URL url = buildURLForConnection ( textUrl ) ; HttpURLConnection connection = getHttpConnection ( url ) ; BufferedInputStream bis = null ; ByteArrayOutputStream baos = null ; byte [ ] buffer = null ; int len ; if ( ! urlExists ( connection ) ) { return null ; } try { bis = new BufferedInputStream ( connection . getInputStream ( ) , 8192 ) ; baos = new ByteArrayOutputStream ( ) ; buffer = new byte [ 1024 ] ; while ( ( len = bis . read ( buffer ) ) > - 1 ) { baos . write ( buffer , 0 , len ) ; } baos . flush ( ) ; buffer = baos . toByteArray ( ) ; } catch ( final Exception e ) { if ( DEBUG ) { Log . e ( TAG , " Failed to download cover. " , e ) ; } } finally { if ( bis ! = null ) { try { bis . close ( ) ; } catch ( final IOException e ) { Log . e ( TAG , " Failed to close the BufferedInputStream. " , e ) ; } } if ( baos ! = null ) { try { baos . close ( ) ; } catch ( final IOException e ) { Log . e ( TAG , " Failed to close the BufferedArrayOutputStream. " , e ) ; } } if ( connection ! = null ) { connection . disconnect ( ) ; } } return buffer ; }
private void prev ( ) { Log . d ( TAG , " StreamingService.prev() " ) ; MPD mpd = app . oMPDAsyncHelper . oMPD ; try { mpd . previous ( ) ;
public abstract void doStop ( ) throws OpenAS2Exception ; public boolean canHandle ( final String sAction , final IMessage aMsg , final Map < String , Object > aOptions ) { return false ; } public void forceStop ( final Exception aCause ) { new ForcedStopException ( aCause ) . terminate ( ) ; try { stop ( ) ; } catch ( final OpenAS2Exception ex ) { ex . terminate ( ) ; } } public void handle ( final String sAaction , final IMessage aMsg , final Map < String , Object > aOptions ) throws OpenAS2Exception { throw new UnsupportedException ( " Active modules don't handle anything by default " ) ; } private void _setRunning ( final boolean bRunning ) { m_bRunning = bRunning ; } public void start ( ) throws OpenAS2Exception { _setRunning ( true ) ; doStart ( ) ; } public void stop ( ) throws OpenAS2Exception { _setRunning ( false ) ; doStop ( ) ; } @Override public String toString ( ) { return getClass ( ) . getName ( ) + " :  " + getParameters ( ) ; } }
public void onRefreshStarted ( ) { } public void onReleaseToRefresh ( ) { } public void onRefreshMinimized ( ) { } public abstract boolean showHeaderView ( ) ; public abstract boolean hideHeaderView ( ) ; public void onConfigurationChanged ( Activity activity , Configuration newConfig ) { } }
void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; MemcachedNode getHandlingNode ( ) ; void setHandlingNode ( MemcachedNode to ) ; void timeOut ( ) ; boolean isTimedOut ( ) ; boolean isTimedOut ( long ttlMillis ) ; boolean isTimedOutUnsent ( ) ; long getWriteCompleteTimestamp ( ) ; byte [ ] getErrorMsg ( ) ; }
public void testReadChunkLenEOS ( ) throws Exception { InputStream noNewLine = new ByteArrayInputStream ( " 1 " . getBytes ( ) ) ; HTTPHelper . readChunkLen ( noNewLine ) ; fail ( " An EOFException should have been thrown " ) ; }
protected void updateGUI ( ) { speedSlider . repaint ( ) ; updateScheduled . set ( false ) ;
public Config wrapRead ( Config config ) { return new ConvertedConfig ( config , this : : convert , v - > v , config : : supportsType ) ; }
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }
public final void clear ( ) { for ( int i = 0 ; i < levels ; i + + ) { if ( level [ i ] ! = null ) { level [ i ] . clear ( ) ; } } nameTable . clear ( ) ; currentLevel = levels - 1 ; levelIndex = capacity % levels ; mass = 0 ; currentCounter = 0 ; }
public static void main ( String [ ] args ) throws Exception { new MeterTest ( ) . meterMeters ( ) ;
public void readFrom ( File file , boolean merge ) throws IOException { if ( ! merge ) { this . asMap ( ) . clear ( ) ; } new JsonParser ( ) . parseConfig ( file , this ) ; }
public void seek ( int songId , long position ) throws MPDServerException { if ( mpdConnection = = null ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } String [ ] args = new String [ 2 ] ; args [ 0 ] = Integer . toString ( songId ) ; args [ 1 ] = Long . toString ( position ) ; mpdConnection . sendCommand ( MPD_CMD_SEEK_ID , args ) ; mpdStatus . songId = songId ; mpdStatus . elapsedTime = position ; }
public void compute_closure ( ) throws internal_error { lalr_item_set consider ; lalr_item itm , new_itm , add_itm ; non_terminal nt ; terminal_set new_lookaheads ; Enumeration p ; production prod ; boolean need_prop ; hashcode_cache = null ; consider = new lalr_item_set ( this ) ; while ( consider . size ( ) > 0 ) {
public void testBag ( final boolean List , final int levels , final int capacity , final PortableDouble forgetRate ) { totalPriority = 0 ; totalMass = 0 ; totalMaxItemsPerLevel = totalMinItemsPerLevel = 0 ; final Performance p = new Performance ( ( List ? " DequeArray " : " LinkedList " ) + " , " + levels + " , " + capacity , repeats , warmups ) { @Override public void init ( ) { } @Override public void run ( final boolean warmup ) { Nar nar = null ; try { nar = new Nar ( ) ; } catch ( IOException ex ) { Logger . getLogger ( BagPerf . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( InstantiationException ex ) { Logger . getLogger ( BagPerf . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( InvocationTargetException ex ) { Logger . getLogger ( BagPerf . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( NoSuchMethodException ex ) { Logger . getLogger ( BagPerf . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ParserConfigurationException ex ) { Logger . getLogger ( BagPerf . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( IllegalAccessException ex ) { Logger . getLogger ( BagPerf . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( SAXException ex ) { Logger . getLogger ( BagPerf . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ClassNotFoundException ex ) { Logger . getLogger ( BagPerf . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } catch ( ParseException ex ) { Logger . getLogger ( BagPerf . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } final LevelBag < NullItem , CharSequence > b = new LevelBag ( levels , capacity , nar . narParameters ) { } ; randomBagIO ( b , randomAccesses , insertRatio ) ; if ( ! warmup ) { totalPriority + = b . getAveragePriority ( ) ; totalMass + = b . getMass ( ) ; totalMinItemsPerLevel + = b . getMinItemsPerLevel ( ) ; totalMaxItemsPerLevel + = b . getMaxItemsPerLevel ( ) ; } } } . printCSV ( true ) ; System . out . print ( ( totalMaxItemsPerLevel / p . repeats ) + " , " ) ; System . out . print ( totalPriority / p . repeats + " , " ) ; System . out . print ( totalMass / repeats / levels + " , " ) ; System . out . println ( ) ; }
public List < V > remove ( final K key ) { return mInternalMap . remove ( key ) ; }
private void freeze ( ) { if ( env = = null ) return ; try { if ( stackEnv . getLast ( ) = = env ) return ; } catch ( NoSuchElementException e ) { } stackEnv . addLast ( env ) ; }
BlockingQueue < Operation > createReadOperationQueue ( ) ; BlockingQueue < Operation > createWriteOperationQueue ( ) ; long getOpQueueMaxBlockTime ( ) ; ExecutorService getListenerExecutorService ( ) ; boolean isDefaultExecutorService ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; boolean isDaemon ( ) ; boolean useNagleAlgorithm ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; int getReadBufSize ( ) ; HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; MetricType enableMetrics ( ) ; MetricCollector getMetricCollector ( ) ; long getAuthWaitTime ( ) ; }
protected void parseSentence ( String s , Narsese narsese , List < String > statements , boolean modifyVocabulary ) { s = s . trim ( ) ; String punct = " . " ; if ( s . endsWith ( " ? " ) ) { punct = " ? " ; } else if ( s . endsWith ( " ! " ) ) { punct = " ! " ; } s = s . replace ( " go to " , " go-to " ) . replace ( " should be " , " is " ) ; s = s . replace ( " ? " , " " ) . replace ( " ! " , " " ) . replace ( " . " , " " ) . replace ( " , " , " " ) ; s = s . replace ( " who  " , " ?1  " ) . replace ( " what  " , " ?1  " ) . replace ( " when  " , " ?1  " ) . replace ( " where  " , " ?1  " ) ; s = s . replace ( " somewhere " , " #1 " ) . replace ( " something " , " #1 " ) ; String [ ] words = s . split ( "   " ) ; ArrayList < String > realwords = new ArrayList < String > ( ) ; for ( int i = 0 ; i < words . length ; i + + ) { if ( ! ( words [ i ] . equals ( " a " ) | | words [ i ] . equals ( " an " ) | | words [ i ] . equals ( " the " ) ) ) { realwords . add ( words [ i ] ) ; if ( modifyVocabulary ) { if ( ! vocabulary . contains ( words [ i ] ) ) { vocabulary . add ( words [ i ] ) ; } } } } words = realwords . toArray ( new String [ realwords . size ( ) ] ) ; for ( String word : words ) { for ( String mword : vocabulary ) { if ( word . equals ( mword ) ) { continue ; } int difference = levenshteinDistance ( word . replace ( " ing " , " " ) , mword . replace ( " ing " , " " ) ) ; int longerword = Math . max ( word . length ( ) , mword . length ( ) ) ; double perc = ( ( double ) difference ) / ( ( double ) longerword ) ; if ( perc < 0.3 ) { statements . add ( " < " + word + "  <->  " + mword + " >. " ) ; } } } String sentence = " " ; if ( words . length = = 2 ) { sentence = " (^ " + words [ 0 ] + " , " + words [ 1 ] + " ) " + punct + "  :|: " ; } else if ( words . length = = 3 | | ( words . length > 3 & & ( words [ 3 ] . equals ( " at " ) | | words [ 3 ] . equals ( " on " ) | | words [ 3 ] . equals ( " in " ) ) ) ) { if ( " is " . equals ( words [ 1 ] ) ) { sentence = " < " + words [ 0 ] + "  -->  " + words [ 2 ] + " > " + punct + "  :|: " ; } else { sentence = " <(*, " + words [ 0 ] + " , " + words [ 2 ] + " ) -->  " + words [ 1 ] + " > " + punct + "  :|: " ; } } else { boolean contains_is = false ; for ( int i = 0 ; i < words . length ; i + + ) { if ( words [ i ] . equals ( " is " ) ) { contains_is = true ; String left = " <(* " ; String right = " (* " ; int leftcnt = 0 ; int rightcnt = 0 ; for ( int j = 0 ; j < i ; j + + ) { if ( words [ j ] . equals ( " at " ) | | words [ j ] . equals ( " on " ) | | words [ j ] . equals ( " in " ) ) { break ; } leftcnt + + ; left + = " , " + words [ j ] ; } for ( int j = i + 1 ; j < words . length ; j + + ) { if ( words [ j ] . equals ( " at " ) | | words [ j ] . equals ( " on " ) | | words [ j ] . equals ( " in " ) ) { break ; } rightcnt + + ; right + = " , " + words [ j ] ; } left + = " ) " ; right + = " )> " ; if ( rightcnt = = 1 ) { right = right . replace ( " (*, " , " " ) ; right = right . replace ( " ) " , " " ) ; } if ( leftcnt = = 1 ) { left = left . replace ( " (*, " , " " ) ; left = left . replace ( " ) " , " " ) ; } sentence = left + "  -->  " + right + punct + "  :|: " ; } } if ( contains_is = = false ) { sentence = " <(* " ; for ( int i = 0 ; i < words . length ; i + + ) { sentence + = " , " + words [ i ] ; } sentence + = " ) --> sentence> " + punct + "  :|: " ; } } statements . add ( sentence ) ; for ( int i = 0 ; i < words . length - 1 ; i + + ) { if ( words [ i ] . equals ( " at " ) | | words [ i ] . equals ( " on " ) | | words [ i ] . equals ( " in " ) ) {
default void save ( ) throws OpenAS2Exception { save ( getFilename ( ) , getPassword ( ) ) ; }
private void cleanupCover ( final MenuItem item , final boolean isWrongCover ) { final AdapterView . AdapterContextMenuInfo info = ( AdapterView . AdapterContextMenuInfo ) item . getMenuInfo ( ) ; final Album album = ( Album ) items . get ( ( int ) info . id ) ; final AlbumInfo albumInfo = album . getAlbumInfo ( ) ; if ( isWrongCover ) { CoverManager . getInstance ( ) . markWrongCover ( albumInfo ) ; } else { CoverManager . getInstance ( ) . clear ( albumInfo ) ; } refreshCover ( info . targetView , albumInfo ) ; updateNowPlayingSmallFragment ( albumInfo ) ; }
boolean canHandle ( String sAction , IMessage aMsg , Map < String , Object > aOptions ) ; void handle ( String sAction , IMessage aMsg , Map < String , Object > aOptions ) throws OpenAS2Exception ; }
void gotData ( String key , int flags , byte [ ] data ) ; void getComplete ( ) ; } }
void prepareGoal ( ) { LinkedHashMap < Var , Var > goalVars = new LinkedHashMap < > ( ) ; startGoal = ( Struct ) ( query ) . copyGoal ( goalVars , 0 ) ; this . goalVars = goalVars . values ( ) ; }
public void init ( ) { } public void start ( ) { if ( ! started ) { started = true ; mario = new MarioComponent ( ) ; setContentPane ( mario ) ; setFocusable ( false ) ; mario . setFocusCycleRoot ( true ) ; mario . start ( ) ; } } public void stop ( ) { if ( started ) { started = false ; removeKeyListener ( mario ) ; mario . stop ( ) ; removeFocusListener ( mario ) ; } } }
public static File resource ( String path ) { return new File ( " ./nars_lab/nars/launcher/ " + path ) ; }
public void log ( Level level , Object message , Throwable e ) { org . apache . log4j . Level pLevel = org . apache . log4j . Level . DEBUG ; switch ( level = = null ? Level . FATAL : level ) { case TRACE : pLevel = org . apache . log4j . Level . TRACE ; break ; case DEBUG : pLevel = org . apache . log4j . Level . DEBUG ; break ; case INFO : pLevel = org . apache . log4j . Level . INFO ; break ; case WARN : pLevel = org . apache . log4j . Level . WARN ; break ; case ERROR : pLevel = org . apache . log4j . Level . ERROR ; break ; case FATAL : pLevel = org . apache . log4j . Level . FATAL ; break ; default : pLevel = org . apache . log4j . Level . FATAL ; l4jLogger . log ( " net.spy.compat.log.AbstractLogger " , pLevel , " Unhandled  " + " log level:   " + level + "  for the following message " , null ) ; } l4jLogger . log ( " net.spy.compat.log.AbstractLogger " , pLevel , message , e ) ; }
static Object parseValue ( CharacterInput input , TomlParser parser ) { return parseValue ( input , Toml . readNonSpaceChar ( input ) , parser ) ; }
public void setParameters ( @Nullable final String sFormat , @Nullable final String sDelimiters , @Nonnull final String sValue ) throws OpenAS2Exception { final List < String > aKeys = StringHelper . getExploded ( ',' , sFormat ) ; final StringTokenizer aValueTokens = new StringTokenizer ( sValue , sDelimiters , false ) ; for ( final String sKey : aKeys ) {
public void run ( ) { String allText = FileUtils . readAllText ( path ) ; String [ ] values = allText . split ( " OBJECTS " ) [ 0 ] . split ( " ; " ) ; for ( String cell : values ) { String [ ] c = cell . split ( " , " ) ; if ( c . length < 14 ) { continue ; } if ( ! c [ 11 ] . equals ( " " ) & & ! c [ 11 ] . contains ( " { " ) ) { c [ 11 ] = " { " + c [ 11 ] + " } " ; } int i = Integer . valueOf ( c [ 0 ] ) ; int j = Integer . valueOf ( c [ 1 ] ) ; s . cells . readCells [ i ] [ j ] . charge = Float . valueOf ( c [ 2 ] ) ; s . cells . writeCells [ i ] [ j ] . charge = Float . valueOf ( c [ 2 ] ) ; s . cells . readCells [ i ] [ j ] . chargeFront = Boolean . valueOf ( c [ 3 ] ) ; s . cells . writeCells [ i ] [ j ] . chargeFront = Boolean . valueOf ( c [ 3 ] ) ; s . cells . readCells [ i ] [ j ] . conductivity = Float . valueOf ( c [ 4 ] ) ; s . cells . writeCells [ i ] [ j ] . conductivity = Float . valueOf ( c [ 4 ] ) ; s . cells . readCells [ i ] [ j ] . height = Float . valueOf ( c [ 5 ] ) ; s . cells . writeCells [ i ] [ j ] . height = Float . valueOf ( c [ 5 ] ) ; s . cells . readCells [ i ] [ j ] . is_solid = Boolean . valueOf ( c [ 6 ] ) ; s . cells . writeCells [ i ] [ j ] . is_solid = Boolean . valueOf ( c [ 6 ] ) ; s . cells . readCells [ i ] [ j ] . light = Float . valueOf ( c [ 7 ] ) ; s . cells . writeCells [ i ] [ j ] . light = Float . valueOf ( c [ 7 ] ) ; s . cells . readCells [ i ] [ j ] . logic = Logic . values ( ) [ Integer . valueOf ( c [ 8 ] ) ] ; s . cells . writeCells [ i ] [ j ] . logic = Logic . values ( ) [ Integer . valueOf ( c [ 8 ] ) ] ; if ( s . cells . readCells [ i ] [ j ] . logic = = Logic . SWITCH ) { if ( TestChamber . staticInformation ) s . nar . addInput ( " < " + c [ 11 ] + "  --> switch>. " ) ; if ( s . cells . readCells [ i ] [ j ] . light = = 1.0f ) { } else { } } if ( s . cells . readCells [ i ] [ j ] . logic = = Logic . OFFSWITCH ) { if ( TestChamber . staticInformation ) s . nar . addInput ( " < " + c [ 11 ] + "  --> switch>. " ) ; if ( s . cells . readCells [ i ] [ j ] . light = = 1.0f ) { } else { } } if ( ! c [ 9 ] . equals ( " " ) ) { s . cells . readCells [ i ] [ j ] . machine = Machine . values ( ) [ Integer . valueOf ( c [ 9 ] ) ] ; s . cells . writeCells [ i ] [ j ] . machine = Machine . values ( ) [ Integer . valueOf ( c [ 9 ] ) ] ; if ( s . cells . readCells [ i ] [ j ] . machine = = Machine . Turret ) { if ( TestChamber . staticInformation ) s . nar . addInput ( " < " + c [ 11 ] + "  --> firework>. " ) ; if ( s . cells . readCells [ i ] [ j ] . light = = 1.0f ) { } else { } } if ( s . cells . readCells [ i ] [ j ] . machine = = Machine . Light ) { if ( TestChamber . staticInformation ) s . nar . addInput ( " < " + c [ 11 ] + "  --> light>. " ) ; if ( s . cells . readCells [ i ] [ j ] . light = = 1.0f ) { } else { } } } s . cells . readCells [ i ] [ j ] . material = Material . values ( ) [ Integer . valueOf ( c [ 10 ] ) ] ; s . cells . writeCells [ i ] [ j ] . material = Material . values ( ) [ Integer . valueOf ( c [ 10 ] ) ] ; if ( s . cells . readCells [ i ] [ j ] . material = = Material . Door ) { if ( TestChamber . staticInformation ) s . nar . addInput ( " < " + c [ 11 ] + "  --> door>. " ) ; } s . cells . readCells [ i ] [ j ] . name = c [ 11 ] ; s . cells . writeCells [ i ] [ j ] . name = c [ 11 ] ; try { if ( ! c [ 11 ] . equals ( " " ) ) { String value = c [ 11 ] . replaceAll ( " [A-Za-z] " , " " ) . replaceAll ( " \\ } " , " " ) . replaceAll ( " \\ { " , " " ) ; int res = Integer . parseInt ( value ) ; if ( res > Hauto . entityID ) { Hauto . entityID = res + 1 ; } } } catch ( Exception ex ) { } s . cells . readCells [ i ] [ j ] . value = Float . valueOf ( c [ 12 ] ) ; s . cells . writeCells [ i ] [ j ] . value = Float . valueOf ( c [ 12 ] ) ; s . cells . readCells [ i ] [ j ] . value2 = Float . valueOf ( c [ 13 ] ) ; s . cells . writeCells [ i ] [ j ] . value2 = Float . valueOf ( c [ 13 ] ) ; } String [ ] objs = allText . split ( " OBJECTS " ) [ 1 ] . split ( " ; " ) ; ArrayList < GridObject > newobj = new ArrayList < > ( ) ; for ( String obj : objs ) { String [ ] val = obj . split ( " , " ) ; if ( val . length = = 0 ) { continue ; } if ( ! val [ 1 ] . equals ( " " ) & & ! val [ 1 ] . contains ( " { " ) ) { val [ 1 ] = " { " + val [ 1 ] + " } " ; } String name = val [ 1 ] ; try { if ( ! name . equals ( " " ) ) { String value = name . replaceAll ( " [A-Za-z] " , " " ) ; int res = Integer . parseInt ( value ) ; if ( res > Hauto . entityID ) { Hauto . entityID = res + 1 ; } } } catch ( Exception ex ) { } float cx = Float . valueOf ( val [ 2 ] ) ; float cy = Float . valueOf ( val [ 3 ] ) ; int x = Integer . valueOf ( val [ 5 ] ) ; int y = Integer . valueOf ( val [ 6 ] ) ; if ( val [ 0 ] . equals ( " GridAgent " ) ) { for ( GridObject z : s . objects ) { if ( z instanceof GridAgent ) { ( ( GridAgent ) z ) . cx = cx ; ( ( GridAgent ) z ) . cy = cy ; ( ( GridAgent ) z ) . x = x ; ( ( GridAgent ) z ) . y = y ; newobj . add ( z ) ; s . target = new PVector ( x , y ) ; s . current = new PVector ( x , y ) ; } } } if ( val [ 0 ] . equals ( " Key " ) ) { Key addu = new Key ( x , y , name ) ; if ( TestChamber . staticInformation ) s . nar . addInput ( " < " + name + "  --> Key>. " ) ; addu . space = s ; newobj . add ( addu ) ; } if ( val [ 0 ] . equals ( " Pizza " ) ) { Pizza addu = new Pizza ( x , y , name ) ; if ( TestChamber . staticInformation ) s . nar . addInput ( " < " + name + "  --> pizza>. " ) ; addu . space = s ; newobj . add ( addu ) ; } } s . objects = newobj ; }
public KeyStore getKeyStore ( ) { return m_aRWLock . readLocked ( ( ) - > { if ( m_aKeyStore = = null )
public void add ( T value ) { add ( new HeapNode < T > ( null , value ) ) ; }
protected void add ( final Item item , final boolean replace , final boolean play ) { try { mApp . oMPDAsyncHelper . oMPD . add ( ( Album ) item , replace , play ) ;
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseNoDocs vr = null ; if ( status . isSuccess ( ) ) { vr = parseNoDocsViewResult ( json ) ; } ( ( NoDocsCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }
public CharSequence subSequence ( int start , int end ) { return new RepeatedCharacterSequence ( getCharacter ( ) , end - start ) ; }
private static Document toDocument ( final IStringMap stringMap ) { final Document document = new Document ( ) ; for ( final Entry < String , String > entry : stringMap ) { document . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return document ; }
FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }
private void write ( ) throws IOException { final String cmdString = mCommand . toString ( ) ; getOutputStream ( ) . write ( cmdString ) ; getOutputStream ( ) . flush ( ) ; }
Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; int getReadBufSize ( ) ; HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; }
< T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public boolean isDirective ( ) { return ( type = = DIRECTIVE ) ; }
public void testRequiredFields ( ) { Map < String , Object > configMap = new HashMap < > ( ) ; configMap . put ( " fields " , Lists . newArrayList ( " name " , " age " , " nickname " ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; CheckForNullsRowRule rule = new CheckForNullsRowRule ( ) ; assertNoValidationFailures ( rule , config ) ; rule . configure ( " fieldscheck " , config ) ; Row row1 = new RowWithSchema ( SCHEMA , " Ian " , null , 34 , new BigDecimal ( " 0.00 " ) ) ; assertFalse ( " Row should not pass rule " , rule . check ( row1 ) ) ; Row row2 = new RowWithSchema ( SCHEMA , " Webster1 " , " Websta1 " , 110 , new BigDecimal ( " 450.10 " ) ) ; assertTrue ( " Row should pass rule " , rule . check ( row2 ) ) ; Row row4 = new RowWithSchema ( SCHEMA , " Ian " , " foo " , null , new BigDecimal ( " 450.10 " ) ) ; assertFalse ( " Row should not pass rule " , rule . check ( row4 ) ) ; }
private ViewResponseNoDocs parseNoDocsViewResult ( String json ) throws ParseException { final Collection < RowNoDocs > rows = new LinkedList < RowNoDocs > ( ) ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " rows " ) ) { JSONArray ids = base . getJSONArray ( " rows " ) ; for ( int i = 0 ; i < ids . length ( ) ; i + + ) { String id = ids . getJSONObject ( i ) . getString ( " id " ) ; String key = ids . getJSONObject ( i ) . getString ( " key " ) ; String value = ids . getJSONObject ( i ) . getString ( " value " ) ; rows . add ( new RowNoDocs ( id , key , value ) ) ; } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json:  " + json , 0 ) ; } } return new ViewResponseNoDocs ( rows ) ; }
public void shutdown ( ) { for ( BucketMonitor monitor : this . monitors . values ( ) ) { monitor . shutdown ( ) ;
public void missingNames ( ) { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( SchemaFactory . TYPE_CONFIG_NAME , " flat " ) ; paramMap . put ( FlatSchema . FIELD_TYPES_CONFIG , Lists . newArrayList ( " long " , " integer " ) ) ; config = ConfigFactory . parseMap ( paramMap ) ; FlatSchema flatSchema = new FlatSchema ( ) ; assertValidationFailures ( flatSchema , config ) ; }
public V put ( K key , V value ) { return put ( new Pair < K , V > ( key , value ) ) ; }
public void buildTermLinks ( final BudgetValue taskBudget ) { if ( termLinkTemplates . size ( ) > 0 ) { BudgetValue subBudget = distributeAmongLinks ( taskBudget , termLinkTemplates . size ( ) ) ;
protected void testNAL ( String path ) { int extraCycles = 0 ; final NAR n = new NAR ( ) ; final LinkedList < String > out = new LinkedList ( ) ; final LinkedList < String > expressions = new LinkedList ( ) ; new TextInput ( n , getExample ( path ) ) ; new TextOutput ( n ) { @Override public void nextOutput ( ArrayList < String > lines ) { for ( String s : lines ) { s = s . trim ( ) ; String OUT_PREFIX = Symbols . OUTPUT_LINE + " :  " ; if ( s . startsWith ( OUT_PREFIX ) ) { out . add ( s . substring ( OUT_PREFIX . length ( ) ) ) ; } else if ( s . startsWith ( " \" \ ' " ) ) { String expression = s . substring ( 2 , s . length ( ) - 1 ) ; expressions . add ( expression ) ; } } } } ; n . run ( extraCycles , false ) ; js . put ( " test " , this ) ; js . put ( " out " , out ) ; for ( String e : expressions ) { try { Object result = js . eval ( e ) ; if ( result instanceof Boolean ) { assertTrue ( path + " :  " + e , ( Boolean ) result ) ; } } catch ( Exception x ) { assertTrue ( path + " :  " + e + "  -->  " + x . toString ( ) , false ) ; System . err . println ( e ) ; System . err . println ( x ) ; x . printStackTrace ( ) ; } } if ( testPerformance ) { perfNAL ( path , 0 , performanceIterations , 1 ) ;
private void learnStory ( ArrayList < Scene > scenesToLearn ) { for ( Scene iteratorScene : scenesToLearn ) { nar . addInput ( iteratorScene . actionAsString + " . :|: " ) ;
private void adjustAllItems ( ) { final int first = getFirstVisiblePosition ( ) ; final int last = getLastVisiblePosition ( ) ; int begin = Math . max ( 0 , getHeaderViewsCount ( ) - first ) ; int end = Math . min ( last - first , getCount ( ) - 1 - getFooterViewsCount ( ) - first ) ; for ( int i = begin ; i < = end ; + + i ) { View v = getChildAt ( i ) ;
public void test_java_array_set_3_2 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " java_object('java.lang.String[]', [1], s), java_catch(java_array_set(s, 0, 1), [('java.lang.IllegalArgumentException'(Cause, Message, StackTrace), true)], true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Term cause = info . getTerm ( " Cause " ) ; assertFalse ( cause instanceof Var ) ; Term message = info . getTerm ( " Message " ) ; assertFalse ( message instanceof Var ) ; Term stackTrace = info . getTerm ( " StackTrace " ) ; assertTrue ( stackTrace . isList ( ) ) ; }
protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type:   " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; ByteBuffer bb = ByteBuffer . allocate ( bufSize + extraLen ) ; assert bb . order ( ) = = ByteOrder . BIG_ENDIAN ; bb . put ( REQ_MAGIC ) ; bb . put ( cmd ) ; bb . putShort ( ( short ) keyBytes . length ) ; bb . put ( ( byte ) extraLen ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( vbucket ) ; bb . putInt ( keyBytes . length + val . length + extraLen ) ; bb . putInt ( opaque ) ; bb . putLong ( cas ) ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { bb . putInt ( ( Integer ) o ) ; } else if ( o instanceof byte [ ] ) { bb . put ( ( byte [ ] ) o ) ; } else if ( o instanceof Long ) { bb . putLong ( ( Long ) o ) ; } else { assert false : " Unhandled extra header type:   " + o . getClass ( ) ; } } bb . put ( keyBytes ) ; bb . put ( val ) ; bb . flip ( ) ; setBuffer ( bb ) ; }
private static void syllogisms ( TaskLink tLink , TermLink bLink , Term taskTerm , Term beliefTerm , Memory memory ) { Sentence taskSentence = memory . getCurrentTask ( ) . getSentence ( ) ; Sentence belief = memory . getCurrentBelief ( ) ; int figure ; if ( taskTerm instanceof Inheritance ) { if ( beliefTerm instanceof Inheritance ) {
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
private String debugIntent ( final Intent intent ) { final ComponentName callingActivity = getCallingActivity ( ) ; final StringBuilder stringBuilder = new StringBuilder ( ) ; final Bundle extras = intent . getExtras ( ) ; stringBuilder . append ( " SimpleLibraryActivity started with invalid extra " ) ; if ( callingActivity ! = null ) { stringBuilder . append ( " , calling activity:  " ) ; stringBuilder . append ( callingActivity . getClassName ( ) ) ; } if ( extras ! = null ) { for ( final String what : extras . keySet ( ) ) { stringBuilder . append ( " , intent extra:  " ) ; stringBuilder . append ( what ) ; } } stringBuilder . append ( '.' ) ; return stringBuilder . toString ( ) ; }
public boolean add ( List < String > path , Object value ) { return super . add ( path , checkedValue ( value ) ) ; }
Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndLock ( final String key , int exp ) ; < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndLock ( String key , int exp ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public String toString ( ) { return " value= " + value + "  parent= " + ( ( parent ! = null ) ? parent . value : " NULL " ) +
public void initDynamicComponent ( final ISession aSession , final IStringMap aOptions ) throws OpenAS2Exception { super . initDynamicComponent ( aSession , aOptions ) ; getParameterRequired ( PARAM_FILENAME ) ; }
protected void add_precedence ( String term ) { if ( term = = null ) { System . err . println ( " Unable to add precedence to nonexistent terminal " ) ;
public abstract < R , A > R accept ( BaseRule . Visitor < R , A > v , A arg ) ; public interface Visitor < R , A > { public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . BaseR p , A arg ) ; } }
public void resetDetection ( ) { clear ( ) ; nar . stop ( ) ; for ( Answered ans : q ) { ans . off ( ) ;
public K floorKey ( K key ) { return keyOrNull ( getFloorEntry ( key ) ) ; }
private static SphereCluster calculateCenter ( ArrayList < Cluster > cluster , int dimensions ) { double [ ] res = new double [ dimensions ] ; for ( int i = 0 ; i < res . length ; i + + ) { res [ i ] = 0.0 ; } if ( cluster . size ( ) = = 0 ) { return new SphereCluster ( res , 0.0 ) ; } for ( Cluster point : cluster ) { double [ ] center = point . getCenter ( ) ; for ( int i = 0 ; i < res . length ; i + + ) { res [ i ] + = center [ i ] ; } } for ( int i = 0 ; i < res . length ; i + + ) { res [ i ] / = cluster . size ( ) ; } double radius = 0.0 ; for ( Cluster point : cluster ) { double dist = distance ( res , point . getCenter ( ) ) ; if ( dist > radius ) { radius = dist ; } } return new SphereCluster ( res , radius ) ; }
public OutputStream getOutputStream ( ) throws IOException { return httpURLConnection . getOutputStream ( ) ; }
public void event ( Class channel , Object [ ] arguments ) { if ( channel = = OUT . class ) { Object o = arguments [ 0 ] ;
public void putIn ( Type newItem ) { String newKey = newItem . getKey ( ) ; Type oldItem = nameTable . put ( newKey , newItem ) ; if ( oldItem ! = null ) { outOfBase ( oldItem ) ; newItem . merge ( oldItem ) ; } Type overflowItem = intoBase ( newItem ) ; if ( overflowItem ! = null ) { String overflowKey = overflowItem . getKey ( ) ;
public void onDataBind ( Context context , View targetView , List < ? extends Object > items , Object item , int position ) { final TextView text1 = ( TextView ) targetView . findViewById ( R . id . text1 ) ; text1 . setText ( LibraryTabsUtil . getTabTitleResId ( ( ( TabItem ) item ) . text ) ) ; }
private void combined ( RangeMaximumData < N > data ) { if ( data . maximum . doubleValue ( ) > this . maximum . doubleValue ( ) ) { this . maximum = data . maximum ;
public void applyBulkMutations ( List < Tuple2 < MutationType , DataFrame > > planned ) { for ( Tuple2 < MutationType , DataFrame > mutation : planned ) { MutationType mutationType = mutation . _1 ( ) ;
public void testDriverMemoryClientMode ( ) { Properties props = new Properties ( ) ; props . setProperty ( Contexts . SPARK_CONF_PROPERTY_PREFIX + " . " + Contexts . SPARK_DEPLOY_MODE_PROPERTY , Contexts . SPARK_DEPLOY_MODE_CLIENT ) ; props . setProperty ( Contexts . DRIVER_MEMORY_PROPERTY , " 2G " ) ; Config config = ConfigFactory . parseProperties ( props ) ; Contexts . initialize ( config , Contexts . ExecutionMode . UNIT_TEST ) ; thrown . expect ( RuntimeException . class ) ; thrown . expectMessage ( " Driver memory can not be set " ) ; Contexts . getSparkSession ( ) . sparkContext ( ) . getConf ( ) ; }
public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( String key ) ; }
public void receivedStatus ( OperationStatus status ) { crv . set ( json , status ) ; }
static FileConfigBuilder builder ( File file , ConfigFormat < ? > format ) { return builder ( file . toPath ( ) , format ) ; }
public void init ( ) { setSpeed ( 0 ) ; setSpeed ( 0 ) ; updateGUI ( ) ; ioText . setText ( " " ) ; }
public Literal visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitTrue p , A arg ) { return new com . googlecode . opennars . parser . loan . Loan . Absyn . LitTrue ( ) ; }
protected static String makeCompoundName ( final Operator op , final ArrayList < Term > arg ) { final StringBuilder name = new StringBuilder ( 16 ) . append ( Symbols . COMPOUND_TERM_OPENER ) . append ( op . toString ( ) ) ; for ( final Term t : arg ) { name . append ( Symbols . ARGUMENT_SEPARATOR ) ; if ( t instanceof CompoundTerm ) { ( ( CompoundTerm ) t ) . setName ( ( ( CompoundTerm ) t ) . makeName ( ) ) ; } name . append ( t . getName ( ) ) ; } name . append ( Symbols . COMPOUND_TERM_CLOSER ) ; return name . toString ( ) ; }
public void forget ( final E x ) { float forgetRate = forgetRate ( ) ; if ( forgetRate > 0 ) { BudgetFunctions . forget ( x . budget , forgetRate , RELATIVE_THRESHOLD ) ;
void hsim_ElemClicked ( Obj i ) { if ( lastclicked ! = null ) { lastclicked . DrawField = false ; } lastclicked = i ; }
protected void onSaveInstanceState ( Bundle outState ) { super . onSaveInstanceState ( outState ) ; getSherlock ( ) . dispatchSaveInstanceState ( outState ) ; }
void updateLocator ( final List < MemcachedNode > nodes , final Config conf ) ; }
static void putWithParsingMode ( ParsingMode parsingMode , CommentedConfig newCC , ConcurrentCommentedConfig config ) { config . bulkCommentedUpdate ( view - > { for ( CommentedConfig . Entry entry : newCC . entrySet ( ) ) {
public static byte [ ] readData ( final Socket aSocket , final IMessage aMsg ) throws IOException , MessagingException { byte [ ] aData = null ; final InputStream aIS = StreamUtils . getBuffered ( aSocket . getInputStream ( ) ) ; final String [ ] aRequest = readRequest ( aIS ) ; aMsg . setAttribute ( MA_HTTP_REQ_TYPE , aRequest [ 0 ] ) ; aMsg . setAttribute ( MA_HTTP_REQ_URL , aRequest [ 1 ] ) ; aMsg . setHeaders ( new InternetHeaders ( aIS ) ) ; final DataInputStream aDataIS = new DataInputStream ( aIS ) ; if ( aMsg . getHeader ( " Content-Length " ) = = null ) { final String sTransferEncoding = aMsg . getHeader ( " Transfer-Encoding " ) ; if ( sTransferEncoding ! = null ) { if ( sTransferEncoding . replaceAll ( " \\ s+ " , " " ) . equalsIgnoreCase ( " chunked " ) ) { int nLength = 0 ; for ( ; ; ) { int nBlocklen = 0 ; for ( ; ; ) { int ch = aDataIS . readByte ( ) ; if ( ch = = '\n' ) break ; if ( ch > = 'a' & & ch < = 'f' ) ch - = ( 'a' - 10 ) ; else if ( ch > = 'A' & & ch < = 'F' ) ch - = ( 'A' - 10 ) ; else if ( ch > = '0' & & ch < = '9' ) ch - = '0' ; else continue ; nBlocklen = ( nBlocklen * 16 ) + ch ; } if ( nBlocklen = = 0 ) break ; final int nNewlen = nLength + nBlocklen ; final byte [ ] aNewData = new byte [ nNewlen ] ; if ( nLength > 0 ) System . arraycopy ( aData , 0 , aNewData , 0 , nLength ) ; aDataIS . readFully ( aNewData , nLength , nBlocklen ) ; aData = aNewData ; nLength = nNewlen ; while ( aDataIS . readByte ( ) ! = '\n' ) { } } aMsg . setHeader ( " Content-Length " , Integer . toString ( nLength ) ) ; } else { HTTPUtil . sendHTTPResponse ( aSocket . getOutputStream ( ) , HttpURLConnection . HTTP_LENGTH_REQUIRED , false ) ; throw new IOException ( " Transfer-Encoding unimplemented:  " + sTransferEncoding ) ; } } else if ( aMsg . getHeader ( " Content-Length " ) = = null ) { HTTPUtil . sendHTTPResponse ( aSocket . getOutputStream ( ) , HttpURLConnection . HTTP_LENGTH_REQUIRED , false ) ; throw new IOException ( " Content-Length missing " ) ; } } else { final int nContentSize = Integer . parseInt ( aMsg . getHeader ( " Content-Length " ) ) ; aData = new byte [ nContentSize ] ; aDataIS . readFully ( aData ) ; } return aData ; }
public NAR newNAR ( ) { return new NeuromorphicNARBuilder ( ) . build ( ) ; }
protected boolean moveCaretStartOfLine ( TextLayoutHitInfo currPos ) { if ( currPos . thi . getCharIndex ( ) = = 0 ) return false ; currPos . thi = currPos . tli . layout . getNextLeftHit ( 1 ) ; return true ; }
public CachedData encode ( String o ) { throw new RuntimeException ( " Not invoked. " ) ; }
void checkSelect ( ) { if ( selected = = null ) {
public boolean removeAll ( Collection < ? > c ) { return false ; }
public BudgetValue backward ( TruthValue truth ) { return budgetInference ( truthToQuality ( truth ) , 1 ) ; }
public void test_text_concat_3_1 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch(text_concat(X, a, b), error(instantiation_error, instantiation_error(Goal, ArgNo)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " text_concat " , new Var ( " X " ) , new Struct ( " a " ) , new Struct ( " b " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 1 ) ; }
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 8 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; try { GetOperation . Callback cb = ( GetOperation . Callback ) getCallback ( ) ; cb . gotData ( key , flags , data ) ; } catch ( ClassCastException e ) { GetsOperation . Callback cb = ( GetsOperation . Callback ) getCallback ( ) ; cb . gotData ( key , flags , decodeLong ( pl , 0 ) , data ) ; } getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
public long estimatedRemainingInstances ( ) ; public boolean hasMoreInstances ( ) ; public E nextInstance ( ) ; public boolean isRestartable ( ) ; public void restart ( ) ; }
public void onCreate ( ) { super . onCreate ( ) ; System . err . println ( " onCreate Application " ) ; if ( android . os . Build . VERSION . SDK_INT > 9 ) { StrictMode . VmPolicy vmpolicy = new StrictMode . VmPolicy . Builder ( ) . penaltyLog ( ) . build ( ) ; StrictMode . ThreadPolicy policy = new StrictMode . ThreadPolicy . Builder ( ) . permitAll ( ) . build ( ) ; StrictMode . setThreadPolicy ( policy ) ; StrictMode . setVmPolicy ( vmpolicy ) ; } oMPDAsyncHelper = new MPDAsyncHelper ( ) ; oMPDAsyncHelper . addConnectionListener ( ( MPDApplication ) getApplicationContext ( ) ) ; settingsHelper = new SettingsHelper ( this , oMPDAsyncHelper ) ; disconnectSheduler = new Timer ( ) ; SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( this ) ; if ( ! settings . contains ( " albumTrackSort " ) ) settings . edit ( ) . putBoolean ( " albumTrackSort " , true ) . commit ( ) ;
public void testToRowValueCalendarInterval ( ) { DataType field = DataTypes . CalendarIntervalType ; thrown . expect ( RuntimeException . class ) ; thrown . expectMessage ( JUnitMatchers . containsString ( " StructField DataType unrecognized or not yet implemented " ) ) ; RowUtils . toRowValue ( " INTERVAL 1 MONTH " , field ) ; }
public abstract T dequeue ( ) ; public abstract boolean contains ( T value ) ; public abstract int size ( ) ; public static < T > Queue < T > createQueue ( QueueType type ) { switch ( type ) { case ArrayQueue : return new ArrayQueue < T > ( ) ; default : return new LinkedQueue < T > ( ) ; } } public static class ArrayQueue < T > extends Queue < T > { private static final int MINIMUM_SIZE = 10 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ MINIMUM_SIZE ] ; private int nextIndex = 0 ; private int firstIndex = 0 ; @Override public void enqueue ( T value ) { int length = nextIndex - firstIndex ; if ( length > = array . length ) { array = Arrays . copyOfRange ( array , firstIndex , ( ( nextIndex * 3 ) / 2 ) + 1 ) ; nextIndex = nextIndex - firstIndex ; firstIndex = 0 ; } array [ nextIndex + + ] = value ; } @Override public T dequeue ( ) { int length = nextIndex - firstIndex ; if ( length < 0 ) return null ; T t = array [ firstIndex ] ; array [ firstIndex + + ] = null ; length = nextIndex - firstIndex ; if ( length = = 0 ) { nextIndex = 0 ; firstIndex = 0 ; } if ( length > = MINIMUM_SIZE & & ( array . length - length ) > = length ) { array = Arrays . copyOfRange ( array , firstIndex , nextIndex ) ; nextIndex = length ; firstIndex = 0 ; } return t ; } @Override public boolean contains ( T value ) { for ( int i = firstIndex ; i < nextIndex ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public int size ( ) { return nextIndex - firstIndex ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = nextIndex - 1 ; i > = firstIndex ; i - - ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } public static class LinkedQueue < T > extends Queue < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; public LinkedQueue ( ) { head = null ; tail = null ; size = 0 ; } @Override public void enqueue ( T value ) { enqueue ( new Node < T > ( value ) ) ; } private void enqueue ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > oldHead = head ; head = node ; node . next = oldHead ; oldHead . prev = node ; } size + + ; } @Override public T dequeue ( ) { T result = null ; if ( tail ! = null ) { result = tail . value ; Node < T > prev = tail . prev ; if ( prev ! = null ) { prev . next = null ; tail = prev ; } else { head = null ; tail = null ; } size - - ; } return result ; } @Override public boolean contains ( T value ) { if ( head = = null ) return false ; Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . next ; } return false ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . next ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > prev = null ; private Node < T > next = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( prev ! = null ) ? prev . value : " NULL " ) + "  next= " + ( ( next ! = null ) ? next . value : " NULL " ) ; } } } }
public Builder mergeFrom ( com . google . protobuf . Message other ) { if ( other instanceof com . cloudera . labs . envelope . input . translate . ProtobufMultipleMessage . IncludedExample ) { return mergeFrom ( ( com . cloudera . labs . envelope . input . translate . ProtobufMultipleMessage . IncludedExample ) other ) ;
public boolean process ( ContentEvent event ) { if ( event . isLastEvent ( ) = = true | | ( instancesCount > 0 & & instancesCount % this . sampleFrequency = = 0 ) ) { if ( model . implementsMicroClusterer ( ) ) { Clustering clustering = model . getMicroClusteringResult ( ) ; ClusteringResultContentEvent resultEvent = new ClusteringResultContentEvent ( clustering , event . isLastEvent ( ) ) ; this . outputStream . put ( resultEvent ) ; } } updateStats ( event ) ; return false ; }
public EntranceProcessingItem addEntranceProcessor ( EntranceProcessor entranceProcessor , TopologyStarter starter ) { if ( this . mapProcessorToProcessingItem = = null ) { this . mapProcessorToProcessingItem = new HashMap < Processor , IProcessingItem > ( ) ; } EntranceProcessingItem pi = createEntrancePi ( entranceProcessor , starter ) ; this . mapProcessorToProcessingItem . put ( entranceProcessor , pi ) ; return pi ; }
public static final float temporalProjection ( final long sourceTime , final long targetTime , final long currentTime , RuntimeParameters param ) { final double a = 100000.0 * param . projectionDecay . get ( ) ; return 1.0f - abs ( sourceTime - targetTime ) / ( float ) ( abs ( sourceTime - currentTime ) + abs ( targetTime - currentTime ) + a ) ; }
private static void decomposeCompound ( CompoundTerm compound , Term component , Term term1 , int index , boolean compoundTask , int order , Memory memory ) { if ( ( compound instanceof Statement ) | | ( compound instanceof ImageExt ) | | ( compound instanceof ImageInt ) ) { return ; } Term term2 = CompoundTerm . reduceComponents ( compound , component , memory ) ; if ( term2 = = null ) { return ; } Task task = memory . getCurrentTask ( ) ; Sentence sentence = task . getSentence ( ) ; Sentence belief = memory . getCurrentBelief ( ) ; Statement oldContent = ( Statement ) task . getContent ( ) ; TruthValue v1 , v2 ; if ( compoundTask ) { v1 = sentence . truth ; v2 = belief . truth ; } else { v1 = belief . truth ; v2 = sentence . truth ; } TruthValue truth = null ; Term content ; if ( index = = 0 ) { content = Statement . make ( oldContent , term1 , term2 , order , memory ) ; if ( content = = null ) { return ; } if ( oldContent instanceof Inheritance ) { if ( compound instanceof IntersectionExt ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof IntersectionInt ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetInt ) & & ( component instanceof SetInt ) ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetExt ) & & ( component instanceof SetExt ) ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } else if ( compound instanceof DifferenceExt ) { if ( compound . term [ 0 ] . equals ( component ) ) { truth = TruthFunctions . reduceDisjunction ( v2 , v1 ) ; } else { truth = TruthFunctions . reduceConjunctionNeg ( v1 , v2 ) ; } } } else if ( oldContent instanceof Implication ) { if ( compound instanceof Conjunction ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof Disjunction ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } } } else { content = Statement . make ( oldContent , term2 , term1 , order , memory ) ; if ( content = = null ) { return ; } if ( oldContent instanceof Inheritance ) { if ( compound instanceof IntersectionInt ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof IntersectionExt ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetExt ) & & ( component instanceof SetExt ) ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetInt ) & & ( component instanceof SetInt ) ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } else if ( compound instanceof DifferenceInt ) { if ( compound . term [ 1 ] . equals ( component ) ) { truth = TruthFunctions . reduceDisjunction ( v2 , v1 ) ; } else { truth = TruthFunctions . reduceConjunctionNeg ( v1 , v2 ) ; } } } else if ( oldContent instanceof Implication ) { if ( compound instanceof Disjunction ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof Conjunction ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } } } if ( truth ! = null ) { BudgetValue budget = BudgetFunctions . compoundForward ( truth , content , memory ) ;
private int nextPowerOfTwo ( int n ) { return Integer . highestOneBit ( n ) < < 1 ; }
final public void onReceive ( final Context context , final Intent intent ) { final String action = intent . getAction ( ) ; final KeyEvent event = intent . getParcelableExtra ( Intent . EXTRA_KEY_EVENT ) ; String command = null ; Log . d ( TAG , " Intent:  " + intent + "  received with context:  " + context + "  with action:  " + action ) ; if ( AudioManager . ACTION_AUDIO_BECOMING_NOISY . equals ( action ) ) { command = AudioManager . ACTION_AUDIO_BECOMING_NOISY ; } else if ( event ! = null & & event . getAction ( ) = = KeyEvent . ACTION_DOWN & & Intent . ACTION_MEDIA_BUTTON . equals ( action ) ) { final int eventKeyCode = event . getKeyCode ( ) ; Log . d ( TAG , " with keycode:  " + eventKeyCode ) ; switch ( eventKeyCode ) { case KeyEvent . KEYCODE_MEDIA_STOP : command = NotificationService . ACTION_STOP ; break ; case KeyEvent . KEYCODE_HEADSETHOOK : case KeyEvent . KEYCODE_MEDIA_PLAY_PAUSE : command = NotificationService . ACTION_TOGGLE_PLAYBACK ; break ; case KeyEvent . KEYCODE_MEDIA_NEXT : command = NotificationService . ACTION_NEXT ; break ; case KeyEvent . KEYCODE_MEDIA_PREVIOUS : command = NotificationService . ACTION_PREVIOUS ; break ; } } if ( command ! = null ) { Intent i = new Intent ( context , NotificationService . class ) ;
static FileConfigBuilder < Config > builder ( String filePath , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return builder ( new File ( filePath ) , format ) ; }
public static void introVarOuter ( final Statement taskContent , final Statement beliefContent , final int index , final DerivationContext nal ) { if ( ! ( taskContent instanceof Inheritance ) ) { return ; } Variable varInd1 = new Variable ( " $varInd1 " ) ; Variable varInd2 = new Variable ( " $varInd2 " ) ; Term term11dependent = null , term12dependent = null , term21dependent = null , term22dependent = null ; Term term11 , term12 , term21 , term22 , commonTerm = null ; HashMap < Term , Term > subs = new HashMap < > ( ) ; if ( index = = 0 ) { term11 = varInd1 ; term21 = varInd1 ; term12 = taskContent . getPredicate ( ) ; term22 = beliefContent . getPredicate ( ) ; term12dependent = term12 ; term22dependent = term22 ; if ( term12 instanceof ImageExt ) { if ( ( term12 ) . containsTermRecursively ( term22 ) ) { commonTerm = term22 ; } if ( commonTerm = = null & & term12 instanceof ImageExt ) { commonTerm = ( ( ImageExt ) term12 ) . getTheOtherComponent ( ) ; if ( ! ( term22 . containsTermRecursively ( commonTerm ) ) ) { commonTerm = null ; } if ( term22 instanceof ImageExt & & ( ( commonTerm = = null ) | | ! ( term22 ) . containsTermRecursively ( commonTerm ) ) ) { commonTerm = ( ( ImageExt ) term22 ) . getTheOtherComponent ( ) ; if ( ( commonTerm = = null ) | | ! ( term12 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = null ; } } } if ( commonTerm ! = null ) { subs . put ( commonTerm , varInd2 ) ; term12 = ( ( CompoundTerm ) term12 ) . applySubstitute ( subs ) ; if ( ! ( term22 instanceof CompoundTerm ) ) { term22 = varInd2 ; } else { term22 = ( ( CompoundTerm ) term22 ) . applySubstitute ( subs ) ; } } } if ( commonTerm = = null & & term22 instanceof ImageExt ) { if ( ( term22 ) . containsTermRecursively ( term12 ) ) { commonTerm = term12 ; } if ( commonTerm = = null & & term22 instanceof ImageExt ) { commonTerm = ( ( ImageExt ) term22 ) . getTheOtherComponent ( ) ; if ( ! ( term12 . containsTermRecursively ( commonTerm ) ) ) { commonTerm = null ; } if ( term12 instanceof ImageExt & & ( ( commonTerm = = null ) | | ! ( term12 ) . containsTermRecursively ( commonTerm ) ) ) { commonTerm = ( ( ImageExt ) term12 ) . getTheOtherComponent ( ) ; if ( ( commonTerm = = null ) | | ! ( term22 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = null ; } } } if ( commonTerm ! = null ) { subs . put ( commonTerm , varInd2 ) ; term22 = ( ( CompoundTerm ) term22 ) . applySubstitute ( subs ) ; if ( ! ( term12 instanceof CompoundTerm ) ) { term12 = varInd2 ; } else { term12 = ( ( CompoundTerm ) term12 ) . applySubstitute ( subs ) ; } } } } else { term11 = taskContent . getSubject ( ) ; term21 = beliefContent . getSubject ( ) ; term12 = varInd1 ; term22 = varInd1 ; term11dependent = term11 ; term21dependent = term21 ; if ( term21 instanceof ImageInt ) { if ( ( term21 ) . containsTermRecursively ( term11 ) ) { commonTerm = term11 ; } if ( term11 instanceof ImageInt & & commonTerm = = null & & term21 instanceof ImageInt ) { commonTerm = ( ( ImageInt ) term11 ) . getTheOtherComponent ( ) ; if ( ! ( term21 . containsTermRecursively ( commonTerm ) ) ) { commonTerm = null ; } if ( ( commonTerm = = null ) | | ! ( term21 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = ( ( ImageInt ) term21 ) . getTheOtherComponent ( ) ; if ( ( commonTerm = = null ) | | ! ( term11 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = null ; } } } if ( commonTerm ! = null ) { subs . put ( commonTerm , varInd2 ) ; term21 = ( ( CompoundTerm ) term21 ) . applySubstitute ( subs ) ; if ( ! ( term11 instanceof CompoundTerm ) ) { term11 = varInd2 ; } else { term11 = ( ( CompoundTerm ) term11 ) . applySubstitute ( subs ) ; } } } if ( commonTerm = = null & & term11 instanceof ImageInt ) { if ( ( term11 ) . containsTermRecursively ( term21 ) ) { commonTerm = term21 ; } if ( term21 instanceof ImageInt & & commonTerm = = null & & term11 instanceof ImageInt ) { commonTerm = ( ( ImageInt ) term21 ) . getTheOtherComponent ( ) ; if ( ! ( term11 . containsTermRecursively ( commonTerm ) ) ) { commonTerm = null ; } if ( ( commonTerm = = null ) | | ! ( term11 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = ( ( ImageInt ) term11 ) . getTheOtherComponent ( ) ; if ( ( commonTerm = = null ) | | ! ( term21 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = null ; } } } if ( commonTerm ! = null ) { subs . put ( commonTerm , varInd2 ) ; term11 = ( ( CompoundTerm ) term11 ) . applySubstitute ( subs ) ; if ( ! ( term21 instanceof CompoundTerm ) ) { term21 = varInd2 ; } else { term21 = ( ( CompoundTerm ) term21 ) . applySubstitute ( subs ) ; } } } } Statement state1 = Inheritance . make ( term11 , term12 ) ; Statement state2 = Inheritance . make ( term21 , term22 ) ; Term content = Implication . make ( state1 , state2 ) ; if ( content = = null ) { return ; } TruthValue truthT = nal . getCurrentTask ( ) . sentence . truth ; TruthValue truthB = nal . getCurrentBelief ( ) . truth ; if ( ( truthT = = null ) | | ( truthB = = null ) ) { return ; } TruthValue truth = induction ( truthT , truthB ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; nal . doublePremiseTask ( content , truth , budget , false , false ) ; content = Implication . make ( state2 , state1 ) ; truth = induction ( truthB , truthT ) ; budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; nal . doublePremiseTask ( content , truth , budget , false , false ) ; content = Equivalence . make ( state1 , state2 ) ; truth = comparison ( truthT , truthB ) ; budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; nal . doublePremiseTask ( content , truth , budget , false , false ) ; Variable varDep = new Variable ( " #varDep " ) ; if ( index = = 0 ) { state1 = Inheritance . make ( varDep , term12dependent ) ; state2 = Inheritance . make ( varDep , term22dependent ) ; } else { state1 = Inheritance . make ( term11dependent , varDep ) ; state2 = Inheritance . make ( term21dependent , varDep ) ; } if ( ( state1 = = null ) | | ( state2 = = null ) ) return ; content = Conjunction . make ( state1 , state2 ) ; truth = intersection ( truthT , truthB ) ; budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; nal . doublePremiseTask ( content , truth , budget , false , false ) ; }
AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; MetricType enableMetrics ( ) ; MetricCollector getMetricCollector ( ) ; }
abstract public E takeOut ( boolean removeFromNameTable ) ; abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } protected int forgetRate ( ) { if ( forgettingRate ! = null ) { return forgettingRate . get ( ) ; } return - 1 ; } protected void reprocess ( E x ) { int r = forgetRate ( ) ; if ( r > 0 ) { BudgetFunctions . forget ( x . budget , forgetRate ( ) , RELATIVE_THRESHOLD ) ; } } public final boolean putBack ( final E oldItem , final boolean insertIntoNameTable ) { reprocess ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public final boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( ) { final E x = takeOut ( false ) ; if ( x ! = null ) { reprocess ( x ) ; boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else return null ; } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( CharSequence key ) ; }
private static void _initPartnershipFactory ( final AS2Session aSession ) throws ComponentDuplicateException { final SelfFillingPartnershipFactory aPartnershipFactory = new SelfFillingPartnershipFactory ( ) ; aSession . setPartnershipFactory ( aPartnershipFactory ) ; }
static void decomposeStatement ( CompoundTerm compound , Term component , boolean compoundTask , Memory memory ) { Task task = memory . currentTask ; Sentence sentence = task . getSentence ( ) ; Sentence belief = memory . currentBelief ; Term content = CompoundTerm . reduceComponents ( compound , component , memory ) ; if ( content = = null ) { return ; } TruthValue truth = null ; BudgetValue budget ; if ( sentence . isQuestion ( ) ) { budget = BudgetFunctions . compoundBackward ( content , memory ) ;
public Concept addConcept ( Term t , Memory m ) { RTConcept concept = new RTConcept ( t , new ContinuousBag < TaskLink > ( 20 , m . param . taskCyclesToForget , true ) , new ContinuousBag < TermLink > ( 20 , m . param . taskCyclesToForget , true ) , m ) ; concepts . put ( concept . getKey ( ) , concept ) ; conceptList . add ( concept ) ; return concept ; }
public void update ( final StatsSession session , final Meter tracker , final long now ) { lock . lock ( ) ; try { delegate . update ( session , tracker , now ) ;
public boolean isSigned ( @Nonnull final MimeBodyPart aPart ) throws MessagingException { ValueEnforcer . notNull ( aPart , " Part " ) ; final ContentType aContentType = new ContentType ( aPart . getContentType ( ) ) ; final String sBaseType = aContentType . getBaseType ( ) . toLowerCase ( Locale . US ) ; return sBaseType . equals ( " multipart/signed " ) ; }
public static boolean isHandled ( String type ) { for ( EventHandler handler : handlers ) { if ( handler . canHandleEventType ( type ) ) { return true ; } } return false ; }
public void testBinarySearch ( ) { int index = BinarySearch . find ( valueInArray , sorted , false ) ; assertTrue ( " Brute force error. expected= " + valueIndex + "  got= " + index , ( index = = valueIndex ) ) ; index = BinarySearch . find ( valueNotInArray , sorted , false ) ; assertTrue ( " Brute force error. expected= " + Integer . MAX_VALUE + "  got= " + index , ( index = = Integer . MAX_VALUE ) ) ; }
public ArrayRealVector call ( ) { return align ( node ) ; }
public static boolean equalSubjectPredicateInRespectToImageAndProduct ( final Term a , final Term b ) { if ( a = = null | | b = = null ) { return false ; } if ( ! ( a instanceof Statement ) & & ! ( b instanceof Statement ) ) { return false ; } if ( a . equals ( b ) ) { return true ; } Statement A = ( Statement ) a ; Statement B = ( Statement ) b ; if ( ! ( A instanceof Similarity & & B instanceof Similarity | | A instanceof Inheritance & & B instanceof Inheritance ) ) return false ; Term subjA = A . getSubject ( ) ; Term predA = A . getPredicate ( ) ; Term subjB = B . getSubject ( ) ; Term predB = B . getPredicate ( ) ; Term ta = null , tb = null ; Term sa = null , sb = null ; if ( ( subjA instanceof Product ) & & ( predB instanceof ImageExt ) ) { ta = predA ; sa = subjA ; tb = subjB ; sb = predB ; } if ( ( subjB instanceof Product ) & & ( predA instanceof ImageExt ) ) { ta = subjA ; sa = predA ; tb = predB ; sb = subjB ; } if ( ( predA instanceof ImageExt ) & & ( predB instanceof ImageExt ) ) { ta = subjA ; sa = predA ; tb = subjB ; sb = predB ; } if ( ( subjA instanceof ImageInt ) & & ( subjB instanceof ImageInt ) ) { ta = predA ; sa = subjA ; tb = predB ; sb = subjB ; } if ( ( predA instanceof Product ) & & ( subjB instanceof ImageInt ) ) { ta = subjA ; sa = predA ; tb = predB ; sb = subjB ; } if ( ( predB instanceof Product ) & & ( subjA instanceof ImageInt ) ) { ta = predA ; sa = subjA ; tb = subjB ; sb = predB ; } if ( ta ! = null ) { Term [ ] sat = ( ( CompoundTerm ) sa ) . term ; Term [ ] sbt = ( ( CompoundTerm ) sb ) . term ; if ( sa instanceof Image & & sb instanceof Image ) { Image im1 = ( Image ) sa ; Image im2 = ( Image ) sb ; if ( im1 . relationIndex ! = im2 . relationIndex ) { return false ; } } Set < Term > componentsA = new HashSet ( 1 + sat . length ) ; Set < Term > componentsB = new HashSet ( 1 + sbt . length ) ; componentsA . add ( ta ) ; Collections . addAll ( componentsA , sat ) ; componentsB . add ( tb ) ; Collections . addAll ( componentsB , sbt ) ; for ( Term sA : componentsA ) { boolean had = false ; for ( Term sB : componentsB ) { if ( sA instanceof Variable & & sB instanceof Variable ) { if ( sA . name . equals ( sB . name ) ) { had = true ; } } else if ( sA . equals ( sB ) ) { had = true ; } } if ( ! had ) { return false ; } } return true ; } return false ; }
public void testReadChunkLenEmpty ( ) throws Exception { final NonBlockingByteArrayInputStream noNewLine = new NonBlockingByteArrayInputStream ( " \ n " . getBytes ( ) ) ; final int res = HTTPHelper . readChunkLen ( noNewLine ) ; assertEquals ( " Chunk size with header " , 0 , res ) ; }
public static String multiplyUsingFFT ( String a , String b ) { if ( a . equals ( " 0 " ) | | b . equals ( " 0 " ) ) { return " 0 " ; } boolean negative = false ; if ( ( a . charAt ( 0 ) = = '-' & & b . charAt ( 0 ) ! = '-' ) | | ( a . charAt ( 0 ) ! = '-' & & b . charAt ( 0 ) = = '-' ) ) { negative = true ; } if ( a . charAt ( 0 ) = = '-' ) { a = a . substring ( 1 ) ; } if ( b . charAt ( 0 ) = = '-' ) { b = b . substring ( 1 ) ; } int size = 1 ; while ( size < ( a . length ( ) + b . length ( ) ) ) { size * = 2 ; } Complex [ ] aCoefficients = new Complex [ size ] ; Complex [ ] bCoefficients = new Complex [ size ] ; for ( int i = 0 ; i < size ; i + + ) { aCoefficients [ i ] = new Complex ( ) ; bCoefficients [ i ] = new Complex ( ) ; } for ( int i = 0 ; i < a . length ( ) ; i + + ) { aCoefficients [ i ] = new Complex ( ( double ) ( Character . getNumericValue ( a . charAt ( a . length ( ) - i - 1 ) ) ) , 0.0 ) ; } for ( int i = 0 ; i < b . length ( ) ; i + + ) { bCoefficients [ i ] = new Complex ( ( double ) ( Character . getNumericValue ( b . charAt ( b . length ( ) - i - 1 ) ) ) , 0.0 ) ; } FFT . FFT ( aCoefficients ) ; FFT . FFT ( bCoefficients ) ; for ( int i = 0 ; i < size ; i + + ) { aCoefficients [ i ] = aCoefficients [ i ] . multiply ( bCoefficients [ i ] ) ; } for ( int i = 0 ; i < size / 2 ; i + + ) { Complex temp = aCoefficients [ i ] ; aCoefficients [ i ] = aCoefficients [ size - i - 1 ] ; aCoefficients [ size - i - 1 ] = temp ; } FFT . FFT ( aCoefficients ) ; ArrayList < Integer > res = new ArrayList < > ( ) ; int pass = 0 ; for ( int i = 0 ; i < size ; i + + ) { res . add ( ( int ) ( pass + Math . floor ( ( aCoefficients [ i ] . abs ( ) + 1 ) / size ) ) ) ; if ( res . get ( i ) > = 10 ) { pass = res . get ( i ) / 10 ; res . set ( i , res . get ( i ) % 10 ) ; } else { pass = 0 ; } } Collections . reverse ( res ) ; StringBuilder result = new StringBuilder ( ) ; if ( negative ) { result . append ( '-' ) ; } boolean startPrinting = false ; for ( Integer x : res ) { if ( x ! = 0 ) { startPrinting = true ; } if ( startPrinting ) { result . append ( x ) ; } } return result . toString ( ) ; }
protected void replaceNodeWithNode ( Node < T > nodeToRemoved , Node < T > replacementNode ) { if ( replacementNode ! = null ) { Node < T > replacementNodeLesser = replacementNode . lesser ; Node < T > replacementNodeGreater = replacementNode . greater ; Node < T > nodeToRemoveLesser = nodeToRemoved . lesser ; if ( nodeToRemoveLesser ! = null & & ! nodeToRemoveLesser . equals ( replacementNode ) ) { replacementNode . lesser = nodeToRemoveLesser ; nodeToRemoveLesser . parent = replacementNode ; } Node < T > nodeToRemoveGreater = nodeToRemoved . greater ; if ( nodeToRemoveGreater ! = null & & ! nodeToRemoveGreater . equals ( replacementNode ) ) { replacementNode . greater = nodeToRemoveGreater ; nodeToRemoveGreater . parent = replacementNode ; } Node < T > replacementParent = replacementNode . parent ; if ( replacementParent ! = null & & ! replacementParent . equals ( nodeToRemoved ) ) { Node < T > replacementParentLesser = replacementParent . lesser ; Node < T > replacementParentGreater = replacementParent . greater ; if ( replacementParentLesser ! = null & & replacementParentLesser . equals ( replacementNode ) ) { replacementParent . lesser = replacementNodeGreater ; if ( replacementNodeGreater ! = null ) replacementNodeGreater . parent = replacementParent ; } else if ( replacementParentGreater ! = null & & replacementParentGreater . equals ( replacementNode ) ) { replacementParent . greater = replacementNodeLesser ; if ( replacementNodeLesser ! = null ) replacementNodeLesser . parent = replacementParent ; } } } Node < T > parent = nodeToRemoved . parent ; if ( parent = = null ) { root = replacementNode ; if ( root ! = null ) root . parent = null ; } else if ( parent . lesser ! = null & & ( parent . lesser . id . compareTo ( nodeToRemoved . id ) = = 0 ) ) { parent . lesser = replacementNode ; if ( replacementNode ! = null ) replacementNode . parent = parent ; } else if ( parent . greater ! = null & & ( parent . greater . id . compareTo ( nodeToRemoved . id ) = = 0 ) ) { parent . greater = replacementNode ; if ( replacementNode ! = null ) replacementNode . parent = parent ; } size - - ; }
public void testArrayValues ( ) throws Exception { var de = ObjectDeserializer . standard ( ) ; var deserialized = de . deserializeFields ( ArrayValues . SERIALIZED , ArrayValues : : new ) ; assertEquals ( new ArrayValues < String > ( ) , deserialized ) ; var ser = ObjectSerializer . standard ( ) ; var serialized = ser . serializeFields ( new ArrayValues < String > ( ) , Config : : inMemory ) ; assertEquals ( ArrayValues . SERIALIZED , serialized ) ; var serialized2 = ser . serialize ( new ArrayValues < String > ( ) , CommentedConfig : : inMemory ) ; assertEquals ( ArrayValues . SERIALIZED , serialized2 ) ; }
public static Term make ( Term [ ] arg ) { if ( arg . length = = 1 ) { return arg [ 0 ] ; } if ( arg . length ! = 2 ) { return null ; } if ( ( arg [ 0 ] instanceof SetExt ) & & ( arg [ 1 ] instanceof SetExt ) ) { TreeSet < Term > set = new TreeSet < > ( ( ( CompoundTerm ) arg [ 0 ] ) . asTermList ( ) ) ; set . removeAll ( ( ( CompoundTerm ) arg [ 1 ] ) . asTermList ( ) ) ; return SetExt . make ( set ) ; } if ( arg [ 0 ] . equals ( arg [ 1 ] ) ) { return null ; } return new DifferenceExt ( arg ) ; }
void writeBytes ( String str , int off , int len ) { for ( int i = 0 ; i < len ; i + + ) { writeByte ( str . charAt ( off + i ) ) ;
Entry < K , V > exactEntry ( int index ) ; int keyIndex ( K k ) ; }
public void testIsCompound ( ) { Struct emptyList = new Struct ( ) ; assertFalse ( emptyList . isCompound ( ) ) ; Struct atom = new Struct ( " atom " ) ; assertFalse ( atom . isCompound ( ) ) ; Struct list = new Struct ( new Term [ ] { new Int ( 0 ) , new Int ( 1 ) } ) ; assertTrue ( list . isCompound ( ) ) ; Struct compound = new Struct ( " f " , new Struct ( " a " ) , new Struct ( " b " ) ) ; assertTrue ( compound . isCompound ( ) ) ; Struct singleQuoted = new Struct ( " 'atom' " ) ; assertFalse ( singleQuoted . isCompound ( ) ) ; Struct doubleQuoted = new Struct ( " \" atom \" " ) ; assertFalse ( doubleQuoted . isCompound ( ) ) ; }
int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; }
public void adjustVolume ( int modifier ) throws MPDServerException { if ( ! isConnected ( ) ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } int vol = mpdStatus . getVolume ( ) + modifier ; vol = Math . max ( MPDCommand . MIN_VOLUME , Math . min ( MPDCommand . MAX_VOLUME , vol ) ) ; mpdConnection . sendCommand ( MPDCommand . MPD_CMD_SET_VOLUME , Integer . toString ( vol ) ) ; }
public void onStop ( ) { app . unsetActivity ( getActivity ( ) ) ; super . onStop ( ) ; }
private void readAttrs ( final Context context , final AttributeSet attrs ) { final TypedArray a = context . obtainStyledAttributes ( attrs , R . styleable . FixedRatioRelativeLayout ) ; final CharSequence s = a . getString ( R . styleable . FixedRatioRelativeLayout_fixedSide ) ; if ( s ! = null ) { final String fixString = s . toString ( ) ; if ( fixString . equals ( FIXED_HEIGHT ) ) { mFixedSide = FIXED_HEIGHT_INT ; } else if ( fixString . equals ( FIXED_WIDTH ) ) { mFixedSide = FIXED_WIDTH_INT ; } } a . recycle ( ) ; }
public void start ( Task question , NAR n ) { this . nar = n ; this . question = question ; nar . event ( this , true , events ) ; }
public static synchronized void registerHashAlgorithm ( String name , HashAlgorithm alg ) { validateName ( name ) ; validateAlgorithm ( alg ) ; REGISTRY . put ( name . toLowerCase ( ) , alg ) ; }
public void event ( Class event , Object [ ] arguments ) { long now = System . currentTimeMillis ( ) ; if ( ( pgraph ! = null ) & & ( now - lastFrame > minFrameTime ) ) { SwingUtilities . invokeLater ( update ) ;
public static void loadFrom ( FileInputStream fileStream , NarParameters parameters ) throws IOException { loadFromImpl ( fileStream , parameters ) ; }
public KeyStore loadKeyStore ( @Nullable @WillNotClose final InputStream aIS , @Nonnull final char [ ] aPassword ) throws Exception { final KeyStore aKeyStore = createNewKeyStore ( ) ; if ( aIS ! = null ) aKeyStore . load ( aIS , aPassword ) ; return aKeyStore ; }
public Sentence newImplicationEdge ( final Term source , final Term target , final Item c , final Sentence parent ) { Implication impParent = ( Implication ) parent . content ; Implication impFinal = new Implication ( source , target , impParent . getTemporalOrder ( ) ) ; Sentence impFinalSentence = new Sentence ( impFinal , '.' , parent . truth , parent . stamp ) ; try { addEdge ( source , target , impFinalSentence ) ; concepts . put ( impFinalSentence , c ) ; } catch ( IllegalArgumentException e ) { return null ; } return impFinalSentence ; }
public void start ( ) { streamSourceP . sendInstances ( inputStream , this . numTrainInstances , true , false , this . numEvaluationInstances ) ; System . out . println ( " Instances sent to train " ) ; streamSourceP . sendInstances ( inputStream , this . numTestInstances , false , true , this . numEvaluationInstances ) ; System . out . println ( " Instances sent to test " ) ; streamSourceP . sendEndEvaluationInstance ( inputStream ) ;
public Task newTask ( Term content , char sentenceType , float freq , float conf , float priority , float durability , Task parentTask , Tense tense ) { TruthValue truth = new TruthValue ( freq , conf ) ; Sentence . MakeByTermPunctuationTruthStampNormalizeParameters sentenceMakeParameters = new Sentence . MakeByTermPunctuationTruthStampNormalizeParameters ( ) ; sentenceMakeParameters . term = content ; sentenceMakeParameters . punctuation = sentenceType ; sentenceMakeParameters . truth = truth ; sentenceMakeParameters . stamp = new Stamp ( this , tense ) ; Sentence sentence = Sentence . makeByTermPunctuationTruthStampNormalize ( sentenceMakeParameters ) ; BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY , truth ) ; Task task = new Task ( sentence , budget , parentTask ) ; return task ; }
public AlbumDetails getAlbumDetails ( final String artist , final String album , final boolean isAlbumArtist ) { return mAlbumDetails . get ( albumCode ( artist , album , isAlbumArtist ) ) ; }
public void testGraphPlan ( String input , String expected ) throws IOException { NAR n = new DefaultNARBuilder ( ) . build ( ) ; AtomicBoolean success = new AtomicBoolean ( true ) ; new Output ( n ) { @Override public void event ( Class channel , Object . . . args ) { if ( args . length > 0 ) { Object o = args [ 1 ] ; if ( o . toString ( ) . contains ( expected ) ) success . set ( true ) ; } } } ; n . addInput ( input ) ;
protected byte [ ] decompress ( byte [ ] in ) { assert in ! = null ; ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPInputStream gis ; try { gis = new GZIPInputStream ( bis ) ; byte [ ] buf = new byte [ 8192 ] ; int r = - 1 ; while ( ( r = gis . read ( buf ) ) > 0 ) { bos . write ( buf , 0 , r ) ; } } catch ( IOException e ) { getLogger ( ) . warn ( " Failed to decompress data " , e ) ; bos = null ; } return bos = = null ? null : bos . toByteArray ( ) ; }
private Runnable runnableOrNothing ( Runnable r ) { return ( r = = null ) ? ( ) - > { } : r ; }
public boolean dispatchOptionsItemSelected ( android . view . MenuItem item ) { throw new IllegalStateException ( " Native callback invoked. Create a test case and report! " ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmProp p , A arg ) { p . term_1 . accept ( new TermVisitor < R , A > ( ) , arg ) ; p . term_2 . accept ( new TermVisitor < R , A > ( ) , arg ) ; return null ; }
boolean addCloseable ( Closeable closeable ) { Objects . requireNonNull ( closeable ) ; Preconditions . checkState ( ! triggered , " Can't add closeable %s; already shutting down " , closeable ) ; synchronized ( closeAtShutdown ) { boolean wasFirst = closeAtShutdown . isEmpty ( ) ;
protected void onHandleIntent ( Intent intent ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; app . setActivity ( this ) ; final MPD mpd = app . oMPDAsyncHelper . oMPD ; final String action = intent . getAction ( ) ; app . oMPDAsyncHelper . execAsync ( new Runnable ( ) { @Override public void run ( ) { processIntent ( action , mpd ) ; } } ) ; app . unsetActivity ( this ) ; }
public void testDebugBuffer ( ) throws Exception { String input = " this is a test _ " ; ByteBuffer bb = ByteBuffer . wrap ( input . getBytes ( ) ) ; String s = MemcachedConnection . dbgBuffer ( bb , input . length ( ) ) ; assertEquals ( " this is a test  \\ x5f " , s ) ; }
public static void main ( String [ ] args ) throws Exception { int cycles = 3000 ; int inputDelay = 8 ; NAR nar = new DefaultNARBuilder ( ) . build ( ) ; new TestChamber ( nar , false ) ; NARTrace t = new NARTrace ( nar ) ; TextInput i = new TextInput ( new File ( " nal/TestChamber/TestChamberIndependentExperience/switch_on_door_opened.nal " ) ) { int c = 0 ; @Override public Object next ( ) throws IOException { if ( c + + % 2 = = 0 ) return super . next ( ) ; else return inputDelay + " \ n " ; } } ; TextOutput o = new TextOutput ( nar , System . out ) { @Override public synchronized void output ( Class channel , Object o ) { if ( channel = = EXE . class ) super . output ( channel , o ) ; } } ; nar . addInput ( i ) ; nar . finish ( cycles ) ; System . out . println ( nar . getTime ( ) ) ; nar . finish ( cycles ) ; System . out . println ( nar . getTime ( ) ) ; new NWindow ( " _ " , new Timeline2DCanvas (
public MimeBodyPart sign ( @Nonnull final MimeBodyPart aPart , @Nonnull final X509Certificate aX509Cert , @Nonnull final PrivateKey aPrivateKey , @Nonnull final ECryptoAlgorithmSign eAlgorithm ) throws GeneralSecurityException , SMIMEException , MessagingException , OperatorCreationException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( aX509Cert , " X509Cert " ) ; ValueEnforcer . notNull ( aPrivateKey , " PrivateKey " ) ; ValueEnforcer . notNull ( eAlgorithm , " Algorithm " ) ; final List < X509Certificate > aCertList = new ArrayList < X509Certificate > ( ) ; aCertList . add ( aX509Cert ) ; final JcaCertStore aCertStore = new JcaCertStore ( aCertList ) ; final ASN1EncodableVector aSignedAttrs = new ASN1EncodableVector ( ) ; final SMIMECapabilityVector aCapabilities = new SMIMECapabilityVector ( ) ; aCapabilities . addCapability ( eAlgorithm . getOID ( ) ) ; aSignedAttrs . add ( new SMIMECapabilitiesAttribute ( aCapabilities ) ) ; final SMIMESignedGenerator aSGen = new SMIMESignedGenerator ( ) ; aSGen . addSignerInfoGenerator ( new JcaSimpleSignerInfoGeneratorBuilder ( ) . setProvider ( BouncyCastleProvider . PROVIDER_NAME ) . setSignedAttributeGenerator ( new AttributeTable ( aSignedAttrs ) ) . build ( eAlgorithm . getSignAlgorithmName ( ) , aPrivateKey , aX509Cert ) ) ; aSGen . addCertificates ( aCertStore ) ; final MimeMultipart aSignedData = aSGen . generate ( aPart ) ; final MimeBodyPart aTmpBody = new MimeBodyPart ( ) ; aTmpBody . setContent ( aSignedData ) ; aTmpBody . setHeader ( CAS2Header . HEADER_CONTENT_TYPE , aSignedData . getContentType ( ) ) ; return aTmpBody ; }
public void tableChanged ( TableModelEvent tableModelEvent ) { super . tableChanged ( tableModelEvent ) ; reallocateIndexes ( ) ; sortByColumn ( 0 ) ; fireTableStructureChanged ( ) ; }
public void actionPerformed ( ActionEvent e ) { checkbox . setText ( checkbox . isSelected ( ) ? I18N . TRUE : I18N . FALSE ) ; }
public void handle ( String line ) { if ( " # COMPLETED " . equals ( line . trim ( ) ) ) { signalComplete . countDown ( ) ;
public Artist createItemFromElement ( DomElement element ) { Artist artist = new Artist ( null , null ) ; MusicEntry . loadStandardInfo ( artist , element ) ; DomElement similar = element . getChild ( " similar " ) ; if ( similar ! = null ) { Collection < DomElement > children = similar . getChildren ( " artist " ) ; for ( DomElement child : children ) { artist . similar . add ( createItemFromElement ( child ) ) ; } } return artist ; }
private void ensureAttacher ( ) { if ( mPullToRefreshAttacher = = null ) { throw new IllegalStateException ( " You need to setup the PullToRefreshLayout before using it " ) ;
public void addConnectionListener ( ConnectionListener listener ) { connectionListners . add ( listener ) ; }
public static Term make ( final Term t , final Memory memory ) { if ( t instanceof Negation ) { return ( ( Negation ) t ) . cloneTerms ( ) [ 0 ] ; } return make ( new Term [ ] { t } , memory ) ; }
public boolean hasMoreInstances ( ) { return ! this . hitEndOfFile ; }
public void receivedStatus ( OperationStatus val ) { if ( val instanceof CASOperationStatus ) { rv . set ( ( ( CASOperationStatus ) val ) . getCASResponse ( ) , val ) ;
void onIncomingMDN ( boolean bSynchronousMDN , @Nonnull IMessageMDN aMDN , @Nullable String sSenderAS2ID , @Nullable String sReceiverAS2ID , @Nullable String sDisposition , @Nullable String sReturnMIC , @Nullable String sOriginalAS2MessageID , boolean bMDNWasSigned , boolean bMICMatched ) ; }
public boolean addAll ( Collection < ? extends E > c ) { throw new UnsupportedOperationException ( " This is a read-only list " ) ; }
public Term copyGoal ( AbstractMap < Var , Var > vars , int idExecCtx ) { return copy ( vars , idExecCtx ) ; }
public void handle ( Event t ) { update ( memoryDisplay ) ; nar . tick ( ) ;
public ComputeContentEvent read ( Kryo kryo , Input input , Class < ComputeContentEvent > type ) { long splitId = input . readLong ( true ) ; long learningNodeId = input . readLong ( true ) ; int dataLength = input . readInt ( true ) ; double [ ] preSplitDist = new double [ dataLength ] ; for ( int i = 0 ; i < dataLength ; i + + ) { preSplitDist [ i ] = input . readDouble ( ) ; } return new ComputeContentEvent ( splitId , learningNodeId , preSplitDist ) ; }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o instanceof com . googlecode . opennars . parser . loan . Loan . Absyn . StmInst ) { com . googlecode . opennars . parser . loan . Loan . Absyn . StmInst x = ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInst ) o ; return this . term_1 . equals ( x . term_1 ) & & this . term_2 . equals ( x . term_2 ) ; } return false ; }
public Object clone ( ) { return new Operation ( name , cloneList ( components ) , isConstant ( ) , containVar ( ) , getComplexity ( ) , hashCode ( ) ) ; }
public static Level load ( DataInputStream dis ) throws IOException { long header = dis . readLong ( ) ; if ( header ! = Level . FILE_HEADER ) throw new IOException ( " Bad level header " ) ; int version = dis . read ( ) & 0xff ; int width = dis . readShort ( ) & 0xffff ; int height = dis . readShort ( ) & 0xffff ; Level level = new Level ( width , height ) ; level . map = new byte [ width ] [ height ] ; level . data = new byte [ width ] [ height ] ; for ( int i = 0 ; i < width ; i + + ) { dis . readFully ( level . map [ i ] ) ; dis . readFully ( level . data [ i ] ) ; } return level ; }
public FancyJsonWriter createWriter ( ) { return new FancyJsonWriter ( ) ; }
public void testOneArrivingMultipleExistingWhereArrivingSameTimeAsLatestExistingWithDifferentValues ( ) { p = new BitemporalHistoryPlanner ( ) ; assertNoValidationFailures ( p , config ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , 1L , 2L , CURRENT_FLAG_DEFAULT_NO ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 199L , 3L , 253402214400000L , CURRENT_FLAG_DEFAULT_NO ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello! " , 200L , 200L , 253402214400000L , 3L , 4L , CURRENT_FLAG_DEFAULT_NO ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello! " , 200L , 200L , 299L , 5L , 253402214400000L , CURRENT_FLAG_DEFAULT_NO ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello? " , 300L , 300L , 253402214400000L , 5L , 253402214400000L , CURRENT_FLAG_DEFAULT_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 300L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 2 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; Long systemStart1 = planned . get ( 1 ) . getAs ( " systemstart " ) ; assertEquals ( planned . get ( 0 ) . getAs ( " value " ) , " hello? " ) ; assertEquals ( planned . get ( 0 ) . getAs ( " eventstart " ) , 300L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " eventend " ) , 253402214400000L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " systemstart " ) , 5L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " systemend " ) , systemStart1 - 1 ) ; assertEquals ( planned . get ( 0 ) . getAs ( " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( planned . get ( 1 ) . getAs ( " value " ) , " world " ) ; assertEquals ( planned . get ( 1 ) . getAs ( " eventstart " ) , 300L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " eventend " ) , 253402214400000L ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( planned . get ( 1 ) . getAs ( " systemend " ) , 253402214400000L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " currentflag " ) , CURRENT_FLAG_DEFAULT_YES ) ; }
public void configure ( Config config ) { this . config = config ; if ( ! config . hasPath ( TABLE_CONFIG_NAME ) ) { throw new RuntimeException ( " Hive output requires ' " + TABLE_CONFIG_NAME + " ' property " ) ;
private static < T extends Comparable < T > > boolean testStack ( IStack < T > stack , String name ) { for ( int i = 0 ; i < unsorted . length ; i + + ) { T item = ( T ) unsorted [ i ] ; boolean added = stack . push ( item ) ; if ( validateStructure & & ( ! stack . validate ( ) | | ( stack . size ( ) ! = i + 1 ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; handleError ( stack ) ; return false ; } if ( validateContents & & ( ! added | | item = = null | | ! stack . contains ( item ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists but has been added. " ) ; handleError ( stack ) ; return false ; } } boolean contains = stack . contains ( ( T ) INVALID ) ; boolean removed = stack . remove ( ( T ) INVALID ) ; if ( contains | | removed ) { System . err . println ( name + "  invalidity check. contains= " + contains + "  removed= " + removed ) ; handleError ( stack ) ; return false ; } int size = stack . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { T item = stack . pop ( ) ; T correct = ( T ) unsorted [ unsorted . length - ( i + 1 ) ] ; if ( validateStructure & & ( item . compareTo ( correct ) ! = 0 ) ) { System . err . println ( name + "  YIKES!!  " + item + "  does not match LIFO item. " ) ; handleError ( stack ) ; return false ; } if ( validateStructure & & ( ! stack . validate ( ) | | ( stack . size ( ) ! = unsorted . length - ( i + 1 ) ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; handleError ( stack ) ; return false ; } if ( validateContents & & ( item = = null | | stack . contains ( item ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists but it has been remove. " ) ; handleError ( stack ) ; return false ; } } int quarter = unsorted . length / 4 ; int half = unsorted . length / 2 ; for ( int i = 0 ; i < half ; i + + ) { T item = ( T ) unsorted [ i ] ; boolean added = stack . push ( item ) ; if ( validateStructure & & ( ! stack . validate ( ) | | ( stack . size ( ) ! = i + 1 ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; handleError ( stack ) ; return false ; } if ( validateContents & & ( ! added | | item = = null | | ! stack . contains ( item ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists but has been added. " ) ; handleError ( stack ) ; return false ; } } for ( int i = ( half - 1 ) ; i > = quarter ; i - - ) { T item = stack . pop ( ) ; T correct = ( T ) unsorted [ i ] ; if ( validateStructure & & ( item . compareTo ( correct ) ! = 0 ) ) { System . err . println ( name + "  YIKES!!  " + item + "  does not match LIFO item. " ) ; handleError ( stack ) ; return false ; } if ( validateStructure & & ( ! stack . validate ( ) | | ( stack . size ( ) ! = i ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; handleError ( stack ) ; return false ; } if ( validateContents & & ( item = = null | | stack . contains ( item ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists but it has been remove. " ) ; handleError ( stack ) ; return false ; } } for ( int i = quarter ; i < unsorted . length ; i + + ) { T item = ( T ) unsorted [ i ] ; boolean added = stack . push ( item ) ; if ( validateStructure & & ( ! stack . validate ( ) | | ( stack . size ( ) ! = i + 1 ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; handleError ( stack ) ; return false ; } if ( validateContents & & ( ! added | | item = = null | | ! stack . contains ( item ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists but has been added. " ) ; handleError ( stack ) ; return false ; } } for ( int i = unsorted . length - 1 ; i > = 0 ; i - - ) { T item = stack . pop ( ) ; T correct = ( T ) unsorted [ i ] ; if ( validateStructure & & ( item . compareTo ( correct ) ! = 0 ) ) { System . err . println ( name + "  YIKES!!  " + item + "  does not match LIFO item. " ) ; handleError ( stack ) ; return false ; } if ( validateStructure & & ( ! stack . validate ( ) | | ( stack . size ( ) ! = i ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; handleError ( stack ) ; return false ; } if ( validateContents & & ( item = = null | | stack . contains ( item ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists but it has been remove. " ) ; handleError ( stack ) ; return false ; } } if ( validateStructure & & ( stack . size ( ) ! = 0 ) ) { System . err . println ( name + "  YIKES!! a size mismatch. " ) ; handleError ( stack ) ; return false ; } return true ; }
static void dedExe ( Term term1 , Term term2 , Sentence sentence , Sentence belief , Memory memory ) { if ( Statement . invalidStatement ( term1 , term2 ) ) { return ; } TruthValue value1 = sentence . getTruth ( ) ; TruthValue value2 = belief . getTruth ( ) ; TruthValue truth1 = null ; TruthValue truth2 = null ; BudgetValue budget1 , budget2 ; if ( sentence . isQuestion ( ) ) { budget1 = BudgetFunctions . backwardWeak ( value2 , memory ) ; budget2 = BudgetFunctions . backwardWeak ( value2 , memory ) ; } else { truth1 = TruthFunctions . deduction ( value1 , value2 ) ; truth2 = TruthFunctions . exemplification ( value1 , value2 ) ; budget1 = BudgetFunctions . forward ( truth1 , memory ) ; budget2 = BudgetFunctions . forward ( truth2 , memory ) ; } Statement content = ( Statement ) sentence . getContent ( ) ; Statement content1 = Statement . make ( content , term1 , term2 , memory ) ; Statement content2 = Statement . make ( content , term2 , term1 , memory ) ; memory . doublePremiseTask ( content1 , truth1 , budget1 ) ; memory . doublePremiseTask ( content2 , truth2 , budget2 ) ; }
public abstract byte [ ] getTextBytes ( ) ; @Deprecated public abstract String getTextString ( ) ; public abstract String getType ( ) ; public abstract String getTypeWithSubtype ( ) ; @Deprecated public abstract String getURL ( ) ; @Deprecated public abstract String getURL ( String protocol ) ; public abstract String [ ] getURLs ( ) ; public abstract String [ ] getURLs ( String protocol ) ; public abstract int getWeight ( ) ; public abstract boolean hasData ( ) ; public abstract boolean isPersistent ( ) ; public abstract void setText ( final byte [ ] text ) throws IllegalStateException ; public abstract void setText ( final Map < String , ? > props ) throws IllegalStateException ; }
public static void main ( String [ ] args ) { Board b = new Board ( new HumanPlayer ( " Human1 " ) , new HumanPlayer ( " Human2 " ) , 8 , 8 ) ; JFrame frame = new JFrame ( " Checkers " ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; JPanel boardPane = new JPanel ( new FlowLayout ( ) ) ; ( ( FlowLayout ) boardPane . getLayout ( ) ) . setAlignment ( FlowLayout . CENTER ) ; boardPane . add ( b ) ; frame . getContentPane ( ) . setLayout ( new java . awt . BorderLayout ( ) ) ; frame . getContentPane ( ) . add ( boardPane , java . awt . BorderLayout . CENTER ) ; frame . pack ( ) ; frame . setVisible ( true ) ; b . play ( ) ; }
public Directory makeDirectory ( final String subPath ) { final String name ; final String remainingPath ; final int slashIndex = subPath . indexOf ( '/' ) ; if ( slashIndex = = 0 ) { throw new IllegalArgumentException ( " name starts with '/' " ) ; } if ( slashIndex = = - 1 ) { name = subPath ; remainingPath = null ; } else { name = subPath . substring ( 0 , slashIndex ) ; remainingPath = subPath . substring ( slashIndex + 1 ) ; } final Directory dir ; if ( ! mDirectoryEntries . containsKey ( name ) ) { dir = new Directory ( mMPD , this , name ) ; mDirectoryEntries . put ( dir . getFilename ( ) , dir ) ; } else { dir = mDirectoryEntries . get ( name ) ; } if ( remainingPath ! = null ) { return dir . makeDirectory ( remainingPath ) ; } return dir ; }
@Override public void run ( ) { s . cells . click ( " XOR " , " " , " " ) ; } } ) ;
protected static < D extends Data > Segment < D > createFromList ( int minLength , List < OverlappingSegment < D > > segments , long start , int length ) { OverlappingSegment < D > segment = new OverlappingSegment < D > ( minLength ) ; segment . start = start ; segment . end = start + ( length - 1 ) ; segment . length = length ; for ( Segment < D > s : segments ) { if ( s . data = = null ) continue ; if ( s . end < segment . start | | s . start > segment . end ) { } else { segment . range . add ( s ) ; } if ( s . start = = segment . start & & s . end = = segment . end ) { if ( segment . data = = null ) segment . data = ( ( D ) s . data . copy ( ) ) ; else segment . data . combined ( s . data ) ; } else if ( ! segment . hasChildren ( ) & & s . start > = segment . start & & s . end < = segment . end ) { if ( segment . data = = null ) segment . data = ( ( D ) s . data . copy ( ) ) ; else segment . data . combined ( s . data ) ; } } if ( segment . length > = 2 & & segment . length > = minLength ) { segment . half = segment . length / 2 ; List < OverlappingSegment < D > > s1 = new ArrayList < OverlappingSegment < D > > ( ) ; List < OverlappingSegment < D > > s2 = new ArrayList < OverlappingSegment < D > > ( ) ; for ( int i = 0 ; i < segments . size ( ) ; i + + ) { OverlappingSegment < D > s = segments . get ( i ) ; long middle = segment . start + segment . half ; if ( s . end < middle ) { s1 . add ( s ) ; } else if ( s . start > = middle ) { s2 . add ( s ) ; } else { OverlappingSegment < D > ss1 = new OverlappingSegment < D > ( minLength , s . start , middle - 1 , s . data ) ; s1 . add ( ss1 ) ; OverlappingSegment < D > ss2 = new OverlappingSegment < D > ( minLength , middle , s . end , s . data ) ; s2 . add ( ss2 ) ; } } Segment < D > sub1 = createFromList ( minLength , s1 , segment . start , segment . half ) ; Segment < D > sub2 = createFromList ( minLength , s2 , segment . start + segment . half , segment . length - segment . half ) ; segment . segments = new Segment [ ] { sub1 , sub2 } ; } return segment ; }
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
abstract public Param newParam ( ) ; abstract public Bag < Task , Sentence > newNovelTaskBag ( Param p ) ; abstract public ConceptProcessor newConceptProcessor ( Param p , ConceptBuilder c ) ; abstract public ConceptBuilder getConceptBuilder ( ) ; public NAR build ( ) { Param p = newParam ( ) ; Operator [ ] operators = DefaultOperators . get ( ) ; Memory m = new Memory ( p , new Cycle ( ) , newConceptProcessor ( p , getConceptBuilder ( ) ) , newNovelTaskBag ( p ) , operators ) ; for ( Operator o : ExampleOperators . get ( ) ) { m . addOperator ( o ) ; } return new NAR ( m , new Perception ( ) ) ; } }
public void unsetActivity ( Object activity ) { removeConnectionLock ( activity ) ; if ( currentActivity = = activity ) { currentActivity = null ;
void update ( ) { if ( recording ) { if ( mousePressed ) {
abstract public Param newParam ( ) ; abstract public AbstractBag < Concept > newConceptBag ( Param p ) ; abstract public AbstractBag < Task > newNovelTaskBag ( Param p ) ; public NAR build ( ) { Param p = newParam ( ) ; Operator [ ] operators = DefaultOperators . get ( ) ; Memory m = new Memory ( p , newConceptBag ( p ) , newNovelTaskBag ( p ) , this , operators ) ; return new NAR ( m ) ; } }
default C parse ( File file , FileNotFoundAction nefAction ) { return parse ( file , nefAction , StandardCharsets . UTF_8 ) ; }
private void updateAudioNameText ( final MPDStatus status ) { String optionalTrackInfo = null ; final String state = status . getState ( ) ; if ( currentSong ! = null & & isAudioNameTextEnabled & & ! MPDStatus . MPD_STATE_STOPPED . equals ( state ) ) { final String extension = getExtension ( currentSong . getFullpath ( ) ) . toUpperCase ( ) ; final long bitRate = status . getBitrate ( ) ; final int bitsPerSample = status . getBitsPerSample ( ) ; final int sampleRate = status . getSampleRate ( ) ; if ( ! extension . isEmpty ( ) ) { optionalTrackInfo = extension ; } if ( bitRate > 0 L ) { if ( optionalTrackInfo ! = null ) { optionalTrackInfo + = "  |  " ; } optionalTrackInfo + = bitRate + " kbps " ; } if ( bitsPerSample > 0 ) { if ( optionalTrackInfo ! = null ) { optionalTrackInfo + = "  |  " ; } optionalTrackInfo + = bitsPerSample + " bits " ; } if ( sampleRate > 1000 ) { if ( optionalTrackInfo ! = null ) { optionalTrackInfo + = "  |  " ; } optionalTrackInfo + = sampleRate / 1000 + " khz " ; } if ( optionalTrackInfo ! = null ) { audioNameText . setText ( optionalTrackInfo ) ; audioNameText . setVisibility ( View . VISIBLE ) ; } } if ( optionalTrackInfo = = null | | currentSong = = null ) { audioNameText . setVisibility ( View . GONE ) ;
default C parseConfig ( InputStream input ) throws IOException { Reader reader = new BufferedReader ( new InputStreamReader ( input , StandardCharsets . UTF_8 ) ) ; return parseConfig ( reader ) ; }
List < String [ ] > sendSeparated ( final MPDConnection mpdConnection ) throws MPDServerException { return separatedQueueResults ( send ( mpdConnection , true ) ) ; }
public void run ( ) { try { app . oMPDAsyncHelper . oMPD . getPlaylist ( ) . removeById ( positions ) ;
private void printSchema ( ) { System . out . println ( " Schema for step  " + getName ( ) + " : " ) ; data . printSchema ( ) ; }
public void configureRDD ( JavaPairRDD < Row , Row > rdd ) { this . numPartitions = rdd . getNumPartitions ( ) ; }
public String generateMessageID ( ) { final CompositeParameters params = new CompositeParameters ( false ) . add ( " date " , new DateParameters ( ) ) . add ( " msg " , new MessageParameters ( this ) ) . add ( " rand " , new RandomParameters ( ) ) ; String idFormat = getPartnership ( ) . getAttribute ( CAS2Partnership . PA_MESSAGEID ) ; if ( idFormat = = null ) idFormat = " OPENAS2-$date.ddMMyyyyHHmmssZ$-$rand.1234$@$msg.sender.as2_id$_$msg.receiver.as2_id$ " ; final StringBuilder messageId = new StringBuilder ( ) ; messageId . append ( '<' ) ; try { messageId . append ( AbstractParameterParser . parse ( idFormat , params ) ) ; } catch ( final InvalidParameterException e ) { messageId . append ( idFormat ) ; } messageId . append ( '>' ) ; return messageId . toString ( ) ; }
public void setCertificate ( final String alias , final Certificate cert ) throws CertificateException { try {
public boolean isSequenceConjunction ( Term c ) { if ( c instanceof Conjunction ) { if ( ( ( Conjunction ) c ) . operator ( ) = = NativeOperator . SEQUENCE ) return true ; } return false ; }
R deserialize ( T value , Optional < TypeConstraint > resultType , DeserializerContext ctx ) ; }
public void updateActivity ( float newActivity ) { if ( activity ! = newActivity ) { bgColor = new Color ( 1.0f , 0.5f + 0.5f * ( 1f - activity ) , 0.5f + 0.5f * activity ) ;
public void testAddCancellation ( ) throws Exception { tryCancellation ( client . add ( " x " , 3 , " y " ) ) ; }
public String format ( @Nonnull final String sFormat ) throws InvalidParameterException { if ( s_aLogger . isTraceEnabled ( ) ) s_aLogger . trace ( " Formatting ' " + sFormat + " ' " ) ; final StringBuilder aSB = new StringBuilder ( ) ; for ( int nNext = 0 ; nNext < sFormat . length ( ) ; + + nNext ) { int nPrev = nNext ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) { aSB . append ( sFormat . substring ( nPrev , sFormat . length ( ) ) ) ; break ; } if ( nNext > nPrev ) aSB . append ( sFormat . substring ( nPrev , nNext ) ) ; nPrev = nNext + 1 ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) throw new InvalidParameterException ( " Invalid key (missing closing $) " ) ; if ( nNext = = nPrev ) aSB . append ( " $ " ) ; else aSB . append ( getParameter ( sFormat . substring ( nPrev , nNext ) ) ) ; } if ( s_aLogger . isTraceEnabled ( ) ) s_aLogger . trace ( " Formatted value is now ' " + aSB . toString ( ) + " ' " ) ; return aSB . toString ( ) ; }
public abstract void post ( String str ) ; @SuppressWarnings ( " rawtypes " ) public abstract BagObserver createBagObserver ( ) ; public abstract void startPlay ( Concept concept , boolean showLinks ) ; public abstract void stop ( ) ; void refresh ( String message ) ; }
public void testCASPrependSuccess ( ) throws Exception { final String key = " append.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; CASValue < Object > casv = client . gets ( key ) ; assertTrue ( client . prepend ( casv . getCas ( ) , key , " es " ) . get ( ) ) ; assertEquals ( " estest " , client . get ( key ) ) ; }
public static CharSequence n2 ( final double p ) { return n2 ( ( float ) p ) ; }
protected Mario newMario ( LevelScene level ) { return new Mario ( this ) ; }
public Object clone ( ) { return new Conjunction ( getName ( ) , cloneTerms ( components ) , isConstant ( ) , complexity , temporalOrder ) ; }
public boolean containsValue ( List < String > path ) { return searchInfosOrConfig ( path ) ! = null ; }
public abstract ServiceInfo [ ] list ( String type , long timeout ) ; public abstract Map < String , ServiceInfo [ ] > listBySubtype ( String type ) ; public abstract Map < String , ServiceInfo [ ] > listBySubtype ( String type , long timeout ) ; @Deprecated public abstract void printServices ( ) ; public abstract void registerService ( ServiceInfo info ) throws IOException ; public abstract boolean registerServiceType ( String type ) ; public abstract void removeServiceListener ( String type , ServiceListener listener ) ; public abstract void removeServiceTypeListener ( ServiceTypeListener listener ) ; public abstract void requestServiceInfo ( String type , String name ) ; public abstract void requestServiceInfo ( String type , String name , boolean persistent ) ; public abstract void requestServiceInfo ( String type , String name , boolean persistent , long timeout ) ; public abstract void requestServiceInfo ( String type , String name , long timeout ) ; public abstract Delegate setDelegate ( Delegate value ) ; public abstract void unregisterAllServices ( ) ; public abstract void unregisterService ( ServiceInfo info ) ; }
@Override public int compare ( Concept o1 , Concept o2 ) { return o1 . name ( ) . toString ( ) . compareTo ( o2 . name ( ) . toString ( ) ) ; }
public void step ( final int cycles ) { if ( thread ! = null ) { stepLater ( cycles ) ; return ; } final boolean wasRunning = running ; running = true ; for ( int i = 0 ; i < cycles ; i + + ) { cycle ( ) ; } running = wasRunning ; }
protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { js . put ( " memory " , memory ) ; if ( args . length < 1 ) return null ; Object result = null ; String input = Texts . unescape ( args [ 0 ] . name ( ) ) . toString ( ) ; if ( input . charAt ( 0 ) = = '"' ) input = input . substring ( 1 , input . length ( ) - 1 ) ; try { result = js . eval ( input ) ; } catch ( Throwable ex ) { result = ex . toString ( ) ; } memory . output ( Javascript . class , input + "  |  " + result ) ; if ( result instanceof Number ) { result = " n_ " + result ; } Term r = new Term ( Texts . escape ( '"' + result . toString ( ) + '"' ) . toString ( ) ) ; Inheritance t = Inheritance . make ( Product . make ( new Term [ ] { operation , r } , memory ) , new Term ( " js_evaluation " ) , memory ) ; memory . output ( Task . class , t ) ; ArrayList < Task > results = new ArrayList < > ( 1 ) ; results . add ( memory . newTask ( t , Symbols . JUDGMENT_MARK , 1f , 0.99f , Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY ) ) ; return results ;
protected abstract OperationFactory getOperationFactory ( ) ; public void testDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , genericCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertCallback ( op2 ) ; } public void testCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , genericCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getBytes ( ) ) ; assertCallback ( op2 ) ; } public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatatorOperation op2 = cloneOne ( MutatatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } public void testMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatatorOperation op2 = cloneOne ( MutatatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } public void testStoreOperationAddCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . add , TEST_KEY , flags , exp , testData , genericCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . add , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testStoreOperationSetCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . set , TEST_KEY , flags , exp , testData , genericCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . set , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testConcatenationOperationAppendCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . append , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . append , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testConcatenationOperationPrependCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . prepend , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . prepend , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testSingleGetOperationCloning ( ) { GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( TEST_KEY , callback ) ; GetOperation op2 = cloneOne ( GetOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; } public void testSingleGetsOperationCloning ( ) { GetsOperation . Callback callback = ( GetsOperation . Callback ) mock ( GetsOperation . Callback . class ) . proxy ( ) ; GetsOperation op = ofact . gets ( TEST_KEY , callback ) ; GetsOperation op2 = cloneOne ( GetsOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; } public void testMultipleGetOperationCloning ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Collection < Operation > ops = ofact . clone ( op ) ; assertEquals ( 3 , ops . size ( ) ) ; Collection < String > mutableKeys = new ArrayList < String > ( keys ) ; int i = 3 ; for ( Operation o : ops ) { assertEquals ( i , mutableKeys . size ( ) ) ; GetOperation go = ( GetOperation ) o ; mutableKeys . removeAll ( go . getKeys ( ) ) ; assertEquals ( - - i , mutableKeys . size ( ) ) ; assertSame ( callback , go . getCallback ( ) ) ; } } protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; } protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; } private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( testData , bytes ) ) ; } @SuppressWarnings ( " unchecked " ) private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; } protected < T > T cloneOne ( Class < T > c , KeyedOperation t ) { return assertOne ( c , ofact . clone ( t ) ) ; } }
ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
public void move ( int songId , int to ) throws MPDServerException { this . mpd . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_MOVE_ID , Integer . toString ( songId ) , Integer . toString ( to ) ) ; this . refresh ( ) ; }
public void step ( ) { if ( cnt % missionPeriod = = 0 ) { nar . addInput ( " $0.99;0.99;0.99$ <goal --> eat>! %1.00;0.99% " ) ; nar . addInput ( " $0.50;0.99;0.99$ Wall! %0.00;0.50% " ) ; nar . addInput ( " $0.50;0.99;0.99$ Food! %1.00;0.75% " ) ; } for ( VisionRay v : vision ) v . step ( ) ; if ( Math . random ( ) < curiosity ) { nar . addInput ( " (^motor,random)! " ) ; } if ( feel_motion ) { feelMotion ( ) ; } cnt + + ; }
public void put ( ContentEvent event ) { this . put ( event , this . getNextCounter ( ) ) ; }
private static int recursiveFind ( int value , int start , int end ) { if ( start = = end ) { int lastValue = sorted [ start ] ; if ( value = = lastValue ) return start ; return Integer . MAX_VALUE ; } int mid = start + ( ( value - sorted [ start ] ) * ( end - start ) ) / ( sorted [ end ] - sorted [ start ] ) ; if ( mid < 0 | | mid > end ) return Integer . MAX_VALUE ; int midValue = sorted [ mid ] ; if ( value = = midValue ) return mid ; if ( value > midValue ) { return recursiveFind ( value , mid + 1 , end ) ;
public Iterable < Tuple2 < Row , Tuple2 < Iterable < Row > , Iterable < Row > > > > call ( Iterator < Tuple2 < Row , Iterable < Row > > > arrivingForKeysIterator ) throws Exception { if ( ! arrivingForKeysIterator . hasNext ( ) ) { return Lists . newArrayList ( ) ; } if ( output = = null ) { output = ( RandomOutput ) Output . outputFor ( outputConfig ) ; } List < Tuple2 < Row , Iterable < Row > > > arrivingForKeys = Lists . newArrayList ( arrivingForKeysIterator ) ; Set < Row > arrivingKeys = extractKeys ( arrivingForKeys ) ; Iterable < Row > existingWithoutKeys = output . getExistingForFilters ( arrivingKeys ) ; Map < Row , Iterable < Row > > existingForKeys = mapExistingToKeys ( existingWithoutKeys ) ; List < Tuple2 < Row , Tuple2 < Iterable < Row > , Iterable < Row > > > > arrivingAndExistingForKeys = attachExistingToArrivingForKeys ( existingForKeys , arrivingForKeys ) ; return arrivingAndExistingForKeys ; }
public boolean equals ( final Object other ) { if ( other = = this ) return true ; if ( other instanceof CharArrayRope ) { CharArrayRope cother = ( CharArrayRope ) other ; if ( cother . length ( ) ! = len ) return false ; return Arrays . equals ( sequence , cother . sequence ) ; } return false ; }
static TruthValue exemplification ( TruthValue v1 , TruthValue v2 ) { float f1 = v1 . getFrequency ( ) ; float f2 = v2 . getFrequency ( ) ; float c1 = v1 . getConfidence ( ) ; float c2 = v2 . getConfidence ( ) ; float w = and ( f1 , f2 , c1 , c2 ) ; float c = w2c ( w ) ; return new TruthValue ( 1 , c ) ; }
public void testStupidlyLargeSetAndSizeOverride ( ) throws Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) ) { return ; } Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( Integer . MAX_VALUE ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte [ ] data = new byte [ 21 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( ExecutionException e ) { System . err . println ( " Successful failure setting bigassthing.  Ass size  " + data . length + "  bytes doesn't fit. " ) ; e . printStackTrace ( ) ; OperationException oe = ( OperationException ) e . getCause ( ) ; assertSame ( OperationErrorType . SERVER , oe . getType ( ) ) ; } client . set ( " k " , 5 , " Blah " ) ; assertEquals ( " Blah " , client . get ( " k " ) ) ; }
public void run ( ) { try { getPlaylist ( ) . add ( directory ) ;
public void removeUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners = = null ) { return ; } mUpdateListeners . remove ( listener ) ; if ( mUpdateListeners . size ( ) = = 0 ) { mUpdateListeners = null ;
public void decisionPlanning ( final DerivationContext nal , final Task t , final Concept concept ) { if ( ! concept . isDesired ( ) ) { return ; } boolean plannable = graph . isPlannable ( t . getTerm ( ) ) ; if ( plannable ) { graph . plan ( nal , concept , t , t . getTerm ( ) , planParticles , searchDepth , '!' , maxPlannedTasks ) ;
public java . util . Iterator < C > iterator ( ) { return ( new PatriciaTrieIterator < C > ( trie ) ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmFut p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInher p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmSim p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInst p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmProp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInPp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmOp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmTrm p , A arg ) ; } }
void writing ( ) ; void writeComplete ( ) ; void initialize ( ) ; void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; MemcachedNode getHandlingNode ( ) ; void setHandlingNode ( MemcachedNode to ) ; void timeOut ( ) ; boolean isTimedOut ( ) ; boolean isTimedOut ( long ttlMillis ) ; boolean isTimedOutUnsent ( ) ; long getWriteCompleteTimestamp ( ) ; byte [ ] getErrorMsg ( ) ; void addClone ( Operation op ) ; int getCloneCount ( ) ; void setCloneCount ( int count ) ; }
private boolean canResize ( TableColumn column ) { return ( column ! = null ) & & table . getTableHeader ( ) . getResizingAllowed ( )
protected abstract AS2Session createAS2Session ( @Nonnull ICommonsMap < String , String > aInitParams ) throws AS2Exception , ServletException ; @Override public void onServletInit ( @Nonnull final ICommonsMap < String , String > aInitParams ) throws ServletException { super . onServletInit ( aInitParams ) ; try { m_aReceiver = getSession ( ) . getMessageProcessor ( ) . getModuleOfClass ( AS2ServletMDNReceiverModule . class ) ; if ( m_aReceiver = = null ) throw new ServletException ( " Failed to retrieve 'AS2ServletMDNReceiverModule' which is a mandatory module! Please ensure your configuration file contains at least the module ' " + AS2ServletMDNReceiverModule . class . getName ( ) + " ' " ) ; } catch ( final AS2Exception ex ) { throw new ServletException ( " Failed to init AS2 configuration " , ex ) ; } LOGGER . info ( " Successfully initialized AS2 configuration " ) ; } @Nonnull protected final AS2ServletMDNReceiverModule getMDNReceiverModule ( ) { if ( m_aReceiver = = null ) throw new IllegalStateException ( " This servlet was not initialized properly! No receiver is present. " ) ; return m_aReceiver ; } @Override protected final boolean isQuoteHeaderValues ( ) { return m_aReceiver . isQuoteHeaderValues ( ) ; } @Override @OverrideOnDemand @OverridingMethodsMustInvokeSuper protected void handleIncomingMessage ( @Nonnull final String sClientInfo , @Nonnull final DataSource aMsgData , @Nonnull final AS2Message aMsg , @Nonnull final IAS2HttpResponseHandler aResponseHandler ) throws ServletException { final String sReceivedContentType = AS2HttpHelper . getCleanContentType ( aMsg . getHeader ( CHttpHeader . CONTENT_TYPE ) ) ; if ( sReceivedContentType = = null ) throw new ServletException ( " Incoming message does not contain a valid Content-Type: ' " + aMsg . getHeader ( CHttpHeader . CONTENT_TYPE ) + " ' " ) ; final AS2MDNReceiverHandler aReceiverHandler = getMDNReceiverModule ( ) . createHandler ( ) ; aReceiverHandler . handleIncomingMessage ( sClientInfo , aMsgData , aMsg , aResponseHandler ) ; } }
public static void main ( String [ ] args ) { { int a = Integer . MAX_VALUE ; System . out . println ( " Integer to binary string using division and modulus. " ) ; long before = System . nanoTime ( ) ; String result = Integers . toBinaryUsingDivideAndModulus ( a ) ; long after = System . nanoTime ( ) ; System . out . println ( " a= " + a + "   " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Integer to binary string using shifts and modulus. " ) ; before = System . nanoTime ( ) ; result = Integers . toBinaryUsingShiftsAndModulus ( a ) ; after = System . nanoTime ( ) ; System . out . println ( " a= " + a + "   " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; System . out . println ( " Integer to binary string using BigDecimal. " ) ; before = System . nanoTime ( ) ; result = Integers . toBinaryUsingBigDecimal ( a ) ; after = System . nanoTime ( ) ; System . out . println ( " a= " + a + "   " + result ) ; System . out . println ( " Computed in  " + FORMAT . format ( after - before ) + "  ns " ) ; System . gc ( ) ; } { long a = Long . MAX_VALUE ;
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmStm p , A arg ) ; } }
private void normalizeWeights ( ) { double sumWeights = 0.0 ; for ( int i = 0 ; i < kernels . size ( ) ; i + + ) { sumWeights + = kernels . get ( i ) . generator . getWeight ( ) ; } for ( int i = 0 ; i < kernels . size ( ) ; i + + ) { kernels . get ( i ) . generator . setWeight ( kernels . get ( i ) . generator . getWeight ( ) / sumWeights ) ;
public void testMerge ( ) throws IOException { Path file = tmp . resolve ( " syncFileConfig.txt " ) ; Util . testLoadMerge ( newConfig ( file , ParsingMode . MERGE , true ) ) ; Util . testLoadMerge ( newConfig ( file , ParsingMode . MERGE , false ) ) ; }
public abstract MessageEncoding acceptsType ( ) ; public abstract Schema getSchema ( ) ; public static Translator translatorFor ( Properties props ) throws Exception { Translator translator = null ; String translatorName = props . getProperty ( " translator " ) ; if ( translatorName . equals ( " kvp " ) ) { translator = new KVPTranslator ( props ) ; } else if ( translatorName . equals ( " delimited " ) ) { translator = new DelimitedTranslator ( props ) ; } else if ( translatorName . equals ( " avro " ) ) { translator = new AvroTranslator ( props ) ; } else { Class < ? > clazz = Class . forName ( translatorName ) ; Constructor < ? > constructor = clazz . getConstructor ( Properties . class ) ; translator = ( Translator ) constructor . newInstance ( props ) ; } return translator ; } }
public void insertValue ( double val , double label , double weight ) { if ( val = = this . cut_point ) { this . leftStatistics . addToValue ( 0 , 1 ) ;
public boolean contains ( String cacheEntryName ) { try { PreparedStatement stmt = conn . prepareStatement ( " SELECT key FROM  " + TABLE_NAME + "  WHERE key = ?; " ) ;
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { throw new TimeoutException ( " Timed out waiting for operation " ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return objRef . get ( ) ; }
public void event ( Class event , Object [ ] a ) { if ( ( event ! = Events . TaskDerive . class & & event ! = Events . TaskAdd . class ) | | Memory . randomNumber . nextDouble ( ) > Parameters . INTERNAL_EXPERIENCE_PROBABILITY ) return ; Task task = ( Task ) a [ 0 ] ; if ( task . sentence . punctuation = = Symbols . JUDGMENT_MARK ) {
public void load ( String filename ) throws FileNotFoundException , IOException , ClassNotFoundException { ObjectInputStream in = new ObjectInputStream ( new FileInputStream ( filename ) ) ; w = ( double [ ] [ ] [ ] ) in . readObject ( ) ; in . close ( ) ; }
CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }
public float next ( final long time , final NAR nar ) { if ( concept = = null ) { concept = nar . memory . concept ( conceptTerm ) ; if ( concept = = null ) { return 0 ; } } switch ( mode ) { case Priority : return concept . getPriority ( ) ; case Duration : return concept . getDurability ( ) ; case BeliefConfidenceMax : if ( concept . beliefs . size ( ) > 0 ) { return concept . beliefs . get ( 0 ) . sentence . truth . getConfidence ( ) ; } return 0 ; } return 0f ; }
public boolean run ( Integer [ ] unsorted , Integer [ ] sorted , String input ) { this . input = input ; HashMap < Integer , String > pHashMap = new HashMap < Integer , String > ( HashMap . Type . PROBING , ARRAY_SIZE / 2 ) ; java . util . Map < Integer , String > jMap = pHashMap . toMap ( ) ; if ( ! testJavaMap ( jMap , Integer . class , String . class , name , unsorted , sorted , input ) ) return false ; return true ; }
public boolean addAll ( int index , Collection < ? extends ClauseInfo > c ) { throw new UnsupportedOperationException ( " Not supported. " ) ; }
Certificate getCertificate ( @Nullable String sAlias ) throws AS2CertificateException ; void setCertificate ( @Nonnull String sAlias , @Nonnull Certificate aCert ) throws AS2CertificateException ; @Nullable String getAlias ( @Nullable Certificate aCert ) throws AS2CertificateException ; void removeCertificate ( @Nullable String sAlias ) throws AS2CertificateException ; void clearCertificates ( ) throws AS2CertificateException ; @Nullable Key getKey ( @Nullable String sAlias , char [ ] aPassword ) throws AS2CertificateException ; void setKey ( @Nonnull String sAlias , @Nonnull Key aKey , char [ ] aPassword ) throws AS2CertificateException ; }
public void testSimpleGet ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; client . set ( " test1 " , 5 , " test1value " ) ; assertEquals ( " test1value " , client . get ( " test1 " ) ) ; }
void setupResend ( ) ; void fillWriteBuffer ( boolean optimizeGets ) ; void transitionWriteItem ( ) ; Operation getCurrentReadOp ( ) ; Operation removeCurrentReadOp ( ) ; Operation getCurrentWriteOp ( ) ; Operation removeCurrentWriteOp ( ) ; boolean hasReadOp ( ) ; boolean hasWriteOp ( ) ; void addOp ( Operation op ) ; int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; }
public void step ( ) { for ( VisionRay v : vision ) v . step ( ) ; double d = 999999 ; String inp = " " ; for ( InputDistance I : Li ) { if ( I . dist < d ) { inp = I . inp ; d = I . dist ; } } Li . clear ( ) ; if ( ! ( " " . equals ( inp ) ) ) { nar . addInput ( inp ) ; } if ( Rover . cnt > = do_sth_importance ) { Rover . cnt = 0 ; Rover . do_sth_importance + = decrease_of_importance_step ; ArrayList < String > candids = new ArrayList < > ( ) ; candids . add ( " (^motor,left)! :|: " ) ; candids . add ( " (^motor,right)! :|: " ) ; candids . add ( " (^motor,backward)! :|: " ) ; candids . add ( " (^motor,forward)! :|: " ) ; int candid = ( int ) ( Math . random ( ) * candids . size ( ) - 0.001 ) ; nar . addInput ( candids . get ( candid ) ) ; } if ( feel_motion ) { feelMotion ( ) ; } Rover . cnt + + ; }
public void onItemClick ( final AdapterView < ? > adapterView , View v , final int position , long id ) { app . oMPDAsyncHelper . execAsync ( new Runnable ( ) { @Override
public void defineValue ( List < String > path , Object defaultValue ) { defineValue ( path , defaultValue , o - > o ! = null & & defaultValue . getClass ( ) . isAssignableFrom ( o . getClass ( ) ) ) ; }
public static < T > Collection < T > buildCollection ( DomElement element , ItemFactory < T > factory ) { if ( element = = null ) return Collections . emptyList ( ) ; Collection < DomElement > children = element . getChildren ( ) ; Collection < T > items = new ArrayList < T > ( children . size ( ) ) ; for ( DomElement child : children ) { items . add ( factory . createItemFromElement ( child ) ) ; } return items ; }
public void hrend_DrawGUI ( ) { } @Override public void setup ( ) { frameRate ( FrameRate ) ; } int calcevery = 100 ; int calci = 0 ; float rendersize = 100 ; public void drawit ( ) { calci + + ; if ( calci % 100 = = 0 ) { A . Exec ( ) ; } strokeCap ( SQUARE ) ; strokeJoin ( PROJECT ) ; fill ( 255 ) ; for ( int i = 0 ; i < A . n ; i + + ) { for ( int j = 0 ; j < A . n ; j + + ) { fill ( 255 ) ; if ( i = = 0 | | i = = A . n - 1 | | j = = 0 | | j = = A . n - 1 ) { fill ( 0 , 0 , 255 ) ; rect ( i * rendersize , j * rendersize , rendersize , rendersize ) ; } else if ( A . readCells [ i ] [ j ] . state = = 0 ) { fill ( 255 ) ; rect ( i * 100 , j * rendersize , rendersize , rendersize ) ; } else { fill ( 128 ) ; rect ( i * rendersize , j * rendersize , rendersize , rendersize ) ; } } } } class ProcessingJs { ProcessingJs ( ) { addMouseWheelListener ( new java . awt . event . MouseWheelListener ( ) { public void mouseWheelMoved ( java . awt . event . MouseWheelEvent evt ) { mouseScroll = - evt . getWheelRotation ( ) ; mouseScrolled ( ) ; } } ) ; } } class Hnav { private float savepx = 0 ; private float savepy = 0 ; private int selID = 0 ; private float zoom = 1.0f ; private float difx = 0 ; private float dify = 0 ; private int lastscr = 0 ; private boolean EnableZooming = true ; private float scrollcamspeed = 1.1f ; float MouseToWorldCoordX ( int x ) { return 1 / zoom * ( x - difx - width / 2 ) ; } float MouseToWorldCoordY ( int y ) { return 1 / zoom * ( y - dify - height / 2 ) ; } private boolean md = false ; void mousePressed ( ) { md = true ; if ( mouseButton = = RIGHT ) { savepx = mouseX ; savepy = mouseY ; } drawn = false ; } void mouseReleased ( ) { md = false ; } void mouseDragged ( ) { if ( mouseButton = = RIGHT ) { difx + = ( mouseX - savepx ) ; dify + = ( mouseY - savepy ) ; savepx = mouseX ; savepy = mouseY ; } drawn = false ; } private float camspeed = 20.0f ; private float scrollcammult = 0.92f ; boolean keyToo = true ; void keyPressed ( ) { if ( ( keyToo & & key = = 'w' ) | | keyCode = = UP ) { dify + = ( camspeed ) ; } if ( ( keyToo & & key = = 's' ) | | keyCode = = DOWN ) { dify + = ( - camspeed ) ; } if ( ( keyToo & & key = = 'a' ) | | keyCode = = LEFT ) { difx + = ( camspeed ) ; } if ( ( keyToo & & key = = 'd' ) | | keyCode = = RIGHT ) { difx + = ( - camspeed ) ; } if ( ! EnableZooming ) { return ; } if ( key = = '-' | | key = = '#' ) { float zoomBefore = zoom ; zoom * = scrollcammult ; difx = ( difx ) * ( zoom / zoomBefore ) ; dify = ( dify ) * ( zoom / zoomBefore ) ; } if ( key = = '+' ) { float zoomBefore = zoom ; zoom / = scrollcammult ; difx = ( difx ) * ( zoom / zoomBefore ) ; dify = ( dify ) * ( zoom / zoomBefore ) ; } drawn = false ; } void Init ( ) { difx = - width / 2 ; dify = - height / 2 ; } void mouseScrolled ( ) { if ( ! EnableZooming ) { return ; } float zoomBefore = zoom ; if ( mouseScroll > 0 ) { zoom * = scrollcamspeed ; } else { zoom / = scrollcamspeed ; } difx = ( difx ) * ( zoom / zoomBefore ) ; dify = ( dify ) * ( zoom / zoomBefore ) ; drawn = false ; } void Transform ( ) { translate ( difx + 0.5f * width , dify + 0.5f * height ) ; scale ( zoom , zoom ) ; } } class Hsim { ArrayList obj = new ArrayList ( ) ; void Init ( ) { smooth ( ) ; } void mousePressed ( ) { if ( mouseButton = = LEFT ) { checkSelect ( ) ; float x = hnav . MouseToWorldCoordX ( mouseX ) ; float y = hnav . MouseToWorldCoordY ( mouseY ) ; automataclicked ( x , y ) ; } } boolean dragged = false ; void mouseDragged ( ) { if ( mouseButton = = LEFT ) { dragged = true ; dragElems ( ) ; } } void mouseReleased ( ) { dragged = false ; } void dragElems ( ) { } void checkSelect ( ) { } } class Hamlib { void Init ( ) { noStroke ( ) ; hnav . Init ( ) ; hsim . Init ( ) ; } void mousePressed ( ) { hnav . mousePressed ( ) ; hsim . mousePressed ( ) ; } void mouseDragged ( ) { hnav . mouseDragged ( ) ; hsim . mouseDragged ( ) ; } void mouseReleased ( ) { hnav . mouseReleased ( ) ; hsim . mouseReleased ( ) ; } public void mouseMoved ( ) { } void keyPressed ( ) { hnav . keyPressed ( ) ; } void mouseScrolled ( ) { hnav . mouseScrolled ( ) ; } void Camera ( ) { } } } public class TestChamber extends Window { TestChamber_applet app = null ; public TestChamber ( NAR n ) { super ( " TestChamber " ) ; app = new TestChamber_applet ( ) ; app . init ( ) ; app . nar = n ; this . setSize ( 1000 , 860 ) ; this . setVisible ( true ) ; Container content = getContentPane ( ) ; content . setLayout ( new BorderLayout ( ) ) ; JPanel menu = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; content . add ( menu , BorderLayout . NORTH ) ; content . add ( app , BorderLayout . CENTER ) ; } @Override protected void close ( ) { app . stop ( ) ; app . destroy ( ) ; getContentPane ( ) . removeAll ( ) ; app = null ; } public static void main ( String [ ] arg ) { NAR n = new NAR ( ) ; new TestChamber ( n ) ; } }
KeyStore loadKeyStore ( @Nonnull String sFilename , @Nonnull char [ ] aPassword ) throws Exception ; boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isCompressed ( @Nonnull String sContentType ) throws OpenAS2Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
void update ( Music music ) { this . setArtist ( music . getArtist ( ) ) ; this . setAlbum ( music . getAlbum ( ) ) ; this . setTitle ( music . getTitle ( ) ) ; this . setTime ( music . getTime ( ) ) ; this . setTotalTracks ( music . getTotalTracks ( ) ) ; this . setTrack ( music . getTrack ( ) ) ; }
protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { Term term = args [ 0 ] ; Concept concept = memory . conceptualize ( Consider . budgetMentalConcept ( operation ) , term ) ; BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_QUESTION_PRIORITY , Parameters . DEFAULT_QUESTION_DURABILITY , 1 ) ; activate ( memory , concept , budget , Activating . TaskLink ) ; return null ; }
public void testLongestPalindromicSubsequence ( ) { final int result = LongestPalindromicSubsequence . getLongestPalindromeSubsequence ( " AABCDEBAZ " ) ; assertTrue ( " Longest Palindromic Subsequence, expected= " + 5 + "  result= " + result , result = = 5 ) ; final int result1 = LongestPalindromicSubsequence . getLongestPalindromeSubsequence ( " subsequence " ) ; assertTrue ( " Longest Palindromic Subsequence, expected= " + 3 + "  result1= " + result1 , result1 = = 3 ) ; }
protected void processQuestion ( final DerivationContext nal , final Task task ) { Task quesTask = task ; boolean newQuestion = true ; for ( final Task t : questions ) { if ( t . sentence . equalsContent ( quesTask . sentence ) ) { quesTask = t ; newQuestion = false ; break ; } } if ( newQuestion ) { if ( questions . size ( ) + 1 > Parameters . CONCEPT_QUESTIONS_MAX ) { Task removed = questions . remove ( 0 ) ; memory . event . emit ( ConceptQuestionRemove . class , this , removed ) ; } questions . add ( task ) ; memory . event . emit ( ConceptQuestionAdd . class , this , task ) ; } Sentence ques = task . sentence ; final Task newAnswerT = ( ques . isQuestion ( ) ) ? selectCandidate ( ques , beliefs , false ) : selectCandidate ( ques , desires , false ) ; if ( newAnswerT ! = null ) { trySolution ( newAnswerT . sentence , task , nal ) ;
public void clear ( ) { final CachedCover cachedCover = getCacheRetriever ( ) ; if ( cachedCover ! = null ) { cachedCover . clear ( ) ; } initializeCoverData ( ) ; }
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public void close ( ) { if ( DBG ) Log . d ( LOG_TAG , " close() " ) ; changeCursor ( null ) ; mClosed = true ; }
protected List < Task > execute ( final Operation operation , final Term [ ] args , final Memory memory ) { final Term content = args [ 1 ] ; final Sentence sentence = new Sentence ( content , Symbols . QUESTION_MARK , null , new Stamp ( memory ) ) ; final BudgetValue budget = new BudgetValue ( memory . narParameters . DEFAULT_QUESTION_PRIORITY , memory . narParameters . DEFAULT_QUESTION_DURABILITY , 1 , memory . narParameters ) ; final Task newTask = new Task ( sentence , budget , Task . EnumType . INPUT ) ; return Lists . newArrayList ( newTask ) ; }
public void actionPerformed ( ActionEvent event ) { savePreferences ( ) ; }
private void processInstanceContentEvent ( InstancesContentEvent instContentEvent ) { this . numBatches + + ; this . contentEventList . add ( instContentEvent ) ; if ( this . numBatches = = 1 | | this . numBatches > 4 ) { this . processInstances ( this . contentEventList . remove ( 0 ) ) ;
< T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > tc ) ; < T > CASValue < T > getAndLock ( String key , int exp , Transcoder < T > tc ) ; CASValue < Object > getAndLock ( String key , int exp ) ; }
public D query ( long startIndex , long endIndex ) { if ( root = = null ) return null ; if ( startIndex < root . startIndex ) startIndex = root . startIndex ; if ( endIndex > root . endIndex ) endIndex = root . endIndex ; return ( D ) ( ( NonOverlappingSegment < D > ) root ) . query ( startIndex , endIndex ) ; }
public void recusriveExponentiationTest ( ) { final List < Integer > baseList = Arrays . asList ( 1 , 2 , 4 , 6 , 8 , 17 , 24 ) ; final List < Integer > exponentList = Arrays . asList ( 1000 , 27 , 14 , 11 , 10 , 7 , 5 ) ; final List < Integer > expectedResultList = Arrays . asList ( 1 , 134217728 , 268435456 , 362797056 , 1073741824 , 410338673 , 7962624 ) ; for ( int i = 0 ; i < expectedResultList . size ( ) ; i + + ) assertEquals ( expectedResultList . get ( i ) , Exponentiation . recursiveExponentiation ( baseList . get ( i ) , exponentList . get ( i ) ) ) ;
private static void writeSubTables ( OrganizedTable table , List < String > configPath , CharacterOutput output , TomlWriter writer ) { boolean hasArraysOfTables = ! table . arraysOfTables . isEmpty ( ) ; for ( Iterator < Entry > it = table . subTables . iterator ( ) ; it . hasNext ( ) ; ) { Entry entry = it . next ( ) ;
protected final void setPartners ( @Nonnull final PartnerMap aPartners ) throws AS2Exception { m_aRWLock . writeLockedThrowing ( ( ) - > { m_aPartners . setPartners ( aPartners ) ;
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitSVarD p , A arg ) { return visitDefault ( p , arg ) ; } public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitSVarI p , A arg ) { return visitDefault ( p , arg ) ; }
protected abstract StorageTable tableFor ( Properties props ) throws Exception ; public StorageTable getStorageTable ( Properties props ) throws Exception { String tableName = props . getProperty ( " storage.table.name " ) ; if ( ! tables . containsKey ( tableName ) ) { StorageTable table = tableFor ( props ) ; tables . put ( tableName , table ) ; } return tables . get ( tableName ) ; } }
private String insertTypeRestrictionsU ( KB kb ) { if ( DEBUG ) { System . out . println ( " ENTER insertTypeRestrictionsU( " + this + " ,  " + kb + " ) " ) ; } String result = " " ; try { Formula varlistF = new Formula ( ) ; varlistF . read ( this . getArgument ( 1 ) ) ; int vlen = varlistF . listLength ( ) ; Formula nextF = new Formula ( ) ; nextF . read ( this . getArgument ( 2 ) ) ; List constraints = new ArrayList ( ) ; List ios = new ArrayList ( ) ; List scs = new ArrayList ( ) ; Iterator classIt = null ; String constraint = null ; String var =   null ; for ( int i = 0 ; i < vlen ; i + + ) { ios . clear ( ) ; scs . clear ( ) ; var =   varlistF . getArgument ( i ) ; nextF . computeTypeRestrictions ( ios , scs , var , kb ) ; if ( ! ios . isEmpty ( ) ) { winnowTypeList ( ios , kb ) ; classIt = ios . iterator ( ) ; while ( classIt . hasNext ( ) ) { constraint = " (instance  " + var +   "   "   +   classIt . next ( ) + " ) " ; if ( this . theFormula . indexOf ( constraint ) = = - 1 ) { constraints . add ( constraint ) ; } } } if ( ! scs . isEmpty ( ) ) { winnowTypeList ( scs , kb ) ; classIt = scs . iterator ( ) ; while ( classIt . hasNext ( ) ) { constraint = " (subclass  " + var +   "   "   +   classIt . next ( ) + " ) " ; if ( this . theFormula . indexOf ( constraint ) = = - 1 ) { constraints . add ( constraint ) ; } } } } result + = " (forall  " + varlistF . theFormula ; if ( constraints . isEmpty ( ) ) { result + = "   " + nextF . insertTypeRestrictions ( kb ) ; } else { result + = "  (=> " ; int clen = constraints . size ( ) ; if ( clen > 1 ) { result + = "  (and " ; } for ( int j = 0 ; j < clen ; j + + ) { result + = "   " + constraints . get ( j ) ; } if ( clen > 1 ) { result + = " ) " ; } result + = "   " + nextF . insertTypeRestrictions ( kb ) ; result + = " ) " ; } result + = " ) " ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; result = this . theFormula ; } if ( DEBUG ) { System . out . println ( " EXIT insertTypeRestrictionsU( " + this + " ,  " + kb + " ) ->  " + result ) ; } return result ; }
public static void notifyUser ( String message , Context context ) { Toast . makeText ( context , message , Toast . LENGTH_SHORT ) . show ( ) ; }
public void statsComplete ( ) { todo . decrementAndGet ( ) ; sync . set ( todo ) ; } } ) ) ;
public void removePropertyChangeListener ( PropertyChangeListener listener ) { propertyChangeSupport . removePropertyChangeListener ( listener ) ; }
public void toTypeSchemaStructTypeNotNullable ( ) throws Exception { Schema schema = AvroUtils . typeFor ( DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " field1 " , DataTypes . StringType , false ) ) ) , false ) ; assertEquals ( " Invalid type " , Schema . Type . RECORD , schema . getType ( ) ) ; assertEquals ( " Invalid record name " , " record0 " , schema . getName ( ) ) ; assertEquals ( " Invalid field count " , 1 , schema . getFields ( ) . size ( ) ) ; assertEquals ( " Invalid field name " , " field1 " , schema . getFields ( ) . get ( 0 ) . name ( ) ) ; assertEquals ( " Invalid field type " , Schema . Type . STRING , schema . getFields ( ) . get ( 0 ) . schema ( ) . getType ( ) ) ;
public void gotData ( ViewResponseNoDocs response ) { vr = response ; }
private static NotificationCompat . Builder buildStaticCollapsedNotification ( ) { final Intent musicPlayerActivity = new Intent ( sApp , MainMenuActivity . class ) ; final TaskStackBuilder stackBuilder = TaskStackBuilder . create ( sApp ) ; stackBuilder . addParentStack ( MainMenuActivity . class ) ; stackBuilder . addNextIntent ( musicPlayerActivity ) ; final PendingIntent notificationClick = stackBuilder . getPendingIntent ( 0 , PendingIntent . FLAG_UPDATE_CURRENT ) ; final NotificationCompat . Builder builder = new NotificationCompat . Builder ( sApp ) ; builder . setSmallIcon ( R . drawable . icon_bw ) ; builder . setContentIntent ( notificationClick ) ; builder . setStyle ( new NotificationCompat . BigTextStyle ( ) ) ; return builder ; }
int getAttributeAsInt ( @Nullable String sName ) ; int getAttributeAsInt ( @Nullable String sName , int nDefault ) ; long getAttributeAsLong ( @Nullable String sName ) ; long getAttributeAsLong ( @Nullable String sName , long nDefault ) ; double getAttributeAsDouble ( @Nullable String sName ) ; double getAttributeAsDouble ( @Nullable String sName , double dDefault ) ; boolean getAttributeAsBoolean ( @Nullable String sName ) ; boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; @Nonnull @ReturnsMutableCopy Enumeration < String > getAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Collection < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; @Nonnull Iterator < Entry < String , String > > iterator ( ) ; }
public void readFromBuffer ( ByteBuffer b ) throws IOException { if ( headerOffset < MIN_RECV_PACKET ) { int toRead = MIN_RECV_PACKET - headerOffset ; int available = b . remaining ( ) ; toRead = Math . min ( toRead , available ) ; getLogger ( ) . debug ( " Reading %d header bytes " , toRead ) ; b . get ( header , headerOffset , toRead ) ; headerOffset + = toRead ; if ( headerOffset = = MIN_RECV_PACKET ) { int magic = header [ 0 ] ; assert magic = = RES_MAGIC : " Invalid magic:   " + magic ; responseCmd = header [ 1 ] ; assert cmd = = DUMMY_OPCODE | | responseCmd = = cmd : " Unexpected response command value " ; keyLen = decodeShort ( header , 2 ) ; errorCode = ( short ) decodeShort ( header , 6 ) ; int bytesToRead = decodeInt ( header , 8 ) ; payload = new byte [ bytesToRead ] ; responseOpaque = decodeInt ( header , 12 ) ; responseCas = decodeLong ( header , 16 ) ; assert opaqueIsValid ( ) : " Opaque is not valid " ; } } if ( headerOffset > = MIN_RECV_PACKET & & payload = = null ) { finishedPayload ( EMPTY_BYTES ) ;
protected void add ( Item item , boolean replace , boolean play ) { try { final Directory ToAdd = mCurrentDirectory . getDirectory ( item . getName ( ) ) ;
public static boolean get ( Context context ) { return ViewConfiguration . get ( context ) . hasPermanentMenuKey ( ) ; }
public ArrayRealVector call ( ) { return align ( node , null ) ; }
public void onPanelCollapsed ( View panel ) { nowPlayingSmallFragment . setVisibility ( View . VISIBLE ) ; nowPlayingSmallFragment . setAlpha ( 1 ) ; mDrawerLayout . setDrawerLockMode ( DrawerLayout . LOCK_MODE_UNLOCKED ) ; }
boolean answeredBy ( DNSEntry rec ) { return this . isSameRecordClass ( rec ) & & this . isSameType ( rec ) & & this . getName ( ) . equals ( rec . getName ( ) ) ;
public Object clone ( ) { return new Negation ( getName ( ) , ( ArrayList < Term > ) cloneList ( components ) , isConstant ( ) , complexity ) ; }
public String toString ( ) { return score ( ) + " [ " + activation + " | " + distance + " ]  " + "  <-  " + Arrays . toString ( shortestPath ) ; }
public Concept concept ( Term term ) ; public Concept conceptualize ( BudgetValue budget , Term term , boolean createIfMissing ) ; public void activate ( Concept c , BudgetValue b , Activating mode ) ; public Concept sampleNextConcept ( ) ; public void init ( Memory m ) ; }
public Object visit ( LitInt p , LoanParser arg ) { return new NumericLiteral ( p . integer_ . intValue ( ) ) ; }
public void test_$op_3_2 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch('$op'(600, Specifier, '+'), error(instantiation_error, instantiation_error(Goal, ArgNo)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " $op " , new Int ( 600 ) , new Var ( " Specifier " ) , new Struct ( " + " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 2 ) ; }
public void onChange ( float v ) { int level = ( int ) v ; ( nar . param ) . noiseLevel . set ( level ) ; }
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
DeleteOperation delete ( String key , OperationCallback operationCallback ) ; UnlockOperation unlock ( String key , long casId , OperationCallback operationCallback ) ; ObserveOperation observe ( String key , long casId , int index , ObserveOperation . Callback operationCallback ) ; FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetlOperation getl ( String key , int exp , GetlOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; MutatorOperation mutate ( Mutator m , String key , long by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; KeyedOperation touch ( String key , int expiration , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
public Task planTask ( Concept c , Task goal , Term goalTerm , char punctuation ) { Cause currentEdge = path [ path . length - 1 ] ; Stamp stamp = new Stamp ( goal . sentence . stamp , currentEdge . getStamp ( ) , memory . time ( ) ) ; for ( Term T : sequence ) { stamp . derivationChain . add ( T ) ; } Term subj = sequence . size ( ) > 1 ? Conjunction . make ( sequence . toArray ( new Term [ sequence . size ( ) ] ) , TemporalRules . ORDER_FORWARD ) : sequence . get ( 0 ) ; Term imp = Implication . make ( subj , goalTerm , TemporalRules . ORDER_FORWARD ) ; if ( imp = = null ) { throw new RuntimeException ( " Invalid implication:  " + subj + "  = \\ >  " + goalTerm ) ; } this . goal = goal ; this . solution = new Task ( new Sentence ( imp , punctuation , truth , stamp ) , budget , goal ) { @Override public void end ( boolean success ) { super . end ( success ) ; } @Override public void expect ( boolean eventHappened ) { if ( eventHappened ) { rememberPlanSuccess ( ParticlePlan . this , goalTerm , this ) ; } if ( ! eventHappened ) { forgetPlanSuccess ( ParticlePlan . this , goalTerm , this ) ; } } } ; return solution ; }
public String cddr ( ) { Formula fCdr = this . cdrAsFormula ( ) ; if ( fCdr ! = null ) { return fCdr . cdr ( ) ; } return null ; }
private void writeObject ( @Nonnull final ObjectOutputStream aOOS ) throws IOException { aOOS . writeObject ( m_aAttributes ) ; aOOS . writeObject ( m_aHeaders ) ; aOOS . writeObject ( m_aPartnership ) ; }
public static boolean isReallyFile ( String param ) { return ! " --silence " . equals ( param ) ; }
public void onWarning ( WarningEvent event ) { warningPane . setText ( warningPane . getText ( ) + event . getMsg ( ) + " \ n " ) ; warningPane . setCaretPosition ( warningPane . getDocument ( ) . getLength ( ) - 1 ) ; }
public void setCrossfade ( final int time ) throws MPDServerException { mConnection . sendCommand ( MPDCommand . MPD_CMD_CROSSFADE , Integer . toString ( Math . max ( 0 , time ) ) ) ;
protected void onStop ( ) { super . onStop ( ) ; app . setActivity ( this ) ; }
public static void sendSimpleHTTPResponse ( @Nonnull final IAS2HttpResponseHandler aResponseHandler , final int nResponseCode ) throws IOException { final InternetHeaders aHeaders = new InternetHeaders ( ) ; final NonBlockingByteArrayOutputStream aData = new NonBlockingByteArrayOutputStream ( ) ; aData . write ( ( Integer . toString ( nResponseCode ) + "   " + getHTTPResponseMessage ( nResponseCode ) + " \ r \ n " ) . getBytes ( ) ) ; aResponseHandler . sendHttpResponse ( nResponseCode , aHeaders , aData ) ; }
protected final void showBuffer ( final Graphics2D g ) { Graphics localGraphics = getGraphics ( ) ; localGraphics . drawImage ( image , 0 , 0 , null ) ; g . dispose ( ) ; localGraphics . dispose ( ) ; }
public boolean checkAsyncMDN ( @Nonnull final AS2Message aMsg ) throws AS2Exception { try { final String sReturnMIC = aMsg . getMDN ( ) . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_MIC ) ; final MIC aReturnMIC = MIC . parse ( sReturnMIC ) ; final String sOrigMessageID = aMsg . getMDN ( ) . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_ORIG_MESSAGEID ) ; final String sPendingInfoFile = AS2IOHelper . getSafeFileAndFolderName ( getModule ( ) . getSession ( ) . getMessageProcessor ( ) . attrs ( ) . getAsString ( ATTR_PENDINGMDNINFO ) ) + " / " + AS2IOHelper . getFilenameFromMessageID ( sOrigMessageID ) ; final String sOriginalMIC ; final MIC aOriginalMIC ; final File aPendingFile ; try ( final NonBlockingBufferedReader aPendingInfoReader = FileHelper . getBufferedReader ( new File ( sPendingInfoFile ) , StandardCharsets . ISO_8859_1 ) ) { sOriginalMIC = aPendingInfoReader . readLine ( ) ; aOriginalMIC = MIC . parse ( sOriginalMIC ) ; aPendingFile = new File ( aPendingInfoReader . readLine ( ) ) ; } final String sDisposition = aMsg . getMDN ( ) . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_DISPOSITION ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " received MDN [ " + sDisposition + " ] " + aMsg . getLoggingText ( ) ) ; if ( aOriginalMIC = = null | | aReturnMIC = = null | | ! aReturnMIC . equals ( aOriginalMIC ) ) { m_aMICMatchingHandler . onMICMismatch ( aMsg , sOriginalMIC , sReturnMIC ) ; return false ; } m_aMICMatchingHandler . onMICMatch ( aMsg , sReturnMIC ) ; final File aPendingInfoFile = new File ( sPendingInfoFile ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " delete pendinginfo file :  " + aPendingInfoFile . getName ( ) + "  from pending folder :  " + getModule ( ) . getSession ( ) . getMessageProcessor ( ) . attrs ( ) . getAsString ( ATTR_PENDINGMDN ) + aMsg . getLoggingText ( ) ) ; if ( ! aPendingInfoFile . delete ( ) ) { if ( LOGGER . isErrorEnabled ( ) ) LOGGER . error ( " Error delete pendinginfo file  " + aPendingFile ) ; } if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " delete pending file :  " + aPendingFile . getName ( ) + "  from pending folder :  " + aPendingFile . getParent ( ) + aMsg . getLoggingText ( ) ) ; if ( ! aPendingFile . delete ( ) ) { if ( LOGGER . isErrorEnabled ( ) ) LOGGER . error ( " Error delete pending file  " + aPendingFile ) ; } } catch ( final IOException | ComponentNotFoundException ex ) { LOGGER . error ( " Error checking async MDN " , ex ) ; return false ; } return true ; }
public void testOnlyUsesLatestArrivingRecordForAKey ( ) { p = new EventTimeUpsertPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( recordSchema , " a " , " world " , 50L ) ) ; arriving . add ( new RowWithSchema ( recordSchema , " a " , " 125 " , 125L ) ) ; arriving . add ( new RowWithSchema ( recordSchema , " a " , " 200 " , 200L ) ) ; arriving . add ( new RowWithSchema ( recordSchema , " a " , " 135 " , 135L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 1 ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . UPDATE ) ; Row plannedRow = planned . get ( 0 ) . getRow ( ) ; assertEquals ( plannedRow . get ( plannedRow . fieldIndex ( " value " ) ) , " 200 " ) ; }
public static void revision ( Sentence newBelief , Sentence oldBelief , boolean feedbackToLinks , Memory memory ) { TruthValue newTruth = newBelief . getTruth ( ) ; TruthValue oldTruth = oldBelief . getTruth ( ) ; TruthValue truth = TruthFunctions . revision ( newTruth , oldTruth ) ; BudgetValue budget = BudgetFunctions . revise ( newTruth , oldTruth , truth , feedbackToLinks , memory ) ; Term content = newBelief . getContent ( ) ; memory . doublePremiseTask ( content , truth , budget , false ) ; }
public boolean equals ( Object e1 ) { if ( ! ( e1 instanceof CostVertexPair ) ) return false ; CostVertexPair pair = ( CostVertexPair ) e1 ; if ( this . cost ! = pair . cost ) return false ; if ( ! this . vertex . equals ( pair ) ) return false ; return true ; }
public Future < Boolean > delete ( String key , int when ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( latch ) ; DeleteOperationImpl op = new DeleteOperationImpl ( key , when , new OperationCallback ( ) { public void receivedStatus ( String line ) { rv . set ( line . equals ( " DELETED " ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }
public static boolean after ( TimeModel timeModel , Row first , Row second ) { return timeModel . compare ( first , second ) > 0 ; }
List < View > getViews ( final String designDocumentName ) ; HttpFuture < ViewResponse > asyncQuery ( View view , Query query ) ; ViewResponse query ( View view , Query query ) ; }
public static String getHTTPResponseMessage ( final int nResponseCode ) { String sMsg ; switch ( nResponseCode ) { case 100 : sMsg = " Continue " ; break ; case 101 : sMsg = " Switching Protocols " ; break ; case 200 : sMsg = " OK " ; break ; case 201 : sMsg = " Created " ; break ; case 202 : sMsg = " Accepted " ; break ; case 203 : sMsg = " Non-Authoritative Information " ; break ; case 204 : sMsg = " No Content " ; break ; case 205 : sMsg = " Reset Content " ; break ; case 206 : sMsg = " Partial Content " ; break ; case 300 : sMsg = " Multiple Choices " ; break ; case 301 : sMsg = " Moved Permanently " ; break ; case 302 : sMsg = " Found " ; break ; case 303 : sMsg = " See Other " ; break ; case 304 : sMsg = " Not Modified " ; break ; case 305 : sMsg = " Use Proxy " ; break ; case 307 : sMsg = " Temporary Redirect " ; break ; case 400 : sMsg = " Bad Request " ; break ; case 401 : sMsg = " Unauthorized " ; break ; case 402 : sMsg = " Payment Required " ; break ; case 403 : sMsg = " Forbidden " ; break ; case 404 : sMsg = " Not Found " ; break ; case 405 : sMsg = " Method Not Allowed " ; break ; case 406 : sMsg = " Not Acceptable " ; break ; case 407 : sMsg = " Proxy Authentication Required " ; break ; case 408 : sMsg = " Request Time-out " ; break ; case 409 : sMsg = " Conflict " ; break ; case 410 : sMsg = " Gone " ; break ; case 411 : sMsg = " Length Required " ; break ; case 412 : sMsg = " Precondition Failed " ; break ; case 413 : sMsg = " Request Entity Too Large " ; break ; case 414 : sMsg = " Request-URI Too Large " ; break ; case 415 : sMsg = " Unsupported Media Type " ; break ; case 416 : sMsg = " Requested range not satisfiable " ; break ; case 417 : sMsg = " Expectation Failed " ; break ; case 500 : sMsg = " Internal Server Error " ; break ; case 501 : sMsg = " Not Implemented " ; break ; case 502 : sMsg = " Bad Gateway " ; break ; case 503 : sMsg = " Service Unavailable " ; break ; case 504 : sMsg = " Gateway Time-out " ; break ; case 505 : sMsg = " HTTP Version not supported " ; break ; default : sMsg = " Unknown ( " + nResponseCode + " ) " ; break ; } return sMsg ; }
public Operator operator ( ) { return Operator . DIFFERENCE_EXT ; }
public void adjustVolume ( int modifier ) throws MPDServerException { int vol = mStatus . getVolume ( ) + modifier ; vol = Math . max ( MPDCommand . MIN_VOLUME , Math . min ( MPDCommand . MAX_VOLUME , vol ) ) ; mConnection . sendCommand ( MPDCommand . MPD_CMD_SET_VOLUME , Integer . toString ( vol ) ) ; }
private void fireOnSelected ( ) { if ( mOnItemSelectedListener = = null ) return ; int selection = this . getSelectedItemPosition ( ) ; if ( selection > = 0 ) { View v = getSelectedView ( ) ;
public static void perfNAL ( final String path , final int extraCycles , final int repeats , final int warmups ) { } public static double perfNAL ( final Nar n , final String path , final int extraCycles , final int repeats , final int warmups , final boolean gc ) { final String example = NALTest . getExample ( path ) ; final Performance p = new Performance ( path , repeats , warmups , gc ) { long totalCycles ; @Override public void init ( ) { System . out . print ( name + " :  " ) ; totalCycles = 0 ; } @Override public void run ( final boolean warmup ) { n . reset ( ) ; n . addInput ( example ) ; n . cycles ( 1 ) ; n . cycles ( extraCycles ) ; totalCycles + = n . memory . time ( ) ; } @Override public Performance print ( ) { super . print ( ) ; System . out . print ( " ,  " + df . format ( getCycleTimeMS ( ) / totalCycles * 1000.0 ) + "  uS/cycle,  " + ( ( ( float ) totalCycles ) / ( warmups + repeats ) ) + "  cycles/run " ) ; return this ; } @Override public Performance printCSV ( final boolean finalComma ) { super . printCSV ( true ) ; System . out . print ( df . format ( getCycleTimeMS ( ) / totalCycles * 1000.0 ) + " ,  " + ( ( ( float ) totalCycles ) / ( warmups + repeats ) ) ) ; if ( finalComma ) System . out . print ( " ,  " ) ; return this ; } } ; p . print ( ) ; System . out . println ( ) ; return p . getCycleTimeMS ( ) ; } public static void test ( final Nar n ) { final int repeats = 1 ; final int warmups = 0 ; final int extraCycles = 5000 ; final Collection c = NALTest . params ( ) ; double totalTime = 0 ; for ( final Object o : c ) { final String examplePath = ( String ) ( ( Object [ ] ) o ) [ 0 ] ; totalTime + = perfNAL ( n , examplePath , extraCycles , repeats , warmups , true ) ; } System . out . println ( " \ n \ nTotal mean runtime (ms):  " + totalTime ) ; } public static void main ( final String [ ] args ) { final Nar nd = new Nar ( ) ; test ( nd ) ; } }
public Stream createStream ( IProcessingItem sourcePi ) { Stream stream = this . componentFactory . createStream ( sourcePi ) ; this . topology . addStream ( stream ) ; return stream ; }
private void shutdownNotification ( ) { if ( sApp . isNotificationPersistent ( ) ) { windDownResources ( ) ;
public static boolean isValidTerm ( Term t ) { return t instanceof CompoundTerm ; }
public static final int euclidsGreatestCommonDivsor ( int x , int y ) { int greater = x ; int smaller = y ; if ( y > x ) { greater = y ; smaller = x ; } int result = 0 ; while ( true ) { if ( smaller = = greater ) { result = smaller ; break ; } greater - = smaller ; if ( smaller > greater ) { int temp = smaller ; smaller = greater ; greater = temp ; } } return result ; }
public static boolean isReallyFile ( String param ) { return ! " --silence " . equals ( param ) ; }
public static ConvRectangle UpdateConvRectangle ( final Term [ ] term ) { String index_last_var = null ; int minX = Integer . MAX_VALUE , minY = Integer . MAX_VALUE , maxX = 0 , maxY = 0 , minsX = Integer . MAX_VALUE , minsY = Integer . MAX_VALUE ; boolean hasTermIndices = false ; boolean calculateTermIndices = true ; for ( final Term t : term ) { if ( t ! = null & & t . term_indices ! = null ) { if ( ! calculateTermIndices | | ( t . index_variable ! = null & & index_last_var ! = null & & ( ! t . index_variable . equals ( index_last_var ) ) ) ) { calculateTermIndices = false ; hasTermIndices = false ; continue ; } hasTermIndices = true ; final int size_X = t . term_indices [ 0 ] ; if ( size_X < minsX ) minsX = size_X ; final int size_Y = t . term_indices [ 1 ] ; if ( size_Y < minsY ) minsY = size_Y ; final int pos_X = t . term_indices [ 2 ] ; final int pos_Y = t . term_indices [ 3 ] ; if ( pos_X < minX ) minX = pos_X ; if ( pos_Y < minY ) minY = pos_Y ; if ( pos_X + size_X > maxX ) maxX = pos_X + size_X ; if ( pos_Y + size_Y > maxY ) maxY = pos_Y + size_Y ; index_last_var = t . index_variable ; } } final ConvRectangle rect = new ConvRectangle ( ) ; if ( hasTermIndices ) { rect . term_indices = new int [ 6 ] ; rect . term_indices [ 0 ] = maxX - minX ; rect . term_indices [ 1 ] = maxY - minY ; rect . term_indices [ 2 ] = minX ; rect . term_indices [ 3 ] = minY ; rect . term_indices [ 4 ] = minsX ; rect . term_indices [ 5 ] = minsY ; rect . index_variable = index_last_var ; } return rect ; }
public MenuItem add ( int groupId , int itemId , int order , int titleRes ) { return add ( groupId , itemId , order , mContext . getResources ( ) . getString ( titleRes ) ) ; }
public int hashCode ( ) { int hash = 5 ; hash = 67 * hash + ( this . content ! = null ? this . content . hashCode ( ) : 0 ) ; hash = 67 * hash + this . punctuation ; hash = 67 * hash + ( this . truth ! = null ? this . truth . hashCode ( ) : 0 ) ; hash = 67 * hash + ( stamp ! = null ? stamp . hashCode ( ) : 0 ) ; return hash ; }
Future < Boolean > append ( long cas , String key , Object val ) ; Future < Boolean > append ( String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > append ( String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; Future < Boolean > prepend ( String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > prepend ( String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public void onBufferingUpdate ( MediaPlayer mp , int percent ) { } @Override public boolean onError ( MediaPlayer mp , int what , int extra ) { pauseStreaming ( ) ; return false ; } @Override public boolean onInfo ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public void connectionFailed ( String message ) { } @Override public void connectionSucceeded ( String message ) { } @Override public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } @Override public void playlistChanged ( MPDStatus mpdStatus , int oldPlaylistVersion ) { } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { oldStatus = " " ; showNotification ( ) ; } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = oldStatus ) return ; if ( state = = MPDStatus . MPD_STATE_PLAYING ) { isPaused = false ; resumeStreaming ( ) ; isPlaying = true ; } else { oldStatus = state ; isPlaying = false ; stopStreaming ( ) ; } } } } @Override public void repeatChanged ( boolean repeating ) { } @Override public void randomChanged ( boolean random ) { } @Override public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } @Override public void onAudioFocusChange ( int focusChange ) { if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS_TRANSIENT ) { mediaPlayer . setVolume ( 0.2f , 0.2f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_GAIN ) { mediaPlayer . setVolume ( 1f , 1f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS ) { stop ( ) ; } } }
private void assertConfigMatchesJsonExpectation ( CommentedConfig tomlConfig , Config jsonExpect , String testName ) { tomlConfig . clearComments ( ) ; assertMatchJsonExpectValue ( List . of ( ) , tomlConfig , jsonExpect , String . format ( " Valid test %s failed " , testName ) ) ; }
public Chart height ( float h ) { this . height = h ; return this ; }
public static ServiceInfo create ( final String type , final String name , final String subtype , final int port , final int weight , final int priority , final String text ) { return new ServiceInfoImpl ( type , name , subtype , port , weight , priority , false , text ) ; }
protected abstract AS2Session createAS2Session ( @Nonnull ICommonsMap < String , String > aInitParams ) throws OpenAS2Exception , ServletException ; @Override public void onServletInit ( @Nonnull final ICommonsMap < String , String > aInitParams ) throws ServletException { try { m_aSession = createAS2Session ( aInitParams ) ; m_aReceiver = m_aSession . getMessageProcessor ( ) . getModuleOfClass ( AS2ServletReceiverModule . class ) ; if ( m_aReceiver = = null ) throw new ServletException ( " Failed to retrieve AS2ReceiverModule which is a mandatory module! Please ensure your configuration file contains at least the module ' " + AS2ServletReceiverModule . class . getName ( ) + " ' " ) ; } catch ( final OpenAS2Exception ex ) { throw new ServletException ( " Failed to init AS2 configuration " , ex ) ; } LOGGER . info ( " Successfully initialized AS2 configuration " ) ; } @Nonnull protected AS2Session getSession ( ) { if ( m_aSession = = null ) throw new IllegalStateException ( " This servlet was not initialized properly! No AS2 session is present. " ) ; return m_aSession ; } @Nonnull protected AS2ReceiverModule getReceiverModule ( ) { if ( m_aReceiver = = null ) throw new IllegalStateException ( " This servlet was not initialized properly! No receiver is present. " ) ; return m_aReceiver ; } @OverrideOnDemand @OverridingMethodsMustInvokeSuper protected void handeIncomingMessage ( @Nonnull final HttpServletRequest aHttpRequest , @Nonnull final HttpServletResponse aHttpResponse , @Nonnull final IRequestWebScope aRequestScope , @Nonnull final byte [ ] aMsgData , @Nonnull final AS2Message aMsg , @Nonnull final AS2OutputStreamCreatorHttpServletResponse aResponseHandler ) throws ServletException { final String sClientInfo = aHttpRequest . getRemoteAddr ( ) + " : " + aHttpRequest . getRemotePort ( ) ; final String sReceivedContentType = AS2HttpHelper . getCleanContentType ( aMsg . getHeader ( CHttpHeader . CONTENT_TYPE ) ) ; if ( sReceivedContentType = = null ) throw new ServletException ( " Incoming message does not contain a valid Content-Type: ' " + aMsg . getHeader ( CHttpHeader . CONTENT_TYPE ) + " ' " ) ; final DataSource aPayload = new ByteArrayDataSource ( aMsgData , sReceivedContentType , null ) ; getReceiverModule ( ) . createHandler ( ) . handleIncomingMessage ( sClientInfo , aPayload , aMsg , aResponseHandler ) ; } public final void onRequest ( @Nonnull final HttpServletRequest aHttpRequest , @Nonnull final HttpServletResponse aHttpResponse , @Nonnull final EHttpVersion eHttpVersion , @Nonnull final EHttpMethod eHttpMethod , @Nonnull final IRequestWebScope aRequestScope ) throws ServletException , IOException { final AS2Message aMsg = new AS2Message ( ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_SOURCE_IP , aHttpRequest . getRemoteAddr ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_SOURCE_PORT , aHttpRequest . getRemotePort ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_DESTINATION_IP , aHttpRequest . getLocalAddr ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_DESTINATION_PORT , aHttpRequest . getLocalPort ( ) ) ; aMsg . attrs ( ) . putIn ( HTTPHelper . MA_HTTP_REQ_TYPE , aHttpRequest . getMethod ( ) ) ; aMsg . attrs ( ) . putIn ( HTTPHelper . MA_HTTP_REQ_URL , ServletHelper . getRequestRequestURI ( aHttpRequest ) ) ; aMsg . headers ( ) . setAllHeaders ( aRequestScope . headers ( ) ) ; final boolean bQuoteHeaderValues = getReceiverModule ( ) . attrs ( ) . getAsBoolean ( AbstractActiveNetModule . ATTR_QUOTE_HEADER_VALUES , AbstractActiveNetModule . DEFAULT_QUOTE_HEADER_VALUES ) ; final AS2OutputStreamCreatorHttpServletResponse aResponseHandler = new AS2OutputStreamCreatorHttpServletResponse ( aHttpResponse , bQuoteHeaderValues ) ; final long nContentLength = aHttpRequest . getContentLengthLong ( ) ; if ( nContentLength > Integer . MAX_VALUE ) throw new IllegalStateException ( " Currently only payload with up to 2GB can be handled! " ) ; final byte [ ] aMsgData ; if ( nContentLength > = 0 ) { aMsgData = new byte [ ( int ) nContentLength ] ; try ( final DataInputStream aDataIS = new DataInputStream ( aHttpRequest . getInputStream ( ) ) ) { aDataIS . readFully ( aMsgData ) ; } } else { aMsgData = StreamHelper . getAllBytes ( aHttpRequest . getInputStream ( ) ) ; } final IHTTPIncomingDumper aIncomingDumper = HTTPHelper . getHTTPIncomingDumper ( ) ; if ( aIncomingDumper ! = null ) aIncomingDumper . dumpIncomingRequest ( aMsg . headers ( ) . getAllHeaderLines ( true ) , aMsgData , aMsg ) ; handeIncomingMessage ( aHttpRequest , aHttpResponse , aRequestScope , aMsgData , aMsg , aResponseHandler ) ; } }
private static boolean testAVLTree ( ) { String bstName = " AVL Tree " ; BinarySearchTree < Integer > bst = new AVLTree < Integer > ( ) ; Collection < Integer > bstCollection = bst . toCollection ( ) ; if ( ! testJavaCollection ( bstCollection , Integer . class , bstName ) ) return false ; return true ; }
String getContentDisposition ( ) ; void setContentDisposition ( @Nullable String sContentDisposition ) ; @Nullable String getSubject ( ) ; void setSubject ( @Nullable String sSubject ) ; @Nullable MimeBodyPart getData ( ) ; void setData ( @Nullable MimeBodyPart aData , @Nullable DataHistoryItem aHistoryItem ) throws OpenAS2Exception ; @Nonnull DataHistoryItem setData ( @Nonnull MimeBodyPart aData ) throws OpenAS2Exception ; @Nullable IMessageMDN getMDN ( ) ; void setMDN ( @Nullable IMessageMDN aMDN ) ; @Nonnull @Nonempty String getLoggingText ( ) ; @Nonnull DataHistory getHistory ( ) ; String getProtocol ( ) ; boolean isRequestingMDN ( ) ; boolean isRequestingAsynchMDN ( ) ; @Deprecated String toString ( ) ; }
void giveUpAudioFocus ( ) { if ( mAudioFocus = = AudioFocus . Focused & & mAudioFocusHelper ! = null & & mAudioFocusHelper . abandonFocus ( ) ) mAudioFocus = AudioFocus . NoFocusNoDuck ;
public void test ( ) { ConfigSpec spec = new ConfigSpec ( ) ; spec . defineInRange ( " a.i " , 0 , - 20 , 20 ) ; spec . defineInRange ( " a.l " , 0 , - 20 , 20 ) ; spec . defineInRange ( " a.f " , 0.1f , - 0.2f , 0.2f ) ; spec . defineInRange ( " a.d " , 0.1 , - 0.1 , 0.2 ) ; spec . defineInList ( " a.s " , " default " , Arrays . asList ( " a " , " b " , " c " , " d " , " e " , " f " , " default " ) ) ; spec . defineList ( " a.list " , Arrays . asList ( " 1 " , " 2 " ) , element - > element instanceof String ) ; { Config config = new SimpleConfig ( ) ; config . setValue ( " a.i " , 256 ) ; config . setValue ( " a.l " , 1234567890 ) ; config . setValue ( " a.f " , 12 f ) ; config . setValue ( " a.d " , 123 d ) ; config . setValue ( " a.s " , " value " ) ; config . setValue ( " a.list " , Arrays . asList ( " hey " , null , false , 1 ) ) ; assert ! spec . isCorrect ( config ) ; System . out . println ( " Before correction:  " + configToString ( config ) ) ; spec . correct ( config ) ; System . out . println ( " After correction:  " + configToString ( config ) ) ; assert spec . isCorrect ( config ) : " Config was not corrected correctly! " ; } { Config config = new SimpleConfig ( ) ;
public void run ( ) { add ( items . get ( id ) , name ) ; }
public void removeAssociationWithTask ( DNSTask task ) ; public boolean revertState ( ) ; public boolean waitForAnnounced ( long timeout ) ; public boolean waitForCanceled ( long timeout ) ; }
private boolean partOfThis ( char c , int idx ) { if ( string ! = null & & idx < string . length ( ) & & string . charAt ( idx ) = = c ) return true ; return false ; }
private boolean isFiltered ( final String item ) { final String processedItem ; if ( item ! = null ) { processedItem = item . toLowerCase ( Locale . getDefault ( ) ) ; } else { processedItem = " " . toLowerCase ( Locale . getDefault ( ) ) ; } return processedItem . contains ( filter ) ; }
private static void inferToSym ( Sentence judgment1 , Sentence judgment2 , NAL nal ) { Statement s1 = ( Statement ) judgment1 . content ; Term t1 = s1 . getSubject ( ) ; Term t2 = s1 . getPredicate ( ) ; Term content ; if ( s1 instanceof Inheritance ) { content = Similarity . make ( t1 , t2 , nal . mem ( ) ) ; } else { content = Equivalence . make ( t1 , t2 , s1 . getTemporalOrder ( ) , nal . mem ( ) ) ; } TruthValue value1 = judgment1 . truth ; TruthValue value2 = judgment2 . truth ; TruthValue truth = TruthFunctions . intersection ( value1 , value2 ) ; BudgetValue budget = BudgetFunctions . forward ( truth , nal ) ; nal . doublePremiseTask ( content , truth , budget , false ) ; }
private static final void showComparison ( ) { System . out . println ( " Algorithm \ t \ t \ tRandom \ tSorted \ tReverse Sorted " ) ; if ( showBubble ) { int i = 0 ; System . out . println ( " Bubble sort \ t \ t \ t " + bubbleResults [ i + + ] + " \ t " + bubbleResults [ i + + ] + " \ t " + bubbleResults [ i + + ] ) ; } if ( showInsertion ) { int i = 0 ; System . out . println ( " Insertion sort \ t \ t \ t " + insertionResults [ i + + ] + " \ t " + insertionResults [ i + + ] + " \ t " + insertionResults [ i + + ] ) ; } if ( showMerge ) { int i = 0 ; System . out . println ( " Merger sort \ t \ t \ t " + mergeResults [ i + + ] + " \ t " + mergeResults [ i + + ] + " \ t " + mergeResults [ i + + ] ) ; } if ( showQuick ) { int i = 0 ; System . out . println ( " Quicksort with first as pviot: \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] ) ; System . out . println ( " Quicksort with middle as pviot: \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] ) ; System . out . println ( " Quicksort with random as pviot: \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] + " \ t " + quickResults [ i + + ] ) ; } if ( showHeap ) { int i = 0 ; System . out . println ( " Heap sort \ t \ t \ t " + heapResults [ i + + ] + " \ t " + heapResults [ i + + ] + " \ t " + heapResults [ i + + ] ) ; } if ( showCounting ) { int i = 0 ; System . out . println ( " Counting sort \ t \ t \ t " + countingResults [ i + + ] + " \ t " + countingResults [ i + + ] + " \ t " + countingResults [ i + + ] ) ; } if ( showRadix ) { int i = 0 ; System . out . println ( " Radix sort \ t \ t \ t " + radixResults [ i + + ] + " \ t " + radixResults [ i + + ] + " \ t " + radixResults [ i + + ] ) ; } if ( showBSTs ) { int i = 0 ;
abstract public int size ( ) ; abstract public E takeOut ( boolean removeFromNameTable ) ; abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } public void addBagObserver ( BagObserver < E > bagObserver , String title ) { this . bagObserver = bagObserver ; bagObserver . post ( toString ( ) ) ; bagObserver . setTitle ( title ) ; bagObserver . setBag ( this ) ; } protected int forgetRate ( ) { if ( forgettingRate ! = null ) { return forgettingRate . get ( ) ; } return - 1 ; } public void play ( ) { if ( bagObserver ! = null ) { bagObserver . post ( toString ( ) ) ; } } protected void reprocess ( E x ) { int r = forgetRate ( ) ; if ( r > 0 ) { BudgetFunctions . forget ( x . budget , forgetRate ( ) , RELATIVE_THRESHOLD ) ; } } public void stop ( ) { if ( bagObserver ! = null ) { bagObserver . stop ( ) ; } } public boolean putBack ( final E oldItem , boolean insertIntoNameTable ) { reprocess ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( ) { final E x = takeOut ( false ) ; if ( x ! = null ) { reprocess ( x ) ; boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else return null ; } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( CharSequence key ) ; }
public void pageChanged ( int position ) { if ( actionBar . getNavigationMode ( ) = = ActionBar . NAVIGATION_MODE_LIST ) actionBar . setSelectedNavigationItem ( position ) ;
static TruthValue intersection ( TruthValue v1 , TruthValue v2 ) { float f1 = v1 . getFrequency ( ) ; float f2 = v2 . getFrequency ( ) ; float c1 = v1 . getConfidence ( ) ; float c2 = v2 . getConfidence ( ) ; float f = and ( f1 , f2 ) ; float c = and ( c1 , c2 ) ; return new TruthValue ( f , c ) ; }
Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
protected void onCreate ( Bundle arg0 ) { if ( ! MPDApplication . isHoneycombOrBetter ( ) ) { setTheme ( android . R . style . Theme_Wallpaper_NoTitleBar ) ; } super . onCreate ( arg0 ) ; setContentView ( R . layout . main_activity ) ; }
public MimeBodyPart sign ( @Nonnull final MimeBodyPart aPart , @Nonnull final X509Certificate aX509Cert , @Nonnull final PrivateKey aPrivateKey , @Nonnull final ECryptoAlgorithm eAlgorithm ) throws GeneralSecurityException , SMIMEException , MessagingException , OperatorCreationException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( aX509Cert , " X509Cert " ) ; ValueEnforcer . notNull ( aPrivateKey , " PrivateKey " ) ; ValueEnforcer . notNull ( eAlgorithm , " Algorithm " ) ; ValueEnforcer . isTrue ( eAlgorithm . isDigesting ( ) , " The passed algorithm is not usable for signing " ) ; final List < X509Certificate > aCertList = new ArrayList < X509Certificate > ( ) ; aCertList . add ( aX509Cert ) ; final JcaCertStore aCertStore = new JcaCertStore ( aCertList ) ; final ASN1EncodableVector aSignedAttrs = new ASN1EncodableVector ( ) ; final SMIMECapabilityVector aCapabilities = new SMIMECapabilityVector ( ) ; aCapabilities . addCapability ( eAlgorithm . getOID ( ) ) ; aSignedAttrs . add ( new SMIMECapabilitiesAttribute ( aCapabilities ) ) ; final SMIMESignedGenerator aSGen = new SMIMESignedGenerator ( ) ; aSGen . addSignerInfoGenerator ( new JcaSimpleSignerInfoGeneratorBuilder ( ) . setProvider ( BouncyCastleProvider . PROVIDER_NAME ) . setSignedAttributeGenerator ( new AttributeTable ( aSignedAttrs ) ) . build ( " SHA1withRSA " , aPrivateKey , aX509Cert ) ) ; aSGen . addCertificates ( aCertStore ) ; final MimeMultipart aSignedData = aSGen . generate ( aPart ) ; final MimeBodyPart aTmpBody = new MimeBodyPart ( ) ; aTmpBody . setContent ( aSignedData ) ; aTmpBody . setHeader ( CAS2Header . HEADER_CONTENT_TYPE , aSignedData . getContentType ( ) ) ; return aTmpBody ; }
public boolean isConnected ( ) { return mpdIdleConnection ! = null & & mpdStatusConnection ! = null & & mpdConnection ! = null & & mpdIdleConnection . isConnected ( ) ; }
public void testGetBulkVarargWithTranscoder ( ) throws Exception { Transcoder < String > t = new TestTranscoder ( ) ; assertEquals ( 0 , client . getBulk ( t , " test1 " , " test2 " , " test3 " ) . size ( ) ) ; client . set ( " test1 " , 5 , " val1 " , t ) ; client . set ( " test2 " , 5 , " val2 " , t ) ; Map < String , String > vals = client . getBulk ( t , " test1 " , " test2 " , " test3 " ) ; assertEquals ( 2 , vals . size ( ) ) ; assertEquals ( " val1 " , vals . get ( " test1 " ) ) ; assertEquals ( " val2 " , vals . get ( " test2 " ) ) ; }
public boolean dispatchKeyEvent ( KeyEvent event ) { return false ; }
private boolean validateNode ( Node < T > node ) { int keySize = node . keys . size ( ) ; if ( keySize > 1 ) { for ( int i = 1 ; i < keySize ; i + + ) { T p = node . keys . get ( i - 1 ) ; T n = node . keys . get ( i ) ; if ( p . compareTo ( n ) > 0 ) return false ; } } int childrenSize = node . children . size ( ) ; if ( node . parent = = null ) { if ( keySize > this . maxKeySize ) { return false ; } else if ( childrenSize = = 0 ) { return true ; } else if ( childrenSize < 2 ) { return false ; } else if ( childrenSize > this . maxChildrenSize ) { return false ; } } else { if ( keySize < this . minKeySize ) { return false ; } else if ( keySize > this . maxKeySize ) { return false ; } else if ( childrenSize = = 0 ) { return true ; } else if ( keySize ! = ( childrenSize - 1 ) ) { return false ; } else if ( childrenSize < this . minChildrenSize ) { return false ; } else if ( childrenSize > this . maxChildrenSize ) { return false ; } } Node < T > first = node . children . get ( 0 ) ; if ( first . keys . get ( first . keys . size ( ) - 1 ) . compareTo ( node . keys . get ( 0 ) ) > 0 ) return false ; Node < T > last = node . children . get ( node . children . size ( ) - 1 ) ; if ( last . keys . get ( 0 ) . compareTo ( node . keys . get ( node . keys . size ( ) - 1 ) ) < 0 ) return false ; for ( int i = 1 ; i < node . keys . size ( ) ; i + + ) { T p = node . keys . get ( i - 1 ) ; T n = node . keys . get ( i ) ; Node < T > c = node . children . get ( i ) ; if ( p . compareTo ( c . keys . get ( 0 ) ) > 0 ) return false ; if ( n . compareTo ( c . keys . get ( c . keys . size ( ) - 1 ) ) < 0 ) return false ; } for ( Node < T > c : node . children ) { boolean valid = this . validateNode ( c ) ; if ( ! valid ) return false ; } return true ; }
protected void cycle ( ) { updateTasks ( ) ; if ( tasks . size ( ) = = 0 ) return ; if ( NAR . DEBUG ) { if ( tasks . get ( 0 ) . delayUntil = = - 1 ) { if ( tasks . size ( ) > 1 ) { System . out . println ( " Tasks @  " + memory . getTime ( ) ) ; for ( TaskExecution tcc : tasks ) System . out . println ( "    " + tcc . toString ( ) ) ; } else { System . out . println ( " Task @  " + memory . getTime ( ) + " :  " + tasks . get ( 0 ) ) ; } } } TaskExecution topConcept = tasks . getFirst ( ) ; Task top = topConcept . t ; Term term = top . getContent ( ) ; if ( term instanceof Operation ) { execute ( ( Operation ) term , top ) ;
public void receiveExpectedSchema ( StructType expectedSchema ) { if ( expectedSchema . equals ( SchemaUtils . binaryValueSchema ( ) ) ) { received = true ;
private boolean hasCurrentFlagField ( ) { return config . hasPath ( CURRENT_FLAG_FIELD_NAME_CONFIG_NAME ) ; }
protected static String makeCompoundName ( final NativeOperator op , final Term [ ] arg ) { final int sizeEstimate = 12 * arg . length ; final StringBuilder nameBuilder = new StringBuilder ( sizeEstimate ) . append ( COMPOUND_TERM_OPENER . ch ) . append ( op . toString ( ) ) ; for ( final Term t : arg ) { nameBuilder . append ( Symbols . ARGUMENT_SEPARATOR ) ; if ( t instanceof CompoundTerm ) { CompoundTerm ct = ( CompoundTerm ) t ; if ( ! ct . containVar ( ) & & allowNonDeepCopy ) { } else { t . setName ( ct . makeName ( ) ) ; } } nameBuilder . append ( t . getName ( ) ) ; } nameBuilder . append ( COMPOUND_TERM_CLOSER . ch ) ; return nameBuilder . toString ( ) ; }
public AS2ClientResponse sendSynchronous ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2ClientRequest aRequest ) { ValueEnforcer . notNull ( aSettings , " ClientSettings " ) ; ValueEnforcer . notNull ( aRequest , " ClientRequest " ) ; final AS2ClientResponse aResponse = createResponse ( ) ; IMessage aMsg = null ; final StopWatch aSW = StopWatch . createdStarted ( ) ; try { final Partnership aPartnership = buildPartnership ( aSettings ) ; aMsg = createMessage ( aPartnership , aRequest ) ; aResponse . setOriginalMessageID ( aMsg . getMessageID ( ) ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " MessageID to send:  " + aMsg . getMessageID ( ) ) ; final boolean bHasRetries = aSettings . getRetryCount ( ) > 0 ; final AS2Session aSession = createSession ( ) ; initCertificateFactory ( aSettings , aSession ) ; initPartnershipFactory ( aSession ) ; initMessageProcessor ( aSession ) ; if ( bHasRetries ) { final IProcessorResenderModule aResender = new ImmediateResenderModule ( ) ; aResender . initDynamicComponent ( aSession , null ) ; aSession . getMessageProcessor ( ) . addModule ( aResender ) ; } aSession . getMessageProcessor ( ) . startActiveModules ( ) ; try { beforeSend ( aSettings , aSession , aMsg ) ; final ICommonsMap < String , Object > aHandleOptions = new CommonsHashMap < > ( ) ; if ( bHasRetries ) aHandleOptions . put ( IProcessorResenderModule . OPTION_RETRIES , Integer . toString ( aSettings . getRetryCount ( ) ) ) ; aPartnership . setContentTransferEncodingSend ( aRequest . getContentTransferEncoding ( ) ) ; aPartnership . setContentTransferEncodingReceive ( aRequest . getContentTransferEncoding ( ) ) ; final AS2SenderModule aSender = m_aAS2SenderModuleFactory . get ( ) ; aSender . initDynamicComponent ( aSession , null ) ; aSender . attrs ( ) . putIn ( AbstractHttpSenderModule . ATTR_CONNECT_TIMEOUT , aSettings . getConnectTimeoutMS ( ) ) ; aSender . attrs ( ) . putIn ( AbstractHttpSenderModule . ATTR_READ_TIMEOUT , aSettings . getReadTimeoutMS ( ) ) ; aSender . setHttpOutgoingDumperFactory ( aSettings . getHttpOutgoingDumperFactory ( ) ) ; aMsg . headers ( ) . setAllHeaders ( aSettings . customHeaders ( ) ) ; aSession . getMessageProcessor ( ) . addModule ( aSender ) ; aSender . handle ( IProcessorSenderModule . DO_SEND , aMsg , aHandleOptions ) ; } finally { aSession . getMessageProcessor ( ) . stopActiveModules ( ) ; } } catch ( final Exception ex ) { LOGGER . error ( " Error sending AS2 message " , ex ) ; aResponse . setException ( ex ) ; } finally { if ( aMsg ! = null & & aMsg . getMDN ( ) ! = null ) { aResponse . setMDN ( aMsg . getMDN ( ) ) ; final String sReceivedCert = aMsg . attrs ( ) . getAsString ( AS2Message . ATTRIBUTE_RECEIVED_SIGNATURE_CERTIFICATE ) ; if ( sReceivedCert ! = null ) { final X509Certificate aReceivedCert = CertificateHelper . convertStringToCertficateOrNull ( sReceivedCert ) ; aResponse . setMDNVerificationCertificate ( aReceivedCert ) ; } } } if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Response retrieved:  " + aResponse . getAsString ( ) ) ; aResponse . setExecutionDuration ( aSW . stopAndGetDuration ( ) ) ; return aResponse ; }
public AbstractBag < E > newBag ( ) ; } public static double compare ( String label , BagBuilder b , final int iterations , final int randomAccesses , final float insertRatio , int repeats , int warmups ) { Performance p = new Performance ( label , repeats , warmups ) { @Override public void init ( ) { } @Override public void run ( boolean warmup ) { AbstractBag bag = b . newBag ( ) ; randomBagIO ( bag , randomAccesses , insertRatio ) ; for ( int i = 0 ; i < iterations ; i + + ) iterate ( bag ) ; if ( ! warmup ) { } } } ; return p . getCycleTimeMS ( ) ; } public BagPerf ( ) { for ( int capacity = 8 ; capacity < 40000 ; capacity * = capacity ) { randomAccesses = capacity * 64 ; for ( int i = 5 ; i < 200 ; i + = 5 ) { testBag ( false , i , capacity , forgetRate ) ; testBag ( true , i , capacity , forgetRate ) ; } } } public static void main ( String [ ] args ) { int capacityPerLevel = 10 ; int repeats = 4 ; int warmups = 1 ; double totalDiff = 0 ; final int iterations = 10 ; for ( float insertRatio = 0.1f ; insertRatio < = 1.0f ; insertRatio + = 0.1f ) { for ( int levels = 10 ; levels < = 150 ; levels + = 20 ) { int randomAccesses = 512 * levels ; final int capacity = levels * capacityPerLevel ; final int _levels = levels ; double a = 0 , b = 0 ; a = compare ( " ArrayDeque " , new BagBuilder ( ) { @Override public AbstractBag newBag ( ) { return new DefaultBag < Item > ( _levels , capacity , forgetRate ) { @Override protected Deque < Item > newLevel ( ) { return new ArrayDeque < > ( 1 + capacity / _levels ) ; } } ; } } , iterations , randomAccesses , insertRatio , repeats , warmups ) ; b = compare ( " LinkedList " , new BagBuilder ( ) { @Override public AbstractBag newBag ( ) { return new DefaultBag < Item > ( _levels , capacity , forgetRate ) { @Override protected Deque < Item > newLevel ( ) { return new LinkedList < > ( ) ; } } ; } } , iterations , randomAccesses , insertRatio , repeats , warmups ) ; System . out . print ( insertRatio + " ,  " + levels + " ,  " + capacity + " ,  " ) ; System . out . println ( ( a - b ) / ( ( a + b ) / 2.0 ) ) ; totalDiff + = ( a - b ) ; } } if ( totalDiff > 0 ) System . out . print ( " B faster:  " ) ; else System . out . print ( " A faster:  " ) ; System . out . println ( " total difference (ms):  " + totalDiff ) ; } }
public int compare ( Music o1 , Music o2 ) { return String . CASE_INSENSITIVE_ORDER . compare ( o1 . getTitle ( ) , o2 . getTitle ( ) ) ; }
private List < String > innerSyncedWriteRead ( MPDCommand command ) throws MPDServerException { ArrayList < String > result = new ArrayList < String > ( ) ; if ( ! isConnected ( ) ) throw new MPDConnectionException ( " No connection to server " ) ; try { writeToServer ( command . toString ( ) ) ; } catch ( IOException e1 ) { throw new MPDConnectionException ( e1 ) ; } try { result = readFromServer ( ) ;
public final boolean isCaretBlinkEnabled ( ) { return caretBlinks ; }
public Step copy ( ) { Step copy = new TaskStep ( name , config ) ; copy . setSubmitted ( hasSubmitted ( ) ) ; return copy ; }
public static int [ ] toIntArray ( List < Integer > list ) { int [ ] ret = new int [ list . size ( ) ] ; int i = 0 ; for ( Integer e : list ) ret [ i + + ] = e . intValue ( ) ; return ret ; }
public static Term text ( final String t ) { return Term . get ( Texts . escape ( '"' + t + '"' ) . toString ( ) ) ; }
void selectionChanged ( ) { if ( mOnItemSelectedListener ! = null ) { if ( mInLayout | | mBlockLayoutRequests ) { if ( mSelectionNotifier = = null ) { mSelectionNotifier = new SelectionNotifier ( ) ; } post ( mSelectionNotifier ) ; } else { fireOnSelected ( ) ; } } if ( mSelectedPosition ! = ListView . INVALID_POSITION & & isShown ( ) & & ! isInTouchMode ( ) ) { sendAccessibilityEvent ( AccessibilityEvent . TYPE_VIEW_SELECTED ) ;
private int measureContentWidth ( ListAdapter adapter ) { int width = 0 ; View itemView = null ; int itemType = 0 ; final int widthMeasureSpec = MeasureSpec . makeMeasureSpec ( 0 , MeasureSpec . UNSPECIFIED ) ; final int heightMeasureSpec = MeasureSpec . makeMeasureSpec ( 0 , MeasureSpec . UNSPECIFIED ) ; final int count = adapter . getCount ( ) ; for ( int i = 0 ; i < count ; i + + ) { final int positionType = adapter . getItemViewType ( i ) ; if ( positionType ! = itemType ) { itemType = positionType ; itemView = null ; } if ( mMeasureParent = = null ) { mMeasureParent = new FrameLayout ( mContext ) ; } itemView = adapter . getView ( i , itemView , mMeasureParent ) ; itemView . measure ( widthMeasureSpec , heightMeasureSpec ) ; width = Math . max ( width , itemView . getMeasuredWidth ( ) ) ; } return width ; }
public static Map < Bag , Double > compare ( final int iterations , final int randomAccesses , final float insertRatio , final int repeats , final int warmups , final Bag . . . B ) { final Map < Bag , Double > t = new LinkedHashMap ( ) ; for ( final Bag X : B ) { X . clear ( ) ; t . put ( X , getTime ( X . toString ( ) , ( ) - > X , iterations , randomAccesses , insertRatio , repeats , warmups ) ) ; } return t ;
public boolean isEmpty ( ) { synchronized ( rootMonitor ) { return config . isEmpty ( ) ;
public V remove ( K key ) { int hashedKey = hashingFunction ( key ) ; List < Pair < K , V > > list = array [ hashedKey ] ; for ( Pair < K , V > pair : list ) { if ( pair . key . equals ( key ) ) { list . remove ( pair ) ; size - - ; V value = pair . value ; pair . key = null ; pair . value = null ; return value ; } } return null ; }
public void initialize ( MenuItemImpl itemData , int menuType ) { mItemData = itemData ; setVisibility ( itemData . isVisible ( ) ? View . VISIBLE : View . GONE ) ; setTitle ( itemData . getTitleForItemView ( this ) ) ; setCheckable ( itemData . isCheckable ( ) ) ; setShortcut ( itemData . shouldShowShortcut ( ) , itemData . getShortcut ( ) ) ; setIcon ( itemData . getIcon ( ) ) ; setEnabled ( itemData . isEnabled ( ) ) ; }
static CNfa newCNfa ( CSpec spec ) { CNfa p ; p = new CNfa ( ) ; spec . m_nfa_states . addElement ( p ) ; p . m_edge = CNfa . EPSILON ; return p ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " list= " ) . append ( list ) ; return builder . toString ( ) ; }
public void send ( InputStream toSend ) throws IOException { aRequestBuilder . setEntity ( new InputStreamEntity ( toSend ) ) ; HttpUriRequest aHttpUriRequest = aRequestBuilder . build ( ) ; aCloseableHttpResponse = aCloseableHttpClient . execute ( aHttpUriRequest ) ;
public void doublePremiseTaskRevised ( Term newContent , TruthValue newTruth , BudgetValue newBudget ) { if ( newContent ! = null ) { Sentence newSentence = new Sentence ( newContent , getCurrentTask ( ) . sentence . punctuation , newTruth , getNewStamp ( ) ) ;
public static void main ( String [ ] args ) { NAR nar = new NAR ( new Default ( ) ) ; new NARSwing ( nar ) ; NlpGui g = new NlpGui ( nar ) ; }
public void processConcepts ( int c , Collection < Runnable > run ) { if ( c = = 0 ) return ; for ( int i = 0 ; i < c ; i + + ) { FireConcept f = next ( ) ;
public void cycle ( ) { updateTasks ( ) ; if ( tasks . size ( ) = = 0 ) return ; if ( NAR . DEBUG ) { if ( tasks . get ( 0 ) . delayUntil = = - 1 ) { if ( tasks . size ( ) > 1 ) { System . out . println ( " Tasks @  " + memory . getTime ( ) ) ; for ( TaskExecution tcc : tasks ) System . out . println ( "    " + tcc . toString ( ) ) ; } else { System . out . println ( " Task @  " + memory . getTime ( ) + " :  " + tasks . get ( 0 ) ) ; } } } TaskExecution topConcept = tasks . getFirst ( ) ; Task top = topConcept . t ; Term term = top . getContent ( ) ; if ( term instanceof Operation ) { execute ( ( Operation ) term , top ) ;
public String toString ( ) { return super . toString ( ) + "  Key:  " + key ; }
public AbstractBag < Concept > newConceptBag ( Param p ) { return new ContinuousBag < > ( getConceptBagSize ( ) , p . conceptForgetDurations , randomRemoval ) ; }
private void updateDrawableBounds ( int w , int h ) { int right = w - getPaddingRight ( ) - getPaddingLeft ( ) ; int bottom = h - getPaddingBottom ( ) - getPaddingTop ( ) ; int top = 0 ; int left = 0 ; if ( mIndeterminateDrawable ! = null ) { if ( mOnlyIndeterminate & & ! ( mIndeterminateDrawable instanceof AnimationDrawable ) ) { final int intrinsicWidth = mIndeterminateDrawable . getIntrinsicWidth ( ) ; final int intrinsicHeight = mIndeterminateDrawable . getIntrinsicHeight ( ) ; final float intrinsicAspect = ( float ) intrinsicWidth / intrinsicHeight ; final float boundAspect = ( float ) w / h ; if ( intrinsicAspect ! = boundAspect ) { if ( boundAspect > intrinsicAspect ) { final int width = ( int ) ( h * intrinsicAspect ) ; left = ( w - width ) / 2 ; right = left + width ; } else { final int height = ( int ) ( w * ( 1 / intrinsicAspect ) ) ; top = ( h - height ) / 2 ; bottom = top + height ; } } } mIndeterminateDrawable . setBounds ( 0 , 0 , right - left , bottom - top ) ; mIndeterminateRealLeft = left ; mIndeterminateRealTop = top ; } if ( mProgressDrawable ! = null ) { mProgressDrawable . setBounds ( 0 , 0 , right , bottom ) ;
public void addValue ( int index , double value ) { if ( Double . isNaN ( value ) ) { if ( debug ) System . out . println ( " NaN for  " + names [ index ] ) ; corrupted [ index ] = true ; } if ( value < 0 ) { if ( debug ) System . out . println ( " Negative value for  " + names [ index ] ) ; } values [ index ] . add ( value ) ; sumValues [ index ] + = value ; if ( value < minValue [ index ] ) minValue [ index ] = value ; if ( value > maxValue [ index ] ) maxValue [ index ] = value ; }
public void testDefaultDynamicPivot ( ) throws Exception { List < Row > sourceList = Lists . newArrayList ( RowFactory . create ( " A " , " hello " , 1 ) , RowFactory . create ( " A " , " world " , 2 ) , RowFactory . create ( " B " , " hello " , 3 ) , RowFactory . create ( " C " , " world " , 4 ) ) ; StructType schema = RowUtils . structTypeFor ( Lists . newArrayList ( " entity_id " , " key " , " value " ) , Lists . newArrayList ( " string " , " string " , " int " ) ) ; Dataset < Row > source = Contexts . getSparkSession ( ) . createDataFrame ( sourceList , schema ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " source " , source ) ; Config config = ConfigFactory . empty ( ) . withValue ( PivotDeriver . STEP_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " source " ) ) . withValue ( PivotDeriver . ENTITY_KEY_FIELD_NAMES_CONFIG , ConfigValueFactory . fromAnyRef ( Lists . newArrayList ( " entity_id " ) ) ) . withValue ( PivotDeriver . PIVOT_KEY_FIELD_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " key " ) ) . withValue ( PivotDeriver . PIVOT_VALUE_FIELD_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " value " ) ) ; Deriver d = new PivotDeriver ( ) ; d . configure ( config ) ; List < Row > results = d . derive ( dependencies ) . collectAsList ( ) ; assertEquals ( results . size ( ) , 3 ) ; assertTrue ( results . contains ( RowFactory . create ( " A " , 1 , 2 ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " B " , 3 , null ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " C " , null , 4 ) ) ) ; }
private static boolean testQuadTree ( ) { System . out . println ( " QuadTree. " ) ; int size = 16000 ; java . util . Set < QuadTree . XYPoint > set = new java . util . HashSet < QuadTree . XYPoint > ( size ) ; while ( set . size ( ) < size ) { float x = RANDOM . nextInt ( size ) ; float y = RANDOM . nextInt ( size ) ; QuadTree . XYPoint xyPoint = new QuadTree . XYPoint ( x , y ) ; set . add ( xyPoint ) ; } java . util . List < QuadTree . XYPoint > query = new java . util . ArrayList < QuadTree . XYPoint > ( size ) ; for ( int j = 0 ; j < size ; j + + ) { float x = RANDOM . nextInt ( size ) ; float y = RANDOM . nextInt ( size ) ; QuadTree . XYPoint xyPoint = new QuadTree . XYPoint ( x , y ) ; query . add ( xyPoint ) ; } long beforeInsert ; long beforeQuery ; long beforeMemory ; long beforeTreeQuery ; long beforeRemove ; long afterInsert ; long afterQuery ; long afterMemory ; long afterTreeQuery ; long afterRemove ; long insertTime ; long queryTime ; long removeTime ; long treeMemory ; long treeQuery ; { QuadTree . PointRegionQuadTree < QuadTree . XYPoint > tree = new QuadTree . PointRegionQuadTree < QuadTree . XYPoint > ( 0 , 0 , size , size ) ; beforeMemory = DataStructures . getMemoryUse ( ) ; { beforeInsert = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : set ) tree . insert ( p . getX ( ) , p . getY ( ) ) ; afterInsert = System . nanoTime ( ) ; insertTime = afterInsert - beforeInsert ; if ( debug > 1 ) System . out . println ( " PointRegionQuadTree insertTime= " + insertTime / 100000 d + "  ms " ) ; } afterMemory = DataStructures . getMemoryUse ( ) ; treeMemory = afterMemory - beforeMemory ; if ( debug > 1 ) System . out . println ( " PointRegionQuadTree treeMemory= " + treeMemory ) ; if ( debug > 1 ) System . out . println ( tree ) ; for ( QuadTree . XYPoint p : set ) { java . util . List < QuadTree . XYPoint > result = tree . queryRange ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; if ( result . size ( ) < = 0 ) { System . err . println ( " Quad tree queryRange error. result= " + result ) ; return false ; } } { beforeQuery = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : query ) tree . queryRange ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; afterQuery = System . nanoTime ( ) ; queryTime = afterQuery - beforeQuery ; if ( debug > 1 ) System . out . println ( " PointRegionQuadTree queryTime= " + queryTime / 100000 d + "  ms " ) ; } beforeTreeQuery = System . nanoTime ( ) ; java . util . List < QuadTree . XYPoint > result = tree . queryRange ( 0 , 0 , size , size ) ; afterTreeQuery = System . nanoTime ( ) ; treeQuery = afterTreeQuery - beforeTreeQuery ; if ( debug > 1 ) System . out . println ( " PointRegionQuadTree wholeTreeQuery= " + treeQuery / 100000 d + "  ms " ) ; Collections . sort ( result ) ; QuadTree . XYPoint prev = null ; for ( QuadTree . XYPoint p : result ) { if ( prev ! = null & & prev . equals ( p ) ) { System . err . println ( " Quad tree compare error. p= " + p + "  prev= " + prev + "  result= " + result ) ; return false ; } prev = p ; } { beforeRemove = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : set ) { boolean removed = tree . remove ( p . getX ( ) , p . getY ( ) ) ; if ( ! removed ) { System . err . println ( " Quad tree remove error. removed= " + removed + "  x= " + p . getX ( ) + "  y= " + p . getY ( ) ) ; return false ; } } afterRemove = System . nanoTime ( ) ; removeTime = afterRemove - beforeRemove ; if ( debug > 1 ) System . out . println ( " PointRegionQuadTree removeTime= " + removeTime / 100000 d + "  ms " ) ; } } { QuadTree . MxCifQuadTree < QuadTree . AxisAlignedBoundingBox > tree = new QuadTree . MxCifQuadTree < QuadTree . AxisAlignedBoundingBox > ( 0 , 0 , size , size , 10 , 10 ) ; beforeMemory = DataStructures . getMemoryUse ( ) ; { beforeInsert = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : set ) tree . insert ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; afterInsert = System . nanoTime ( ) ; insertTime = afterInsert - beforeInsert ; if ( debug > 1 ) System . out . println ( " MxCifQuadTree insertTime= " + insertTime / 100000 d + "  ms " ) ; } afterMemory = DataStructures . getMemoryUse ( ) ; treeMemory = afterMemory - beforeMemory ; if ( debug > 1 ) System . out . println ( " MxCifQuadTree treeMemory= " + treeMemory ) ; if ( debug > 1 ) System . out . println ( tree ) ; for ( QuadTree . XYPoint p : set ) { java . util . List < QuadTree . AxisAlignedBoundingBox > result = tree . queryRange ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; if ( result . size ( ) < = 0 ) { System . err . println ( " Quad tree queryRange error. result= " + result ) ; return false ; } } { beforeQuery = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : query ) tree . queryRange ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; afterQuery = System . nanoTime ( ) ; queryTime = afterQuery - beforeQuery ; if ( debug > 1 ) System . out . println ( " MxCifQuadTree queryTime= " + queryTime / 100000 d + "  ms " ) ; } beforeTreeQuery = System . nanoTime ( ) ; java . util . List < QuadTree . AxisAlignedBoundingBox > result = tree . queryRange ( 0 , 0 , size , size ) ; afterTreeQuery = System . nanoTime ( ) ; treeQuery = afterTreeQuery - beforeTreeQuery ; if ( debug > 1 ) System . out . println ( " MxCifQuadTree wholeTreeQuery= " + treeQuery / 100000 d + "  ms " ) ; Collections . sort ( result ) ; QuadTree . AxisAlignedBoundingBox prev = null ; for ( QuadTree . AxisAlignedBoundingBox p : result ) { if ( prev ! = null & & prev . equals ( p ) ) { System . err . println ( " Quad tree compare error. p= " + p + "  prev= " + prev + "  result= " + result ) ; return false ; } prev = p ; } { beforeRemove = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : set ) { boolean removed = tree . remove ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; if ( ! removed ) { System . err . println ( " Quad tree remove error. removed= " + removed + "  x= " + p . getX ( ) + "  y= " + p . getY ( ) ) ; return false ; } } afterRemove = System . nanoTime ( ) ; removeTime = afterRemove - beforeRemove ; if ( debug > 1 ) System . out . println ( " MxCifQuadTree removeTime= " + removeTime / 100000 d + "  ms " ) ; } } System . out . println ( " QuadTree worked correctly. " ) ; return true ; }
private void addToSubtree ( Node < T > subtreeRoot , Node < T > node ) { addAsBinarySearchTree ( subtreeRoot , node ) ; heapify ( node ) ; }
public String toString ( ) { return TreePrinter . getString ( this ) ; }
private boolean balanceAfterDelete ( RedBlackNode < T > node ) { if ( node . parent = = null ) { return true ; } RedBlackNode < T > parent = ( RedBlackNode < T > ) node . parent ; RedBlackNode < T > sibling = node . getSibling ( ) ; if ( sibling . color = = RED ) { parent . color = RED ; sibling . color = BLACK ; if ( node . equals ( parent . lesser ) ) { rotateLeft ( parent ) ; parent = ( RedBlackNode < T > ) node . parent ; sibling = node . getSibling ( ) ; } else if ( node . equals ( parent . greater ) ) { rotateRight ( parent ) ; parent = ( RedBlackNode < T > ) node . parent ; sibling = node . getSibling ( ) ; } else { System . err . println ( " Yikes! I'm not related to my parent. " ) ; return false ; } } if ( parent . color = = BLACK & & sibling . color = = BLACK & & ( ( RedBlackNode < T > ) sibling . lesser ) . color = = BLACK & & ( ( RedBlackNode < T > ) sibling . greater ) . color = = BLACK ) { sibling . color = RED ; boolean result = balanceAfterDelete ( parent ) ; if ( ! result ) return false ; } else if ( parent . color = = RED & & sibling . color = = BLACK & & ( ( RedBlackNode < T > ) sibling . lesser ) . color = = BLACK & & ( ( RedBlackNode < T > ) sibling . greater ) . color = = BLACK ) { sibling . color = RED ; parent . color = BLACK ; } else { if ( sibling . color = = BLACK ) { if ( node . equals ( parent . lesser ) & & ( ( RedBlackNode < T > ) sibling . lesser ) . color = = RED & & ( ( RedBlackNode < T > ) sibling . greater ) . color = = BLACK ) { sibling . color = RED ; ( ( RedBlackNode < T > ) sibling . lesser ) . color = RED ; rotateRight ( sibling ) ; parent = ( RedBlackNode < T > ) node . parent ; sibling = node . getSibling ( ) ; } else if ( node . equals ( parent . greater ) & & ( ( RedBlackNode < T > ) sibling . lesser ) . color = = BLACK & & ( ( RedBlackNode < T > ) sibling . greater ) . color = = RED ) { sibling . color = RED ; ( ( RedBlackNode < T > ) sibling . greater ) . color = RED ; rotateLeft ( sibling ) ; parent = ( RedBlackNode < T > ) node . parent ; sibling = node . getSibling ( ) ; } } sibling . color = parent . color ; parent . color = BLACK ; if ( node . equals ( parent . lesser ) ) { ( ( RedBlackNode < T > ) sibling . greater ) . color = BLACK ; rotateLeft ( node . parent ) ; } else if ( node . equals ( parent . greater ) ) { ( ( RedBlackNode < T > ) sibling . lesser ) . color = BLACK ; rotateRight ( node . parent ) ; } else { System . err . println ( " Yikes! I'm not related to my parent.  " + node . toString ( ) ) ; return false ; } } return true ; }
public void removeFromPlaylist ( String playlistName , Integer pos ) throws MPDServerException { getMpdConnection ( ) . sendCommand ( MPDCommand . MPD_CMD_PLAYLIST_DEL , playlistName , Integer . toString ( pos ) ) ; }
public void disableOutput ( int id ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; mpdConnection . sendCommand ( MPD_CMD_OUTPUTDISABLE , Integer . toString ( id ) ) ; }
Iterator < MemcachedNode > getSequence ( String k ) ; Collection < MemcachedNode > getAll ( ) ; NodeLocator getReadonlyCopy ( ) ; }
public < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tc_iter ) { final Map < String , Future < T > > m = new ConcurrentHashMap < String , Future < T > > ( ) ; final Map < String , Transcoder < T > > tc_map = new HashMap < String , Transcoder < T > > ( ) ; final Map < MemcachedNode , Collection < String > > chunks = new HashMap < MemcachedNode , Collection < String > > ( ) ; final NodeLocator locator = conn . getLocator ( ) ; Iterator < String > key_iter = keys . iterator ( ) ; while ( key_iter . hasNext ( ) & & tc_iter . hasNext ( ) ) { String key = key_iter . next ( ) ; tc_map . put ( key , tc_iter . next ( ) ) ; validateKey ( key ) ; final MemcachedNode primaryNode = locator . getPrimary ( key ) ; MemcachedNode node = null ; if ( primaryNode . isActive ( ) ) { node = primaryNode ; } else { for ( Iterator < MemcachedNode > i = locator . getSequence ( key ) ; node = = null & & i . hasNext ( ) ; ) { MemcachedNode n = i . next ( ) ; if ( n . isActive ( ) ) { node = n ; } } if ( node = = null ) { node = primaryNode ; } } assert node ! = null : " Didn't find a node for  " + key ; Collection < String > ks = chunks . get ( node ) ; if ( ks = = null ) { ks = new ArrayList < String > ( ) ; chunks . put ( node , ks ) ; } ks . add ( key ) ; } final CountDownLatch latch = new CountDownLatch ( chunks . size ( ) ) ; final Collection < Operation > ops = new ArrayList < Operation > ( ) ; GetOperation . Callback cb = new GetOperation . Callback ( ) { @SuppressWarnings ( " synthetic-access " ) public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful get:  %s " , status ) ; } } public void gotData ( String k , int flags , byte [ ] data ) { Transcoder < T > tc = tc_map . get ( k ) ; m . put ( k , tcService . decode ( tc , new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; final Map < MemcachedNode , Operation > mops = new HashMap < MemcachedNode , Operation > ( ) ; for ( Map . Entry < MemcachedNode , Collection < String > > me : chunks . entrySet ( ) ) { Operation op = opFact . get ( me . getValue ( ) , cb ) ; mops . put ( me . getKey ( ) , op ) ; ops . add ( op ) ; } assert mops . size ( ) = = chunks . size ( ) ; checkState ( ) ; conn . addOperations ( mops ) ; return new BulkGetFuture < T > ( m , ops , latch ) ; }
public void testSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 2 , 1 , 2 ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . nextNode ; } return builder . toString ( ) ; }
protected void init ( final Term [ ] components ) { super . init ( components ) ; this . hash = Objects . hash ( super . hashCode ( ) , relationIndex ) ; }
public void onClose ( WebSocket conn , int code , String reason , boolean remote ) { this . sendToAll ( conn + "  has left the room! " ) ; System . out . println ( conn + "  has left the room! " ) ; }
public boolean equals ( final Object that ) { if ( that instanceof Sentence ) { final Sentence t = ( Sentence ) that ; return getKey ( ) . equals ( t . getKey ( ) ) ; } return false ; }
public int compare ( Music o1 , Music o2 ) { return String . CASE_INSENSITIVE_ORDER . compare ( o1 . getTitle ( ) , o2 . getTitle ( ) ) ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; app = ( MPDApplication ) getApplication ( ) ; setContentView ( R . layout . browse ) ; loadingView = findViewById ( R . id . loadingLayout ) ; loadingTextView = ( TextView ) findViewById ( R . id . loadingText ) ; noResultView = findViewById ( R . id . noResultLayout ) ; loadingView . setVisibility ( View . VISIBLE ) ; loadingTextView . setText ( R . string . loading ) ; final Intent queryIntent = getIntent ( ) ; final String queryAction = queryIntent . getAction ( ) ; if ( Intent . ACTION_SEARCH . equals ( queryAction ) ) { searchKeywords = queryIntent . getStringExtra ( SearchManager . QUERY ) . trim ( ) ; } else { return ; } setTitle ( getTitle ( ) + "  :  " + searchKeywords ) ; registerForContextMenu ( getListView ( ) ) ; updateList ( ) ; }
public static Partitioner create ( Config config , JavaPairRDD < Row , Row > rdd ) { String partitionerType = config . getString ( TYPE_CONFIG_NAME ) ; if ( ! config . hasPath ( TYPE_CONFIG_NAME ) ) { throw new RuntimeException ( " Partitioner type not specified " ) ; } String partitionerClass = null ; Partitioner partitioner = null ; switch ( partitionerType ) { case " hash " : partitioner = new HashPartitioner ( rdd . getNumPartitions ( ) ) ; break ; case " range " : Ordering < Row > rowOrdering = Ordering$ . MODULE$ . < Row > comparatorToOrdering ( new RowComparator ( ) ) ; ClassTag < Row > rowClassTag = ClassTag$ . MODULE$ . < Row > apply ( Row . class ) ; partitioner = new RangePartitioner < Row , Row > ( rdd . getNumPartitions ( ) , rdd . rdd ( ) , true , rowOrdering , rowClassTag ) ; break ; case " uuid " : partitionerClass = " com.cloudera.labs.envelope.partition.UUIDPartitioner " ; break ; default : partitionerClass = partitionerType ; } if ( partitioner = = null ) { try { Class < ? > clazz = Class . forName ( partitionerClass ) ; Constructor < ? > constructor = clazz . getConstructor ( ) ; partitioner = ( Partitioner ) constructor . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } if ( partitioner instanceof ConfigurablePartitioner ) { ( ( ConfigurablePartitioner ) partitioner ) . configure ( config , rdd ) ; } return partitioner ; }
public void testEqualsToStruct ( ) { Struct s = new Struct ( ) ; Int zero = new Int ( 0 ) ; assertFalse ( zero . equals ( s ) ) ; }
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; app = ( MPDApplication ) getApplication ( ) ; setContentView ( R . layout . playlist_activity ) ; this . setTitle ( R . string . nowPlaying ) ; ListView list = getListView ( ) ; registerForContextMenu ( list ) ; try { Activity activity = this ;
int getVbucketsCount ( ) ; int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; int getVbucketByKey ( String key ) ; int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }
protected void loseFocus ( GAbstractControl grabber ) { if ( cursorIsOver = = this ) cursorIsOver = null ; focusIsWith = grabber ; }
private void populateDefaultSettings ( ) { addSetting ( new TestbedSetting ( Hz , SettingType . ENGINE , 60 , 1 , 400 ) ) ; addSetting ( new TestbedSetting ( PositionIterations , SettingType . ENGINE , 3 , 0 , 100 ) ) ; addSetting ( new TestbedSetting ( VelocityIterations , SettingType . ENGINE , 8 , 1 , 100 ) ) ; addSetting ( new TestbedSetting ( AllowSleep , SettingType . ENGINE , true ) ) ; addSetting ( new TestbedSetting ( WarmStarting , SettingType . ENGINE , true ) ) ; addSetting ( new TestbedSetting ( ContinuousCollision , SettingType . ENGINE , true ) ) ; addSetting ( new TestbedSetting ( SubStepping , SettingType . ENGINE , false ) ) ; addSetting ( new TestbedSetting ( DrawShapes , SettingType . DRAWING , true ) ) ; addSetting ( new TestbedSetting ( DrawJoints , SettingType . DRAWING , true ) ) ; addSetting ( new TestbedSetting ( DrawAABBs , SettingType . DRAWING , false ) ) ; addSetting ( new TestbedSetting ( DrawContactPoints , SettingType . DRAWING , false ) ) ; addSetting ( new TestbedSetting ( DrawContactNormals , SettingType . DRAWING , false ) ) ; addSetting ( new TestbedSetting ( DrawContactImpulses , SettingType . DRAWING , false ) ) ; addSetting ( new TestbedSetting ( DrawFrictionImpulses , SettingType . DRAWING , false ) ) ; addSetting ( new TestbedSetting ( DrawCOMs , SettingType . DRAWING , false ) ) ; addSetting ( new TestbedSetting ( DrawStats , SettingType . DRAWING , false ) ) ; addSetting ( new TestbedSetting ( DrawHelp , SettingType . DRAWING , false ) ) ; addSetting ( new TestbedSetting ( DrawTree , SettingType . DRAWING , false ) ) ; addSetting ( new TestbedSetting ( DrawWireframe , SettingType . DRAWING , true ) ) ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; final Intent queryIntent = getIntent ( ) ; final String queryAction = queryIntent . getAction ( ) ; if ( Intent . ACTION_SEARCH . equals ( queryAction ) ) { searchKeywords = queryIntent . getStringExtra ( SearchManager . QUERY ) ; } else { return ; } setContentView ( R . layout . artists ) ; setTitle ( getTitle ( ) + "  :  " + searchKeywords ) ; pd = ProgressDialog . show ( SearchSongActivity . this , getResources ( ) . getString ( R . string . loading ) , getResources ( ) . getString ( R . string . loading ) ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; final String finalSearch = searchKeywords ; app . oMPDAsyncHelper . addAsyncExecListener ( this ) ; iJobID = app . oMPDAsyncHelper . execAsync ( new Runnable ( ) { @Override public void run ( ) { try { MPDApplication app = ( MPDApplication ) getApplication ( ) ; arrayMusic = new ArrayList < Music > ( app . oMPDAsyncHelper . oMPD . search ( " any " , finalSearch ) ) ; } catch ( MPDServerException e ) { } } } ) ; registerForContextMenu ( getListView ( ) ) ; }
public void testAllStepsFinished ( ) { Set < Step > steps = Sets . newHashSet ( ) ; BatchStep step1 = new BatchStep ( " step1 " ) ; BatchStep step2 = new BatchStep ( " step2 " ) ; step1 . configure ( ConfigFactory . empty ( ) ) ; step2 . configure ( ConfigFactory . empty ( ) ) ; steps . add ( step1 ) ; steps . add ( step2 ) ; step1 . setState ( StepState . FINISHED ) ; step2 . setState ( StepState . FINISHED ) ; assertTrue ( StepUtils . allStepsSubmitted ( steps ) ) ; }
public void test_catch_3_4 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String theory = " p(0) :- throw(error). " ; engine . setTheory ( new Theory ( theory ) ) ; String goal = " catch(p(0), E, E == err). " ; SolveInfo info = engine . solve ( goal ) ; assertFalse ( info . isSuccess ( ) ) ; }
public EChange setContentTransferEncodingSend ( @Nullable final EContentTransferEncoding eCTE ) { return setContentTransferEncodingSend ( eCTE ! = null ? eCTE . getID ( ) : null ) ; }
public Action agent_start ( Observation o ) { start ( ) ; inputObservation ( o ) ; think ( ) ; action . intArray [ 0 ] = decideAction ( 0 ) ; return action ; }
public List < Artist > getArtists ( boolean useAlbumArtist ) throws MPDServerException { List < String > artistNames = useAlbumArtist ? listAlbumArtists ( ) : listArtists ( true ) ; List < Artist > artists = new ArrayList < Artist > ( ) ; if ( null ! = artistNames & & ! artistNames . isEmpty ( ) ) { for ( String artist : artistNames ) { artists . add ( new Artist ( artist , MPD . showArtistAlbumCount ( ) ? getAlbumCount ( artist , useAlbumArtist ) : 0 ) ) ; } } Collections . sort ( artists ) ; return artists ; }
public static com . cloudera . labs . envelope . translate . ProtobufSingleMessage . SingleExample parseFrom ( com . google . protobuf . ByteString data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
public abstract boolean contains ( T value ) ; public abstract T get ( int index ) ; public abstract int size ( ) ; public static < T > List < T > createList ( ListType type ) { switch ( type ) { case ArrayList : return new ArrayList < T > ( ) ; default : return new LinkedList < T > ( ) ; } } public static class ArrayList < T > extends List < T > { private static final int MINIMUM_SIZE = 10 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ MINIMUM_SIZE ] ; private int size = 0 ; @Override public void add ( T value ) { if ( size > = array . length ) { array = Arrays . copyOf ( array , ( ( size * 3 ) / 2 ) + 1 ) ; } array [ size + + ] = value ; } @Override public boolean remove ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) { if ( i ! = - - size ) { System . arraycopy ( array , i + 1 , array , i , size - i ) ; } array [ size ] = null ; if ( size > = MINIMUM_SIZE & & size < array . length / 2 ) { array = Arrays . copyOf ( array , size ) ; } return true ; } } return false ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public T get ( int index ) { if ( index > = size ) return null ; return array [ index ] ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i + + ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } @Override public Iterator < T > iterator ( ) { return ( new ArrayListIterator < T > ( this ) ) ; } private static class ArrayListIterator < T > implements Iterator < T > { private ArrayList < T > list = null ; private int index = 0 ; private ArrayListIterator ( ArrayList < T > list ) { this . list = list ; } @Override public boolean hasNext ( ) { return ( index + 1 < = list . size ) ; } @Override public T next ( ) { if ( index > = list . size ) return null ; return list . array [ index + + ] ; } @Override public void remove ( ) { System . err . println ( " OperationNotSupported " ) ; } } } public static class LinkedList < T > extends List < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; @Override public void add ( T value ) { add ( new Node < T > ( value ) ) ; } private void add ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > prev = tail ; prev . next = node ; node . prev = prev ; tail = node ; } size + + ; } @Override public boolean remove ( T value ) { Node < T > node = head ; while ( node ! = null & & ( ! node . value . equals ( value ) ) ) { node = node . next ; } if ( node = = null ) return false ; if ( node . equals ( tail ) ) tail = node . prev ; Node < T > prev = node . prev ; Node < T > next = node . next ; if ( prev ! = null & & next ! = null ) { prev . next = next ; next . prev = prev ; } else if ( prev ! = null & & next = = null ) { prev . next = null ; } else if ( prev = = null & & next ! = null ) { next . prev = null ; head = next ; } else { head = null ; } size - - ; return true ; } @Override public boolean contains ( T value ) { Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . next ; } return false ; } @Override public T get ( int index ) { T result = null ; Node < T > node = head ; int i = 0 ; while ( node ! = null & & i < index ) { node = node . next ; i + + ; } if ( node ! = null ) result = node . value ; return result ; } @Override public int size ( ) { return size ; } private static class Node < T > { private T value = null ; private Node < T > prev = null ; private Node < T > next = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( prev ! = null ) ? prev . value : " NULL " ) + "  next= " + ( ( next ! = null ) ? next . value : " NULL " ) ; } } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . next ; } return builder . toString ( ) ; } @Override public Iterator < T > iterator ( ) { return ( new LinkedListIterator < T > ( this . head ) ) ; } private static class LinkedListIterator < T > implements Iterator < T > { private Node < T > nextNode = null ; private LinkedListIterator ( Node < T > head ) { this . nextNode = head ; } @Override public boolean hasNext ( ) { return ( nextNode ! = null ) ; } @Override public T next ( ) { Node < T > current = nextNode ; if ( current ! = null ) { nextNode = current . next ; return current . value ; } else { nextNode = null ; } return null ; } @Override public void remove ( ) { System . err . println ( " OperationNotSupported " ) ; } } } }
public void prepareParsing ( Config config ) { preparationAction . accept ( config ) ; }
public void testSubtractSchemaAllFields ( ) { StructField field1 = DataTypes . createStructField ( " field1 " , DataTypes . StringType , true ) ; StructField field2 = DataTypes . createStructField ( " field2 " , DataTypes . IntegerType , true ) ; StructField field3 = DataTypes . createStructField ( " field3 " , DataTypes . FloatType , true ) ; StructType schema = DataTypes . createStructType ( Lists . newArrayList ( field1 , field2 , field3 ) ) ; StructType subset = RowUtils . subtractSchema ( schema , Lists . newArrayList ( " field1 " , " field2 " , " field3 " ) ) ; assertEquals ( subset . fields ( ) . length , 0 ) ; }
public Object put ( Config config , List < String > key , Object value ) { return putAction . put ( config , key , value ) ; }
public void drop ( int from , int to ) { if ( from = = to ) { return ; } HashMap < String , Object > itemFrom = songlist . get ( from ) ; Integer songID = ( Integer ) itemFrom . get ( " songid " ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; try { if ( from < to ) { app . oMPDAsyncHelper . oMPD . getPlaylist ( ) . move ( songID , to - 1 ) ; } else { app . oMPDAsyncHelper . oMPD . getPlaylist ( ) . move ( songID , to ) ; } } catch ( MPDServerException e ) { } MainMenuActivity . notifyUser ( " Updating ... " , getApplication ( ) ) ; }
public EntranceProcessingItem createEntrancePi ( EntranceProcessor entranceProcessor ) { S4EntranceProcessingItem entrancePi = new S4EntranceProcessingItem ( entranceProcessor , app ) ; entrancePi . setParallelism ( 1 ) ; return entrancePi ; }
public TreeSet < ParticlePlan > particlePlan ( final Term target , final double distance , final int particles ) { PostCondition targetPost = new PostCondition ( target ) ; if ( ! implication . containsVertex ( targetPost ) ) { return null ; } ParticleActivation act = new ParticleActivation ( implication ) { @Override public boolean validVertex ( final Term x ) { return ! targetPost . equals ( x ) ; } } ; SortedSet < ParticlePath > roots = act . activate ( targetPost , false , particles , distance ) ; if ( roots = = null ) { return null ; } TreeSet < ParticlePlan > plans = new TreeSet ( ) ; for ( final ParticlePath pp : roots ) { Sentence [ ] path = pp . shortestPath ; if ( path . length = = 0 ) throw new RuntimeException ( " ParticlePath empty:  " + pp ) ; int operations = 0 ; List < Term > seq = new ArrayList ( path . length ) ; Implication imp ; long accumulatedDelay = 0 ; float minConf = 1.0f ; boolean onSubject = false ; Term prevTerm = null ; for ( int i = path . length - 1 ; i > = 0 ; ) { Sentence s = path [ i ] ; Term t = s . content ; if ( ! ( t instanceof Implication ) ) throw new RuntimeException ( " Unknown type:  " + t + "  in sequence generation of  " + this ) ; imp = ( Implication ) t ; Term term = onSubject ? imp . getSubject ( ) : imp . getPredicate ( ) ; if ( onSubject ) i - - ; onSubject = ! onSubject ; if ( prevTerm ! = null & & term = = prevTerm ) { prevTerm = term ; continue ; } prevTerm = term ; if ( isPlanTerm ( term ) ) { boolean isInterval = term instanceof Interval ; if ( ! isInterval ) { if ( accumulatedDelay > 0 ) { seq . add ( Interval . intervalTime ( accumulatedDelay , memory ) ) ; accumulatedDelay = 0 ; } seq . add ( term ) ; } else { Interval in = ( Interval ) term ; long time = in . getTime ( memory ) ; accumulatedDelay + = time ; } } else { float c = getEffectiveConfidence ( memory , term ) ; if ( c < minConf ) minConf = c ; } if ( term instanceof Operation ) operations + + ; } if ( operations = = 0 ) continue ; if ( seq . isEmpty ( ) ) continue ; int lastTerm = seq . size ( ) - 1 ; if ( seq . get ( lastTerm ) instanceof Interval ) seq . remove ( lastTerm ) ; ParticlePlan rp = new ParticlePlan ( path , seq , pp . score ( ) , pp . distance , minConf ) ; plans . add ( rp ) ; } return plans ; }
default < T extends Enum < T > > T getEnumOrElse ( String path , Class < T > enumType , Supplier < T > defaultValueSupplier ) { return getEnumOrElse ( path , enumType , EnumGetMethod . NAME_IGNORECASE , defaultValueSupplier ) ; }
char peekChar ( ) ; char peekChar ( int n ) ; void skipPeeks ( ) ; void pushBack ( char c ) ; }
public String toString ( ) { return new ToStringGenerator ( this ) . append ( " Map " , m_aMap ) . toString ( ) ; }
public static void exploreRandom ( ) { List < String > res = new ArrayList < > ( ) ; for ( GridObject g : space . objects ) { if ( g instanceof LocalGridObject ) { LocalGridObject obi = ( LocalGridObject ) g ; if ( obi instanceof Key ) { res . add ( " (^go-to, " + obi . doorname + " )! " ) ; } if ( obi instanceof Key & & ( ( int ) obi . x ) = = ( int ) current . x & & ( ( int ) obi . y ) = = ( int ) current . y ) { res . add ( " (^go-to, " + obi . doorname + " )! " ) ; res . add ( " (^pick, " + obi . doorname + " )! " ) ; } } } for ( int i = 0 ; i < space . cells . w ; i + + ) { for ( int j = 0 ; j < space . cells . h ; j + + ) { if ( space . cells . readCells [ i ] [ j ] . name . startsWith ( " switch " ) | | space . cells . readCells [ i ] [ j ] . name . startsWith ( " place " ) ) { res . add ( " (^go-to, " + space . cells . readCells [ i ] [ j ] . name + " )! " ) ; } } } int i = ( int ) current . x ; int j = ( int ) current . y ; if ( space . cells . readCells [ i ] [ j ] . logic = = Logic . SWITCH | | space . cells . readCells [ i ] [ j ] . logic = = Logic . OFFSWITCH ) { res . add ( " (^activate, " + space . cells . readCells [ i ] [ j ] . name + " )! " ) ; res . add ( " (^deactivate, " + space . cells . readCells [ i ] [ j ] . name + " )! " ) ; } if ( res . isEmpty ( ) ) { explored = new ArrayList < String > ( ) ; return ; } List < String > res2 = new ArrayList < > ( ) ; for ( String s : res ) { if ( ! explored . contains ( s ) ) { res2 . add ( s ) ; } } if ( res2 . isEmpty ( ) ) { explored = new ArrayList < String > ( ) ; return ; } String inp = res . get ( Memory . randomNumber . nextInt ( res2 . size ( ) ) ) ; explored . add ( inp ) ; narinst . addInput ( inp ) ; }
public boolean isEnabled ( int position , List < Object > items , Object item ) { return true ; }
void setAttributes ( @Nullable IStringMap aAttributes ) ; @Nullable String getHeader ( @Nonnull String sKey ) ; @Nullable String getHeader ( @Nonnull String sKey , @Nullable String sDelimiter ) ; @Nonnull InternetHeaders getHeaders ( ) ; void setHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void addHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void setHeaders ( @Nullable InternetHeaders aHeaders ) ; @Nullable String getMessageID ( ) ; void setMessageID ( @Nullable String sMessageID ) ; @Nonnull String generateMessageID ( ) ; void updateMessageID ( ) ; @Nonnull @ReturnsMutableObject ( reason = " Design " ) Partnership getPartnership ( ) ; void setPartnership ( @Nonnull Partnership aPartnership ) ; }
public void step ( ) { n + + ; point1 = body . getWorldPoint ( point ) ; d . set ( distance * MathUtils . cos ( angle + body . getAngle ( ) ) , distance * MathUtils . sin ( angle + body . getAngle ( ) ) ) ; point2 . set ( point1 ) ; point2 . addLocal ( d ) ; ccallback . init ( ) ; getWorld ( ) . raycast ( ccallback , point1 , point2 ) ; Body hit = null ; float d = Float . POSITIVE_INFINITY ; if ( ccallback . m_hit ) { d = ccallback . m_point . sub ( point ) . length ( ) / distance ; getDebugDraw ( ) . drawPoint ( ccallback . m_point , 5.0f , new Color3f ( 0.4f , 0.9f , 0.4f ) ) ; getDebugDraw ( ) . drawSegment ( point1 , ccallback . m_point , new Color3f ( 0.8f , 0.8f , 0.8f ) ) ; pooledHead . set ( ccallback . m_normal ) ; pooledHead . mulLocal ( .5f ) . addLocal ( ccallback . m_point ) ; getDebugDraw ( ) . drawSegment ( ccallback . m_point , pooledHead , new Color3f ( 0.9f , 0.9f , 0.4f ) ) ; hit = ccallback . body ; } else { getDebugDraw ( ) . drawSegment ( point1 , point2 , laserColor ) ; } if ( hit ! = null ) {
public void resetLearning ( ) { this . instancesSeen = 0 L ; this . classInstances = new DoubleVector ( ) ; this . attributeObservers = new HashMap < Integer , AttributeClassObserver > ( ) ; }
public static void main ( String [ ] args ) { DirectArrayList a = new DirectArrayList ( ) ; System . out . println ( Arrays . asList ( a . data ) ) ; a . add ( " x " ) ; System . out . println ( Arrays . asList ( a . data ) ) ; System . out . println ( a . data [ 0 ] ) ; }
public Data query ( long startOfQuery , long endOfQuery ) { if ( endOfQuery < this . start | | startOfQuery > this . end ) return null ; return copy ( ) ; }
void debug ( Object message , Throwable exception ) ; void debug ( Object message ) ; void debug ( String message , Object . . . args ) ; void info ( Object message , Throwable exception ) ; void info ( Object message ) ; void info ( String message , Object . . . args ) ; void warn ( Object message , Throwable exception ) ; void warn ( Object message ) ; void warn ( String message , Object . . . args ) ; void error ( Object message , Throwable exception ) ; void error ( Object message ) ; void error ( String message , Object . . . args ) ; void fatal ( Object message , Throwable exception ) ; void fatal ( Object message ) ; void fatal ( String message , Object . . . args ) ; }
public double get ( ) { return Double . longBitsToDouble ( value . get ( ) ) ; }
public void testDefaultDynamicPivot ( ) throws Exception { List < Row > sourceList = Lists . newArrayList ( RowFactory . create ( " A " , " hello " , " 1 " ) , RowFactory . create ( " A " , " world " , " 2 " ) , RowFactory . create ( " B " , " hello " , " 3 " ) , RowFactory . create ( " C " , " world " , " 4 " ) ) ; StructType schema = SchemaUtils . structTypeFor ( Lists . newArrayList ( " entity_id " , " key " , " value " ) , Lists . newArrayList ( " string " , " string " , " string " ) ) ; Dataset < Row > source = Contexts . getSparkSession ( ) . createDataFrame ( sourceList , schema ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " source " , source ) ; Config config = ConfigFactory . empty ( ) . withValue ( PivotDeriver . STEP_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " source " ) ) . withValue ( PivotDeriver . ENTITY_KEY_FIELD_NAMES_CONFIG , ConfigValueFactory . fromAnyRef ( Lists . newArrayList ( " entity_id " ) ) ) . withValue ( PivotDeriver . PIVOT_KEY_FIELD_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " key " ) ) . withValue ( PivotDeriver . PIVOT_VALUE_FIELD_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " value " ) ) ; PivotDeriver d = new PivotDeriver ( ) ; assertNoValidationFailures ( d , config ) ; d . configure ( config ) ; List < Row > results = d . derive ( dependencies ) . collectAsList ( ) ; assertEquals ( results . size ( ) , 3 ) ; assertTrue ( results . contains ( RowFactory . create ( " A " , " 1 " , " 2 " ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " B " , " 3 " , null ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " C " , null , " 4 " ) ) ) ; }
public static final String reverseWordsUsingStringTokenizerWithAdditionalStorage ( String string ) { String output = new String ( ) ; StringTokenizer st = new StringTokenizer ( string ) ; while ( st . hasMoreTokens ( ) ) { output = ( st . nextToken ( ) ) + ' ' + output ; } return output ; }
public static Sentence parseOutput ( String s ) { Term content = null ; char punc = 0 ; TruthValue truth = null ; try { StringBuilder buffer = new StringBuilder ( s ) ; String truthString = getTruthString ( buffer ) ; String str = buffer . toString ( ) . trim ( ) ; int last = str . length ( ) - 1 ; punc = str . charAt ( last ) ; truth = parseTruth ( truthString , punc ) ; } catch ( InvalidInputException e ) { System . err . println ( " TextInput.parseOutput:  " + s + "  :  " + e . toString ( ) ) ; } return new Sentence ( content , punc , truth , null ) ; }
public static Operation make ( final Operator oper , Term [ ] arg , boolean addSelf ) { return new Operation ( new Product ( arg ) , oper ) ; }
public static void resetStatic ( ) { randomNumber . setSeed ( randomSeed ) ; }
void setHandlingNode ( MemcachedNode to ) ; void timeOut ( ) ; boolean isTimedOut ( ) ; boolean isTimedOut ( long ttlMillis ) ; boolean isTimedOutUnsent ( ) ; long getWriteCompleteTimestamp ( ) ; byte [ ] getErrorMsg ( ) ; void addClone ( Operation op ) ; int getCloneCount ( ) ; void setCloneCount ( int count ) ; }
public static ArrayRealVector randomCoordinates ( final int dimensions ) { final double [ ] randomCoordinates = new double [ dimensions ] ; for ( int randomCoordinatesIndex = 0 ; randomCoordinatesIndex < dimensions ; randomCoordinatesIndex + + ) { randomCoordinates [ randomCoordinatesIndex ] = ( RANDOM . nextDouble ( ) * 2.0 ) - 1.0 ; } return new ArrayRealVector ( randomCoordinates ) ; }
public long incr ( String key , int by , int def ) throws OperationTimeoutException { return mutateWithDefault ( Mutator . incr , key , by , def , 0 ) ; }
void setHistory ( DataHistory history ) ; DataHistory getHistory ( ) ; void setMDN ( IMessageMDN mdn ) ; IMessageMDN getMDN ( ) ; void setMessageID ( String messageID ) ; String getMessageID ( ) ; void setPartnership ( Partnership partnership ) ; Partnership getPartnership ( ) ; String getProtocol ( ) ; boolean isRequestingMDN ( ) ; boolean isRequestingAsynchMDN ( ) ; void setSubject ( String subject ) ; String getSubject ( ) ; void addHeader ( String key , String value ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; String getLoggingText ( ) ; }
private static final void relabel ( Vertex v ) { int minimum = 0 ; for ( Edge e : v . edges ) { if ( e . f < e . c ) minimum = Math . min ( minimum , e . to . h ) ; } v . h = minimum + 1 ; }
private int buildZone ( int x , int maxLength ) { int t = random . nextInt ( totalOdds ) ; int type = 0 ; for ( int i = 0 ; i < odds . length ; i + + ) { if ( odds [ i ] < = t ) { type = i ; } } switch ( type ) { case ODDS_STRAIGHT : return buildStraight ( x , maxLength , false ) ; case ODDS_HILL_STRAIGHT : return buildHillStraight ( x , maxLength ) ; case ODDS_TUBES : return buildTubes ( x , maxLength ) ; case ODDS_JUMP : return buildJump ( x , maxLength ) ; case ODDS_CANNONS : return buildCannons ( x , maxLength ) ; } return 0 ; }
public void randomChanged ( boolean random ) { } private void registerMediaButtonEvent ( ) { if ( registerMediaButtonEventReceiver = = null ) { return ; } try { registerMediaButtonEventReceiver . invoke ( audioManager , remoteControlResponder ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } } @Override public void repeatChanged ( boolean repeating ) { } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd = = null ) { return ; } String state = statusMpd . getState ( ) ; if ( state = = null | | state . equals ( prevMpdState ) ) { return ; } if ( state . equals ( MPDStatus . MPD_STATE_PLAYING ) ) { isPaused = false ; beginStreaming ( ) ; isPlaying = true ; } else { prevMpdState = state ; isPlaying = false ; stopStreaming ( ) ; } } public void stop ( ) { stopStreaming ( ) ; die ( ) ; } public void stopStreaming ( ) { prevMpdState = " " ; if ( mediaPlayer = = null ) { return ; } mediaPlayer . stop ( ) ; } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { prevMpdState = " " ; } private void unregisterMediaButtonEvent ( ) { if ( unregisterMediaButtonEventReceiver = = null ) { return ; } try { unregisterMediaButtonEventReceiver . invoke ( audioManager , remoteControlResponder ) ; } catch ( IllegalArgumentException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } catch ( InvocationTargetException e ) { e . printStackTrace ( ) ; } catch ( NullPointerException e ) { e . printStackTrace ( ) ; } } @Override public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } }
public boolean canHandle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) { return sAction . equals ( IProcessorResenderModule . DO_RESEND ) ; }
public void setShortcut ( boolean showShortcut , char shortcutKey ) ; public void setIcon ( Drawable icon ) ; public boolean prefersCondensedTitle ( ) ; public boolean showsIcon ( ) ; } }
public void adaptContrast ( double rate , double center ) { range . adaptiveContrast ( rate , center ) ; }
public void testGetStatsSlabs ( ) throws Exception { if ( isMembase ( ) ) { return ; } client . set ( " slabinitializer " , 0 , " hi " ) ; Map < SocketAddress , Map < String , String > > stats = client . getStats ( " slabs " ) ; System . out . println ( " Stats:   " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; assertTrue ( oneStat . containsKey ( " 1:chunk_size " ) ) ; }
public void observeAttributeTarget ( double attVal , double target ) { if ( ! Double . isNaN ( attVal ) ) { if ( this . root1 = = null ) {
public P2d sum ( V2d v ) { return new P2d ( x + v . x , y + v . y ) ; }
protected Graph nextGraph ( ) { if ( nar = = null ) return null ; return new NARGraph ( ) . add ( nar , new NARGraph . ExcludeBelowPriority ( minPriority ) , new DefaultGraphizer ( showBeliefs , showBeliefs , showQuestions , showTermContent , 0 , showTermLinks , showTaskLinks ) ) ; }
public void onConnectionStateChanged ( final MPDApplication app , boolean connected ) { outputsScreen . setEnabled ( connected ) ; update . setEnabled ( connected ) ; informationScreen . setEnabled ( connected ) ; new Thread ( new Runnable ( ) {
< T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > append ( String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; Future < Boolean > prepend ( String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > prepend ( String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; CASResponse cas ( String key , long casId , int exp , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public static boolean isMembase ( ) { return TYPE . equals ( TYPE_MEMBASE ) ; }
public void handle ( @Nonnull final AbstractActiveNetModule aOwner , @Nonnull final Socket aSocket ) { final String sClientInfo = getClientInfo ( aSocket ) ; LOGGER . info ( " incoming connection [ " + sClientInfo + " ] " ) ; final AS2Message aMsg = new AS2Message ( ) ; final IAS2HttpResponseHandler aResponseHandler = new AS2HttpResponseHandlerSocket ( aSocket ) ; byte [ ] aData = null ; try {
public boolean isDisableDecrypt ( ) { return " true " . equals ( getAttribute ( CPartnershipIDs . PA_DISABLE_DECRYPT ) ) ; }
public abstract String getPropertyString ( final String name ) ; public abstract String getProtocol ( ) ; public abstract String getQualifiedName ( ) ; public abstract Map < Fields , String > getQualifiedNameMap ( ) ; public abstract String getServer ( ) ; public abstract String getSubtype ( ) ; public abstract byte [ ] getTextBytes ( ) ; @Deprecated public abstract String getTextString ( ) ; public abstract String getType ( ) ; public abstract String getTypeWithSubtype ( ) ; @Deprecated public abstract String getURL ( ) ; @Deprecated public abstract String getURL ( String protocol ) ; public abstract String [ ] getURLs ( ) ; public abstract String [ ] getURLs ( String protocol ) ; public abstract int getWeight ( ) ; public abstract boolean hasData ( ) ; public abstract boolean isPersistent ( ) ; public abstract void setText ( final byte [ ] text ) throws IllegalStateException ; public abstract void setText ( final Map < String , ? > props ) throws IllegalStateException ; }
public void singleFile ( ) throws Exception { FileWatcher watcher = new FileWatcher ( Duration . ZERO , Duration . ZERO , onWatcherException ) ; Path file = tmp . resolve ( " fileNotifications.txt " ) ; AtomicReference < CountDownLatch > ref = new AtomicReference < > ( new CountDownLatch ( 1 ) ) ; watcher . addWatch ( file , ( ) - > ref . get ( ) . countDown ( ) ) ; Thread . sleep ( 10 ) ; Files . createFile ( file ) ; assertTrue ( ref . get ( ) . await ( 100 , TimeUnit . MILLISECONDS ) , " creation not detected " ) ; ref . set ( new CountDownLatch ( 1 ) ) ; Files . write ( file , Arrays . asList ( " something something " ) ) ; assertTrue ( ref . get ( ) . await ( 100 , TimeUnit . MILLISECONDS ) , " write not detected " ) ; ref . set ( new CountDownLatch ( 1 ) ) ; Files . write ( file , Arrays . asList ( " something else " ) ) ; assertTrue ( ref . get ( ) . await ( 100 , TimeUnit . MILLISECONDS ) , " write not detected " ) ; ref . set ( null ) ; file = tmp . resolve ( " fileNotifications-2.txt " ) ; ref . set ( new CountDownLatch ( 1 ) ) ; Files . createFile ( file ) ; watcher . addWatch ( file , ( ) - > ref . get ( ) . countDown ( ) ) ; Thread . sleep ( 10 ) ; Files . write ( file , Arrays . asList ( " test2 " ) ) ; assertTrue ( ref . get ( ) . await ( 100 , TimeUnit . MILLISECONDS ) ) ; CountDownLatch newLatch = new CountDownLatch ( 1 ) ; watcher . setWatch ( file , ( ) - > newLatch . countDown ( ) ) ; Thread . sleep ( 10 ) ; Files . write ( file , Arrays . asList ( " :) " ) ) ; assertTrue ( ref . get ( ) . await ( 100 , TimeUnit . MILLISECONDS ) ) ; ref . set ( null ) ; watcher . removeWatch ( file ) ; Thread . sleep ( 10 ) ; Files . write ( file , Arrays . asList ( " ... " ) ) ; Thread . sleep ( 50 ) ; watcher . stop ( ) ; }
private T removeKey ( int index ) { if ( index > = keysSize ) return null ; T value = keys [ index ] ; keys [ index ] = null ; for ( int i = index + 1 ; i < keysSize ; i + + ) { keys [ i - 1 ] = keys [ i ] ; } keysSize - - ; keys [ keysSize ] = null ; return value ; }
public void onCoverDownloaded ( CoverInfo cover ) ; public void onCoverNotFound ( CoverInfo coverInfo ) ; }
public void unlockAll ( ) { synchronized ( locks ) { Set < String > mutexList = locks . keySet ( ) ;
public final DataHistory getHistory ( ) { if ( m_aHistory = = null ) m_aHistory = new DataHistory ( ) ; return m_aHistory ; }
public CommentedFileConfigBuilder concurrent ( ) { super . concurrent ( ) ; return this ; }
public String toString ( ) { return " id = " + id + "  parent= " + ( ( parent ! = null ) ? parent . id : " NULL " ) + "  lesser= " + ( ( lesser ! = null ) ? lesser . id : " NULL " ) + "  greater= " + ( ( greater ! = null ) ? greater . id : " NULL " ) ;
public StoredPlaylistFragment init ( final String name ) { mPlaylistName = name ; return this ; }
public void conceptsStartPlay ( final BagObserver < Concept > bagObserver , final String title ) { bagObserver . setBag ( concepts ) ; concepts . addBagObserver ( bagObserver , title ) ; }
public void reset ( ) { walkingSteps = 0 ; clock = 0 ; memory . init ( ) ; Stamp . init ( ) ; output ( resetMessage ) ;
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; Future < Boolean > append ( String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > append ( String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; Future < Boolean > prepend ( String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > prepend ( String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; Future < CASResponse > asyncCAS ( String key , long casId , int exp , Object value ) ; < T > OperationFuture < CASResponse > asyncCAS ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; CASResponse cas ( String key , long casId , int exp , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
protected String calculateMIC ( @Nonnull final AS2Message aMsg ) throws Exception { final Partnership aPartnership = aMsg . getPartnership ( ) ; final String sDispositionOptions = aPartnership . getAttribute ( CPartnershipIDs . PA_AS2_MDN_OPTIONS ) ; final DispositionOptions aDispositionOptions = DispositionOptions . createFromString ( sDispositionOptions ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " DispositionOptions= " + aDispositionOptions ) ; final boolean bIncludeHeadersInMIC = aPartnership . getAttribute ( CPartnershipIDs . PA_SIGN ) ! = null | | aPartnership . getAttribute ( CPartnershipIDs . PA_ENCRYPT ) ! = null | | aPartnership . getAttribute ( CPartnershipIDs . PA_COMPRESSION_TYPE ) ! = null ; final String sMIC = AS2Helper . getCryptoHelper ( ) . calculateMIC ( aMsg . getData ( ) , aDispositionOptions . getFirstMICAlg ( ) , bIncludeHeadersInMIC ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Calculated MIC: ' " + sMIC + " ' " ) ; if ( aPartnership . getAttribute ( CPartnershipIDs . PA_AS2_RECEIPT_OPTION ) ! = null ) { storePendingInfo ( aMsg , sMIC ) ; } return sMIC ; }
protected List < Task > execute ( nars . operator . Operation operation , Term [ ] args , Memory memory ) { if ( args . length ! = 2 ) { return null ; } Term key = args [ 0 ] ; String theory = PrologQueryOperator . getStringOfTerm ( args [ 1 ] ) ; Agent a = new Agent ( theory ) ; Prolog p = new Prolog ( ) ; context . prologs . put ( key , p ) ; memory . output ( Prolog . class , key + " = " + p ) ; return null ; }
private OperationFuture < Long > asyncMutate ( Mutator m , String key , long by , long def , int exp ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Long > rv = new OperationFuture < Long > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; mconn . enqueueOperation ( key , op ) ; rv . setOperation ( op ) ; return rv ; }
public boolean isChunkedEncodingAlreadyProcessed ( ) { return false ; }
public static boolean isCITest ( ) { return TEST_TYPE . equals ( TYPE_TEST_CI ) ; }
void error ( Object message , Throwable exception ) ; void error ( Object message ) ; void error ( String message , Object . . . args ) ; void fatal ( Object message , Throwable exception ) ; void fatal ( Object message ) ; void fatal ( String message , Object . . . args ) ; }
public T peek ( ) ; public boolean remove ( T value ) ; public void clear ( ) ; public boolean contains ( T value ) ; public int size ( ) ; public boolean validate ( ) ; public java . util . Queue < T > toLifoQueue ( ) ; public java . util . Collection < T > toCollection ( ) ; }
public List < String > listArtists ( boolean sortInsensitive ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; List < String > response = mpdConnection . sendCommand ( MPDCommand . MPD_CMD_LIST_TAG , MPDCommand . MPD_TAG_ARTIST ) ; ArrayList < String > result = new ArrayList < String > ( ) ; for ( String s : response ) { String name = s . substring ( " Artist:  " . length ( ) ) ; if ( name . length ( ) > 0 ) result . add ( name ) ; } if ( sortInsensitive ) Collections . sort ( result , String . CASE_INSENSITIVE_ORDER ) ; else Collections . sort ( result ) ; return result ; }
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( getActivity ( ) ) ; albumartist = settings . getBoolean ( " albumartist " , false ) ; }
public void trackChanged ( final MPDStatus mpdStatus , final int oldTrack ) { mLastStatusRefresh = new Date ( ) . getTime ( ) ; mLastKnownElapsed = 0 L ; updateCurrentMusic ( mpdStatus ) ; updatePlayingInfo ( mpdStatus ) ; }
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; void setTranscoder ( Transcoder < Object > tc ) ; Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
public List < String > listAlbums ( boolean useAlbumArtist ) throws MPDServerException { return listAlbums ( null , useAlbumArtist , false ) ; }
public void testQueryListener ( ) throws Exception { Prolog engine = new Prolog ( ) ; TestPrologEventAdapter a = new TestPrologEventAdapter ( ) ; engine . addQueryListener ( a ) ; engine . setTheory ( new Theory ( " a(1). \ na(2). \ n " ) ) ; engine . solve ( " a(X). " ) ; assertEquals ( " a(X) " , a . firstMessage ) ; assertEquals ( " yes. \ nX / 1 " , a . secondMessage ) ; engine . solveNext ( ) ; assertEquals ( " a(X) " , a . firstMessage ) ; assertEquals ( " yes. \ nX / 2 " , a . secondMessage ) ; }
public void post ( ) { if ( ! toDisposeOf . isEmpty ( ) ) { for ( GWindow gwindow : toDisposeOf ) {
public java . util . Queue < T > asQueue ( ) { return ( new JavaCompatibleLinkedQueue < T > ( this ) ) ; }
private static void symmetricSymmetric ( final Sentence belief , final Sentence taskSentence , final int figure , final DerivationContext nal ) { final Statement s1 = ( Statement ) belief . term ; final Statement s2 = ( Statement ) taskSentence . term ; final Statement . EnumStatementSide figureLeft = retSideFromFigure ( figure , EnumFigureSide . LEFT ) ; final Statement . EnumStatementSide figureRight = retSideFromFigure ( figure , EnumFigureSide . RIGHT ) ; final Term ut1 = s1 . retBySide ( figureLeft ) ; final Term ut2 = s2 . retBySide ( figureRight ) ; Term rt1 = s1 . retBySide ( retOppositeSide ( figureLeft ) ) ; Term rt2 = s2 . retBySide ( retOppositeSide ( figureRight ) ) ; final Term [ ] u = new Term [ ] { s1 , s2 } ; if ( Variables . unify ( VAR_INDEPENDENT , ut1 , ut2 , u ) ) {
protected List < Task > execute ( final Operation operation , final Term [ ] args , final Memory memory ) { final Operator op = new NullOperator ( args [ 1 ] . toString ( ) ) ; memory . addOperator ( op ) ; return null ; }
public void testRead ( ) throws IOException { config . readFrom ( file ) ; System . out . println ( config ) ; }
public void testSetNumThreadsSimple ( ) { ThreadsEngine . setNumberThreads ( numThreads ) ; assertEquals ( " Number of threads is not set correctly. " , numThreads , ThreadsEngine . getNumberThreads ( ) , 0 ) ;
public void remove ( ) { throw new UnsupportedOperationException ( " OperationNotSupported " ) ; }
public static void readTillNexLine ( InputStream aIS ) throws IOException { while ( true ) {
Iterable < Row > translate ( T key , T message ) throws Exception ; StructType getSchema ( ) ; }
public CharSequence convertToString ( Cursor cursor ) { if ( mCursorToStringConverter ! = null ) { return mCursorToStringConverter . convertToString ( cursor ) ; } else if ( mStringConversionColumn > - 1 ) { return cursor . getString ( mStringConversionColumn ) ; } return super . convertToString ( cursor ) ; }
private String toStringLongIfNotNull ( Item item , String title ) { return item = = null ? " " : " \ n  " + title + " : \ n " + item . toStringLong ( ) ;
public void executeConjunctionSequence ( final Execution task , final Conjunction c ) { int s = task . sequence ; Term currentTerm = c . term [ s ] ; long now = memory . time ( ) ; if ( task . delayUntil > now ) { return ; } if ( currentTerm instanceof Operation ) { Concept conc = memory . concept ( currentTerm ) ; execute ( ( Operation ) currentTerm , task . t ) ; task . delayUntil = now + memory . param . duration . get ( ) ; s + + ; } else if ( currentTerm instanceof Interval ) { Interval ui = ( Interval ) currentTerm ; task . delayUntil = memory . time ( ) + Interval . magnitudeToTime ( ui . magnitude , memory . param . duration ) ; s + + ; } else { System . err . println ( " Non-executable term in sequence:  " + currentTerm + "  in  " + c + "  from task  " + task . t ) ; } if ( s = = c . term . length ) {
public static Term make ( Term [ ] argList , Memory memory ) { if ( argList . length = = 1 ) { return argList [ 0 ] ; } if ( argList . length ! = 2 ) { return null ; } if ( ( argList [ 0 ] instanceof SetExt ) & & ( argList [ 1 ] instanceof SetExt ) ) { TreeSet < Term > set = new TreeSet < Term > ( ( ( CompoundTerm ) argList [ 0 ] ) . cloneTermsList ( ) ) ; set . removeAll ( ( ( CompoundTerm ) argList [ 1 ] ) . cloneTermsList ( ) ) ; return SetExt . make ( set , memory ) ; } CharSequence name = makeCompoundName ( NativeOperator . DIFFERENCE_EXT , argList ) ; Term t = memory . conceptTerm ( name ) ; return ( t ! = null ) ? t : new DifferenceExt ( name , argList ) ; }
private void _write ( @Nonnull final byte [ ] aBytes , @Nonnegative final int nOfs , @Nonnegative final int nLen ) { try {
public static Planner create ( Config plannerConfig ) throws Exception { if ( ! plannerConfig . hasPath ( TYPE_CONFIG_NAME ) ) { throw new RuntimeException ( " Planner type not specified " ) ; } String plannerType = plannerConfig . getString ( TYPE_CONFIG_NAME ) ; Planner planner ; switch ( plannerType ) { case " append " : planner = new AppendPlanner ( ) ; break ; case " upsert " : planner = new SystemTimeUpsertPlanner ( ) ; break ; case " overwrite " : planner = new OverwritePlanner ( ) ; break ; case " eventtimeupsert " : planner = new EventTimeUpsertPlanner ( ) ; break ; case " history " : planner = new EventTimeHistoryPlanner ( ) ; break ; case " bitemporal " : planner = new BitemporalHistoryPlanner ( ) ; break ; case " delete " : planner = new DeletePlanner ( ) ; break ; default : Class < ? > clazz = Class . forName ( plannerType ) ; Constructor < ? > constructor = clazz . getConstructor ( ) ; planner = ( Planner ) constructor . newInstance ( ) ; } planner . configure ( plannerConfig ) ; return planner ; }
private void processInput ( ) { if ( walkingSteps = = 0 ) { boolean reasonerShouldRun = false ;
protected abstract boolean areAttributesEqual ( final StatsKey other ) ; @SuppressWarnings ( " unchecked " ) @Override public int compareTo ( final StatsKey other ) { int i = this . name . compareTo ( other . getName ( ) ) ; if ( i = = 0 ) { i = other . getAttributeCount ( ) - this . getAttributeCount ( ) ; if ( i = = 0 ) { Map < String , Object > thisAttrs = this . getAttributes ( ) ; Map < String , Object > otherAttrs = other . getAttributes ( ) ; List < String > thisAttrKeys = new ArrayList < String > ( thisAttrs . keySet ( ) ) ; List < String > otherAttrKeys = new ArrayList < String > ( otherAttrs . keySet ( ) ) ; Collections . sort ( thisAttrKeys ) ; Collections . sort ( otherAttrKeys ) ; Iterator < String > thisItr = thisAttrKeys . iterator ( ) ; Iterator < String > otherItr = otherAttrKeys . iterator ( ) ; while ( thisItr . hasNext ( ) & & otherItr . hasNext ( ) ) { i = thisItr . next ( ) . compareTo ( otherItr . next ( ) ) ; if ( i ! = 0 ) { break ; } } if ( i = = 0 ) { for ( Map . Entry < String , Object > entry : thisAttrs . entrySet ( ) ) { Object otherValue = otherAttrs . get ( entry . getKey ( ) ) ; i = ( ( Comparable ) entry . getValue ( ) ) . compareTo ( otherValue ) ; if ( i ! = 0 ) { break ; } } } } } return i ; } @Override public String toString ( ) { int attrCount = getAttributeCount ( ) ; StringBuilder buf = new StringBuilder ( name . length ( ) + 20 + ( attrCount * 8 ) ) ; buf . append ( StatsKey . class . getSimpleName ( ) ) ; buf . append ( " [name= " ) ; buf . append ( name ) ; if ( attrCount > 0 ) { buf . append ( " ,attrs= " ) ; appendAttributes ( buf ) ; } buf . append ( ']' ) ; return buf . toString ( ) ; } protected void appendAttributes ( final StringBuilder buf ) { } }
public static void main ( String [ ] args ) throws Exception { Properties props = new Properties ( ) ; props . put ( " bootstrap.servers " , args [ 0 ] ) ; props . put ( " metadata.broker.list " , args [ 0 ] ) ; props . put ( " key.serializer " , " org.apache.kafka.common.serialization.StringSerializer " ) ; props . put ( " value.serializer " , " org.apache.kafka.common.serialization.StringSerializer " ) ; KafkaProducer < String , String > producer = new KafkaProducer < String , String > ( props ) ; String key = UUID . randomUUID ( ) . toString ( ) ; while ( true ) { Random random = new Random ( ) ;
public double totalWeightOfClassObservations ( ) { return 0.0 ; }
public static Term make ( Term term1 , Term term2 , Memory memory ) { TreeSet < Term > set ; if ( term1 instanceof Disjunction ) { set = new TreeSet < > ( ( ( CompoundTerm ) term1 ) . cloneTermsList ( ) ) ; if ( term2 instanceof Disjunction ) { set . addAll ( ( ( CompoundTerm ) term2 ) . cloneTermsList ( ) ) ; } else { set . add ( term2 . clone ( ) ) ; } } else if ( term2 instanceof Disjunction ) { set = new TreeSet < > ( ( ( CompoundTerm ) term2 ) . cloneTermsList ( ) ) ; set . add ( term1 . clone ( ) ) ; } else { set = new TreeSet < > ( ) ; set . add ( term1 . clone ( ) ) ; set . add ( term2 . clone ( ) ) ; } return make ( set , memory ) ; }
public Builder alpha ( double alpha ) { this . pageHinckleyAlpha = alpha ; return this ; }
public void insert ( Instance instance , long timestamp ) { N + + ; LST + = timestamp ; SST + = timestamp * timestamp ; for ( int i = 0 ; i < instance . numValues ( ) ; i + + ) { LS [ i ] + = instance . value ( i ) ;
public void handleIO ( ) throws IOException { int selected = selector . select ( ) ; Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; if ( selectedKeys . size ( ) > 0 ) { emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { getLogger ( ) . debug ( " Got selection key:  %s (r=%s, w=%s, c=%s, op=%s) " , sk , sk . isReadable ( ) , sk . isWritable ( ) , sk . isConnectable ( ) , sk . attachment ( ) ) ; handleIO ( sk ) ; } } else { getLogger ( ) . info ( " No selectors ready, interrupted:  " + Thread . interrupted ( ) ) ; if ( + + emptySelects > MAX_EMPTY ) { for ( SelectionKey sk : selector . keys ( ) ) { getLogger ( ) . info ( " %s has %s, interested in %s " , sk , sk . readyOps ( ) , sk . interestOps ( ) ) ; } assert false : " Too many empty selects " ; } } selectedKeys . clear ( ) ; }
protected void trackFile ( @Nonnull final File aFile ) { final Map < String , Long > aTrackedFiles = trackedFiles ( ) ; final String sFilePath = aFile . getAbsolutePath ( ) ; if ( ! aTrackedFiles . containsKey ( sFilePath ) ) aTrackedFiles . put ( sFilePath , Long . valueOf ( aFile . length ( ) ) ) ;
public StringMap getPartnerOfName ( @Nullable final String sPartnerName ) { return m_aMap . get ( sPartnerName ) ; }
public static TempSharedFileInputStream getTempSharedFileInputStream ( @Nonnull @WillNotClose final InputStream aIS , @Nonnull final String sName ) throws IOException { final File aDest = storeContentToTempFile ( aIS , sName ) ; return new TempSharedFileInputStream ( aDest , aIS ) ; }
public void updateAnticipations ( ) { if ( anticipations . isEmpty ( ) ) return ; long now = nal . memory . time ( ) ; boolean hasNewTasks = ! newTasks . isEmpty ( ) ; Iterator < Map . Entry < Vector2Int , LinkedHashSet < Term > > > aei = anticipations . entrySet ( ) . iterator ( ) ; while ( aei . hasNext ( ) ) { Map . Entry < Vector2Int , LinkedHashSet < Term > > ae = aei . next ( ) ; long aTime = ae . getKey ( ) . predictedOccurenceTime ; long predictionstarted = ae . getKey ( ) . predictionCreationTime ; if ( aTime < predictionstarted ) { return ; } Interval Int = Interval . interval ( aTime - predictionstarted , nal . memory ) ; double expiredate = predictionstarted + Interval . magnitudeToTime ( Int . magnitude + 1 , nal . memory . param . duration ) ; boolean didntHappen = ( now > = expiredate ) ; boolean maybeHappened = hasNewTasks & & ! didntHappen ; if ( ( ! didntHappen ) & & ( ! maybeHappened ) ) continue ; LinkedHashSet < Term > terms = ae . getValue ( ) ; Iterator < Term > ii = terms . iterator ( ) ; while ( ii . hasNext ( ) ) { Term aTerm = ii . next ( ) ; boolean remove = false ; if ( didntHappen ) { deriveDidntHappen ( aTerm , aTime ) ; remove = true ; } if ( maybeHappened ) { if ( newTasks . remove ( aTerm ) ) { remove = true ; hasNewTasks = ! newTasks . isEmpty ( ) ; } } if ( remove ) ii . remove ( ) ; } if ( terms . isEmpty ( ) ) { aei . remove ( ) ; } } newTasks . clear ( ) ; }
public abstract Set < OperationType > getSupportedOperationTypes ( ) ; public abstract Schema getSchema ( ) ; public abstract List < GenericRecord > getExistingForFilter ( GenericRecord filter ) throws Exception ; public abstract void applyPlannedMutations ( List < PlannedRecord > mutations ) throws Exception ; }
public AS2Response sendAsync ( final AS2ConnectionSettings settings , final AS2Request request ) { throw new UnsupportedOperationException ( ) ;
public void send ( InputStream toSend ) throws IOException { m_aRequestBuilder . setEntity ( new InputStreamEntity ( toSend ) ) ; HttpUriRequest aHttpUriRequest = m_aRequestBuilder . build ( ) ; m_aCloseableHttpResponse = m_aCloseableHttpClient . execute ( aHttpUriRequest ) ;
public void testCantUseDefaultDependency ( ) { Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " dep1 " , testDataFrame ( ) ) ; dependencies . put ( " dep2 " , testDataFrame ( ) ) ; Map < String , Object > configMap = Maps . newHashMap ( ) ; Config config = ConfigFactory . parseMap ( configMap ) ; HashDeriver d = new HashDeriver ( ) ; assertNoValidationFailures ( d , config ) ; d . configure ( config ) ; d . derive ( dependencies ) ; }
public Collection < T > nearestNeighbourSearch ( int K , T value ) { if ( value = = null ) return null ; System . out . println ( " Looking for  " + value . toString ( ) ) ; TreeSet < KdNode > results = new TreeSet < KdNode > ( new EuclideanComparator ( value ) ) ; KdNode prev = null ; KdNode node = root ; while ( node ! = null ) { if ( KdNode . compareTo ( node . depth , node . k , node . id , value ) < 0 ) { prev = node ; node = node . greater ; } else { prev = node ; node = node . lesser ; } } KdNode leaf = prev ; if ( leaf ! = null ) { Set < KdNode > examined = new HashSet < KdNode > ( ) ; node = leaf ; while ( node ! = null ) { searchNode ( value , node , K , results , examined ) ; node = node . parent ; } } Collection < T > collection = new ArrayList < T > ( K ) ; for ( KdNode kdNode : results ) { collection . add ( ( T ) kdNode . id ) ; } return collection ; }
< T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
protected void add ( Item item , String playlist ) { try { app . oMPDAsyncHelper . oMPD . addToPlaylist ( playlist ,
public void insertValue ( double val , int label , double weight ) { if ( val = = this . cut_point ) { this . classCountsLeft . addToValue ( label , weight ) ;
private void updateRefs ( ) { synchronized ( mLOCK ) { cleanPhantomReferences ( ) ;
public void testReadHttpRequestStreamMessage ( ) throws Exception { final IAS2HttpResponseHandler mockedResponseHandler = ( nHttpResponseCode , aHeaders , aData ) - > { } ; NonBlockingByteArrayInputStream is = new NonBlockingByteArrayInputStream ( m_sChunkedMessage . getBytes ( StandardCharsets . UTF_8 ) ) ; AS2Message aMsg = new AS2Message ( ) ; IAS2InputStreamProvider mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; final DataSource resRegular = HTTPHelper . readHttpRequest ( mockStreamProvider , mockedResponseHandler , aMsg ) ; is = new NonBlockingByteArrayInputStream ( m_sChunkedMessage . getBytes ( StandardCharsets . UTF_8 ) ) ; aMsg = new AS2Message ( ) ; mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; final DataSource resStream = HTTPHelper . readHttpRequest ( mockStreamProvider , mockedResponseHandler , aMsg ) ; assertTrue ( " Compare regular and stream read " , _compareLineByLine ( resRegular . getInputStream ( ) , resStream . getInputStream ( ) ) ) ;
void setupSetter ( Class targetClass ) { super . setupSetter ( targetClass ) ;
public void testReadMDNIssue97 ( ) throws Exception { final String sPrefix = " mdn/issue97 " ; final IReadableResource aHeaderRes = new ClassPathResource ( sPrefix + " .header " ) ; assertTrue ( aHeaderRes . exists ( ) ) ; final IReadableResource aPayloadRes = new ClassPathResource ( sPrefix + " .payload " ) ; assertTrue ( aPayloadRes . exists ( ) ) ; if ( false ) { final IReadableResource aCertRes = new ClassPathResource ( sPrefix + " .pem " ) ; assertTrue ( aCertRes . exists ( ) ) ; } final HttpHeaderMap aHeaders = new HttpHeaderMap ( ) ; try ( NonBlockingBufferedReader aBR = new NonBlockingBufferedReader ( aHeaderRes . getReader ( StandardCharsets . ISO_8859_1 ) ) ) { String s ; while ( ( s = aBR . readLine ( ) ) ! = null ) { final int i = s . indexOf ( ':' ) ; final String sName = s . substring ( 0 , i ) . trim ( ) ; final String sValue = s . substring ( i + 1 ) . trim ( ) ; aHeaders . addHeader ( sName , sValue ) ; } } if ( false ) assertEquals ( " <MOKOsi42435716cf621589dnode1POP000046@sfgt1.unix.fina.hr> " , aHeaders . getFirstHeaderValue ( " Message-ID " ) ) ; final AS2Message aMsg = new AS2Message ( ) ; final IMessageMDN aMDN = new AS2MessageMDN ( aMsg ) ; aMDN . headers ( ) . addAllHeaders ( aHeaders ) ; final MimeBodyPart aPart = new MimeBodyPart ( AS2HttpHelper . getAsInternetHeaders ( aMDN . headers ( ) ) , StreamHelper . getAllBytes ( aPayloadRes ) ) ; assertNotNull ( aPart ) ; aMsg . getMDN ( ) . setData ( aPart ) ; final ICryptoHelper aCryptoHelper = AS2Helper . getCryptoHelper ( ) ; assertFalse ( aCryptoHelper . isSigned ( aPart ) ) ; assertFalse ( aCryptoHelper . isEncrypted ( aPart ) ) ; assertFalse ( aCryptoHelper . isCompressed ( aPart . getContentType ( ) ) ) ; final Consumer < X509Certificate > aCertHolder = null ; AS2Helper . parseMDN ( aMsg , null , true , aCertHolder ) ; }
public Spliterator < Entry < String , Object > > spliterator ( ) { return new CheckedEntrySpliterator ( wrapped . spliterator ( ) ) ; }
public int compareTo ( final Term that ) { if ( that . getClass ( ) = = getClass ( ) ) return name . compareTo ( that . name ( ) ) ; return that . getClass ( ) . getName ( ) . compareTo ( getClass ( ) . getName ( ) ) ;
public boolean run ( Integer [ ] unsorted , Integer [ ] sorted , String input ) { this . input = input ; HashMap < Integer , String > cHashMap = new HashMap < Integer , String > ( HashMap . Type . CHAINING , ARRAY_SIZE / 2 ) ; java . util . Map < Integer , String > jMap = cHashMap . toMap ( ) ; if ( ! testJavaMap ( jMap , Integer . class , String . class , name , unsorted , sorted , input ) ) return false ; return true ; }
public X509Certificate getCertificate ( final String sAlias ) throws OpenAS2Exception { try {
public void testFancyWriter ( ) throws IOException { try ( Writer fileWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , StandardCharsets . UTF_8 ) ) ) {
public static final long multiplyUsingShift ( int a , int b ) { int bits = 1 ; int bitInteger = Math . abs ( b ) ; while ( bitInteger > 0 ) { bitInteger / = 2 ; bits + + ; } long biggerInteger = ( int ) Math . pow ( 2 , bits ) ; long difference = biggerInteger - b ; long result = a < < bits ; int diffInteger = a ; while ( diffInteger > 0 ) { result - = difference ; diffInteger - - ; } return result ; }
public void call ( Iterator < PlannedRow > t ) throws Exception { if ( output = = null ) { output = ( RandomOutput ) Output . outputFor ( config ) ; } output . applyMutations ( Lists . newArrayList ( t ) ) ; }
public void handleError ( @Nonnull final IMessage aMsg , @Nonnull final OpenAS2Exception aSrcEx ) { aSrcEx . addSource ( OpenAS2Exception . SOURCE_MESSAGE , aMsg ) ; aSrcEx . terminate ( ) ; try {
static void detachment ( Sentence mainSentence , Sentence subSentence , int side , boolean checkTermAgain , DerivationContext nal ) { Statement statement = ( Statement ) mainSentence . term ; if ( ! ( statement instanceof Implication ) & & ! ( statement instanceof Equivalence ) ) { return ; } Term subject = statement . getSubject ( ) ; Term predicate = statement . getPredicate ( ) ; Term content ; Term term = subSentence . term ; if ( ( side = = 0 ) & & ( ! checkTermAgain | | term . equals ( subject ) ) ) { content = predicate ; } else if ( ( side = = 1 ) & & ( ! checkTermAgain | | term . equals ( predicate ) ) ) { content = subject ; } else { return ; } if ( ( content instanceof Statement ) & & ( ( Statement ) content ) . invalid ( ) ) { return ; } Sentence taskSentence = nal . getCurrentTask ( ) . sentence ; Sentence beliefSentence = nal . getCurrentBelief ( ) ; if ( beliefSentence = = null ) return ; int order = statement . getTemporalOrder ( ) ; long occurrence_time = nal . getTheNewStamp ( ) . getOccurrenceTime ( ) ; if ( ( order ! = ORDER_NONE ) & & ( order ! = ORDER_INVALID ) ) { long baseTime = subSentence . getOccurenceTime ( ) ; if ( baseTime = = Stamp . ETERNAL ) { baseTime = nal . getTime ( ) ; } long inc = order * Parameters . DURATION ; occurrence_time = ( side = = 0 ) ? baseTime + inc : baseTime - inc ; } TruthValue beliefTruth = beliefSentence . truth ; TruthValue truth1 = mainSentence . truth ; TruthValue truth2 = subSentence . truth ; TruthValue truth = null ; boolean strong = false ; BudgetValue budget ; if ( taskSentence . isQuestion ( ) ) { if ( statement instanceof Equivalence ) { budget = BudgetFunctions . backward ( beliefTruth , nal ) ; } else if ( side = = 0 ) { budget = BudgetFunctions . backwardWeak ( beliefTruth , nal ) ; } else { budget = BudgetFunctions . backward ( beliefTruth , nal ) ; } } else if ( taskSentence . isQuest ( ) ) { if ( statement instanceof Equivalence ) { budget = BudgetFunctions . backwardWeak ( beliefTruth , nal ) ; } else if ( side = = 0 ) { budget = BudgetFunctions . backward ( beliefTruth , nal ) ; } else { budget = BudgetFunctions . backwardWeak ( beliefTruth , nal ) ; } } else { if ( taskSentence . isGoal ( ) ) { if ( statement instanceof Equivalence ) { truth = TruthFunctions . desireStrong ( truth1 , truth2 ) ; strong = true ; } else if ( side = = 0 ) { truth = TruthFunctions . desireInd ( truth1 , truth2 ) ; } else { truth = TruthFunctions . desireDed ( truth1 , truth2 ) ; strong = true ; } } else { if ( statement instanceof Equivalence ) { truth = TruthFunctions . analogy ( truth2 , truth1 ) ; strong = true ; } else if ( side = = 0 ) { truth = TruthFunctions . deduction ( truth1 , truth2 ) ; strong = true ; } else { truth = TruthFunctions . abduction ( truth2 , truth1 ) ; } } budget = BudgetFunctions . forward ( truth , nal ) ; } if ( ! Variables . indepVarUsedInvalid ( content ) ) { boolean allowOverlap = taskSentence . isJudgment ( ) & & strong ;
public static void main ( final String [ ] args ) throws Exception { if ( false ) GlobalDebug . setDebugModeDirect ( false ) ; Proxy aHttpProxy = null ; if ( false ) aHttpProxy = new Proxy ( Proxy . Type . HTTP , new InetSocketAddress ( " 172.30.9.6 " , 8080 ) ) ; if ( false ) HTTPHelper . setHTTPOutgoingDumperFactory ( x - > new HTTPOutgoingDumperStreamBased ( System . out ) ) ; if ( false ) HTTPHelper . setHTTPIncomingDumperFactory ( ( ) - > new HTTPIncomingDumperStreamBased ( new NonClosingOutputStream ( System . out ) ) ) ; final AS2ClientSettings aSettings = new AS2ClientSettings ( ) ; aSettings . setKeyStore ( EKeyStoreType . PKCS12 , new File ( " src/test/resources/mendelson/key3.pfx " ) , " test " ) ; aSettings . setSenderData ( " mycompanyAS2 " , " phax.as2-lib@github.com " , " key3 " ) ; aSettings . setReceiverData ( " mendelsontestAS2 " , " mendelsontestAS2 " , " http://testas2.mendelson-e-c.com:8080/as2/HttpReceiver " ) ; final X509Certificate aReceiverCertificate = AS2KeyStoreHelper . readX509Certificate ( " src/test/resources/mendelson/key4.cer " ) ; aSettings . setReceiverCertificate ( aReceiverCertificate ) ; aSettings . setPartnershipName ( aSettings . getSenderAS2ID ( ) + " _ " + aSettings . getReceiverAS2ID ( ) ) ; final ECryptoAlgorithmSign eSignAlgo = ECryptoAlgorithmSign . DIGEST_SHA1 ; final ECryptoAlgorithmCrypt eCryptAlgo = ECryptoAlgorithmCrypt . CRYPT_3DES ; final ECompressionType eCompress = ECompressionType . ZLIB ; final boolean bCompressBeforeSigning = false ; if ( eSignAlgo ! = null ) aSettings . setMDNOptions ( new DispositionOptions ( ) . setMICAlg ( eSignAlgo ) . setMICAlgImportance ( DispositionOptions . IMPORTANCE_REQUIRED ) . setProtocol ( DispositionOptions . PROTOCOL_PKCS7_SIGNATURE ) . setProtocolImportance ( DispositionOptions . IMPORTANCE_REQUIRED ) ) ; if ( false ) aSettings . setMDNOptions ( " " ) ; aSettings . setEncryptAndSign ( eCryptAlgo , eSignAlgo ) ; aSettings . setCompress ( eCompress , bCompressBeforeSigning ) ; aSettings . setMessageIDFormat ( " github-phax-as2-lib-$date.uuuuMMdd-HHmmssZ$-$rand.1234$@$msg.sender.as2_id$_$msg.receiver.as2_id$ " ) ; aSettings . setRetryCount ( 1 ) ; aSettings . setConnectTimeoutMS ( 10_000 ) ; aSettings . setReadTimeoutMS ( 10_000 ) ; final AS2ClientRequest aRequest = new AS2ClientRequest ( " AS2 test message from as2-lib " ) ; if ( false ) aRequest . setData ( new File ( " src/test/resources/mendelson/testcontent.attachment " ) , StandardCharsets . ISO_8859_1 ) ; else aRequest . setData ( new DataHandler ( new FileDataSource ( new File ( " src/test/resources/mendelson/testcontent.attachment " ) ) ) ) ; aRequest . setContentType ( CMimeType . TEXT_PLAIN . getAsString ( ) ) ; aRequest . setContentTransferEncoding ( EContentTransferEncoding . BASE64 ) ; final AS2ClientResponse aResponse = new AS2Client ( ) . setHttpProxy ( aHttpProxy ) . sendSynchronous ( aSettings , aRequest ) ; if ( aResponse . hasException ( ) ) LOGGER . info ( aResponse . getAsString ( ) ) ; LOGGER . info ( " Done " ) ; }
public MimeBodyPart sign ( @Nonnull final MimeBodyPart aPart , @Nonnull final X509Certificate aX509Cert , @Nonnull final PrivateKey aPrivateKey , @Nonnull final ECryptoAlgorithmSign eAlgorithm , final boolean bIncludeCertificateInSignedContent ) throws GeneralSecurityException , SMIMEException , MessagingException , OperatorCreationException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( aX509Cert , " X509Cert " ) ; ValueEnforcer . notNull ( aPrivateKey , " PrivateKey " ) ; ValueEnforcer . notNull ( eAlgorithm , " Algorithm " ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " BCCryptoHelper.sign; X509 subject= " + aX509Cert . getSubjectX500Principal ( ) . getName ( ) + " ; algorithm= " + eAlgorithm + " ; includeCertificateInSignedContent= " + bIncludeCertificateInSignedContent ) ; aX509Cert . checkValidity ( ) ; final List < X509Certificate > aCertList = new ArrayList < X509Certificate > ( ) ; aCertList . add ( aX509Cert ) ; final JcaCertStore aCertStore = new JcaCertStore ( aCertList ) ; final ASN1EncodableVector aSignedAttrs = new ASN1EncodableVector ( ) ; final SMIMECapabilityVector aCapabilities = new SMIMECapabilityVector ( ) ; aCapabilities . addCapability ( eAlgorithm . getOID ( ) ) ; aSignedAttrs . add ( new SMIMECapabilitiesAttribute ( aCapabilities ) ) ; final SMIMESignedGenerator aSGen = new SMIMESignedGenerator ( ) ; aSGen . addSignerInfoGenerator ( new JcaSimpleSignerInfoGeneratorBuilder ( ) . setProvider ( BouncyCastleProvider . PROVIDER_NAME ) . setSignedAttributeGenerator ( new AttributeTable ( aSignedAttrs ) ) . build ( eAlgorithm . getSignAlgorithmName ( ) , aPrivateKey , aX509Cert ) ) ; if ( bIncludeCertificateInSignedContent ) { aSGen . addCertificates ( aCertStore ) ; } final MimeMultipart aSignedData = aSGen . generate ( aPart ) ; final MimeBodyPart aTmpBody = new MimeBodyPart ( ) ; aTmpBody . setContent ( aSignedData ) ; aTmpBody . setHeader ( CAS2Header . HEADER_CONTENT_TYPE , aSignedData . getContentType ( ) ) ; return aTmpBody ; }
public static Output create ( Config config ) { if ( ! config . hasPath ( TYPE_CONFIG_NAME ) ) { throw new RuntimeException ( " Output type not specified " ) ; } String outputType = config . getString ( TYPE_CONFIG_NAME ) ; Output output ; switch ( outputType ) { case " kudu " : output = new KuduOutput ( ) ; break ; case " kafka " : output = new KafkaOutput ( ) ; break ; case " log " : output = new LogOutput ( ) ; break ; case " hive " : output = new HiveOutput ( ) ; break ; case " filesystem " : output = new FileSystemOutput ( ) ; break ; case " jdbc " : output = new JdbcOutput ( ) ; break ; case " hbase " : output = new HBaseOutput ( ) ; break ; case " zookeeper " : output = new ZooKeeperOutput ( ) ; break ; default : try { Class < ? > clazz = Class . forName ( outputType ) ; Constructor < ? > constructor = clazz . getConstructor ( ) ; output = ( Output ) constructor . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } output . configure ( config ) ; return output ; }
default void parse ( InputStream input , Config destination , ParsingMode parsingMode , Charset charset ) { CharsetDecoder decoder = charset . newDecoder ( ) ; decoder . onMalformedInput ( CodingErrorAction . REPORT ) ; decoder . onUnmappableCharacter ( CodingErrorAction . REPORT ) ; Reader reader = new BufferedReader ( new InputStreamReader ( input , decoder ) ) ; parse ( reader , destination , parsingMode ) ; }
private void decisionMaking ( Task task ) { Goal goal = ( Goal ) task . getSentence ( ) ; float desire = 2 * goal . getTruth ( ) . getExpectation ( ) - 1 ; float quality = ( desire < 0 ) ? 0 : desire ; task . setQuality ( quality ) ; }
public void testNoLastUpdated ( ) { Config config = ConfigFactory . empty ( ) ; AppendPlanner ap = new AppendPlanner ( ) ; assertNoValidationFailures ( ap , config ) ; ap . configure ( config ) ; List < Tuple2 < MutationType , Dataset < Row > > > planned = ap . planMutationsForSet ( dataFrame ) ; assertEquals ( planned . size ( ) , 1 ) ; Dataset < Row > plannedDF = planned . get ( 0 ) . _2 ( ) ; assertEquals ( planned . get ( 0 ) . _1 ( ) , MutationType . INSERT ) ; assertEquals ( plannedDF . count ( ) , 1 ) ; Row plannedRow = plannedDF . collectAsList ( ) . get ( 0 ) ; plannedRow . get ( plannedRow . fieldIndex ( " lastupdated " ) ) ; }
public List < Term > asTermList ( ) { List l = new ArrayList ( term . length ) ; addTermsTo ( l ) ; return l ; }
public static Term make ( Term term1 , Term term2 , Memory memory ) { TreeSet < Term > set ; if ( ( term1 instanceof SetInt ) & & ( term2 instanceof SetInt ) ) { set = new TreeSet < Term > ( ( ( CompoundTerm ) term1 ) . cloneTermsList ( ) ) ; set . addAll ( ( ( CompoundTerm ) term2 ) . cloneTermsList ( ) ) ; return SetInt . make ( set , memory ) ; } if ( ( term1 instanceof SetExt ) & & ( term2 instanceof SetExt ) ) { set = new TreeSet < Term > ( ( ( CompoundTerm ) term1 ) . cloneTermsList ( ) ) ; set . retainAll ( ( ( CompoundTerm ) term2 ) . cloneTermsList ( ) ) ; return SetExt . make ( set , memory ) ; } if ( term1 instanceof IntersectionExt ) { set = new TreeSet < Term > ( ( ( CompoundTerm ) term1 ) . cloneTermsList ( ) ) ; if ( term2 instanceof IntersectionExt ) { set . addAll ( ( ( CompoundTerm ) term2 ) . cloneTermsList ( ) ) ; } else { set . add ( ( Term ) term2 . clone ( ) ) ; } } else if ( term2 instanceof IntersectionExt ) { set = new TreeSet < Term > ( ( ( CompoundTerm ) term2 ) . cloneTermsList ( ) ) ; set . add ( ( Term ) term1 . clone ( ) ) ; } else { set = new TreeSet < Term > ( ) ; set . add ( ( Term ) term1 . clone ( ) ) ; set . add ( ( Term ) term2 . clone ( ) ) ; } return make ( set , memory ) ; }
void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; }
public boolean after ( final Stamp s , final int duration ) { if ( isEternal ( ) | | s . isEternal ( ) ) return false ; return order ( s . occurrenceTime , occurrenceTime , duration ) = = TemporalRules . ORDER_FORWARD ; }
public void testKeyWithSpaces ( ) throws Exception { String key = " key with spaces " ; client . set ( key , 0 , " " ) ; assertNotNull ( " Couldn't get the key with spaces in it. " , client . get ( key ) ) ; }
public boolean remove ( T key ) { int hashedKey = hashingFunction ( key ) ; List < T > list = map [ hashedKey ] ; if ( list . remove ( key ) ) { size - - ; return true ; } return false ; }
protected Node < T > removeValue ( T value ) { Node < T > nodeToRemove = super . removeValue ( value ) ; if ( nodeToRemove ! = null ) { if ( nodeToRemove . parent ! = null ) { Node < T > nodeParent = nodeToRemove . parent ; while ( nodeParent . parent ! = null ) { this . splay ( nodeParent ) ; } } } return nodeToRemove ; }
public boolean onMenuItemClick ( MenuItem item ) { final int itemId = item . getItemId ( ) ; app . oMPDAsyncHelper . execAsync ( new Runnable ( ) { @Override public void run ( ) { boolean replace = false ; boolean play = false ; switch ( itemId ) { case ADDNREPLACEPLAY : replace = true ; play = true ; break ; case ADDNREPLACE : replace = true ; break ; case ADDNPLAY : play = true ; break ; } try { app . oMPDAsyncHelper . oMPD . add ( artist , album , replace , play ) ; Tools . notifyUser ( String . format ( getResources ( ) . getString ( R . string . albumAdded ) , album ) , getActivity ( ) ) ; } catch ( MPDServerException e ) { e . printStackTrace ( ) ; } } } ) ; return true ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . next ; } return builder . toString ( ) ; }
public List < Artist > getArtists ( boolean useAlbumArtist ) throws MPDServerException { List < String > artistNames = useAlbumArtist ? listAlbumArtists ( ) : listArtists ( true ) ; final List < Artist > artists = new ArrayList < > ( artistNames . size ( ) ) ; if ( null ! = artistNames & & ! artistNames . isEmpty ( ) ) { for ( String artist : artistNames ) { artists . add ( new Artist ( artist , MPD . showArtistAlbumCount ( ) ? getAlbumCount ( artist , useAlbumArtist ) : 0 ) ) ; } } Collections . sort ( artists ) ; return artists ; }
public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } @Override public void onAudioFocusChange ( int focusChange ) { if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS_TRANSIENT ) { mediaPlayer . setVolume ( 0.2f , 0.2f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_GAIN ) { mediaPlayer . setVolume ( 1f , 1f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS ) { stop ( ) ; } } }
private void combined ( QuadrantData data ) { this . quad1 + = data . quad1 ; this . quad2 + = data . quad2 ; this . quad3 + = data . quad3 ; this . quad4 + = data . quad4 ; }
public void before ( ) { schemaWithoutMT = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " other " , DataTypes . StringType , true ) ) ) ; schemaWithMT = schemaWithoutMT . add ( DataTypes . createStructField ( MutationType . MUTATION_TYPE_FIELD_NAME , DataTypes . StringType , false ) ) ; schemaWithTMs = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " first " , DataTypes . StringType , true ) , DataTypes . createStructField ( " second " , DataTypes . StringType , true ) ) ) ; firstTM = new DummyTimeModel ( ) ; secondTM = new DummyTimeModel ( ) ; firstTM . configure ( ConfigFactory . empty ( ) , Lists . newArrayList ( " first " ) ) ; secondTM . configure ( ConfigFactory . empty ( ) , Lists . newArrayList ( " second " ) ) ; }
public static void main ( String [ ] arg ) { NAR nar = new DefaultNARBuilder ( ) . setConceptBagSize ( 2048 ) . build ( ) ; nar . param ( ) . duration . set ( 5 ) ; nar . param ( ) . noiseLevel . set ( 0 ) ; nar . param ( ) . shortTermMemorySize . set ( 35 ) ; NARio nario = new NARio ( nar ) ; new NARSwing ( nar ) ; nar . start ( 100 , 2 ) ; }
static Object parseValue ( CharacterInput input , char firstChar , TomlParser parser ) { switch ( firstChar ) { case '{' :
public Performance print ( ) { super . print ( ) ; System . out . print ( " ,  " + df . format ( getCycleTimeMS ( ) / totalCycles * 1000.0 ) + "  ns/cycle,  " + ( ( ( float ) totalCycles ) / ( warmups + repeats ) ) + "  cycles/run " ) ; return this ;
private char nextUseful ( boolean skipComments ) { char c = ' ' ; while ( hasNext ( ) & & ( c = = ' ' | | c = = '\t' | | c = = '\r' | | c = = '\n' | | ( c = = '#' & & skipComments ) ) ) { c = next ( ) ; if ( skipComments & & c = = '#' ) { int nextLinebreak = data . indexOf ( '\n' , pos ) ; if ( nextLinebreak = = - 1 ) { pos = data . length ( ) ; } else { pos = nextLinebreak + 1 ; line + + ; } } else if ( c = = '\n' ) { line + + ; } } return c ; }
public void setupResend ( ) { Operation op = getCurrentWriteOp ( ) ; if ( op ! = null ) { op . getBuffer ( ) . reset ( ) ; } while ( hasReadOp ( ) ) { op = removeCurrentReadOp ( ) ; getLogger ( ) . warn ( " Discarding partially completed op: %s " , op ) ; op . cancel ( ) ; } wbuf . clear ( ) ; rbuf . clear ( ) ; toWrite = 0 ; protocolErrors = 0 ; }
public static byte [ ] encodeNum ( long l , int maxBytes ) { byte [ ] rv = new byte [ maxBytes ] ; for ( int i = 0 ; i < rv . length ; i + + ) { int pos = rv . length - i - 1 ; rv [ pos ] = ( byte ) ( ( l > > ( 8 * i ) ) & 0xff ) ; } int firstNonZero = 0 ; for ( ; firstNonZero < rv . length & & rv [ firstNonZero ] = = 0 ; firstNonZero + + ) { } if ( firstNonZero > 0 ) { byte [ ] tmp = new byte [ rv . length - firstNonZero ] ; System . arraycopy ( rv , firstNonZero , tmp , 0 , rv . length - firstNonZero ) ; rv = tmp ; } return rv ; }
public void testRangeMaxSegmentTree ( ) { java . util . List < SegmentTree . Data . RangeMaximumData < Integer > > segments = new ArrayList < SegmentTree . Data . RangeMaximumData < Integer > > ( ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 0 , ( Integer ) 4 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 1 , ( Integer ) 2 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 2 , ( Integer ) 6 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 3 , ( Integer ) 3 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 4 , ( Integer ) 1 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 5 , ( Integer ) 5 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 6 , ( Integer ) 0 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 7 , 17 , ( Integer ) 7 ) ) ; testRangeMaxSegmentTree ( segments ) ; Collections . shuffle ( segments ) ; testRangeMaxSegmentTree ( segments ) ; Collections . sort ( segments ) ; testRangeMaxSegmentTree ( segments ) ; Collections . sort ( segments , REVERSE ) ; testRangeMaxSegmentTree ( segments ) ; }
< T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public String toString ( ) { int attrCount = getAttributeCount ( ) ; StringBuilder buf = new StringBuilder ( name . length ( ) + 20 + ( attrCount * 8 ) ) ; buf . append ( StatsKey . class . getSimpleName ( ) ) ; buf . append ( " [name= " ) ; buf . append ( name ) ; if ( attrCount > 0 ) { buf . append ( " ,attrs= " ) ; appendAttributes ( buf ) ; } buf . append ( ']' ) ; return buf . toString ( ) ; }
public abstract List < PlannedRecord > planOperations ( List < GenericRecord > arrivingRecords , List < GenericRecord > existingRecords , RecordModel recordModel ) throws Exception ; public List < PlannedRecord > planOperations ( List < GenericRecord > arrivingRecords , RecordModel recordModel ) throws Exception { return planOperations ( arrivingRecords , null , recordModel ) ; } public static String currentTimestampString ( ) { return new Date ( System . currentTimeMillis ( ) ) . toString ( ) ; } public abstract boolean requiresExistingRecords ( ) ; public abstract boolean requiresKeyColocation ( ) ; public abstract Set < OperationType > getEmittedOperationTypes ( ) ; public static Planner plannerFor ( Properties props ) throws Exception { String plannerName = props . getProperty ( " planner " ) ; Properties plannerProps = PropertiesUtils . prefixProperties ( props , " planner. " ) ; Planner planner = null ; switch ( plannerName ) { case " upsert " : planner = new UpsertPlanner ( plannerProps ) ; break ; case " history " : planner = new HistoryPlanner ( plannerProps ) ; break ; case " insertonly " : planner = new InsertOnlyPlanner ( plannerProps ) ; break ; default : Class < ? > clazz = Class . forName ( plannerName ) ; Constructor < ? > constructor = clazz . getConstructor ( ) ; planner = ( Planner ) constructor . newInstance ( plannerProps ) ; } return planner ; } }
void dumpHeader ( @Nonnull String sName , @Nonnull String sValue ) ; default void finishedHeaders ( ) { } void dumpPayload ( int nByte ) ; void dumpPayload ( byte [ ] aBytes , int nOfs , int nLen ) ; default void finishedPayload ( ) { } default void close ( ) throws IOException { } @Nonnull default WrappedOutputStream getDumpOS ( @Nonnull final OutputStream aBaseOS ) { return new WrappedOutputStream ( aBaseOS ) { @Override public final void write ( final int b ) throws IOException { super . write ( b ) ; dumpPayload ( b ) ; } @Override public final void write ( final byte [ ] aBytes , final int nOfs , final int nLen ) throws IOException { super . write ( aBytes , nOfs , nLen ) ; dumpPayload ( aBytes , nOfs , nLen ) ; } } ; } }
String getHeader ( @Nonnull String sKey ) ; @Nullable String getHeader ( @Nonnull String sKey , @Nullable String sDelimiter ) ; @Nonnull @ReturnsMutableObject ( " design " ) InternetHeaders getHeaders ( ) ; @Nonnull @Nonempty String getHeadersDebugFormatted ( ) ; void setHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void addHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void setHeaders ( @Nullable InternetHeaders aHeaders ) ; @Nullable String getMessageID ( ) ; void setMessageID ( @Nullable String sMessageID ) ; @Nonnull String generateMessageID ( ) ; void updateMessageID ( ) ; @Nonnull @ReturnsMutableObject ( " Design " ) Partnership getPartnership ( ) ; void setPartnership ( @Nonnull Partnership aPartnership ) ; }
void processPauseRequest ( ) { new Thread ( new Runnable ( ) { @Override public void run ( ) { try { getMpdApplication ( ) ; if ( app ! = null ) { app . oMPDAsyncHelper . oMPD . pause ( ) ; } } catch ( MPDServerException e ) { Log . w ( MPDApplication . TAG , e . getMessage ( ) ) ; } } } ) . start ( ) ; updatePlayingInfo ( RemoteControlClient . PLAYSTATE_PAUSED ) ; }
public double get ( ) { return value ; }
public void setAttribute ( final String key , final String value ) { getAttributes ( ) . put ( key , value ) ; }
private E takeOutFirst ( int level ) { E selected = itemTable . get ( level ) . get ( 0 ) ; itemTable . get ( level ) . remove ( 0 ) ; mass - = ( level + 1 ) ; refresh ( ) ; return selected ; }
ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }
private static int nextSeparator ( String s , int first ) { int levelCounter = 0 ; int i = first ; while ( i < s . length ( ) - 1 ) { if ( isOpener ( s , i ) ) levelCounter + + ; else if ( isCloser ( s , i ) ) levelCounter - - ; else if ( s . charAt ( i ) = = ARGUMENT_SEPARATOR ) if ( levelCounter = = 0 ) break ; i + + ; } return i ; }
@Deprecated abstract protected Term getRange ( ) ; @Override protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory m ) { int numArgs = args . length - 1 ; if ( numArgs < 1 ) { throw new RuntimeException ( " Requires at least 1 arguments " ) ; } if ( numArgs < 2 ) { throw new RuntimeException ( " Requires at least 2 arguments " ) ; } Term lastTerm = args [ numArgs ] ; boolean variable = lastTerm instanceof Variable ; if ( ! variable ) { throw new RuntimeException ( " output can not be specified " ) ; } int numParam = numArgs - 1 ; Term [ ] x = new Term [ numParam ] ; System . arraycopy ( args , 1 , x , 0 , numParam ) ; Term y ; y = function ( m , x ) ; if ( y = = null ) { return null ; } Variable var = new Variable ( " $1 " ) ; operation = ( Operation ) operation . setComponent ( 0 , ( ( CompoundTerm ) operation . getSubject ( ) ) . setComponent ( numArgs , y , m ) , m ) ; float confidence = Parameters . DEFAULT_JUDGMENT_CONFIDENCE ; if ( variable ) { Sentence s = new Sentence ( operation , Symbols . JUDGMENT_MARK , new TruthValue ( 1.0f , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) , new Stamp ( m ) ) ; return Lists . newArrayList ( new Task ( s , new BudgetValue ( Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_FEEDBACK_DURABILITY , truthToQuality ( s . getTruth ( ) ) ) ) ) ; } else { return null ; } } public float equals ( Term a , Term b ) { return a . equals ( b ) ? 1.0f : 0.0f ; } }
public long decr ( String key , long by , long def , int exp ) { return mutateWithDefault ( Mutator . decr , key , by , def , exp ) ; }
public void onClick ( final View v ) { scrollToNowPlaying ( ) ; }
static Concept makeConcept ( String name , float priority ) { BudgetValue budg = new BudgetValue ( priority , priority , priority ) ; Concept s = new Concept ( budg , new Term ( name ) , nar . memory ) ; return s ; }
public void testDefaultDynamicPivot ( ) throws Exception { List < Row > sourceList = Lists . newArrayList ( RowFactory . create ( " A " , " hello " , " 1 " ) , RowFactory . create ( " A " , " world " , " 2 " ) , RowFactory . create ( " B " , " hello " , " 3 " ) , RowFactory . create ( " C " , " world " , " 4 " ) ) ; StructType schema = RowUtils . structTypeFor ( Lists . newArrayList ( " entity_id " , " key " , " value " ) , Lists . newArrayList ( " string " , " string " , " string " ) ) ; Dataset < Row > source = Contexts . getSparkSession ( ) . createDataFrame ( sourceList , schema ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " source " , source ) ; Config config = ConfigFactory . empty ( ) . withValue ( PivotDeriver . STEP_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " source " ) ) . withValue ( PivotDeriver . ENTITY_KEY_FIELD_NAMES_CONFIG , ConfigValueFactory . fromAnyRef ( Lists . newArrayList ( " entity_id " ) ) ) . withValue ( PivotDeriver . PIVOT_KEY_FIELD_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " key " ) ) . withValue ( PivotDeriver . PIVOT_VALUE_FIELD_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " value " ) ) ; PivotDeriver d = new PivotDeriver ( ) ; assertNoValidationFailures ( d , config ) ; d . configure ( config ) ; List < Row > results = d . derive ( dependencies ) . collectAsList ( ) ; assertEquals ( results . size ( ) , 3 ) ; assertTrue ( results . contains ( RowFactory . create ( " A " , " 1 " , " 2 " ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " B " , " 3 " , null ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " C " , null , " 4 " ) ) ) ; }
protected void nextNonEmptyLevel ( ) { if ( size ( ) = = 1 ) { int levelsTraversed = 0 ; do { currentLevel = ( currentLevel + 1 ) % levels ; levelsTraversed + + ; } while ( levelEmpty [ currentLevel ] ) ; levelIndex = ( levelIndex + levelsTraversed ) % DISTRIBUTOR . length ; } else { levelIndex = nextNonEmptyLevel ( levelIndex ) ; } if ( currentLevel < THRESHOLD ) { currentCounter = 1 ;
public ConceptProcessor newConceptProcessor ( Param p , ConceptBuilder c ) { return new SequentialMemoryCycle ( newConceptBag ( p ) , newSubconceptBag ( p ) , c ) ; }
private static boolean testQueue ( ) { { System . out . println ( " Queue. " ) ; Queue < Integer > queue = new Queue < Integer > ( ) ; for ( int i = 0 ; i < unsorted . length ; i + + ) { int item = unsorted [ i ] ; queue . enqueue ( item ) ; boolean exists = ( queue . getSize ( ) = = i + 1 ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + i + "  doesn't exists. " ) ; handleError ( queue ) ; return false ; } } System . out . println ( queue . toString ( ) ) ; int size = queue . getSize ( ) ; for ( int i = 0 ; i < size ; i + + ) { queue . dequeue ( ) ; boolean exists = ( queue . getSize ( ) = = unsorted . length - ( i + 1 ) ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + i + "  doesn't exists. " ) ; handleError ( queue ) ; return false ; } } System . out . println ( ) ; } return true ; }
protected List < Task > execute ( final Operation operation , final Term [ ] args , final Memory memory ) { final Term content = args [ 1 ] ; final TruthValue truth = new TruthValue ( 1 , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) ; final Sentence sentence = new Sentence ( content , Symbols . JUDGMENT_MARK , truth , new Stamp ( memory ) ) ; final float quality = BudgetFunctions . truthToQuality ( truth ) ; final BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY , quality ) ; final Task newTask = new Task ( sentence , budget , Task . EnumType . INPUT ) ; return Lists . newArrayList ( newTask ) ;
public void add ( char character ) { add ( new Node ( null , character ) ) ; }
void track ( Sensor tracker , long now ) ; void update ( Sensor tracker , long now ) ; void clear ( ) ; }
public final boolean canHandle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) { if ( ! sAction . equals ( getModuleAction ( ) ) ) return false ; final String sModProtocol = getAttributeAsString ( PARAM_PROTOCOL ) ; if ( sModProtocol = = null ) return false ; return sModProtocol . equals ( aMsg . getProtocol ( ) ) ; }
private void skipProlog ( ) throws IOException { reader . skip ( 2 ) ; while ( true ) { int next = peek ( ) ;
private void addPrefix ( int last_char_index ) { int parent_node = 0 ; int last_parent_node = - 1 ; while ( true ) { Edge edge = null ; parent_node = currentNode ; if ( isExplicit ( ) ) { edge = Edge . find ( currentNode , SuffixTree . characters [ last_char_index ] ) ; if ( edge ! = null ) { break ; } } else { edge = Edge . find ( currentNode , SuffixTree . characters [ firstCharIndex ] ) ; int span = lastCharIndex - firstCharIndex ; if ( SuffixTree . characters [ edge . firstCharIndex + span + 1 ] = = SuffixTree . characters [ last_char_index ] ) { break ; } parent_node = edge . split ( currentNode , firstCharIndex , lastCharIndex ) ; } edge = new Edge ( last_char_index , SuffixTree . characters . length - 1 , parent_node ) ; Edge . insert ( edge ) ; System . out . printf ( " Created edge to new leaf:  " + edge + " \ n " ) ; if ( last_parent_node > 0 ) { System . out . printf ( " Creating suffix link from node  " + last_parent_node + "  to node  " + parent_node + " . \ n " ) ; nodes . get ( last_parent_node ) . suffixNode = parent_node ; } last_parent_node = parent_node ; if ( currentNode = = 0 ) { System . out . printf ( " Can't follow suffix link, I'm at the root \ n " ) ; firstCharIndex + + ; } else { System . out . printf ( " Following suffix link from node  " + currentNode + "  to node  " + nodes . get ( currentNode ) . suffixNode + " . \ n " ) ; currentNode = nodes . get ( currentNode ) . suffixNode ; } canonize ( ) ; } if ( last_parent_node > 0 ) { System . out . printf ( " Creating suffix link from node  " + last_parent_node + "  to node  " + parent_node + " . \ n " ) ; nodes . get ( last_parent_node ) . suffixNode = parent_node ; } last_parent_node = parent_node ; lastCharIndex + + ; canonize ( ) ; } ;
boolean isDaemon ( ) ; boolean useNagleAlgorithm ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; int getReadBufSize ( ) ; HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; }
public void run ( ) { try { final MPD mpd = app . oMPDAsyncHelper . oMPD ;
public Object parseJsonDocument ( CharacterInput input ) { char firstChar = input . readCharAndSkip ( SPACES ) ; if ( firstChar = = '{' ) return parseObject ( input , new JsonConfig ( ) ) ; if ( firstChar = = '[' ) return parseArray ( input , new ArrayList < > ( ) ) ; throw new ParsingException ( " Invalid first character for a json document:  " + firstChar ) ; }
public OperationFuture < Boolean > flush ( final int delay ) { final AtomicReference < Boolean > flushResult = new AtomicReference < Boolean > ( null ) ; final ConcurrentLinkedQueue < Operation > ops = new ConcurrentLinkedQueue < Operation > ( ) ; CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { Operation op = opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { flushResult . set ( s . isSuccess ( ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; ops . add ( op ) ; return op ; } } ) ; return new OperationFuture < Boolean > ( null , blatch , flushResult , operationTimeout ) {
long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
protected boolean isSynth ( ) { return UIManager . getLookAndFeel ( ) . getClass ( ) . getName ( ) . indexOf ( " ynth " ) ! = - 1 ; }
public void testOneArrivingNoneExisting ( ) { p = new BitemporalHistoryPlanner ( config ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " hello " , 100L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 1 ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertTrue ( ( Long ) RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemstart " ) > = preplanSystemTime ) ; assertTrue ( ( Long ) RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemstart " ) < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_YES ) ; }
private static ScrobbleData decodeScrobbleData ( String s ) { String [ ] parts = s . split ( " ; " , 10 ) ; return new ScrobbleData ( StringUtilities . decode ( parts [ 0 ] ) , StringUtilities . decode ( parts [ 1 ] ) , Integer . parseInt ( parts [ 2 ] ) , Integer . parseInt ( parts [ 3 ] ) , StringUtilities . decode ( parts [ 4 ] ) , StringUtilities . decode ( parts [ 5 ] ) , parts [ 6 ] , Integer . parseInt ( parts [ 7 ] ) , parts [ 8 ] , Boolean . parseBoolean ( parts [ 9 ] ) ) ;
public static SecureRandom getSecureRandom ( ) { return RandomHelper . getSecureRandom ( ) ; }
StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }
public void testNestedRecords ( ) { var de = ObjectDeserializer . builder ( ) . build ( ) ; var deserialized = de . deserializeFields ( Engine . SERIALIZED , Engine : : new ) ; assertEquals ( new Engine ( ) , deserialized ) ; var ser = ObjectSerializer . builder ( ) . build ( ) ; var serialized = ser . serializeFields ( new Engine ( ) , Config : : inMemory ) ; assertEquals ( Engine . SERIALIZED , serialized ) ; var serialized2 = ser . serialize ( new Engine ( ) , CommentedConfig : : inMemory ) ; assertEquals ( Engine . SERIALIZED , serialized2 ) ; }
public void event ( final Class event , final Object [ ] a ) { if ( event = = Events . ConceptForget . class ) {
long getCommits ( ) ; double getFirst ( ) ; double getLast ( ) ; double getMin ( ) ; double getMax ( ) ; double getSum ( ) ; Object getField ( String name ) ; DataSet collectData ( ) ; DataSet drainData ( ) ; void restore ( DataSet dataSet ) ; void track ( Tracker tracker , long now ) ; void update ( Tracker tracker , long now ) ; void clear ( ) ; void setEventManager ( EventManager e ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInPp p , A arg ) { return visitDefault ( p , arg ) ; } public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmOp p , A arg ) { return visitDefault ( p , arg ) ; }
public Node < K , V > grandparent ( ) { assert parent ! = null ; assert parent . parent ! = null ; return parent . parent ; }
public void init ( ) { setSpeed ( 0 ) ; setSpeed ( 0 ) ; updateGUI ( ) ; nar . memory . event . on ( CycleStop . class , this ) ; }
public static terminal find ( int indx ) { Integer the_indx = new Integer ( indx ) ; return ( terminal ) _all_by_index . get ( the_indx ) ; }
private static Number parseNumber ( CharsWrapper valueChars ) { if ( valueChars . indexOfFirst ( ONLY_IN_FP_NUMBER ) ! = - 1 ) { return Utils . parseDouble ( valueChars ) ; } long longValue = Utils . parseLong ( valueChars , 10 ) ; int intValue = ( int ) longValue ; if ( intValue = = longValue ) { return intValue ; } return longValue ; }
public static boolean isCommonVariable ( final Variable v ) { String s = v . getName ( ) ; return s . charAt ( s . length ( ) - 1 ) = = '$' ; }
private static Document toDocument ( final IStringMap stringMap ) { final Document document = new Document ( ) ; for ( final Map . Entry < String , String > entry : stringMap . entrySet ( ) ) { document . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return document ; }
public void onCoverNotFound ( ) ; } private Collection < CoverDownloadListener > coverDownloadListener ; private CoverAsyncWorker oCoverAsyncWorker ; public CoverAsyncHelper ( MPDApplication app , SharedPreferences settings ) { this . app = app ; this . settings = settings ; HandlerThread oThread = new HandlerThread ( " CoverAsyncWorker " ) ; oThread . start ( ) ; oCoverAsyncWorker = new CoverAsyncWorker ( oThread . getLooper ( ) ) ; coverDownloadListener = new LinkedList < CoverDownloadListener > ( ) ; } public void addCoverDownloadListener ( CoverDownloadListener listener ) { coverDownloadListener . add ( listener ) ; } public void downloadCover ( String artist , String album , String path ) { CoverInfo info = new CoverInfo ( ) ; info . sArtist = artist ; info . sAlbum = album ; info . sPath = path ; oCoverAsyncWorker . obtainMessage ( EVENT_DOWNLOADCOVER , info ) . sendToTarget ( ) ; } public void handleMessage ( Message msg ) { switch ( msg . what ) { case EVENT_COVERDOWNLOADED : for ( CoverDownloadListener listener : coverDownloadListener ) listener . onCoverDownloaded ( ( Bitmap ) msg . obj ) ; break ; case EVENT_COVERNOTFOUND : for ( CoverDownloadListener listener : coverDownloadListener ) listener . onCoverNotFound ( ) ; break ; default : break ; } } private class CoverAsyncWorker extends Handler { public CoverAsyncWorker ( Looper looper ) { super ( looper ) ; } public void handleMessage ( Message msg ) { switch ( msg . what ) { case EVENT_DOWNLOADCOVER : CoverInfo info = ( CoverInfo ) msg . obj ; String url = null ; try { url = coverRetriever . getCoverUrl ( info . sArtist , info . sAlbum , info . sPath ) ; } catch ( Exception e1 ) { e1 . printStackTrace ( ) ; CoverAsyncHelper . this . obtainMessage ( EVENT_COVERNOTFOUND ) . sendToTarget ( ) ; } if ( url = = null ) { CoverAsyncHelper . this . obtainMessage ( EVENT_COVERNOTFOUND ) . sendToTarget ( ) ; return ; } Log . i ( MPDApplication . TAG , " Downloading cover art at url :  " + url ) ; Bitmap bmImg = download ( url ) ; if ( null = = bmImg & & url . endsWith ( " /cover.jpg " ) ) { bmImg = download ( url . replace ( " /cover.jpg " , " /cover.png " ) ) ; } if ( null = = bmImg ) { CoverAsyncHelper . this . obtainMessage ( EVENT_COVERNOTFOUND ) . sendToTarget ( ) ; } else { CoverAsyncHelper . this . obtainMessage ( EVENT_COVERDOWNLOADED , bmImg ) . sendToTarget ( ) ; } break ; default : } } } private Bitmap download ( String url ) { URL myFileUrl = null ; HttpURLConnection conn = null ; try { myFileUrl = new URL ( url ) ; conn = ( HttpURLConnection ) myFileUrl . openConnection ( ) ; conn . setDoInput ( true ) ; conn . setDoOutput ( false ) ; conn . connect ( ) ; InputStream is = conn . getInputStream ( ) ; Bitmap bmp = BitmapFactory . decodeStream ( is ) ; is . close ( ) ; conn . disconnect ( ) ; return bmp ; } catch ( MalformedURLException e ) { return null ; } catch ( IOException e ) { return null ; } finally { if ( null ! = conn ) { conn . disconnect ( ) ; } } } private class CoverInfo { public String sArtist ; public String sAlbum ; public String sPath ; } public enum CoverRetrievers { LASTFM , LOCAL ; } }
private long mutateWithDefault ( MutatorOperationImpl . Mutator t , String key , int by , long def ) { long rv = mutate ( t , key , by ) ; if ( rv = = - 1 ) { Future < Boolean > f = asyncStore ( StoreOperationImpl . StoreType . add , key , 0 , String . valueOf ( def ) ) ; try { if ( f . get ( ) ) { rv = def ; } else { rv = mutate ( t , key , by ) ; assert rv ! = - 1 : " Failed to mutate or init value " ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted waiting for store " , e ) ; } catch ( ExecutionException e ) { throw new RuntimeException ( " Failed waiting for store " , e ) ; } } return rv ; }
public boolean containsTerm ( final Term t ) { return Terms . contains ( term , t ) ; }
public void addPlugin ( final Plugin p ) { if ( p instanceof SensoryChannel ) { this . addSensoryChannel ( ( ( SensoryChannel ) p ) . getName ( ) , ( SensoryChannel ) p ) ; } else if ( p instanceof Operator ) { memory . addOperator ( ( Operator ) p ) ; } else if ( p instanceof Emotions ) { memory . emotion = ( Emotions ) p ; } else if ( p instanceof InternalExperience ) { memory . internalExperience = ( InternalExperience ) p ; } final PluginState ps = new PluginState ( p ) ; plugins . add ( ps ) ; emit ( Events . PluginsChange . class , p , null ) ; }
static Config concurrentCopy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) , true ) ; }
public void downloadCover ( final AlbumInfo albumInfo , final boolean priority ) { final CoverInfo info = new CoverInfo ( albumInfo ) ; info . setCoverMaxSize ( mCoverMaxSize ) ; info . setCachedCoverMaxSize ( mCachedCoverMaxSize ) ; info . setPriority ( priority ) ; info . setListener ( this ) ; tagListenerCovers ( albumInfo ) ; if ( albumInfo . isValid ( ) ) { CoverManager . getInstance ( ) . addCoverRequest ( info ) ;
protected Integer doInBackground ( Void . . . voids ) { Integer songIndex = Integer . valueOf ( - 1 ) ; try { songIndex = app . oMPDAsyncHelper . oMPD . getStatus ( ) . getSongPos ( ) ; } catch ( MPDServerException e ) { e ( PlaylistFragment . class . getSimpleName ( ) , " Cannot find the current playing song position :  " + e ) ; } return songIndex ; }
public void readTwoChunkBuffer ( ) throws Exception { InputStream empty = new ByteArrayInputStream ( " 2 \ r \ n12 \ r \ n1 \ na \ r \ n0 \ r \ n " . getBytes ( ) ) ; byte [ ] buf = new byte [ 3 ] ; ChunkedInputStream cIS = new ChunkedInputStream ( empty ) ; int ret = cIS . read ( buf , 0 , buf . length ) ; assertEquals ( " Read two chunk: 3 chars read " , 3 , ret ) ; assertEquals ( " Read one Chunk: corect data returned " , " 12a " ,
protected File getConfigurationFile ( @Nonnull final ICommonsMap < String , String > aInitParams ) throws ServletException { final String sConfigurationFilename = aInitParams . get ( SERVLET_INIT_PARAM_AS2_SERVLET_CONFIG_FILENAME ) ; if ( StringHelper . hasNoText ( sConfigurationFilename ) ) throw new ServletException ( " Servlet Init-Parameter ' " + SERVLET_INIT_PARAM_AS2_SERVLET_CONFIG_FILENAME + " ' is missing or empty! " ) ; try {
Path getNioPath ( ) ; void save ( ) ; void load ( ) ; @Override void close ( ) ; @Override default FileConfig checked ( ) { return new CheckedFileConfig ( this ) ; } < R > R bulkUpdate ( Function < ? super Config , R > action ) ; default void bulkUpdate ( Consumer < ? super Config > action ) { bulkUpdate ( config - > { action . accept ( config ) ; return null ; } ) ; } static FileConfig of ( File file ) { return of ( file . toPath ( ) ) ; } static FileConfig of ( File file , ConfigFormat < ? extends Config > format ) { return of ( file . toPath ( ) , format ) ; } static FileConfig of ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return of ( file , format ) ; } static FileConfig of ( Path file , ConfigFormat < ? extends Config > format ) { return builder ( file , format ) . build ( ) ; } static FileConfig of ( String filePath ) { return of ( Paths . get ( filePath ) ) ; } static FileConfig of ( String filePath , ConfigFormat < ? > format ) { return of ( Paths . get ( filePath ) , format ) ; } @Deprecated static FileConfig ofConcurrent ( File file ) { return ofConcurrent ( file . toPath ( ) ) ; } @Deprecated static FileConfig ofConcurrent ( File file , ConfigFormat < ? > format ) { return ofConcurrent ( file . toPath ( ) , format ) ; } @Deprecated static FileConfig ofConcurrent ( Path file ) { return builder ( file ) . concurrent ( ) . build ( ) ; } @Deprecated static FileConfig ofConcurrent ( Path file , ConfigFormat < ? > format ) { return builder ( file , format ) . concurrent ( ) . build ( ) ; } @Deprecated static FileConfig ofConcurrent ( String filePath ) { return ofConcurrent ( Paths . get ( filePath ) ) ; } @Deprecated static FileConfig ofConcurrent ( String filePath , ConfigFormat < ? > format ) { return ofConcurrent ( Paths . get ( filePath ) , format ) ; } static FileConfigBuilder builder ( File file ) { return builder ( file . toPath ( ) ) ; } static FileConfigBuilder builder ( File file , ConfigFormat < ? > format ) { return builder ( file . toPath ( ) , format ) ; } static FileConfigBuilder builder ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return builder ( file , format ) ; } static FileConfigBuilder builder ( Path file , ConfigFormat < ? > format ) { return new FileConfigBuilder ( file , format ) ; } static FileConfigBuilder builder ( String filePath ) { return builder ( Paths . get ( filePath ) ) ; } static FileConfigBuilder builder ( String filePath , ConfigFormat < ? > format ) { return builder ( Paths . get ( filePath ) , format ) ; } }
public void addStyle ( TextAttribute attr , Object value , int charStart , int charEnd ) { if ( stext ! = null ) { stext . addAttribute ( attr , value , charStart , charEnd ) ;
private static boolean testLinkedQueue ( ) { String name = " Queue <Integer> [linked] " ; Collection < Integer > lCollection = linkedQueue . toCollection ( ) ; if ( ! testJavaCollection ( lCollection , Integer . class , name ) ) return false ; return true ; }
public static ExampleFileInput getExample ( String id ) throws Exception { return new ExampleFileInput ( load ( " ./nal/ " + id + " .nal " ) ) ; }
public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( true ) { return super . onKeyDown ( keyCode , event ) ; } nowPlaying = ( NowPlayingFragment ) getSupportFragmentManager ( ) . findFragmentById ( R . id . nowPlayingFragment ) ; if ( nowPlaying . onKeyDown ( keyCode , event ) ) { return true ;
public String toString ( ) { return ToStringGenerator . getDerived ( super . toString ( ) ) . getToString ( ) ; }
KeyStore loadKeyStore ( @Nonnull InputStream aIS , @Nonnull char [ ] aPassword ) throws Exception ; @Nonnull KeyStore loadKeyStore ( @Nonnull String sFilename , @Nonnull char [ ] aPassword ) throws Exception ; boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithm eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithm eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithm eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bAllowCertificateInBodyPart ) throws Exception ; }
public Uri insert ( Uri uri , ContentValues initialValues ) { if ( sUriMatcher . match ( uri ) ! = SERVERS ) { throw new IllegalArgumentException ( " Unknown URI  " + uri ) ; } ContentValues values ; if ( initialValues ! = null ) { values = new ContentValues ( initialValues ) ; } else { values = new ContentValues ( ) ; } Long now = Long . valueOf ( System . currentTimeMillis ( ) ) ; if ( values . containsKey ( ServerColumns . NAME ) = = false ) { Resources r = Resources . getSystem ( ) ; values . put ( ServerColumns . NAME , r . getString ( android . R . string . untitled ) + now . toString ( ) ) ; } if ( values . containsKey ( ServerColumns . HOST ) = = false ) { values . put ( ServerColumns . HOST , " 0.0.0.0 " ) ; } if ( values . containsKey ( ServerColumns . PORT ) = = false ) { values . put ( ServerColumns . PORT , " 6600 " ) ; } if ( values . containsKey ( ServerColumns . STREAMING_PORT ) = = false ) { values . put ( ServerColumns . STREAMING_PORT , " 8000 " ) ; } if ( values . containsKey ( ServerColumns . STREAMING_URL ) = = false ) { values . put ( ServerColumns . STREAMING_URL , " " ) ; } if ( values . containsKey ( ServerColumns . PASSWORD ) = = false ) { values . put ( ServerColumns . PASSWORD , " " ) ; } SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; long rowId = db . insert ( SERVERS_TABLE_NAME , " server " , values ) ; if ( rowId > 0 ) { Uri noteUri = ContentUris . withAppendedId ( ServerColumns . CONTENT_URI , rowId ) ; getContext ( ) . getContentResolver ( ) . notifyChange ( noteUri , null ) ; return noteUri ; } throw new SQLException ( " Failed to insert row into  " + uri ) ; }
private Config parseJsonExpectationToConfig ( Config jsonExpect ) { return ( Config ) convertJsonExpectValue ( jsonExpect , List . of ( ) ) ; }
public void testClient ( ) { OperationException oe = new OperationException ( Operation . ErrorType . CLIENT , " CLIENT_ERROR nope " ) ; assertSame ( Operation . ErrorType . CLIENT , oe . getType ( ) ) ; assertEquals ( " OperationException: CLIENT: nope " , String . valueOf ( oe ) ) ; }
public void cycle ( Memory m ) { this . memory = m ; m . processNewTasks ( ) ; m . processNovelTask ( ) ; processConcepts ( m ) ; }
private static boolean testSplayTree ( ) { String bstName = " Splay Tree " ; BinarySearchTree < Integer > bst = new SplayTree < Integer > ( ) ; Collection < Integer > bstCollection = bst . toCollection ( ) ; if ( ! testJavaCollection ( bstCollection , Integer . class , bstName ) ) return false ; return true ; }
public void missingTypes ( ) { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( ComponentFactory . TYPE_CONFIG_NAME , " avro " ) ; paramMap . put ( AvroSchema . AVRO_FILE_CONFIG , " " ) ; config = ConfigFactory . parseMap ( paramMap ) ; AvroSchema avroSchema = new AvroSchema ( ) ; assertValidationFailures ( avroSchema , config ) ; }
public static AS2DispositionException wrap ( @Nonnull final Exception ex , @Nonnull final Supplier < DispositionType > aDispositionTypeSupplier , @Nonnull final Supplier < String > aTextSupplier ) { ValueEnforcer . notNull ( ex , " Exception " ) ; ValueEnforcer . notNull ( aDispositionTypeSupplier , " DispositionTypeSupplier " ) ; ValueEnforcer . notNull ( aTextSupplier , " TextSupplier " ) ; if ( ex instanceof AS2DispositionException ) return ( AS2DispositionException ) ex ; if ( ex instanceof AS2ProcessorException ) { final ICommonsList < AS2Exception > aCauses = ( ( AS2ProcessorException ) ex ) . getAllCauses ( ) ; if ( aCauses . size ( ) = = 1 ) { final AS2Exception aFirst = aCauses . getFirstOrNull ( ) ; if ( aFirst instanceof AS2DispositionException ) return ( AS2DispositionException ) aFirst ; } } return new AS2DispositionException ( aDispositionTypeSupplier . get ( ) , aTextSupplier . get ( ) , ex ) ; }
VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
public void testSumOfValues ( ) { assertEquals ( 1.1 + 2.5 + 4.7 , array5Vector . sumOfValues ( ) , Double . MIN_NORMAL ) ; }
public String getContentTransferEncoding ( @Nullable final String sDefault ) { return getAttribute ( CPartnershipIDs . PA_CONTENT_TRANSFER_ENCODING , sDefault ) ; }
public boolean remove ( T value ) { System . out . println ( " Removing  " + value + " \ n " + this . toString ( ) ) ; Node < T > node = this . getNode ( value ) ; if ( node = = null ) return false ; if ( node . keys . size ( ) > 1 ) { int index = node . keys . indexOf ( value ) ; node . keys . remove ( value ) ; if ( node . parent ! = null & & node . keys . size ( ) < lowSize ) { combined ( node ) ; } else if ( index ! = 0 & & index ! = node . keys . size ( ) ) { if ( index < node . children . size ( ) ) { Node < T > child = node . children . get ( index ) ; T childValue = child . keys . remove ( child . keys . size ( ) - 1 ) ; node . addKey ( childValue ) ; if ( child . keys . size ( ) = = 0 ) { node . children . remove ( index ) ; } else if ( child . keys . size ( ) = = 1 ) { combined ( child ) ; } } } else if ( index = = 0 & & node . children . size ( ) > 0 ) { Node < T > child = node . children . get ( 0 ) ; T childValue = child . keys . remove ( child . keys . size ( ) - 1 ) ; node . addKey ( childValue ) ; if ( child . parent ! = null & & child . keys . size ( ) > 0 & & child . keys . size ( ) < lowSize ) combined ( child ) ; } else if ( index = = node . keys . size ( ) & & node . children . size ( ) > 0 ) { Node < T > child = node . children . get ( index + 1 ) ; T childValue = child . keys . remove ( 0 ) ; node . addKey ( childValue ) ; if ( child . parent ! = null & & child . keys . size ( ) > 0 & & child . keys . size ( ) < lowSize ) combined ( child ) ; } } else { Node < T > parent = node . parent ; if ( parent = = null ) { System . out . println ( ) ; } else { parent . children . remove ( node ) ; } } size - - ; System . out . println ( " Removed  " + value + " \ n " + this . toString ( ) ) ; return true ; }
public Task doublePremiseTask ( final Term newContent , final TruthValue newTruth , final BudgetValue newBudget , boolean temporalAdd ) { if ( ! newBudget . aboveThreshold ( ) ) { return null ; } if ( ( newContent ! = null ) & & ( ! ( newContent instanceof Interval ) ) & & ( ! ( newContent instanceof Variable ) ) & & ( ! Sentence . invalidSentenceTerm ( newContent ) ) ) { if ( newContent . subjectOrPredicateIsIndependentVar ( ) ) { return null ; } Task derived = null ; try { final Sentence newSentence = new Sentence ( newContent , getCurrentTask ( ) . sentence . punctuation , newTruth , getTheNewStamp ( ) ) ; newSentence . producedByTemporalInduction = temporalAdd ; final Task newTask = Task . make ( newSentence , newBudget , getCurrentTask ( ) , getCurrentBelief ( ) ) ; if ( newTask ! = null ) { boolean added = derivedTask ( newTask , false , false , null , null ) ; if ( added & & temporalAdd ) { memory . temporalRuleOutputToGraph ( newSentence , newTask ) ; } if ( added ) { derived = newTask ; } } } catch ( CompoundTerm . UnableToCloneException e ) { return null ; } if ( temporalAdd & & Parameters . IMMEDIATE_ETERNALIZATION ) { try { TruthValue truthEt = TruthFunctions . eternalize ( newTruth ) ; Stamp st = getTheNewStamp ( ) . clone ( ) ; st . setEternal ( ) ; final Sentence newSentence = new Sentence ( newContent , getCurrentTask ( ) . sentence . punctuation , truthEt , st ) ; newSentence . producedByTemporalInduction = temporalAdd ; final Task newTask = Task . make ( newSentence , newBudget , getCurrentTask ( ) , getCurrentBelief ( ) ) ; if ( newTask ! = null ) { boolean added = derivedTask ( newTask , false , false , null , null ) ; if ( added & & temporalAdd ) { memory . temporalRuleOutputToGraph ( newSentence , newTask ) ; } } } catch ( CompoundTerm . UnableToCloneException e ) { return null ; } } return derived ; } return null ; }
public void testRedBlackTree ( ) { TestData data = Utils . generateTestData ( 1000 ) ; String bstName = " Red-Black Tree " ; RedBlackTree < Integer > bst = new RedBlackTree < Integer > ( ) ; Collection < Integer > bstCollection = bst . toCollection ( ) ; assertTrue ( TreeTest . testTree ( bst , Type . Integer , bstName , data . unsorted , data . invalid ) ) ; assertTrue ( JavaCollectionTest . testCollection ( bstCollection , Type . Integer , bstName , data . unsorted , data . sorted , data . invalid ) ) ;
public void addTab ( Tab tab ) { addTab ( tab , mTabs . isEmpty ( ) ) ; }
CommentedConfig createSubConfig ( ) ; static CommentedConfig of ( ConfigFormat < ? extends CommentedConfig > format ) { return new SimpleCommentedConfig ( format , false ) ; } static CommentedConfig ofConcurrent ( ConfigFormat < ? extends CommentedConfig > format ) { return new SimpleCommentedConfig ( format , false ) ; } static CommentedConfig inMemory ( ) { return InMemoryCommentedFormat . defaultInstance ( ) . createConfig ( ) ; } static CommentedConfig inMemoryConcurrent ( ) { return InMemoryCommentedFormat . defaultInstance ( ) . createConcurrentConfig ( ) ; } static CommentedConfig wrap ( Map < String , Object > map , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( map , format ) ; } static CommentedConfig copy ( UnmodifiableConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , false ) ; } static CommentedConfig copy ( UnmodifiableConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , false ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , false ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , false ) ; } static CommentedConfig concurrentCopy ( UnmodifiableConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , true ) ; } static CommentedConfig concurrentCopy ( UnmodifiableConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , true ) ; } static CommentedConfig concurrentCopy ( UnmodifiableCommentedConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , true ) ; } static CommentedConfig concurrentCopy ( UnmodifiableCommentedConfig config , ConfigFormat < ? > format ) { return new SimpleCommentedConfig ( config , format , true ) ; } static CommentedConfig fake ( Config config ) { if ( config instanceof CommentedConfig ) { return ( CommentedConfig ) config ; } return new FakeCommentedConfig ( config ) ; } }
public boolean run ( Integer [ ] unsorted , Integer [ ] sorted , String input ) { this . input = input ; if ( ! testJavaMap ( javaTreeMap , String . class , Integer . class , name , unsorted , sorted , input ) ) return false ; return true ; }
public Bucket parseBucket ( String sBucket ) throws ParseException { parseBucketCalled = true ; try { parseBucketsCalled = true ;
public String subText ( ) { String construct = null ; if ( MPD . sortAlbumsByYear ( ) & & 0 ! = year ) { construct = Long . toString ( year ) ; } if ( 0 ! = songCount ) { if ( construct ! = null ) construct + = "  -  " ; construct + = String . format ( 1 = = songCount ? singleTrackFormat : multipleTracksFormat , songCount , Music . timeToString ( duration ) ) ; } return construct ; }
public static boolean findSubstitute ( Random rnd , final char type , final Term term1 , final Term term2 , final Map < Term , Term > map1 , final Map < Term , Term > map2 ) { return findSubstitute ( rnd , type , term1 , term2 , new Map [ ] { map1 , map2 } ) ; }
public BlockingQueue < Operation > create ( ) { return new ArrayBlockingQueue < Operation > ( capacity ) ; }
public void testCarryForwardWhenNullMultipleOutOfOrderArrivingWithPreceding ( ) { p = new BitemporalHistoryPlanner ( ) ; config = config . withValue ( BitemporalHistoryPlanner . CARRY_FORWARD_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( true ) ) . withValue ( BitemporalHistoryPlanner . VALUE_FIELD_NAMES_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( Lists . newArrayList ( " value1 " , " value2 " ) ) ) ; assertNoValidationFailures ( p , config ) ; p . configure ( config ) ; arrivingSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " key " , DataTypes . StringType , false ) , DataTypes . createStructField ( " value1 " , DataTypes . StringType , true ) , DataTypes . createStructField ( " value2 " , DataTypes . StringType , true ) , DataTypes . createStructField ( " timestamp " , DataTypes . LongType , false ) ) ) ; existingSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " key " , DataTypes . StringType , false ) , DataTypes . createStructField ( " value1 " , DataTypes . StringType , false ) , DataTypes . createStructField ( " value2 " , DataTypes . StringType , false ) , DataTypes . createStructField ( " timestamp " , DataTypes . LongType , false ) , DataTypes . createStructField ( " eventstart " , DataTypes . LongType , false ) , DataTypes . createStructField ( " eventend " , DataTypes . LongType , false ) , DataTypes . createStructField ( " systemstart " , DataTypes . LongType , false ) , DataTypes . createStructField ( " systemend " , DataTypes . LongType , false ) , DataTypes . createStructField ( " currentflag " , DataTypes . StringType , false ) ) ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , null , " hello2:100 " , 100L , 100L , 253402214400000L , 1L , 253402214400000L , CURRENT_FLAG_DEFAULT_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " hello1:50 " , null , 50L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , null , " hello2:150 " , 150L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 4 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . INSERT ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . UPDATE ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 2 ) ) , MutationType . INSERT ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 3 ) ) , MutationType . INSERT ) ; Long systemStart0 = planned . get ( 0 ) . getAs ( " systemstart " ) ; Long systemStart2 = planned . get ( 2 ) . getAs ( " systemstart " ) ; Long systemStart3 = planned . get ( 3 ) . getAs ( " systemstart " ) ; assertEquals ( planned . get ( 0 ) . getAs ( " value1 " ) , " hello1:50 " ) ; assertEquals ( planned . get ( 0 ) . getAs ( " value2 " ) , null ) ; assertEquals ( planned . get ( 0 ) . getAs ( " timestamp " ) , 50L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " eventstart " ) , 50L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " eventend " ) , 99L ) ; assertTrue ( systemStart0 > = preplanSystemTime ) ; assertTrue ( systemStart0 < preplanSystemTime + 5000 ) ; assertEquals ( planned . get ( 0 ) . getAs ( " systemend " ) , 253402214400000L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( planned . get ( 1 ) . getAs ( " value1 " ) , null ) ; assertEquals ( planned . get ( 1 ) . getAs ( " value2 " ) , " hello2:100 " ) ; assertEquals ( planned . get ( 1 ) . getAs ( " timestamp " ) , 100L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " eventstart " ) , 100L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " eventend " ) , 253402214400000L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " systemstart " ) , 1L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " systemend " ) , systemStart2 - 1 ) ; assertEquals ( planned . get ( 1 ) . getAs ( " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( planned . get ( 2 ) . getAs ( " value1 " ) , " hello1:50 " ) ; assertEquals ( planned . get ( 2 ) . getAs ( " value2 " ) , " hello2:100 " ) ; assertEquals ( planned . get ( 2 ) . getAs ( " eventstart " ) , 100L ) ; assertEquals ( planned . get ( 2 ) . getAs ( " eventend " ) , 149L ) ; assertTrue ( systemStart2 > = preplanSystemTime ) ; assertTrue ( systemStart2 < preplanSystemTime + 5000 ) ; assertEquals ( planned . get ( 2 ) . getAs ( " systemend " ) , 253402214400000L ) ; assertEquals ( planned . get ( 2 ) . getAs ( " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( planned . get ( 3 ) . getAs ( " value1 " ) , " hello1:50 " ) ; assertEquals ( planned . get ( 3 ) . getAs ( " value2 " ) , " hello2:150 " ) ; assertEquals ( planned . get ( 3 ) . getAs ( " eventstart " ) , 150L ) ; assertEquals ( planned . get ( 3 ) . getAs ( " eventend " ) , 253402214400000L ) ; assertTrue ( systemStart3 > = preplanSystemTime ) ; assertTrue ( systemStart3 < preplanSystemTime + 5000 ) ; assertEquals ( planned . get ( 3 ) . getAs ( " systemend " ) , 253402214400000L ) ; assertEquals ( planned . get ( 3 ) . getAs ( " currentflag " ) , CURRENT_FLAG_DEFAULT_YES ) ; }
static Config copy ( UnmodifiableConfig config , Supplier < Map < String , Object > > mapCreator ) { return new SimpleConfig ( config , mapCreator , config . configFormat ( ) ) ; }
private void finerLog ( String message ) { LOGGER . log ( Level . FINER , message ) ; }
public String getParameterNotRequired ( @Nullable final String sKey ) { return getParameters ( ) . get ( sKey ) ; }
public static void initialize ( Config config , ExecutionMode mode ) { INSTANCE . config = config . hasPath ( APPLICATION_SECTION_PREFIX ) ? config . getConfig ( APPLICATION_SECTION_PREFIX ) : ConfigFactory . empty ( ) ; INSTANCE . mode = mode ; getSparkSession ( ) ; }
public static Operation make ( final Operator oper , final Term [ ] arg , boolean addSelf , final Memory memory ) { addSelf = false ; if ( oper = = null ) { return null ; } Term productArg [ ] ; if ( addSelf ) { productArg = new Term [ arg . length + 1 ] ; System . arraycopy ( arg , 0 , productArg , 0 , arg . length ) ; productArg [ arg . length ] = memory . self ; } else { productArg = arg ; } CharSequence name = makeName ( oper . name ( ) , productArg ) ; Term t = memory . conceptTerm ( name ) ; if ( t ! = null ) { return ( Operation ) t ; } return new Operation ( name , termArray ( Product . make ( productArg , memory ) , oper )
public boolean cancel ( boolean ign ) { boolean rv = false ; for ( Operation op : ops ) { rv | = op . getState ( ) = = OperationState . WRITE_QUEUED ; op . cancel ( ) ; } for ( Future < T > v : rvMap . values ( ) ) { v . cancel ( ign ) ; } cancelled = true ; status = new OperationStatus ( false , " Cancelled " , StatusCode . CANCELLED ) ; notifyListeners ( ) ; return rv ; }
public void handle ( @Nonnull final AbstractActiveNetModule aOwner , @Nonnull final Socket aSocket ) { final String sClientInfo = getClientInfo ( aSocket ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " Incoming connection  " + sClientInfo ) ; final AS2Message aMsg = createMessage ( aSocket ) ; final IAS2HttpResponseHandler aResponseHandler = new AS2HttpResponseHandlerSocket ( aSocket ) ; final StopWatch aSW = StopWatch . createdStarted ( ) ; DataSource aMsgDataSource = null ; try { aMsgDataSource = readAndDecodeHttpRequest ( new AS2InputStreamProviderSocket ( aSocket ) , aResponseHandler , aMsg ) ; } catch ( final Exception ex ) { new NetException ( aSocket . getInetAddress ( ) , aSocket . getPort ( ) , ex ) . terminate ( ) ; } aSW . stop ( ) ; if ( aMsgDataSource ! = null ) if ( aMsgDataSource instanceof ByteArrayDataSource ) { if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " received  " + AS2IOHelper . getTransferRate ( ( ( ByteArrayDataSource ) aMsgDataSource ) . directGetBytes ( ) . length , aSW ) + "  from  " + sClientInfo + aMsg . getLoggingText ( ) ) ; } else { LOGGER . info ( " received message from  " + sClientInfo + aMsg . getLoggingText ( ) ) ; } handleIncomingMessage ( sClientInfo , aMsgDataSource , aMsg , aResponseHandler ) ; }
abstract public void clear ( ) ; abstract public boolean contains ( final E it ) ; abstract public E get ( final String key ) ; abstract public Set < String > keySet ( ) ; abstract public int getCapacity ( ) ; abstract public float getMass ( ) ; abstract public boolean putIn ( final E newItem , boolean insertIntoNameTable ) ; public boolean putIn ( final E newItem ) { return putIn ( newItem , true ) ; } abstract public int size ( ) ; abstract public E takeOut ( boolean removeFromNameTable ) ; abstract public E pickOut ( final String key ) ; public void printAll ( ) { for ( String k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } public void addBagObserver ( BagObserver < E > bagObserver , String title ) { this . bagObserver = bagObserver ; bagObserver . post ( toString ( ) ) ; bagObserver . setTitle ( title ) ; bagObserver . setBag ( this ) ; } protected int forgetRate ( ) { if ( forgettingRate ! = null ) { return forgettingRate . get ( ) ; } return - 1 ; } public void play ( ) { if ( bagObserver ! = null ) { bagObserver . post ( toString ( ) ) ; } } protected void reprocess ( E x ) { int r = forgetRate ( ) ; if ( r > 0 ) { BudgetFunctions . forget ( x . budget , forgetRate ( ) , RELATIVE_THRESHOLD ) ; } } public void stop ( ) { if ( bagObserver ! = null ) { bagObserver . stop ( ) ; } } public boolean putBack ( final E oldItem , boolean insertIntoNameTable ) { reprocess ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( ) { final E x = takeOut ( false ) ; if ( x ! = null ) { reprocess ( x ) ; boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else return null ; } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( String key ) ; }
private String makeStringSafeForInsert ( String chars ) { if ( chars . length ( ) > 0 ) { if ( wrapWidth = = Integer . MAX_VALUE ) chars = removeSingleSpacingFromPlainText ( chars ) ; else { chars = removeDoubleSpacingFromPlainText ( chars ) ; while ( chars . length ( ) > 0 & & chars . charAt ( 0 ) = = '\n' ) chars = chars . substring ( 1 ) ; while ( chars . length ( ) > 0 & & chars . charAt ( chars . length ( ) - 1 ) = = '\n' ) chars = chars . substring ( 0 , chars . length ( ) - 1 ) ; } } return chars ; }
protected void feelMotion ( ) { float xa = torso . getAngularVelocity ( ) ; float angleScale = 1.50f ; float a = ( float ) ( Math . log ( Math . abs ( xa * angleScale ) + 1f ) ) ; float maxAngleVelocityFelt = 0.8f ; if ( a > maxAngleVelocityFelt ) { a = maxAngleVelocityFelt ; } if ( a < 0.1 ) { } else { String direction ; String da = Texts . n1 ( a ) ; if ( xa < 0 ) { direction = " left " ; } else { direction = " right " ; } } float h = torso . getAngle ( ) % ( MathUtils . TWOPI ) ; if ( h < 0 ) { h + = MathUtils . TWOPI ; } h = h / MathUtils . TWOPI ; String dh = " a " + ( int ) ( h * 18 ) ; float speed = Math . abs ( torso . getLinearVelocity ( ) . length ( ) ) ; if ( speed > 0.9f ) { speed = 0.9f ; } String sp = Texts . n1 ( speed ) ;
public final void setMDN ( @Nullable final IMessageMDN aMDN ) { m_aMDN = aMDN ; }
public void testMultistepEndState ( ) { NAR n = new DefaultNARBuilder ( ) . build ( ) ; n . addInput ( new TextInput ( NALTest . getExample ( " nal/Examples/Example-MultiStep-edited.txt " ) ) ) ; new TextOutput ( n , System . out ) ; n . finish ( 10000 ) ;
static boolean abdIndCom ( Term term1 , Term term2 , final Sentence sentence1 , final Sentence sentence2 , final int figure , final DerivationContext nal ) { if ( Statement . invalidStatement ( term1 , term2 ) | | Statement . invalidPair ( term1 , term2 ) ) { return false ; } final int order1 = sentence1 . term . getTemporalOrder ( ) ; final int order2 = sentence2 . term . getTemporalOrder ( ) ; final int order = abdIndComOrder ( order1 , order2 ) ; final Statement taskContent = ( Statement ) sentence1 . term ; TruthValue truth1 = null ; TruthValue truth2 = null ; TruthValue truth3 = null ; final BudgetValue budget1 ; final BudgetValue budget2 ; final BudgetValue budget3 ; final TruthValue value1 = sentence1 . truth ; final TruthValue value2 = sentence2 . truth ; if ( sentence1 . isQuestion ( ) ) { } else if ( sentence1 . isQuest ( ) ) { } else { if ( sentence1 . isGoal ( ) ) { truth1 = TruthFunctions . desireStrong ( value1 , value2 ) ; truth2 = TruthFunctions . desireWeak ( value2 , value1 ) ; truth3 = TruthFunctions . desireStrong ( value1 , value2 ) ; } else { truth1 = TruthFunctions . abduction ( value1 , value2 ) ; truth2 = TruthFunctions . abduction ( value2 , value1 ) ; truth3 = TruthFunctions . comparison ( value1 , value2 ) ; } } if ( sentence1 . isQuestion ( ) ) { budget1 = BudgetFunctions . backward ( value2 , nal ) ; budget2 = BudgetFunctions . backwardWeak ( value2 , nal ) ; budget3 = BudgetFunctions . backward ( value2 , nal ) ; } else if ( sentence1 . isQuest ( ) ) { budget1 = BudgetFunctions . backwardWeak ( value2 , nal ) ; budget2 = BudgetFunctions . backward ( value2 , nal ) ; budget3 = BudgetFunctions . backwardWeak ( value2 , nal ) ; } else { budget1 = BudgetFunctions . forward ( truth1 , nal ) ; budget2 = BudgetFunctions . forward ( truth2 , nal ) ; budget3 = BudgetFunctions . forward ( truth3 , nal ) ; } if ( term1 . imagination ! = null & & term2 . imagination ! = null ) { final TruthValue T = term1 . imagination . AbductionOrComparisonTo ( term2 . imagination , true ) ; nal . doublePremiseTask ( Statement . make ( NativeOperator . SIMILARITY , term1 , term2 , TemporalRules . ORDER_NONE ) , T , budget3 . clone ( ) , false , false ) ; final TruthValue T2 = term1 . imagination . AbductionOrComparisonTo ( term2 . imagination , false ) ; nal . doublePremiseTask ( Statement . make ( NativeOperator . INHERITANCE , term1 , term2 , TemporalRules . ORDER_NONE ) , T2 , budget3 . clone ( ) , false , false ) ; final TruthValue T3 = term2 . imagination . AbductionOrComparisonTo ( term1 . imagination , false ) ; nal . doublePremiseTask ( Statement . make ( NativeOperator . INHERITANCE , term2 , term1 , TemporalRules . ORDER_NONE ) , T3 , budget3 . clone ( ) , false , false ) ; return true ; } long occurrence_time2 = nal . getCurrentTask ( ) . sentence . getOccurenceTime ( ) ; while ( occurrence_time2 ! = Stamp . ETERNAL & & ( term2 instanceof Conjunction ) & & ( ( ( CompoundTerm ) term2 ) . term [ 0 ] instanceof Interval ) ) { final Interval interval = ( Interval ) ( ( CompoundTerm ) term2 ) . term [ 0 ] ; occurrence_time2 + = interval . time ; term2 = ( ( CompoundTerm ) term2 ) . setComponent ( 0 , null , nal . mem ( ) ) ; } long occurrence_time1 = nal . getCurrentTask ( ) . sentence . getOccurenceTime ( ) ; while ( occurrence_time1 ! = Stamp . ETERNAL & & ( term1 instanceof Conjunction ) & & ( ( ( CompoundTerm ) term1 ) . term [ 0 ] instanceof Interval ) ) { final Interval interval = ( Interval ) ( ( CompoundTerm ) term1 ) . term [ 0 ] ; occurrence_time1 + = interval . time ; term1 = ( ( CompoundTerm ) term1 ) . setComponent ( 0 , null , nal . mem ( ) ) ; } if ( order ! = ORDER_INVALID ) { nal . getTheNewStamp ( ) . setOccurrenceTime ( occurrence_time1 ) ; nal . doublePremiseTask ( Statement . make ( taskContent , term1 , term2 , order ) , truth1 , budget1 , false , false ) ; nal . getTheNewStamp ( ) . setOccurrenceTime ( occurrence_time2 ) ; nal . doublePremiseTask ( Statement . make ( taskContent , term2 , term1 , reverseOrder ( order ) ) , truth2 , budget2 , false , false ) ; nal . getTheNewStamp ( ) . setOccurrenceTime ( occurrence_time1 ) ; nal . doublePremiseTask ( Statement . makeSym ( taskContent , term1 , term2 , order ) , truth3 , budget3 , false , false ) ; } if ( Parameters . BREAK_NAL_HOL_BOUNDARY & & order1 = = order2 & & taskContent . isHigherOrderStatement ( ) & & sentence2 . term . isHigherOrderStatement ( ) ) { if ( truth3 ! = null ) truth3 = truth3 . clone ( ) ; nal . doublePremiseTask ( Statement . make ( NativeOperator . SIMILARITY , term1 , term2 , TemporalRules . ORDER_NONE ) , truth3 , budget3 . clone ( ) , false , false ) ; } return false ; }
public void draw ( Timeline2DCanvas l , float y , float timeScale , float yScale ) { this . timeScale = timeScale ; this . yScale = yScale * getHeight ( ) ; this . l = l ; if ( ( timepoints = = null ) | | ( timepoints . isEmpty ( ) ) ) { return ; } lastSubjectEvent . clear ( ) ; events . clear ( ) ; l . noStroke ( ) ; l . textSize ( l . getDrawnTextScale ( ) ) ; synchronized ( timepoints ) { long maxItemsPerCycle = timepoints . values ( ) . stream ( ) . map ( ( x ) - > x . stream ( ) . filter ( ( e ) - > include ( e ) ) . count ( ) ) . max ( Long : : compare ) . get ( ) ; for ( Map . Entry < Long , List < Events . InferenceEvent > > e : timepoints . entrySet ( ) ) { long t = e . getKey ( ) ; List < Events . InferenceEvent > v = e . getValue ( ) ; drawEvent ( t , v , y , ( int ) maxItemsPerCycle ) ; } } l . strokeCap ( PConstants . SQUARE ) ; l . strokeWeight ( 4f ) ; for ( final EventPoint < Object > to : events . values ( ) ) { for ( final EventPoint < Object > from : to . incoming ) {
protected abstract INetModuleHandler getHandler ( ) ; public void handleError ( final IMessage aMsg , final OpenAS2Exception aSrcEx ) { aSrcEx . addSource ( OpenAS2Exception . SOURCE_MESSAGE , aMsg ) ; aSrcEx . terminate ( ) ; try { final CompositeParameters aParams = new CompositeParameters ( false ) . add ( " date " , new DateParameters ( ) ) . add ( " msg " , new MessageParameters ( aMsg ) ) ; final String sName = aParams . format ( getParameter ( PARAM_ERRORS , DEFAULT_ERRORS ) ) ; final String sDirectory = getParameterRequired ( PARAM_ERROR_DIRECTORY ) ; final File aMsgFile = IOUtil . getUniqueFile ( IOUtil . getDirectoryFile ( sDirectory ) , FilenameHelper . getAsSecureValidFilename ( sName ) ) ; final String sMsgText = aMsg . toString ( ) ; final FileOutputStream aFOS = new FileOutputStream ( aMsgFile ) ; aFOS . write ( sMsgText . getBytes ( ) ) ; aFOS . close ( ) ; final InvalidMessageException im = new InvalidMessageException ( " Stored invalid message to  " + aMsgFile . getAbsolutePath ( ) ) ; im . terminate ( ) ; } catch ( final OpenAS2Exception ex ) { ex . addSource ( OpenAS2Exception . SOURCE_MESSAGE , aMsg ) ; ex . terminate ( ) ; } catch ( final IOException ex ) { final WrappedException we = new WrappedException ( ex ) ; we . addSource ( OpenAS2Exception . SOURCE_MESSAGE , aMsg ) ; we . terminate ( ) ; } } protected static final class ConnectionThread extends Thread { private final AbstractNetModule m_aOwner ; private final Socket m_aSocket ; public ConnectionThread ( final AbstractNetModule aOwner , final Socket aSocket ) { super ( ) ; m_aOwner = aOwner ; m_aSocket = aSocket ; start ( ) ; } public AbstractNetModule getOwner ( ) { return m_aOwner ; } public Socket getSocket ( ) { return m_aSocket ; } @Override public void run ( ) { final Socket s = getSocket ( ) ; getOwner ( ) . getHandler ( ) . handle ( getOwner ( ) , s ) ; try { s . close ( ) ; } catch ( final IOException ex ) { new WrappedException ( ex ) . terminate ( ) ; } } } protected static final class MainThread extends Thread { private static final Logger s_aLogger = LoggerFactory . getLogger ( MainThread . class ) ; private final AbstractNetModule m_aOwner ; private final ServerSocket m_aSocket ; private boolean m_bTerminated ; public MainThread ( final AbstractNetModule aOwner , final String sAddress , final int nPort ) throws IOException { super ( ) ; m_aOwner = aOwner ; m_aSocket = new ServerSocket ( ) ; if ( sAddress ! = null ) m_aSocket . bind ( new InetSocketAddress ( sAddress , nPort ) ) ; else m_aSocket . bind ( new InetSocketAddress ( nPort ) ) ; } public AbstractNetModule getOwner ( ) { return m_aOwner ; } public ServerSocket getSocket ( ) { return m_aSocket ; } public void setTerminated ( final boolean bTerminated ) { m_bTerminated = bTerminated ; if ( m_aSocket ! = null ) { try { m_aSocket . close ( ) ; } catch ( final IOException ex ) { m_aOwner . forceStop ( ex ) ; } } } public boolean isTerminated ( ) { return m_bTerminated ; } @Override public void run ( ) { while ( ! isTerminated ( ) ) { try { final Socket aConn = m_aSocket . accept ( ) ; aConn . setSoLinger ( true , 60 ) ; new ConnectionThread ( getOwner ( ) , aConn ) ; } catch ( final IOException ex ) { if ( ! isTerminated ( ) ) m_aOwner . forceStop ( ex ) ; } } s_aLogger . info ( " exited " ) ; } public void terminate ( ) { setTerminated ( true ) ; } } }
public static void main ( String [ ] args ) { System . setProperty ( " prism.dirtyopts " , " false " ) ; launch ( args ) ; }
public void actionPerformed ( java . awt . event . ActionEvent evt ) { bn_closeActionPerformed ( evt ) ; }
TruthValue AbductionOrComparisonTo ( final ImaginationSpace obj , boolean comparison ) ; ImaginationSpace ConstructSpace ( Conjunction program ) ; ImaginationSpace ProgressSpace ( Operation op , ImaginationSpace B ) ; boolean IsOperationInSpace ( Operation oper ) ; }
final void connect ( ) throws MPDServerException { int [ ] result = null ; int retry = 0 ; MPDServerException lastException = null ; while ( result = = null & & retry < MAX_CONNECT_RETRY & & ! mCancelled ) { try { result = innerConnect ( ) ; } catch ( final MPDServerException e ) { lastException = e ; try { Thread . sleep ( 500L ) ; } catch ( final InterruptedException ignored ) { } } catch ( final RuntimeException e ) { lastException = new MPDServerException ( e ) ; } retry + + ; } if ( result = = null ) { if ( lastException = = null ) { throw new MPDServerException ( " Connection request cancelled. " ) ; } else { throw new MPDServerException ( lastException ) ; } } mIsConnected = true ; mMPDVersion = result ; }
private void updateStats ( InstanceContentEvent event ) { model . trainOnInstance ( event . getInstance ( ) ) ; instancesCount + + ; if ( instancesCount % 10000 = = 0 ) { logger . info ( " Trained model using {} events with classifier id {} " ,
X509Certificate getCertificate ( String sAlias ) throws AS2Exception ; ICommonsOrderedMap < String , X509Certificate > getCertificates ( ) throws AS2Exception ; void addCertificate ( @Nonnull @Nonempty String sAlias , @Nonnull X509Certificate aCert , boolean bOverwrite ) throws AS2Exception ; void addPrivateKey ( @Nonnull @Nonempty String sAlias , @Nonnull Key aKey , @Nonnull String sPassword ) throws AS2Exception ; void clearCertificates ( ) throws AS2Exception ; void removeCertificate ( @Nonnull X509Certificate aCert ) throws AS2Exception ; void removeCertificate ( String sAlias ) throws AS2Exception ; }
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; void handleLine ( String line ) ; }
public void run ( ) { try { app . oMPDAsyncHelper . oMPD . next ( ) ;
public void testReadHttpRequestRegularMessage ( ) throws Exception { NonBlockingByteArrayInputStream is = new NonBlockingByteArrayInputStream ( m_sRegularMessage . getBytes ( StandardCharsets . UTF_8 ) ) ; AS2Message aMsg = new AS2Message ( ) ; IAS2InputStreamProvider mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; final DataSource resRegular = HTTPHelper . readHttpRequest ( mockStreamProvider , MOCK_RH , aMsg , INCOMING_DUMPER ) ; is = new NonBlockingByteArrayInputStream ( m_sRegularMessage . getBytes ( StandardCharsets . UTF_8 ) ) ; aMsg = new AS2Message ( ) ; mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; final DataSource resStream = HTTPHelper . readHttpRequest ( mockStreamProvider , MOCK_RH , aMsg , INCOMING_DUMPER ) ; assertTrue ( " Compare regular and stream read " , _compareLineByLine ( resRegular . getInputStream ( ) , resStream . getInputStream ( ) ) ) ; }
public void evaluateClustering ( Clustering clustering , Clustering trueClustering , ArrayList < DataPoint > points ) { int numFCluster = clustering . size ( ) ; double [ ] [ ] pointInclusionProbFC = new double [ points . size ( ) ] [ numFCluster ] ; for ( int p = 0 ; p < points . size ( ) ; p + + ) { DataPoint point = points . get ( p ) ; for ( int fc = 0 ; fc < numFCluster ; fc + + ) { Cluster cl = clustering . get ( fc ) ; pointInclusionProbFC [ p ] [ fc ] = cl . getInclusionProbability ( point ) ; } } double silhCoeff = 0.0 ; int totalCount = 0 ; for ( int p = 0 ; p < points . size ( ) ; p + + ) { DataPoint point = points . get ( p ) ; ArrayList < Integer > ownClusters = new ArrayList < > ( ) ; for ( int fc = 0 ; fc < numFCluster ; fc + + ) { if ( pointInclusionProbFC [ p ] [ fc ] > pointInclusionProbThreshold ) { ownClusters . add ( fc ) ; } } if ( ownClusters . size ( ) > 0 ) { double [ ] distanceByClusters = new double [ numFCluster ] ; int [ ] countsByClusters = new int [ numFCluster ] ; for ( int p1 = 0 ; p1 < points . size ( ) ; p1 + + ) { DataPoint point1 = points . get ( p1 ) ; if ( p1 ! = p & & point1 . classValue ( ) ! = - 1 ) { for ( int fc = 0 ; fc < numFCluster ; fc + + ) { if ( pointInclusionProbFC [ p1 ] [ fc ] > pointInclusionProbThreshold ) { double distance = distance ( point , point1 ) ; distanceByClusters [ fc ] + = distance ; countsByClusters [ fc ] + + ; } } } } double minAvgDistanceOwn = Double . MAX_VALUE ; int minOwnIndex = - 1 ; for ( int fc : ownClusters ) { double normDist = distanceByClusters [ fc ] / ( double ) countsByClusters [ fc ] ; if ( normDist < minAvgDistanceOwn ) { minAvgDistanceOwn = normDist ; minOwnIndex = fc ; } } double minAvgDistanceOther = Double . MAX_VALUE ; for ( int fc = 0 ; fc < numFCluster ; fc + + ) { if ( fc ! = minOwnIndex ) { double normDist = distanceByClusters [ fc ] / ( double ) countsByClusters [ fc ] ; if ( normDist < minAvgDistanceOther ) { minAvgDistanceOther = normDist ; } } } double silhP = ( minAvgDistanceOther - minAvgDistanceOwn ) / Math . max ( minAvgDistanceOther , minAvgDistanceOwn ) ; point . setMeasureValue ( " SC - own " , minAvgDistanceOwn ) ; point . setMeasureValue ( " SC - other " , minAvgDistanceOther ) ; point . setMeasureValue ( " SC " , silhP ) ; silhCoeff + = silhP ; totalCount + + ; } } if ( totalCount > 0 ) silhCoeff / = ( double ) totalCount ; silhCoeff = ( silhCoeff + 1 ) / 2.0 ; addValue ( 0 , silhCoeff ) ; }
public void onDataBind ( Context context , View targetView , List < ? extends Item > items , Object item , int position ) { final Album album = ( Album ) item ; String info = " " ; final long songCount = album . getSongCount ( ) ; if ( album . getYear ( ) > 0 ) info = Long . toString ( album . getYear ( ) ) ; if ( songCount > 0 ) { if ( info ! = null & & info . length ( ) > 0 ) info + = "  -  " ; info + = String . format ( context . getString ( songCount > 1 ? R . string . tracksInfoHeaderPlural : R . string . tracksInfoHeader ) , songCount , Music . timeToString ( album . getDuration ( ) ) ) ; } ( ( TextView ) targetView . findViewById ( R . id . album_name ) ) . setText ( album . getName ( ) ) ; final TextView albumInfo = ( TextView ) targetView . findViewById ( R . id . album_info ) ; if ( info ! = null & & info . length ( ) > 0 ) { albumInfo . setVisibility ( View . VISIBLE ) ;
public void testQuerySetUpdateSeq ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseWithDocs > future = client . asyncQuery ( view , query . setUpdateSeq ( true ) ) ; ViewResponseWithDocs response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }
protected String getFilename ( ) throws InvalidParameterException { long nResendDelay ; if ( getAttributeAsString ( PARAM_RESEND_DELAY ) = = null ) nResendDelay = DEFAULT_RESEND_DELAY ; else nResendDelay = getParameterIntRequired ( PARAM_RESEND_DELAY ) * CGlobal . MILLISECONDS_PER_SECOND ; final long nResendTime = new Date ( ) . getTime ( ) + nResendDelay ; return DateUtil . formatDate ( DATE_FORMAT , new Date ( nResendTime ) ) ; }
public < T > Future < T > decode ( final Transcoder < T > tc , final CachedData cachedData ) { TranscodeService . Task < T > task = new TranscodeService . Task < T > ( new Callable < T > ( ) { public T call ( ) { return tc . decode ( cachedData ) ; } } ) ; if ( tc . asyncDecode ( cachedData ) ) { this . pool . execute ( task ) ; } return task ; }
boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; @Nonnull @ReturnsMutableCopy Enumeration < String > getAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Collection < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; Iterator < Entry < String , String > > iterator ( ) ; }
public double probabilityOfAttributeValueGivenClass ( double attVal , int classVal ) ; public AttributeSplitSuggestion getBestEvaluatedSplitSuggestion ( SplitCriterion criterion , double [ ] preSplitDist , int attIndex , boolean binaryOnly ) ; public void observeAttributeTarget ( double attVal , double target ) ; }
public void setLastModified ( final LocalDateTime aLastModified ) { m_aLastModified = aLastModified ; }
public boolean onNavigationItemSelected ( int itemPosition , long itemId ) { libraryFragment . setCurrentItem ( itemPosition , true ) ; return true ; }
public void onClick ( final DialogInterface dialogInterface , final int i ) { mApp . markGooglePlayDeathWarningAsRead ( ) ; }
public void queueMouseDrag ( Vec2 screenPos , int button ) { inputQueue . add ( new QueueItem ( QueueItemType . MouseDrag , screenPos , button ) ) ; }
public void move ( ) { if ( winTime > 0 ) { winTime + + ; xa = 0 ; ya = 0 ; return ; } if ( deathTime > 0 ) { deathTime + + ; if ( deathTime < 11 ) { xa = 0 ; ya = 0 ; } else if ( deathTime = = 11 ) { ya = - 15 ; } else { ya + = 2 ; } x + = xa ; y + = ya ; return ; } if ( powerUpTime ! = 0 ) { if ( powerUpTime > 0 ) { powerUpTime - - ; blink ( ( ( powerUpTime / 3 ) & 1 ) = = 0 ) ; } else { powerUpTime + + ; blink ( ( ( - powerUpTime / 3 ) & 1 ) = = 0 ) ; } if ( powerUpTime = = 0 ) world . paused = false ; calcPic ( ) ; return ; } if ( invulnerableTime > 0 ) invulnerableTime - - ; visible = ( ( invulnerableTime / 2 ) & 1 ) = = 0 ; wasOnGround = onGround ; float sideWaysSpeed = keys [ KEY_SPEED ] ? 1.2f : 0.6f ; if ( onGround ) { if ( keys [ KEY_DOWN ] & & large ) { ducking = true ; } else { ducking = false ; } } if ( xa > 2 ) { facing = 1 ; } if ( xa < - 2 ) { facing = - 1 ; } if ( keys [ KEY_JUMP ] | | ( jumpTime < 0 & & ! onGround & & ! sliding ) ) { if ( jumpTime < 0 ) { xa = xJumpSpeed ; ya = - jumpTime * yJumpSpeed ; jumpTime + + ; } else if ( onGround & & mayJump ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_JUMP ] , this , 1 , 1 , 1 ) ; xJumpSpeed = 0 ; yJumpSpeed = - 1.9f ; jumpTime = 7 ; ya = jumpTime * yJumpSpeed ; onGround = false ; sliding = false ; } else if ( sliding & & mayJump ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_JUMP ] , this , 1 , 1 , 1 ) ; xJumpSpeed = - facing * 6.0f ; yJumpSpeed = - 2.0f ; jumpTime = - 6 ; xa = xJumpSpeed ; ya = - jumpTime * yJumpSpeed ; onGround = false ; sliding = false ; facing = - facing ; } else if ( jumpTime > 0 ) { xa + = xJumpSpeed ; ya = jumpTime * yJumpSpeed ; jumpTime - - ; } } else { jumpTime = 0 ; } if ( keys [ KEY_LEFT ] & & ! ducking ) { if ( facing = = 1 ) sliding = false ; xa - = sideWaysSpeed ; if ( jumpTime > = 0 ) facing = - 1 ; } if ( keys [ KEY_RIGHT ] & & ! ducking ) { if ( facing = = - 1 ) sliding = false ; xa + = sideWaysSpeed ; if ( jumpTime > = 0 ) facing = 1 ; } if ( ( ! keys [ KEY_LEFT ] & & ! keys [ KEY_RIGHT ] ) | | ducking | | ya < 0 | | onGround ) { sliding = false ; } if ( keys [ KEY_SPEED ] & & canShoot & & Mario . fire & & world . fireballsOnScreen < 2 ) { world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_FIREBALL ] , this , 1 , 1 , 1 ) ; world . addSprite ( new Fireball ( world , x + facing * 6 , y - 20 , facing ) ) ; } canShoot = ! keys [ KEY_SPEED ] ; mayJump = ( onGround | | sliding ) & & ! keys [ KEY_JUMP ] ; xFlipPic = facing = = - 1 ; runTime + = ( Math . abs ( xa ) ) + 5 ; if ( Math . abs ( xa ) < 0.5f ) { runTime = 0 ; xa = 0 ; } calcPic ( ) ; if ( sliding ) { for ( int i = 0 ; i < 1 ; i + + ) { world . addSprite ( new Sparkle ( ( int ) ( x + Math . random ( ) * 4 - 2 ) + facing * 8 , ( int ) ( y + Math . random ( ) * 4 ) - 24 , ( float ) ( Math . random ( ) * 2 - 1 ) , ( float ) Math . random ( ) * 1 , 0 , 1 , 5 ) ) ; } ya * = 0.5f ; } onGround = false ; move ( xa , 0 ) ; move ( 0 , ya ) ; if ( y > world . level . height * 16 + 16 ) { die ( ) ; } if ( x < 0 ) { x = 0 ; xa = 0 ; } if ( x > world . level . xExit * 16 ) { win ( ) ; } if ( x > world . level . width * 16 ) { x = world . level . width * 16 ; xa = 0 ; } ya * = 0.85f ; if ( onGround ) { xa * = GROUND_INERTIA ; } else { xa * = AIR_INERTIA ; } if ( ! onGround ) { ya + = 3 ; } if ( carried ! = null ) {
public CompoundTerm cloneDeepVariables ( ) { Term c = clone ( cloneVariableTermsDeep ( ) ) ; if ( c = = null ) return null ; if ( c . getClass ( ) ! = getClass ( ) ) throw new UnableToCloneException ( " cloneDeepVariables resulted in different class:  " + c + "  from  " + this ) ; CompoundTerm cc = ( CompoundTerm ) c ; cc . setNormalized ( isNormalized ( ) ) ; return cc ; }
public CompoundTerm cloneDeepVariables ( ) { Term c = clone ( cloneVariableTermsDeep ( ) ) ; if ( c . getClass ( ) ! = getClass ( ) ) throw new RuntimeException ( " cloneDeepVariables resulted in different class:  " + c + "  from  " + this ) ; return ( CompoundTerm ) c ; }
public boolean validate ( ) { java . util . Set < T > keys = new java . util . HashSet < T > ( ) ; Node < T > node = head ; if ( node ! = null ) { keys . add ( node . value ) ; if ( node . prev ! = null ) return false ; Node < T > child = node . next ; while ( child ! = null ) { if ( ! validate ( child , keys ) ) return false ; child = child . next ; } } return ( keys . size ( ) = = size ( ) ) ; }
FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( String key , long casId , int flags , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }
static void structuralCompound ( CompoundTerm compound , Term component , boolean compoundTask , Memory memory ) { if ( ! component . isConstant ( ) ) { return ; } Term content = ( compoundTask ? component : compound ) ; Task task = memory . currentTask ; Sentence sentence = task . getSentence ( ) ; TruthValue truth = sentence . getTruth ( ) ; Sentence belief = memory . currentBelief ; BudgetValue budget ; if ( sentence . isQuestion ( ) ) { budget = BudgetFunctions . compoundBackward ( content , memory ) ; } else { if ( ( sentence . isJudgment ( ) ) = = ( compoundTask = = ( compound instanceof Conjunction ) ) ) { truth = TruthFunctions . deduction ( truth , RELIANCE ) ; } else { TruthValue v1 , v2 ; v1 = TruthFunctions . negation ( truth ) ; v2 = TruthFunctions . deduction ( v1 , RELIANCE ) ; truth = TruthFunctions . negation ( v2 ) ; } budget = BudgetFunctions . forward ( truth , memory ) ; } memory . singlePremiseTask ( content , truth , budget ) ; }
private static boolean executePrecondition ( final DerivationContext nal , ExecutablePrecondition precon , final Concept concept , final Sentence projectedGoal , final Task task ) { if ( precon . bestop ! = null & & precon . bestop_truthexp > nal . narParameters . DECISION_THRESHOLD ) { final Sentence createdSentence = new Sentence ( precon . bestop , Symbols . GOAL_MARK , precon . bestop_truth , projectedGoal . stamp ) ; final Task t = new Task ( createdSentence , new BudgetValue ( 1.0f , 1.0f , 1.0f , nal . narParameters ) , Task . EnumType . DERIVED ) ; if ( ! task . sentence . stamp . evidenceIsCyclic ( ) ) { if ( ! executeOperation ( nal , t ) ) { concept . memory . emit ( Events . UnexecutableGoal . class , task , concept , nal ) ; return false ; } return true ; } } return false ; }
public void test_java_call_3 ( ) throws PrologException , IOException { setPath ( true ) ; theory = " demo(Value) :- set_classpath([ " + paths + " ]), class('TestStaticClass') <- echo('Message') returns Value. " ; engine . setTheory ( new Theory ( theory ) ) ; info = engine . solve ( " demo(StringValue). " ) ; assertEquals ( true , info . isSuccess ( ) ) ; result = info . getVarValue ( " StringValue " ) . toString ( ) . replace ( " ' " , " " ) ; assertEquals ( " Message " , result ) ; setPath ( true ) ; theory = " demo_2(Value) :- set_classpath([ " + paths + " ]), class('TestStaticClass').'id' <- get(Value). " ; engine . setTheory ( new Theory ( theory ) ) ; info = engine . solve ( " demo_2(Res). " ) ; assertEquals ( true , info . isSuccess ( ) ) ; assertEquals ( 0 , Integer . parseInt ( info . getVarValue ( " Res " ) . toString ( ) ) ) ; theory = " demo_2(Value, NewValue) :- set_classpath([ " + paths + " ]), class('TestStaticClass').'id' <- set(Value),  \ n " + " class('TestStaticClass').'id' <- get(NewValue). " ; engine . setTheory ( new Theory ( theory ) ) ; info = engine . solve ( " demo_2(5, Val). " ) ; assertEquals ( true , info . isSuccess ( ) ) ; assertEquals ( 5 , Integer . parseInt ( info . getVarValue ( " Val " ) . toString ( ) ) ) ;
default C parse ( InputStream input ) { Reader reader = new BufferedReader ( new InputStreamReader ( input , StandardCharsets . UTF_8 ) ) ; return parse ( reader ) ; }
public void testSign_QuotedPrintable ( ) throws Exception { final MimeBodyPart aPart = new MimeBodyPart ( ) ; aPart . setText ( " Hello world " , StandardCharsets . ISO_8859_1 . name ( ) ) ; final MimeBodyPart aSigned = AS2Helper . getCryptoHelper ( ) . sign ( aPart , ( X509Certificate ) PKE . getCertificate ( ) , PKE . getPrivateKey ( ) , ECryptoAlgorithmSign . DIGEST_SHA_256 , false , false , EContentTransferEncoding . QUOTED_PRINTABLE ) ; assertNotNull ( aSigned ) ; final String sBoundary = AS2HttpHelper . parseContentType ( aSigned . getContentType ( ) ) . getParameter ( " boundary " ) ; assertNotNull ( sBoundary ) ; final NonBlockingByteArrayOutputStream aBAOS = new NonBlockingByteArrayOutputStream ( ) ; aSigned . writeTo ( aBAOS ) ; final String sExpectedStart = " Content-Type: multipart/signed; protocol= \" application/pkcs7-signature \" ; micalg=sha-256;  \ r \ n " + " \ tboundary= \" " + sBoundary + " \" \ r \ n " + " \ r \ n " + " -- " + sBoundary + " \ r \ n " + " Content-Type: text/plain; charset=ISO-8859-1 \ r \ n " + " Content-Transfer-Encoding: 7bit \ r \ n " + " \ r \ n " + " Hello world \ r \ n " + " -- " + sBoundary + " \ r \ n " + " Content-Type: application/pkcs7-signature; name=smime.p7s; smime-type=signed-data \ r \ n " + " Content-Transfer-Encoding: quoted-printable \ r \ n " + " Content-Disposition: attachment; filename= \" smime.p7s \" \ r \ n " + " Content-Description: S/MIME Cryptographic Signature \ r \ n " + " \ r \ n " + " 0=80=06=09*=86H=86=F7 \ r \ n " + " =01=07=02=A0=800=80=02=01=011 \ r \ n " + " 0=0B=06=09`=86H=01e=03=04=02=010=80=06=09*=86H=86=F7 \ r \ n " + " =01=07=01=00=001=82=02=A40=82=02=A0=02=01=010=81=C30=81=BA1#0!=06=09*=86H= \ r \ n " + " =86=F7 \ r \ n " + " =01=09=01=16=14service@mendelson.de1=0B0=09=06=03U=04=06=13=02DE1=0F0 \ r \ n " + " =06=03U=04=08=0C=06Berlin1=0F0 \ r \ n " + " =06=03U=04=07=0C=06Berlin1 \" 0 =06=03U=04 \ r \ n " + " =0C=19mendelson-e-commerce GmbH1!0=1F=06=03U=04=0B=0C=18Do not use in produ= \ r \ n " + " ction1=1D0=1B=06=03U=04=03=0C=14mendelson test key 3=02=04Z*[=1C0=0B=06=09`= \ r \ n " + " =86H=01e=03=04=02=01=A0=81=B40=18=06=09*=86H=86=F7 \ r \ n " + " =01=09=031=0B=06=09*=86H=86=F7 \ r \ n " + " =01=07=010=1C=06=09*=86H=86=F7 \ r \ n " + " =01=09=051=0F=17 \ r \ n " ; final String sExpectedEnd = " \ r \ n " + " -- " + sBoundary + " -- \ r \ n " ; final String sReal = aBAOS . getAsString ( StandardCharsets . ISO_8859_1 ) ; assertTrue ( sReal . startsWith ( sExpectedStart ) ) ; assertTrue ( sReal . endsWith ( sExpectedEnd ) ) ; }
MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm , @Nonnull @Nonempty String sContentTransferEncoding ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt , boolean bLargeFileOn ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs , @Nonnull @Nonempty String sContentTransferEncoding ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
public void onReceive ( final Context context , final Intent intent ) { final Bundle bundle = intent . getBundleExtra ( LocaleConstants . EXTRA_BUNDLE ) ; if ( bundle = = null ) { return ; } final String action = bundle . getString ( EditActivity . BUNDLE_ACTION_STRING ) ; final Intent serviceIntent ; switch ( action ) { case MPDroidService . ACTION_START :
public void doUnbindService ( ) { if ( DEBUG ) { Log . d ( TAG , " doUnbindService() " ) ; } if ( mServiceMessenger ! = null ) { sendMessageToService ( UNREGISTER_CLIENT ) ;
protected void measureChildWithMargins ( View child , int parentWidthMeasureSpec , int widthUsed , int parentHeightMeasureSpec , int heightUsed ) { final int index = indexOfChild ( child ) ; final int orientation = getOrientation ( ) ; final LayoutParams params = ( LayoutParams ) child . getLayoutParams ( ) ; if ( hasDividerBeforeChildAt ( index ) ) { if ( orientation = = VERTICAL ) { params . topMargin = mDividerHeight ; } else { params . leftMargin = mDividerWidth ; } } final int count = getChildCount ( ) ; if ( index = = count - 1 ) { if ( hasDividerBeforeChildAt ( count ) ) { if ( orientation = = VERTICAL ) { params . bottomMargin = mDividerHeight ; } else { params . rightMargin = mDividerWidth ; } } } super . measureChildWithMargins ( child , parentWidthMeasureSpec , widthUsed , parentHeightMeasureSpec , heightUsed ) ; }
public byte markTokensImpl ( byte token , Segment line , int lineIndex ) { char [ ] array = line . array ; int offset = line . offset ; lastOffset = offset ; lastKeyword = offset ; int length = line . count + offset ; boolean backslash = false ; loop : for ( int i = offset ; i < length ; i + + ) { int i1 = ( i + 1 ) ; char c = array [ i ] ; if ( c = = '\\' ) { backslash = ! backslash ; continue ; } switch ( token ) { case Token . NULL : switch ( c ) { case '%' : if ( backslash ) backslash = false ; doKeyword ( line , i , c ) ; addToken ( i - lastOffset , token ) ; addToken ( length - i , Token . COMMENT1 ) ; lastOffset = lastKeyword = length ; break loop ; case '"' : doKeyword ( line , i , c ) ; if ( backslash ) backslash = false ; else { addToken ( i - lastOffset , token ) ; token = Token . LITERAL1 ; lastOffset = lastKeyword = i ; } break ; case '\'' : doKeyword ( line , i , c ) ; if ( backslash ) backslash = false ; else { addToken ( i - lastOffset , token ) ; token = Token . LITERAL1 ; lastOffset = lastKeyword = i ; } break ; case '[' : doKeyword ( line , i , c ) ; if ( backslash ) backslash = false ; else { addToken ( i - lastOffset , token ) ; token = Token . LITERAL2 ; lastOffset = lastKeyword = i ; } break ; case '/' : backslash = false ; doKeyword ( line , i , c ) ; if ( length - i > 1 ) { switch ( array [ i1 ] ) { case '*' : addToken ( i - lastOffset , token ) ; lastOffset = lastKeyword = i ; if ( length - i > 2 & & array [ i + 2 ] = = '*' ) token = Token . COMMENT2 ; else token = Token . COMMENT1 ; break ; } } break ; default : backslash = false ; if ( ! Character . isLetterOrDigit ( c ) & & c ! = '_' & & c ! = '!' ) doKeyword ( line , i , c ) ; break ; } break ; case Token . COMMENT1 : case Token . COMMENT2 : backslash = false ; if ( c = = '*' & & length - i > 1 ) { if ( array [ i1 ] = = '/' ) { i + + ; addToken ( ( i + 1 ) - lastOffset , token ) ; token = Token . NULL ; lastOffset = lastKeyword = i + 1 ; } } break ; case Token . LITERAL1 : if ( backslash ) backslash = false ; else if ( c = = '"' ) { addToken ( i1 - lastOffset , token ) ; token = Token . NULL ; lastOffset = lastKeyword = i1 ; } else if ( c = = '\'' ) { addToken ( i1 - lastOffset , token ) ; token = Token . NULL ; lastOffset = lastKeyword = i1 ; } break ; case Token . LITERAL2 : if ( backslash ) backslash = false ; else if ( c = = ']' ) { addToken ( i1 - lastOffset , Token . LITERAL2 ) ; token = Token . NULL ; lastOffset = lastKeyword = i1 ; } break ; default : throw new InternalError ( " Invalid state:  " + token ) ; } } if ( token = = Token . NULL ) doKeyword ( line , length , '\0' ) ; switch ( token ) { case Token . LITERAL1 : case Token . LITERAL2 : addToken ( length - lastOffset , Token . INVALID ) ; token = Token . NULL ; break ; case Token . KEYWORD2 : addToken ( length - lastOffset , token ) ; if ( ! backslash ) token = Token . NULL ; default : addToken ( length - lastOffset , token ) ; break ; } return token ; }
protected void onOutputTask ( Task t ) { Idea i = ideas . get ( t ) ; if ( i = = null ) { return ; } update ( i ) ; }
public void forget ( Concept c ) { concepts . pickOut ( c . name ( ) ) ; concepts . forget ( c , memory . getTime ( ) ) ; concepts . putBack ( c , memory . getTime ( ) ) ; }
public static StringMap getAttrsWithLowercaseName ( @Nonnull final IMicroElement aElement ) { ValueEnforcer . notNull ( aElement , " Element " ) ; final StringMap ret = new StringMap ( ) ; final Map < String , String > aAttrs = aElement . getAllAttributes ( ) ; if ( aAttrs ! = null ) for ( final Map . Entry < String , String > aEntry : aAttrs . entrySet ( ) ) ret . setAttribute ( aEntry . getKey ( ) . toLowerCase ( Locale . US ) , aEntry . getValue ( ) ) ; return ret ; }
public void add ( Music music ) { if ( getById ( music . getSongId ( ) ) ! = null ) throw new IllegalArgumentException ( " Music is already on list " ) ; map . put ( new Integer ( music . getSongId ( ) ) , music ) ; while ( list . size ( ) < ( music . getPos ( ) + 1 ) ) list . add ( null ) ; list . set ( music . getPos ( ) , music ) ; }
public boolean isEmpty ( ) { return m . isEmpty ( ) ; }
public void before ( ) { field = DataTypes . createStructField ( " time " , DataTypes . TimestampType , true ) ; schema = DataTypes . createStructType ( Lists . newArrayList ( field ) ) ; tm = new TimestampTimeModel ( ) ; tm . configure ( ConfigFactory . empty ( ) ) ; tm . configureFieldNames ( Lists . newArrayList ( field . name ( ) ) ) ; Timestamp firstTs = new Timestamp ( 1000L ) ; firstTs . setNanos ( 1000 ) ; Timestamp secondTs = new Timestamp ( 2000L ) ; secondTs . setNanos ( 100 ) ; Timestamp thirdTs = new Timestamp ( 2000L ) ; thirdTs . setNanos ( 101 ) ; first = new RowWithSchema ( schema , firstTs ) ; second = new RowWithSchema ( schema , secondTs ) ; third = new RowWithSchema ( schema , thirdTs ) ; }
public static void main ( String [ ] args ) { NAR n = new DefaultNARBuilder ( ) . build ( ) ; new NARSwing ( n ) ; new Thread ( new Runnable ( ) {
protected void writeStream ( final InputStream in , final File destination ) throws IOException { final FileOutputStream out = new FileOutputStream ( destination ) ; StreamUtils . copyInputStreamToOutputStreamAndCloseOS ( in , out ) ; }
public Object clone ( ) { return new Operation ( name , cloneList ( components ) , isConstant ( ) , containVar ( ) , getComplexity ( ) ) ; }
public Concept conceptualize ( final BudgetValue budget , Term term ) { if ( term instanceof Interval ) { return null ; } term = CompoundTerm . replaceIntervals ( term ) ; final Concept displaced ; Concept concept ; synchronized ( concepts ) { concept = concepts . take ( term ) ; if ( concept = = null ) { concept = new Concept ( budget , term , this ) ; emit ( Events . ConceptNew . class , concept ) ; } else if ( concept ! = null ) { BudgetFunctions . activate ( concept . budget , budget , BudgetFunctions . Activating . TaskLink ) ; } else { return null ; } displaced = concepts . putBack ( concept , cycles ( param . conceptForgetDurations ) , this ) ; } if ( displaced = = null ) {
void load ( @Nonnull InputStream aIS , @Nonnull char [ ] aPassword ) throws OpenAS2Exception ; default void save ( ) throws OpenAS2Exception { save ( getFilename ( ) , getPassword ( ) ) ; } default void save ( @Nonnull final String sFilename , @Nonnull final char [ ] aPassword ) throws OpenAS2Exception { final OutputStream fOut = FileHelper . getOutputStream ( new File ( sFilename ) , EAppend . TRUNCATE ) ; save ( fOut , aPassword ) ; } void save ( @Nonnull OutputStream aOS , @Nonnull char [ ] aPassword ) throws OpenAS2Exception ; }
private void handleReads ( SelectionKey sk , MemcachedNode qa ) throws IOException { Operation currentOp = qa . getCurrentReadOp ( ) ; if ( currentOp instanceof TapAckOperationImpl ) { qa . removeCurrentReadOp ( ) ; return ; } ByteBuffer rbuf = qa . getRbuf ( ) ; final SocketChannel channel = qa . getChannel ( ) ; int read = channel . read ( rbuf ) ; metrics . updateHistogram ( OVERALL_AVG_BYTES_READ_METRIC , read ) ; if ( read < 0 ) { if ( currentOp instanceof TapOperation ) { currentOp . getCallback ( ) . complete ( ) ; ( ( TapOperation ) currentOp ) . streamClosed ( OperationState . COMPLETE ) ; getLogger ( ) . debug ( " Completed read op: %s and giving the next %d bytes " , currentOp , rbuf . remaining ( ) ) ; Operation op = qa . removeCurrentReadOp ( ) ; assert op = = currentOp : " Expected to pop  " + currentOp + "  got  " + op ; currentOp = qa . getCurrentReadOp ( ) ; } else { throw new IOException ( " Disconnected unexpected, will reconnect. " ) ; } } while ( read > 0 ) { getLogger ( ) . debug ( " Read %d bytes " , read ) ;
public void expandAll ( ) { for ( int i = 0 ; i < spyTree . getRowCount ( ) ; i + + ) spyTree . expandRow ( i ) ;
Transcoder < Object > getTranscoder ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
public final ICertificateFactory getCertificateFactory ( ) throws AS2ComponentNotFoundException { return ( ICertificateFactory ) getComponent ( COMPONENT_ID_CERTIFICATE_FACTORY ) ; }
public Token obtainToken ( ) { LOG . debug ( " Creating new token with generation: {} " , generation ) ; return SecurityUtils . createToken ( new byte [ 0 ] , generation + + ) ; }
public int nextToken ( ) throws IOException { if ( pushedBack ) { pushedBack = false ; return ttype ; } byte ct [ ] = ctype ; sval = null ; int c = peekc ; if ( c < 0 ) c = NEED_CHAR ; if ( c = = SKIP_LF ) { c = read ( ) ; if ( c < 0 ) return ttype = TT_EOF ; if ( c = = '\n' ) c = NEED_CHAR ; } if ( c = = NEED_CHAR ) { c = read ( ) ; if ( c < 0 ) return ttype = TT_EOF ; } ttype = c ; peekc = NEED_CHAR ; int ctype = c < 256 ? ct [ c ] : CT_ALPHA ; while ( ( ctype & CT_WHITESPACE ) ! = 0 ) { if ( c = = '\r' ) { LINENO + + ; if ( eolIsSignificantP ) { peekc = SKIP_LF ; return ttype = TT_EOL ; } c = read ( ) ; if ( c = = '\n' ) c = read ( ) ; } else { if ( c = = '\n' ) { LINENO + + ; if ( eolIsSignificantP ) { return ttype = TT_EOL ; } } c = read ( ) ; } if ( c < 0 ) return ttype = TT_EOF ; ctype = c < 256 ? ct [ c ] : CT_ALPHA ; } if ( ( ctype & CT_DIGIT ) ! = 0 ) { boolean neg = false ; if ( c = = '-' ) { c = read ( ) ; if ( c ! = '.' & & ( c < '0' | | c > '9' ) ) { peekc = c ; return ttype = '-' ; } neg = true ; } double v = 0 ; int decexp = 0 ; int seendot = 0 ; while ( true ) { if ( c = = '.' & & seendot = = 0 ) seendot = 1 ; else if ( '0' < = c & & c < = '9' ) { v = v * 10 + ( c - '0' ) ; decexp + = seendot ; } else break ; c = read ( ) ; } peekc = c ; if ( decexp ! = 0 ) { double denom = 10 ; decexp - - ; while ( decexp > 0 ) { denom * = 10 ; decexp - - ; } v = v / denom ; } nval = neg ? - v : v ; return ttype = TT_NUMBER ; } if ( ( ctype & CT_ALPHA ) ! = 0 ) { int i = 0 ; do { if ( i > = buf . length ) { char nb [ ] = new char [ buf . length * 2 ] ; System . arraycopy ( buf , 0 , nb , 0 , buf . length ) ; buf = nb ; } buf [ i + + ] = ( char ) c ; c = read ( ) ; ctype = c < 0 ? CT_WHITESPACE : c < 256 ? ct [ c ] : CT_ALPHA ; } while ( ( ctype & ( CT_ALPHA | CT_DIGIT ) ) ! = 0 ) ; peekc = c ; sval = String . copyValueOf ( buf , 0 , i ) ; if ( forceLower ) sval = sval . toLowerCase ( ) ; return ttype = TT_WORD ; } if ( ( ctype & CT_QUOTE ) ! = 0 ) { ttype = c ; int i = 0 ; int d = read ( ) ; while ( d > = 0 & & d ! = ttype ) { if ( d = = '\\' ) { c = read ( ) ; int first = c ; if ( c > = '0' & & c < = '7' ) { c = c - '0' ; int c2 = read ( ) ; if ( '0' < = c2 & & c2 < = '7' ) { c = ( c < < 3 ) + ( c2 - '0' ) ; c2 = read ( ) ; if ( '0' < = c2 & & c2 < = '7' & & first < = '3' ) { c = ( c < < 3 ) + ( c2 - '0' ) ; d = read ( ) ; } else d = c2 ; } else d = c2 ; } else { switch ( c ) { case 'a' : c = 0x7 ; break ; case 'b' : c = '\b' ; break ; case 'f' : c = 0xC ; break ; case 'n' : c = '\n' ; break ; case 'r' : c = '\r' ; break ; case 't' : c = '\t' ; break ; case 'v' : c = 0xB ; break ; } d = read ( ) ; } } else { c = d ; d = read ( ) ; } if ( i > = buf . length ) { char nb [ ] = new char [ buf . length * 2 ] ; System . arraycopy ( buf , 0 , nb , 0 , buf . length ) ; buf = nb ; } buf [ i + + ] = ( char ) c ; } peekc = ( d = = ttype ) ? NEED_CHAR : d ; sval = String . copyValueOf ( buf , 0 , i ) ; return ttype ; } if ( c = = '/' & & ( slashSlashCommentsP | | slashStarCommentsP ) ) { c = read ( ) ; if ( c = = '*' & & slashStarCommentsP ) { int prevc = 0 ; while ( ( c = read ( ) ) ! = '/' | | prevc ! = '*' ) { if ( c = = '\r' ) { LINENO + + ; c = read ( ) ; if ( c = = '\n' ) { c = read ( ) ; } } else { if ( c = = '\n' ) { LINENO + + ; c = read ( ) ; } } if ( c < 0 ) return ttype = TT_EOF ; prevc = c ; } return nextToken ( ) ; } else if ( c = = '/' & & slashSlashCommentsP ) { while ( ( c = read ( ) ) ! = '\n' & & c ! = '\r' & & c > = 0 ) ; peekc = c ; return nextToken ( ) ; } else { if ( ( ct [ '/' ] & CT_COMMENT ) ! = 0 ) { while ( ( c = read ( ) ) ! = '\n' & & c ! = '\r' & & c > = 0 ) ; peekc = c ; return nextToken ( ) ; } else { peekc = c ; return ttype = '/' ; } } } if ( ( ctype & CT_COMMENT ) ! = 0 ) { while ( ( c = read ( ) ) ! = '\n' & & c ! = '\r' & & c > = 0 ) ; peekc = c ; return nextToken ( ) ; } return ttype = c ; }
public boolean isEmpty ( ) { return false ; }
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; Set < String > listSaslMechanisms ( ) ; }
public Object clone ( ) { return new Similarity ( name , ( ArrayList < Term > ) cloneList ( components ) , isConstant ( ) , complexity ) ; }
public String toString ( ) { return " volume:  " + volume + " , bitrate:  " + bitrate + " , playlist:  " + playlistVersion + " , playlistLength:  " + playlistLength
public boolean supportsType ( Class < ? > type ) { return type ! = null & & ( ConfigFormat . super . supportsType ( type ) | | Temporal . class . isAssignableFrom ( type ) ) ; }
public void cycleWork ( ) { event . emit ( WorkCycleStart . class ) ; boolean recorderActive = recorder . isActive ( ) ; if ( recorderActive ) recorder . onCycleStart ( clock ) ; conceptProcessor . cycle ( this ) ; if ( recorderActive ) recorder . onCycleEnd ( clock ) ; if ( cyclesQueued > 0 ) cyclesQueued - - ; clock + + ; event . emit ( WorkCycleEnd . class ) ;
public void onCreateContextMenu ( final ContextMenu menu , final View v , final ContextMenu . ContextMenuInfo menuInfo ) { super . onCreateContextMenu ( menu , v , menuInfo ) ; final MenuItem editItem = menu . add ( Menu . NONE , EDIT , 0 , R . string . editPlaylist ) ; editItem . setOnMenuItemClickListener ( this ) ; final MenuItem addAndReplaceItem = menu . add ( Menu . NONE , DELETE , 0 , R . string . deletePlaylist ) ; addAndReplaceItem . setOnMenuItemClickListener ( this ) ; }
KeyStore createNewKeyStore ( @Nonnull IKeyStoreType aKeyStoreType ) throws Exception ; @Nonnull KeyStore loadKeyStore ( @Nonnull final IKeyStoreType aKeyStoreType , @Nonnull @WillNotClose InputStream aIS , @Nonnull char [ ] aPassword ) throws Exception ; boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isCompressed ( @Nonnull String sContentType ) throws OpenAS2Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt , boolean bLargeFileOn ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
void startActiveModules ( ) ; void stopActiveModules ( ) ; List < IProcessorActiveModule > getActiveModules ( ) ; }
public double computeSD ( double squaredVal , double val , long size ) { if ( size > 1 ) { return Math . sqrt ( ( squaredVal - ( ( val * val ) / size ) ) / ( size - 1.0 ) ) ; } return 0.0 ; }
public < V > void defineOfClass ( String path , Supplier < V > defaultValueSupplier , Class < ? super V > acceptableValueClass ) { defineOfClass ( split ( path , '.' ) , defaultValueSupplier , acceptableValueClass ) ; }
public static Term make ( final Term t , final Memory memory ) { if ( t instanceof Negation ) { return ( ( CompoundTerm ) t ) . cloneComponents ( ) . get ( 0 ) ; } final ArrayList < Term > argument = new ArrayList < > ( 1 ) ; argument . add ( t ) ; return make ( argument , memory ) ; }
protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else if ( o instanceof Short ) { extraLen + = 2 ; } else { assert false : " Unhandled extra header type:   " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; ByteBuffer bb = ByteBuffer . allocate ( bufSize + extraLen ) ; assert bb . order ( ) = = ByteOrder . BIG_ENDIAN ; bb . put ( REQ_MAGIC ) ; bb . put ( cmd ) ; bb . putShort ( ( short ) keyBytes . length ) ; bb . put ( ( byte ) extraLen ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( vbucket ) ; bb . putInt ( keyBytes . length + val . length + extraLen ) ; bb . putInt ( opaque ) ; bb . putLong ( cas ) ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { bb . putInt ( ( Integer ) o ) ; } else if ( o instanceof byte [ ] ) { bb . put ( ( byte [ ] ) o ) ; } else if ( o instanceof Long ) { bb . putLong ( ( Long ) o ) ; } else if ( o instanceof Short ) { bb . putShort ( ( Short ) o ) ; } else { assert false : " Unhandled extra header type:   " + o . getClass ( ) ; } } bb . put ( keyBytes ) ; bb . put ( val ) ; bb . flip ( ) ; setBuffer ( bb ) ; }
public void testMultipleTopicsConfigure ( ) { KafkaInput kafkaInput = new KafkaInput ( ) ; new Expectations ( ) { { config . getStringList ( KafkaInput . TOPICS_CONFIG ) ; returns ( Lists . newArrayList ( " foo " , " bar " , " bar " ) ) ; config . getString ( KafkaInput . ENCODING_CONFIG ) ; returns ( " string " ) ; } } ; kafkaInput . configure ( config ) ; assertEquals ( kafkaInput . topics . size ( ) , 2 ) ; assertTrue ( kafkaInput . topics . contains ( " foo " ) ) ; assertTrue ( kafkaInput . topics . contains ( " bar " ) ) ; }
public static void main ( String [ ] args ) { NAR nd = new NAR ( new Plugins ( ) ) ; test ( nd ) ;
Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public String toString ( ) { if ( NARRun . isStandAlone ( ) ) { return ( super . toStringBrief ( ) + "   " + key ) ;
void testTrimmedView ( ) { CharsWrapper trimmed = new CharsWrapper ( "   		 " ) . trimmedView ( ) ; assertEquals ( " " , trimmed . toString ( ) ) ; trimmed = new CharsWrapper ( "  1234  " ) . trimmedView ( ) ; assertEquals ( " 1234 " , trimmed . toString ( ) ) ; trimmed = new CharsWrapper ( " 			a " ) . trimmedView ( ) ; assertEquals ( " a " , trimmed . toString ( ) ) ; trimmed = new CharsWrapper ( " a			 " ) . trimmedView ( ) ; assertEquals ( " a " , trimmed . toString ( ) ) ; trimmed = new CharsWrapper ( " a			b " ) . trimmedView ( ) ; assertEquals ( " a			b " , trimmed . toString ( ) ) ; }
public void viewDebugInformation ( ) { debugArea . setVisible ( true ) ; }
public static double xlogx ( int c ) { if ( c = = 0 ) { return 0.0 ; } return c * Utils . log2 ( ( double ) c ) ; }
private static boolean testJavaMaxHeap ( ) { java . util . PriorityQueue < Integer > maxArrayHeap = new java . util . PriorityQueue < Integer > ( 10 , new Comparator < Integer > ( ) { @Override public int compare ( Integer arg0 , Integer arg1 ) { if ( arg0 . compareTo ( arg1 ) > 0 ) return - 1 ; else if ( arg1 . compareTo ( arg0 ) > 0 ) return 1 ; return 0 ; } } ) ; if ( ! testJavaCollection ( maxArrayHeap , Type . Integer , " Java's Max-Heap [array] " ) ) return false ; return true ; }
public int compare ( AlbumItem o1 , AlbumItem o2 ) { return String . CASE_INSENSITIVE_ORDER . compare ( o1 . getName ( ) , o2 . getName ( ) ) ; }
public static Operation make ( final Operator oper , final Term [ ] arg , boolean addSelf ) { return new Operation ( termArray ( Product . make ( arg ) , oper ) ) ; }
protected void initClient ( ) throws Exception { client = new MemcachedClient ( new DefaultConnectionFactory ( ) { @Override
private Intent createIntent ( String action , Uri data , String extraData , String query , int actionKey , String actionMsg ) { Intent intent = new Intent ( action ) ; intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; if ( data ! = null ) { intent . setData ( data ) ; } intent . putExtra ( SearchManager . USER_QUERY , mUserQuery ) ; if ( query ! = null ) { intent . putExtra ( SearchManager . QUERY , query ) ; } if ( extraData ! = null ) { intent . putExtra ( SearchManager . EXTRA_DATA_KEY , extraData ) ; } if ( mAppSearchData ! = null ) { intent . putExtra ( SearchManager . APP_DATA , mAppSearchData ) ; } if ( actionKey ! = KeyEvent . KEYCODE_UNKNOWN ) { intent . putExtra ( SearchManager . ACTION_KEY , actionKey ) ; intent . putExtra ( SearchManager . ACTION_MSG , actionMsg ) ; } intent . setComponent ( mSearchable . getSearchActivity ( ) ) ; return intent ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . URICur p , A arg ) { R r = leaf ( arg ) ; r = combine ( p . nsprefix_ . accept ( this , arg ) , r , arg ) ; return r ; }
public void initDynamicComponent ( @Nonnull final IAS2Session aSession , @Nullable final IStringMap aParams ) throws AS2Exception { final StringMap aParameters = aParams = = null ? new StringMap ( ) : new StringMap ( aParams ) ; final String sPort = aParameters . getAsString ( ATTR_PORTID ) ; try { final int nPort = Integer . parseInt ( sPort ) ; final SSLServerSocketFactory aSSLServerSocketFactory = ( SSLServerSocketFactory ) SSLServerSocketFactory . getDefault ( ) ; m_aSSLServerSocket = ( SSLServerSocket ) aSSLServerSocketFactory . createServerSocket ( nPort ) ; final String [ ] aEnabledCipherSuites = getEnabledAnonymousCipherSuites ( m_aSSLServerSocket . getEnabledCipherSuites ( ) , m_aSSLServerSocket . getSupportedCipherSuites ( ) ) ; m_aSSLServerSocket . setEnabledCipherSuites ( aEnabledCipherSuites ) ; } catch ( final IOException e ) { throw new AS2Exception ( e ) ; } catch ( final NumberFormatException e ) { throw new AS2Exception ( " Error converting portid parameter ' " + sPort + " ':  " + e ) ; } m_sUserID = aParameters . getAsString ( ATTR_USERID ) ; if ( StringHelper . hasNoText ( m_sUserID ) ) throw new AS2Exception ( " missing 'userid' parameter " ) ; m_sPassword = aParameters . getAsString ( ATTR_PASSWORD ) ; if ( StringHelper . hasNoText ( m_sPassword ) ) throw new AS2Exception ( " missing 'password' parameter " ) ; try {
public int update ( Uri uri , ContentValues values , String where , String [ ] whereArgs ) { SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; int count ; switch ( sUriMatcher . match ( uri ) ) { case NOTES : count = db . update ( NOTES_TABLE_NAME , values , where , whereArgs ) ; break ; case NOTE_ID : String noteId = uri . getPathSegments ( ) . get ( 1 ) ; count = db . update ( NOTES_TABLE_NAME , values , NoteColumns . _ID + " = " + noteId + ( ! TextUtils . isEmpty ( where ) ? "  AND ( " + where + ')' : " " ) , whereArgs ) ; break ; default : throw new IllegalArgumentException ( " Unknown URI  " + uri ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; return count ; }
public char directReadChar ( ) throws ParsingException { if ( index > = chars . length ) throw new ParsingException ( " Not enough data available " ) ; return chars [ index + + ] ; }
public Iterator < Map . Entry < K , V > > iterator ( ) { return new EntryIterator ( getFirstEntry ( ) ) ; }
private boolean removeChild ( Node < T > child ) { boolean found = false ; if ( childrenSize = = 0 ) return found ; for ( int i = 0 ; i < childrenSize ; i + + ) { if ( children [ i ] . equals ( child ) ) { found = true ; } else if ( found ) { children [ i - 1 ] = children [ i ] ; } } if ( found ) { childrenSize - - ; children [ childrenSize ] = null ; } return found ; }
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public void removeConnectionListener ( ConnectionListener listener ) { connectionListners . remove ( listener ) ; }
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . library_tabs_settings ) ; ArrayList < String > allTabs = LibraryTabsUtil . getAllLibraryTabs ( ) ; ArrayList < String > currentTabs = LibraryTabsUtil . getCurrentLibraryTabs ( this . getApplicationContext ( ) ) ; ArrayList < String > hiddenTabs = new ArrayList < String > ( ) ; for ( String tab : allTabs ) { if ( ! currentTabs . contains ( tab ) ) { hiddenTabs . add ( tab ) ; } } tabList = new ArrayList < Object > ( ) ; tabList . add ( getString ( R . string . visibleTabs ) ) ; for ( int i = 0 ; i < currentTabs . size ( ) ; i + + ) { tabList . add ( new TabItem ( currentTabs . get ( i ) ) ) ; } tabList . add ( getString ( R . string . hiddenTabs ) ) ; for ( int i = 0 ; i < hiddenTabs . size ( ) ; i + + ) { tabList . add ( new TabItem ( hiddenTabs . get ( i ) ) ) ; } adapter = new SeparatedListAdapter ( this , R . layout . library_tabs_settings_item , new TabListDataBinder ( ) , tabList ) ; setListAdapter ( adapter ) ; ListView mList ; mList = getListView ( ) ; ( ( TouchInterceptor ) mList ) . setDropListener ( mDropListener ) ; }
Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public Complex sub ( final Complex x ) { final Complex copy = new Complex ( this . real , this . imaginary ) ; copy . real - = x . real ; copy . imaginary - = x . imaginary ; return copy ; }
protected boolean outOfBaseComplete ( final E oldItem ) { for ( int i = 0 ; i < levels ; i + + ) { if ( itemTable [ i ] ! = null ) if ( itemTable [ i ] . remove ( oldItem ) = = true ) return true ; } return false ; }
public E take ( final E value ) { return take ( value . name ( ) ) ; }
OperationState getState ( ) ; ByteBuffer getBuffer ( ) ; void writing ( ) ; void writeComplete ( ) ; void initialize ( ) ; void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; MemcachedNode getHandlingNode ( ) ; void setHandlingNode ( MemcachedNode to ) ; public void timeOut ( ) ; public boolean isTimedOut ( ) ; public boolean isTimedOut ( long ttlMillis ) ; public boolean isTimedOutUnsent ( ) ; }
public List < String > subList ( int arg0 , int arg1 ) { return null ; }
public String toString ( ) { return " \" " + message + " \" " ; }
BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public static IMessageMDN createMDN ( @Nonnull final IAS2Session aSession , @Nonnull final AS2Message aMsg , @Nonnull final DispositionType aDisposition , @Nonnull final String sText ) throws Exception { ValueEnforcer . notNull ( aSession , " AS2Session " ) ; ValueEnforcer . notNull ( aMsg , " AS2Message " ) ; ValueEnforcer . notNull ( aDisposition , " Disposition " ) ; ValueEnforcer . notNull ( sText , " Text " ) ; final Partnership aPartnership = aMsg . partnership ( ) ; final AS2MessageMDN aMDN = new AS2MessageMDN ( aMsg ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . AS2_VERSION , CAS2Header . DEFAULT_AS2_VERSION ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . DATE , AS2DateHelper . getFormattedDateNow ( CAS2Header . DEFAULT_DATE_FORMAT ) ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . SERVER , CAS2Info . NAME_VERSION ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . MIME_VERSION , CAS2Header . DEFAULT_MIME_VERSION ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . AS2_FROM , aPartnership . getReceiverAS2ID ( ) ) ; aMDN . headers ( ) . setHeader ( CHttpHeader . AS2_TO , aPartnership . getSenderAS2ID ( ) ) ; aMDN . partnership ( ) . setSenderAS2ID ( aMDN . getHeader ( CHttpHeader . AS2_FROM ) ) ; aMDN . partnership ( ) . setReceiverAS2ID ( aMDN . getHeader ( CHttpHeader . AS2_TO ) ) ; aMDN . partnership ( ) . setSenderX509Alias ( aPartnership . getReceiverX509Alias ( ) ) ; aMDN . partnership ( ) . setReceiverX509Alias ( aPartnership . getSenderX509Alias ( ) ) ; try { aSession . getPartnershipFactory ( ) . updatePartnership ( aMDN , true ) ; } catch ( final AS2PartnershipNotFoundException ex ) { } aMDN . headers ( ) . setHeader ( CHttpHeader . FROM , aPartnership . getReceiverEmail ( ) ) ; final String sSubject = aMDN . partnership ( ) . getMDNSubject ( ) ; if ( sSubject ! = null ) { aMDN . headers ( ) . setHeader ( CHttpHeader . SUBJECT , new MessageParameters ( aMsg ) . format ( sSubject ) ) ; } else { aMDN . headers ( ) . setHeader ( CHttpHeader . SUBJECT , " Your Requested MDN Response " ) ; } final String sCTE = aPartnership . getContentTransferEncodingSend ( EContentTransferEncoding . AS2_DEFAULT . getID ( ) ) ; aMDN . headers ( ) . addHeader ( CHttpHeader . CONTENT_TRANSFER_ENCODING , sCTE ) ; aMDN . setText ( new MessageParameters ( aMsg ) . format ( sText ) ) ; aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_REPORTING_UA , CAS2Info . NAME_VERSION + " @ " + aMsg . attrs ( ) . getAsString ( CNetAttribute . MA_DESTINATION_IP ) + " : " + aMsg . attrs ( ) . getAsString ( CNetAttribute . MA_DESTINATION_PORT ) ) ; aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_ORIG_RECIPIENT , " rfc822;  " + aMsg . getHeader ( CHttpHeader . AS2_TO ) ) ; aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_FINAL_RECIPIENT , " rfc822;  " + aPartnership . getReceiverAS2ID ( ) ) ; aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_ORIG_MESSAGEID , aMsg . getHeader ( CHttpHeader . MESSAGE_ID ) ) ; aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_DISPOSITION , aDisposition . getAsString ( ) ) ; final String sDispositionOptions = aMsg . getHeader ( CHttpHeader . DISPOSITION_NOTIFICATION_OPTIONS ) ; final DispositionOptions aDispositionOptions = DispositionOptions . createFromString ( sDispositionOptions ) ; ECryptoAlgorithmSign eSigningAlgorithm = aDispositionOptions . getFirstMICAlg ( ) ; if ( eSigningAlgorithm = = null ) { final String sSigningAlgorithm = aPartnership . getSigningAlgorithm ( ) ; eSigningAlgorithm = ECryptoAlgorithmSign . getFromIDOrNull ( sSigningAlgorithm ) ; if ( eSigningAlgorithm = = null ) { if ( LOGGER . isWarnEnabled ( ) ) LOGGER . warn ( " The partnership signing algorithm name ' " + sSigningAlgorithm + " ' is unknown. " ) ; } } MIC aMIC = null ; if ( eSigningAlgorithm ! = null ) { final boolean bIncludeHeadersInMIC = aPartnership . getSigningAlgorithm ( ) ! = null | | aPartnership . getEncryptAlgorithm ( ) ! = null | | aPartnership . getCompressionType ( ) ! = null ; aMIC = getCryptoHelper ( ) . calculateMIC ( aMsg . getData ( ) , eSigningAlgorithm , bIncludeHeadersInMIC ) ; } if ( aMIC ! = null ) aMDN . attrs ( ) . putIn ( AS2MessageMDN . MDNA_MIC , aMIC . getAsAS2String ( ) ) ; boolean bSignMDN = false ; boolean bIncludeCertificateInSignedContent = false ; if ( aDispositionOptions . getProtocol ( ) ! = null ) { if ( aDispositionOptions . isProtocolRequired ( ) | | aDispositionOptions . hasMICAlg ( ) ) { bSignMDN = true ; final ETriState eIncludeCertificateInSignedContent = aPartnership . getIncludeCertificateInSignedContent ( ) ; if ( eIncludeCertificateInSignedContent . isDefined ( ) ) { bIncludeCertificateInSignedContent = eIncludeCertificateInSignedContent . getAsBooleanValue ( ) ; } else { bIncludeCertificateInSignedContent = aSession . isCryptoSignIncludeCertificateInBodyPart ( ) ; } } } final boolean bUseOldRFC3851MicAlgs = aPartnership . isRFC3851MICAlgs ( ) ; createMDNData ( aSession , aMDN , bSignMDN , bIncludeCertificateInSignedContent , aDispositionOptions . getFirstMICAlg ( ) , bUseOldRFC3851MicAlgs ) ; aMDN . updateMessageID ( ) ; aMsg . setMDN ( aMDN ) ; return aMDN ; }
public StatsOperation stats ( String arg , net . spy . memcached . ops . StatsOperation . Callback cb ) { return new StatsOperationImpl ( arg , cb ) ; }
public static void main ( String args [ ] ) { NAR n = new Default ( ) . build ( ) ; new SlowMesh ( n , 6 , 6 ) ; new NARSwing ( n ) ; ConceptGraphCanvas2 cv ; new NWindow ( " Concept Graph 2 " , new ProcessingGraphPanel ( n , cv = new ConceptGraphCanvas2 ( n ) ) ) . show ( 500 , 500 ) ; cv . setTaskLinks ( false ) ; }
private void writeObject ( @Nonnull final ObjectOutputStream aOOS ) throws IOException { aOOS . writeObject ( m_aContentType . toString ( ) ) ; aOOS . writeObject ( m_aAttributes ) ; }
public String [ ] getCoverUrl ( AlbumInfo albumInfo ) throws Exception { String deezerResponse ; JSONObject jsonRootObject ; JSONArray jsonArray ; String coverUrl ; JSONObject jsonObject ; try { deezerResponse = executeGetRequest ( " http://api.deezer.com/search/album?q= " + albumInfo . getAlbum ( ) + "   " + albumInfo . getArtist ( ) + " &nb_items=1&output=json " ) ; jsonRootObject = new JSONObject ( deezerResponse ) ; jsonArray = jsonRootObject . getJSONArray ( " data " ) ; for ( int i = 0 ; i < jsonArray . length ( ) ; i + + ) { jsonObject = jsonArray . getJSONObject ( i ) ; coverUrl = jsonObject . getString ( " cover " ) ; if ( coverUrl ! = null ) { coverUrl + = " &size=big " ; return new String [ ] { coverUrl } ; } } } catch ( Exception e ) { Log . e ( DeezerCover . class . toString ( ) , " Failed to get cover URL from Deeze " ) ; } return new String [ 0 ] ; }
public void testRangeValues ( ) { Set < Step > steps = Sets . newHashSet ( ) ; Map < String , Object > loopStepConfigMap = Maps . newHashMap ( ) ; loopStepConfigMap . put ( LoopStep . MODE_PROPERTY , LoopStep . MODE_PARALLEL ) ; loopStepConfigMap . put ( LoopStep . SOURCE_PROPERTY , LoopStep . SOURCE_RANGE ) ; loopStepConfigMap . put ( LoopStep . RANGE_START_PROPERTY , 5 ) ; loopStepConfigMap . put ( LoopStep . RANGE_END_PROPERTY , 7 ) ; Config loopStepConfig = ConfigFactory . parseMap ( loopStepConfigMap ) ; LoopStep loopStep = new LoopStep ( " loop_step " , loopStepConfig ) ; steps . add ( loopStep ) ; Map < String , Object > step1ConfigMap = Maps . newHashMap ( ) ; step1ConfigMap . put ( " dependencies " , Lists . newArrayList ( " loop_step " ) ) ; Config step1Config = ConfigFactory . parseMap ( step1ConfigMap ) ; Step step1 = new BatchStep ( " step1 " , step1Config ) ; steps . add ( step1 ) ; Set < Step > unrolled = loopStep . unrollLoop ( steps ) ; assertEquals ( unrolled . size ( ) , 4 ) ; assertNotNull ( StepUtils . getStepForName ( " loop_step " , unrolled ) . get ( ) ) ; assertNotNull ( StepUtils . getStepForName ( " step1_5 " , unrolled ) . get ( ) ) ; assertNotNull ( StepUtils . getStepForName ( " step1_6 " , unrolled ) . get ( ) ) ; assertNotNull ( StepUtils . getStepForName ( " step1_7 " , unrolled ) . get ( ) ) ; assertEquals ( StepUtils . getStepForName ( " loop_step " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_5 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_6 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_7 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; }
protected void markAsChanged ( ) throws OpenAS2Exception { } @Nonnull @OverridingMethodsMustInvokeSuper public Partnership getPartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { ValueEnforcer . notNull ( aPartnership , " Partnership " ) ; m_aRWLock . readLock ( ) . lock ( ) ; try { Partnership aRealPartnership = m_aPartnerships . getPartnershipByName ( aPartnership . getName ( ) ) ; if ( aRealPartnership = = null ) { aRealPartnership = m_aPartnerships . getPartnershipByID ( aPartnership . getAllSenderIDs ( ) , aPartnership . getAllReceiverIDs ( ) ) ; } if ( aRealPartnership = = null ) throw new PartnershipNotFoundException ( aPartnership ) ; return aRealPartnership ; } finally { m_aRWLock . readLock ( ) . unlock ( ) ; } } @Nullable public Partnership getPartnershipByName ( @Nullable final String sName ) { return m_aRWLock . readLocked ( ( ) - > m_aPartnerships . getPartnershipByName ( sName ) ) ; } @Nonnull @ReturnsMutableCopy public ICommonsSet < String > getAllPartnershipNames ( ) { return m_aRWLock . readLocked ( ( ) - > m_aPartnerships . getAllPartnershipNames ( ) ) ; } @Nonnull @ReturnsMutableCopy public ICommonsList < Partnership > getAllPartnerships ( ) { return m_aRWLock . readLocked ( ( ) - > m_aPartnerships . getAllPartnerships ( ) ) ; } @Nonnull public IPartnershipMap getPartnershipMap ( ) { return m_aRWLock . readLocked ( ( ) - > m_aPartnerships ) ; } protected final void setPartnerships ( @Nonnull final PartnershipMap aPartnerships ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { m_aPartnerships . setPartnerships ( aPartnerships ) ; markAsChanged ( ) ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } @Nonnull public final EChange addPartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { if ( m_aPartnerships . addPartnership ( aPartnership ) . isUnchanged ( ) ) return EChange . UNCHANGED ; markAsChanged ( ) ; return EChange . CHANGED ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } @Nonnull public final EChange removePartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try { if ( m_aPartnerships . removePartnership ( aPartnership ) . isUnchanged ( ) ) return EChange . UNCHANGED ; markAsChanged ( ) ; return EChange . CHANGED ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } public final void updatePartnership ( @Nonnull final IMessage aMsg , final boolean bOverwrite ) throws OpenAS2Exception { ValueEnforcer . notNull ( aMsg , " Message " ) ; final Partnership aPartnership = getPartnership ( aMsg . getPartnership ( ) ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Updating partnership  " + aPartnership ) ; aMsg . getPartnership ( ) . copyFrom ( aPartnership ) ; if ( bOverwrite ) { final String sSubject = aPartnership . getSubject ( ) ; if ( sSubject ! = null ) { aMsg . setSubject ( new MessageParameters ( aMsg ) . format ( sSubject ) ) ; } } } public final void updatePartnership ( @Nonnull final IMessageMDN aMdn , final boolean bOverwrite ) throws OpenAS2Exception { ValueEnforcer . notNull ( aMdn , " MessageMDN " ) ; final Partnership aPartnership = getPartnership ( aMdn . getPartnership ( ) ) ; aMdn . getPartnership ( ) . copyFrom ( aPartnership ) ; } @Override public String toString ( ) { return ToStringGenerator . getDerived ( super . toString ( ) ) . append ( " Partnerships " , m_aPartnerships ) . toString ( ) ; } }
public static void reason ( final TaskLink tLink , final TermLink bLink , final Memory memory ) { memory . logic . REASON . commit ( tLink . getPriority ( ) ) ; final Task task = memory . getCurrentTask ( ) ; Sentence taskSentence = task . sentence ; Term taskTerm = taskSentence . content . clone ( ) ; Term beliefTerm = bLink . target . clone ( ) ; if ( ( taskTerm instanceof Statement ) & & ( taskTerm instanceof Implication ) & & ( taskSentence . isJudgment ( ) ) ) { StructuralRules . contrapositionAttempts ( ( Statement ) taskTerm , taskSentence , memory ) ; } if ( equalSubTermsInRespectToImageAndProduct ( taskTerm , beliefTerm ) ) return ; Concept beliefConcept = memory . concept ( beliefTerm ) ; Sentence belief = ( beliefConcept ! = null ) ? beliefConcept . getBelief ( task ) : null ; memory . setCurrentBelief ( belief ) ; if ( belief ! = null ) { LocalRules . match ( task , belief , memory ) ; if ( ! memory . noResult ( ) ) { return ; } } Sentence buf1 = memory . getCurrentBelief ( ) ; Task buf2 = memory . getCurrentTask ( ) ; CompositionalRules . dedSecondLayerVariableUnification ( task , memory ) ; memory . setCurrentBelief ( buf1 ) ; memory . setCurrentTask ( buf2 ) ; if ( ! memory . noResult ( ) & & task . sentence . isJudgment ( ) ) { return ; } CompositionalRules . dedConjunctionByQuestion ( taskSentence , belief , memory ) ; short tIndex = tLink . getIndex ( 0 ) ; short bIndex = bLink . getIndex ( 0 ) ; switch ( tLink . type ) { case TermLink . SELF :
public boolean queue ( X task ) { return buffer . add ( task ) ; }
short getIndex ( final int i ) ; T getTarget ( ) ; float getPriority ( ) ; }
public LayoutParams generateOverflowButtonLayoutParams ( ) { LayoutParams result = generateDefaultLayoutParams ( ) ; result . isOverflowButton = true ; return result ; }
public void copyFrom ( @Nonnull final Partnership aPartnership ) { m_sName = aPartnership . getName ( ) ; m_aSenderIDs . setAttributes ( aPartnership . m_aSenderIDs ) ; m_aReceiverIDs . setAttributes ( aPartnership . m_aReceiverIDs ) ; m_aAttributes . setAttributes ( aPartnership . m_aAttributes ) ; }
protected void checkValid ( ) { if ( ! valid ) { throw new IllegalStateException (
public final void setMessageID ( final String sMessageID ) { setHeader ( CAS2Header . HEADER_MESSAGE_ID , sMessageID ) ; }
public void testGracefulShutdownTooSlow ( ) throws Exception { for ( int i = 0 ; i < 10000 ; i + + ) { client . set ( " t " + i , 10 , i ) ; } assertFalse ( " Weird, shut down too fast " , client . shutdown ( 1 , TimeUnit . MILLISECONDS ) ) ; try { Map < SocketAddress , String > m = client . getVersions ( ) ; fail ( " Expected failure, got  " + m ) ; } catch ( IllegalStateException e ) { assertEquals ( " Shutting down " , e . getMessage ( ) ) ; } initClient ( ) ; }
public void writeToParcel ( final Parcel dest , final int flags ) { dest . writeString ( getAlbum ( ) ) ; dest . writeString ( getArtist ( ) ) ; dest . writeString ( getAlbumArtist ( ) ) ; dest . writeString ( getFullpath ( ) ) ; dest . writeInt ( getDisc ( ) ) ; dest . writeLong ( getDate ( ) ) ; dest . writeString ( getGenre ( ) ) ; dest . writeLong ( getTime ( ) ) ; dest . writeString ( getTitle ( ) ) ; dest . writeInt ( getTotalTracks ( ) ) ; dest . writeInt ( getTrack ( ) ) ; dest . writeInt ( getSongId ( ) ) ; dest . writeInt ( getPos ( ) ) ; dest . writeString ( getName ( ) ) ; }
