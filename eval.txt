DataFrame derive ( Map < String , DataFrame > dependencies ) throws Exception ; }
public String getParameter ( final String sKey , final String sDefaultValue ) { final String value = getParameterNotRequired ( sKey ) ; return value = = null ? sDefaultValue : value ; }
public MimeBodyPart sign ( @Nonnull final MimeBodyPart aPart , @Nonnull final X509Certificate aX509Cert , @Nonnull final PrivateKey aPrivateKey , @Nonnull final ECryptoAlgorithmSign eAlgorithm , final boolean bIncludeCertificateInSignedContent , final boolean bUseOldRFC3851MicAlgs , @Nonnull final EContentTransferEncoding eCTE ) throws GeneralSecurityException , SMIMEException , MessagingException , OperatorCreationException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( aX509Cert , " X509Cert " ) ; ValueEnforcer . notNull ( aPrivateKey , " PrivateKey " ) ; ValueEnforcer . notNull ( eAlgorithm , " Algorithm " ) ; ValueEnforcer . notNull ( eCTE , " ContentTransferEncoding " ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " BCCryptoHelper.sign; X509 subject= " + aX509Cert . getSubjectX500Principal ( ) . getName ( ) + " ; algorithm= " + eAlgorithm + " ; includeCertificateInSignedContent= " + bIncludeCertificateInSignedContent + " ; CTE= " + eCTE ) ; aX509Cert . checkValidity ( ) ; final ICommonsList < X509Certificate > aCertList = new CommonsArrayList < > ( aX509Cert ) ; final JcaCertStore aCertStore = new JcaCertStore ( aCertList ) ; final ASN1EncodableVector aSignedAttrs = new ASN1EncodableVector ( ) ; final SMIMECapabilityVector aCapabilities = new SMIMECapabilityVector ( ) ; aCapabilities . addCapability ( eAlgorithm . getOID ( ) ) ; aSignedAttrs . add ( new SMIMECapabilitiesAttribute ( aCapabilities ) ) ; final SMIMESignedGenerator aSGen = new SMIMESignedGenerator ( bUseOldRFC3851MicAlgs ? SMIMESignedGenerator . RFC3851_MICALGS : SMIMESignedGenerator . RFC5751_MICALGS ) ; aSGen . setContentTransferEncoding ( eCTE . getID ( ) ) ; aSGen . addSignerInfoGenerator ( new JcaSimpleSignerInfoGeneratorBuilder ( ) . setProvider ( m_sSecurityProviderName ) . setSignedAttributeGenerator ( new AttributeTable ( aSignedAttrs ) ) . build ( eAlgorithm . getSignAlgorithmName ( ) , aPrivateKey , aX509Cert ) ) ; if ( bIncludeCertificateInSignedContent ) { aSGen . addCertificates ( aCertStore ) ; } final MimeMultipart aSignedData = aSGen . generate ( aPart ) ; final MimeBodyPart aSignedPart = new MimeBodyPart ( ) ; aSignedPart . setContent ( aSignedData ) ; aSignedPart . setHeader ( CHttpHeader . CONTENT_TYPE , aSignedData . getContentType ( ) ) ; return aSignedPart ; }
public void reset ( ) { resetMappings ( ) ; notifyDataSetChanged ( ) ; }
FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; int getReadBufSize ( ) ; public HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; }
public void testAmericanFlagSorts ( ) { Integer [ ] result = AmericanFlagSort . sort ( unsorted . clone ( ) ) ; assertTrue ( " American flag sort unsorted error. result= " + print ( result ) , check ( result ) ) ; result = AmericanFlagSort . sort ( sorted . clone ( ) ) ; assertTrue ( " American flag sort sorted error. result= " + print ( result ) , check ( result ) ) ; result = AmericanFlagSort . sort ( reverse . clone ( ) ) ; assertTrue ( " American flag sort reverse error. result= " + print ( result ) , check ( result ) ) ; }
protected X509Certificate internalGetCertificate ( @Nullable final String sAlias , @Nullable final ECertificatePartnershipType ePartnershipType ) throws OpenAS2Exception { final String sRealAlias = getUnifiedAlias ( sAlias ) ; try {
private void remove ( Node node ) { if ( node . isWord ) return ; if ( node . loKid ! = null | | node . kid ! = null | | node . hiKid ! = null ) return ; final Node parent = node . parent ; if ( parent ! = null ) {
public int plan ( final nars . core . control . NAL nal , Concept c , Task task , Term target , int particles , double searchDistance , char punctuation , int maxTasks ) { TreeSet < ParticlePlan > plans = particlePlan ( target , searchDistance , particles ) ; int n = 0 ; boolean emittingPlans = memory . emitting ( ParticlePlan . class ) ; for ( ParticlePlan p : plans ) { planTask ( nal , p , c , task , target , punctuation ) ; if ( emittingPlans ) { memory . emit ( ParticlePlan . class , target , p ) ; } if ( n + + = = maxTasks ) break ; } memory . logic . PLAN_TASK_PLANNED . commit ( n ) ; return n ;
private boolean onItemSelected ( int position ) { if ( mOnSuggestionListener = = null | | ! mOnSuggestionListener . onSuggestionSelect ( position ) ) { rewriteQueryFromSuggestion ( position ) ; return true ; } return false ; }
public void testOneArrivingOneExistingWhereArrivingSameTimeAsExistingWithSameValues ( ) { p = new BitemporalHistoryPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , 1L , 253402214400000L , CURRENT_FLAG_DEFAULT_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " hello " , 100L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 0 ) ; }
public void nextOutput ( ArrayList < String > output ) ; public void tickTimer ( ) ; }
public boolean directProcess ( final Task task ) { char type = task . sentence . punctuation ; switch ( type ) { case Symbols . JUDGMENT_MARK : memory . logic . JUDGMENT_PROCESS . commit ( ) ; processJudgment ( task ) ; break ; case Symbols . GOAL_MARK : memory . logic . GOAL_PROCESS . commit ( ) ; processGoal ( task ) ; break ; case Symbols . QUESTION_MARK : case Symbols . QUEST_MARK : memory . logic . QUESTION_PROCESS . commit ( ) ; processQuestion ( task ) ; break ; default : return false ; } if ( task . aboveThreshold ( ) ) { memory . logic . LINK_TO_TASK . commit ( ) ; linkToTask ( task ) ; } if ( entityObserver . isActive ( ) ) { entityObserver . refresh ( displayContent ( ) ) ; } return true ; }
public void testQuerySetGroup ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponseReduced > future = client . asyncQueryAndReduce ( view , query . setGroup ( true ) ) ; ViewResponseReduced response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }
public double value ( ) { return value . get ( ) . doubleValue ( ) ; }
public void randomChanged ( boolean random ) { } @Override public void repeatChanged ( boolean repeating ) { } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { } @Override public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } }
public void configure ( Config config ) { this . config = config ; kafkaParams = Maps . newHashMap ( ) ; String brokers = config . getString ( BROKERS_CONFIG ) ; kafkaParams . put ( " bootstrap.servers " , brokers ) ; topics = Sets . newHashSet ( ) ; if ( config . hasPath ( TOPICS_CONFIG ) ) { topics . addAll ( config . getStringList ( TOPICS_CONFIG ) ) ; } if ( topics . size ( ) = = 0 ) { throw new RuntimeException ( " Invalid Kafka configuration. At least  " + " one topic must be specified " ) ; } if ( ! config . hasPath ( ENCODING_CONFIG ) ) { throw new RuntimeException ( " Kafka input encoding type configuration is required. " ) ; } if ( config . hasPath ( WINDOW_ENABLED_CONFIG ) & & ( config . getBoolean ( WINDOW_ENABLED_CONFIG ) = = true ) & & doesRecordProgress ( ) ) { throw new RuntimeException ( " Kafka input offset management not currently compatible with stream windowing. " ) ; } encoding = config . getString ( ENCODING_CONFIG ) ; if ( encoding . equals ( " string " ) ) { kafkaParams . put ( " key.deserializer " , " org.apache.kafka.common.serialization.StringDeserializer " ) ; kafkaParams . put ( " value.deserializer " , " org.apache.kafka.common.serialization.StringDeserializer " ) ; } else if ( encoding . equals ( " bytearray " ) ) { kafkaParams . put ( " key.deserializer " , " org.apache.kafka.common.serialization.ByteArrayDeserializer " ) ; kafkaParams . put ( " value.deserializer " , " org.apache.kafka.common.serialization.ByteArrayDeserializer " ) ; } else { throw new RuntimeException ( " Invalid Kafka input encoding type. Valid types are 'string' and 'bytearray'. " ) ; } if ( config . hasPath ( GROUP_ID_CONFIG ) ) { groupID = config . getString ( GROUP_ID_CONFIG ) ; } else { groupID = UUID . randomUUID ( ) . toString ( ) ; } kafkaParams . put ( " group.id " , groupID ) ; kafkaParams . put ( " enable.auto.commit " , " false " ) ; KafkaCommon . addCustomParams ( kafkaParams , config ) ; }
private boolean isHostnameLinked ( final Bundle bundle ) { final boolean result ; if ( bundle . getInt ( ConnectivityManager . EXTRA_NETWORK_TYPE ) = = ConnectivityManager . TYPE_WIFI ) { result = isConnectedToWIFI ( bundle ) ; } else { result = isLinkedToHostname ( mPreferences . getString ( " hostname " , null ) ) ; } return result ; }
public boolean equals ( final Object that ) { return ( ( that instanceof TruthValue ) & & ( getFrequency ( ) = = ( ( TruthValue ) that ) . getFrequency ( ) )
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmNot p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmPst p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmPres p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmFut p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInher p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmSim p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInst p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmProp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInPp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmOp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmTrm p , A arg ) ; } }
public HttpHeaderMap getResponseHeaderFields ( ) { final HttpHeaderMap ret = new HttpHeaderMap ( ) ; for ( final Map . Entry < String , List < String > > aEntry : m_aHttpURLConnection . getHeaderFields ( ) . entrySet ( ) ) { final String sName = aEntry . getKey ( ) ; if ( StringHelper . hasText ( sName ) ) for ( final String sValue : aEntry . getValue ( ) ) ret . addHeader ( sName , sValue ) ; } return ret ; }
private void checkNoTrailingData ( CharacterInput input ) { if ( ! trailingDataAccepted ) { int trailing = input . readAndSkip ( SPACES ) ;
BudgetValue revise ( TruthValue tTruth , TruthValue bTruth , TruthValue truth , Task task , boolean feedbackToLinks ) { float difT = truth . getExpDifAbs ( tTruth ) ; task . decPriority ( 1 - difT ) ; task . decDurability ( 1 - difT ) ; if ( feedbackToLinks ) { TaskLink tLink = memory . currentTaskLink ; tLink . decPriority ( 1 - difT ) ; tLink . decDurability ( 1 - difT ) ; TermLink bLink = memory . currentBeliefLink ; float difB = truth . getExpDifAbs ( bTruth ) ; bLink . decPriority ( 1 - difB ) ; bLink . decDurability ( 1 - difB ) ; } float dif = truth . getConfidence ( ) - Math . max ( tTruth . getConfidence ( ) , bTruth . getConfidence ( ) ) ; float priority = or ( dif , task . getPriority ( ) ) ; float durability = or ( dif , task . getDurability ( ) ) ; float quality = truthToQuality ( truth ) ; return new BudgetValue ( priority , durability , quality , memory ) ; }
public final Map < String , Object > getSources ( ) { return ContainerHelper . newMap ( m_aSources ) ; }
public static long magnitudeToTime ( int magnitude , AtomicDuration duration ) { return ( long ) ( Math . round ( Math . exp ( magnitude * duration . getLog ( ) ) ) ) ; }
public static < T , EX extends Exception > T execLogged ( final IThrowingGetter < T , EX > aGetter ) throws EX { final T ret = aGetter . get ( ) ; System . out . println ( " Returned:  " + ret ) ; return ret ; }
public void testOneArrivingOneExistingWhereArrivingLaterThanExistingNoCurrentFlag ( ) { p = new BitemporalHistoryPlanner ( ) ; p . configure ( configWithoutCurrentFlag ) ; existing . add ( new RowWithSchema ( existingSchemaWithoutCurrentFlag , " a " , " hello " , 100L , 100L , FAR_FUTURE_MILLIS , 1L , FAR_FUTURE_MILLIS ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 200L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 3 ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . UPDATE ) ; assertEquals ( planned . get ( 1 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( planned . get ( 2 ) . getMutationType ( ) , MutationType . INSERT ) ; Long systemStart1 = ( Long ) RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemstart " ) ; Long systemStart2 = ( Long ) RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " systemstart " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemstart " ) , 1L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemend " ) , RowUtils . precedingTimestamp ( systemStart1 ) ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventend " ) , 199L ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " eventstart " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertTrue ( systemStart2 > = preplanSystemTime ) ; assertTrue ( systemStart2 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; }
private void handleReadsAndWrites ( final SelectionKey sk , final MemcachedNode node ) throws IOException { if ( sk . isValid ( ) ) { if ( sk . isReadable ( ) ) {
public void event ( Class channel , Object [ ] arguments ) { if ( channel = = TaskAdd . class ) { add ( ( Task ) arguments [ 0 ] ) ;
public Map < String , String > getParameters ( ) { if ( m_aParameters = = null ) m_aParameters = new HashMap < String , String > ( ) ; return m_aParameters ; }
public void parse ( File file , boolean merge ) { if ( ! merge ) { clear ( ) ; } LOCAL_PARSER . get ( ) . parse ( file , this ) ; }
private static boolean testStack ( ) { { if ( debug ) System . out . println ( " Stack. " ) ; Stack < Integer > stack = new Stack < Integer > ( ) ; for ( int i = 0 ; i < unsorted . length ; i + + ) { int item = unsorted [ i ] ; stack . push ( item ) ; boolean exists = ( stack . getSize ( ) = = i + 1 ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + i + "  doesn't exists. " ) ; handleError ( stack ) ; return false ; } } if ( debug ) System . out . println ( stack . toString ( ) ) ; int size = stack . getSize ( ) ; for ( int i = 0 ; i < size ; i + + ) { stack . pop ( ) ; boolean exists = ( stack . getSize ( ) = = unsorted . length - ( i + 1 ) ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + i + "  doesn't exists. " ) ; handleError ( stack ) ; return false ; } } if ( debug ) System . out . println ( ) ; } return true ; }
private static boolean testSplayTree ( ) { { System . out . println ( " Splay Tree. " ) ; SplayTree < Character > splay = new SplayTree < Character > ( ) ; String alphabet = new String ( " KLMUFGNRSTABHIJVWXYZCDEOPQ " ) ; for ( int i = 0 ; i < alphabet . length ( ) ; i + + ) { char c = alphabet . charAt ( i ) ; splay . add ( c ) ; boolean exists = splay . contains ( c ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + i + "  doesn't exists. " ) ; handleError ( splay ) ; return false ; } } System . out . println ( splay . toString ( ) ) ; int length = alphabet . length ( ) - 1 ; for ( int i = 0 ; i < = length ; i + + ) { char letter = alphabet . charAt ( length - i ) ; splay . contains ( letter ) ; splay . contains ( letter ) ; splay . contains ( letter ) ; splay . remove ( letter ) ; boolean exists = splay . contains ( letter ) ; if ( exists ) { System . err . println ( " YIKES!!  " + i + "  still exists. " ) ; handleError ( splay ) ; return false ; } } System . out . println ( ) ; } return true ; }
MemcachedNode getHandlingNode ( ) ; void setHandlingNode ( MemcachedNode to ) ; void timeOut ( ) ; boolean isTimedOut ( ) ; boolean isTimedOut ( long ttlMillis ) ; boolean isTimedOutUnsent ( ) ; }
public boolean walk_tree ( int start_node , int last_char_so_far ) { int edges = 0 ; for ( char i = 0 ; i < 256 ; i + + ) { Edge edge = Edge . find ( this , start_node , i ) ; if ( edge ! = null ) { if ( branches [ edge . startNode ] < 0 ) System . err . println ( " Logic error on node  " + edge . startNode ) ; branches [ edge . startNode ] + + ; edges + + ; int l = last_char_so_far ; for ( int j = edge . firstCharIndex ; j < = edge . lastCharIndex ; j + + ) chars [ l + + ] = characters [ j ] ; chars [ l ] = '\0' ; if ( walk_tree ( edge . endNode , l ) ) { if ( branches [ edge . endNode ] > 0 ) System . err . println ( " Logic error on node  " + edge . endNode ) ; branches [ edge . endNode ] - - ; } } } if ( edges = = 0 ) { System . out . print ( " Suffix :  " ) ;
public void onDestroyView ( ) { headerArtist = null ; headerInfo = null ; coverArtListener . freeCoverDrawable ( ) ; super . onDestroyView ( ) ; }
public Object clone ( ) { return new Disjunction ( getName ( ) , cloneTerms ( components ) , isConstant ( ) , complexity ) ; }
private void handleServiceMessages ( final int what ) { Log . d ( TAG , " Message received:  " + getHandlerValue ( what ) ) ; switch ( what ) { case DISCONNECT_ON_NO_CONNECTION :
public void testAveragePriority ( int capacity ) { final float priorityEpsilon = 0.1f ; ContinuousBag < NullItem > c = new ContinuousBag ( capacity , 10 , false ) ; Bag < NullItem > d = new DefaultBag < NullItem > ( capacity , 10 , 10 ) ; assertEquals ( c . getMass ( ) , d . getMass ( ) , 0 ) ; assertEquals ( c . getAveragePriority ( ) , d . getAveragePriority ( ) , 0 ) ; c . putIn ( new NullItem ( .25f ) ) ; d . putIn ( new NullItem ( .25f ) ) ; assertTrue ( c . getMass ( ) ! = d . getMass ( ) ) ; assertEquals ( c . getAveragePriority ( ) , d . getAveragePriority ( ) , priorityEpsilon ) ; c . clear ( ) ; d . clear ( ) ; assert ( c . getAveragePriority ( ) = = 0.01f ) ; assert ( d . getAveragePriority ( ) = = 0.01f ) ; c . putIn ( new NullItem ( .25f ) ) ; d . putIn ( new NullItem ( .25f ) ) ; c . putIn ( new NullItem ( .87f ) ) ; d . putIn ( new NullItem ( .87f ) ) ; assertEquals ( c . getAveragePriority ( ) , d . getAveragePriority ( ) , priorityEpsilon ) ;
public Row call ( Tuple2 < T , T > keyAndMessage ) throws Exception { T key = keyAndMessage . _1 ; T message = keyAndMessage . _2 ; if ( translator = = null ) { translator = ( Translator < T > ) TranslatorFactory . create ( config ) ; LOG . info ( " Translator created:  " + translator . getClass ( ) . getName ( ) ) ; } return translator . translate ( key , message ) ; }
void addPartner ( @Nonnull Partner aNewPartner ) throws AS2Exception ; @Nonnull EChange removePartner ( @Nullable String sPartnerName ) throws AS2Exception ; @Nullable IPartner getPartnerOfName ( @Nullable String sPartnerName ) ; @Nonnull @ReturnsMutableCopy ICommonsSet < String > getAllPartnerNames ( ) ; @Nonnull @ReturnsMutableCopy ICommonsList < ? extends IPartner > getAllPartners ( ) ; }
public int hashCode ( ) { return super . hashCode ( ) ; }
public void run ( ) { s . nar . addInput ( " <(&/,<$1 --> [at]>,(^pick,$1)) =/> <$1 --> [hold]>>. " ) ; s . nar . addInput ( " <(^go-to,$1) =/> <$1 --> [at]>>. " ) ; s . nar . addInput ( " <(&/,<$1 --> [at]>,(^activate,$1)) =/> <$1 --> [on]>>. " ) ; s . nar . addInput ( " <(&/,<$1 --> [at]>,(^deactivate,$1)) =/> (--,<$1 --> [on]>)>. " ) ;
public void receivedStatus ( OperationStatus status ) { if ( ! completed ) { cb . receivedStatus ( status ) ;
public void andNot ( FastBitSet that ) { int i = Math . min ( this . _length , that . _length ) ; while ( - - i > = 0 ) { this . bits [ i ] & = ~ that . bits [ i ] ;
void onAnimationCancel ( Animator animation ) ; void onAnimationRepeat ( Animator animation ) ; } }
void addPartnership ( @Nonnull Partnership aPartnership ) ; void removePartnership ( @Nonnull Partnership aPartnership ) ; void updatePartnership ( @Nonnull IMessage aMsg , boolean bOverwrite ) throws OpenAS2Exception ; void updatePartnership ( @Nonnull IMessageMDN aMdn , boolean bOverwrite ) throws OpenAS2Exception ; @Nonnull @ReturnsMutableCopy List < Partnership > getAllPartnerships ( ) ; @Deprecated Map < String , StringMap > getPartners ( ) ; }
protected void updateHeight ( ) { int lesserHeight = 0 ; int greaterHeight = 0 ; if ( lesser ! = null ) { AVLNode < T > lesserAVLNode = ( AVLNode < T > ) lesser ; lesserHeight = lesserAVLNode . height ; } if ( greater ! = null ) { AVLNode < T > greaterAVLNode = ( AVLNode < T > ) greater ; greaterHeight = greaterAVLNode . height ; } if ( lesserHeight > greaterHeight ) { height = lesserHeight + 1 ;
public abstract void removeServiceListener ( String type , ServiceListener listener ) ; public abstract void registerService ( ServiceInfo info ) throws IOException ; public abstract void unregisterService ( ServiceInfo info ) ; public abstract void unregisterAllServices ( ) ; public abstract boolean registerServiceType ( String type ) ; @Deprecated public abstract void printServices ( ) ; public abstract ServiceInfo [ ] list ( String type ) ; public abstract ServiceInfo [ ] list ( String type , long timeout ) ; public abstract Map < String , ServiceInfo [ ] > listBySubtype ( String type ) ; public abstract Map < String , ServiceInfo [ ] > listBySubtype ( String type , long timeout ) ; public abstract Delegate getDelegate ( ) ; public abstract Delegate setDelegate ( Delegate value ) ; }
public static void copyHttpHeaders ( @Nonnull final HttpURLConnection aConn , @Nonnull final InternetHeaders aHeaders ) { for ( final Map . Entry < String , List < String > > aConnHeader : aConn . getHeaderFields ( ) . entrySet ( ) ) {
public synchronized void output ( Class channel , Object o ) { if ( channel = = EXE . class ) super . output ( channel , o ) ;
public String getName ( ) { return attrs ( ) . getAsString ( ATTR_NAME ) ; }
public final void markGooglePlayDeathWarningAsRead ( ) { mSettings . edit ( ) . putBoolean ( " googlePlayDeathWarningShown " , true ) . commit ( ) ; }
static private String indentPredicatesAsArgX ( Term t , OperatorManager op , int p ) { if ( t instanceof Struct ) { Struct co = ( Struct ) t ;
public boolean areEqual ( E t , E t1 ) { if ( t = = t1 ) return true ; return t . name ( ) . equals ( t1 . name ( ) ) ; }
static BuyLink linkFromElement ( StoreType type , DomElement element ) { BuyLink link = new BuyLink ( element . getChildText ( " supplierName " ) , type , element . getChildText ( " buyLink " ) ) ; link . search = " 1 " . equals ( element . getChildText ( " isSearch " ) ) ; link . icon = element . getChildText ( " supplierIcon " ) ; if ( link . icon ! = null & & link . icon . length ( ) = = 0 ) link . icon = null ; if ( element . hasChild ( " price " ) ) { DomElement child = element . getChild ( " price " ) ; link . currency = child . getChildText ( " currency " ) ; link . price = Double . parseDouble ( child . getChildText ( " amount " ) ) ; } return link ; }
public void setRandom ( boolean random ) throws MPDServerException { if ( ! isConnected ( ) ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } mpdConnection . sendCommand ( MPDCommand . MPD_CMD_RANDOM , random ? " 1 " : " 0 " ) ; }
StatsKey getKey ( ) ; StatsSession getSession ( ) ; DataSet get ( ) ; default public String name ( ) { return getKey ( ) . getName ( ) ; } public void setCyclesSinceLastUpdate ( long cyclesSinceLastUpdate ) ; abstract public void setActive ( boolean b ) ; }
public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero:   " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ;
public String operator ( ) { return Symbols . CONJUNCTION_OPERATOR ; }
public boolean onPrepareActionMode ( ActionMode mode , android . view . Menu menu ) { actionMode = mode ; controller . setSortEnabled ( false ) ; return false ; }
public boolean remove ( Object o ) { synchronized ( mLOCK ) { for ( final ListIterator < ? > itr = this . listIterator ( ) ; itr . hasNext ( ) ; ) {
public Term [ ] cloneTermsExcept ( final boolean requireModification , final Term [ ] toRemove ) { List < Term > l = asTermList ( ) ; boolean removed = false ; for ( final Term t : toRemove ) { if ( l . remove ( t ) ) removed = true ; } if ( ( ! removed ) & & ( requireModification ) ) return null ; return l . toArray ( new Term [ l . size ( ) ] ) ; }
public void run ( ) { s . cells . click ( " Door " , " " , " " ) ; }
public static void contrapositionAttempts ( Statement taskTerm , Sentence taskSentence , NAL nal ) { double n = taskTerm . getComplexity ( ) * nal . mem ( ) . param . contrapositionPriority . get ( ) ; double w = 1.0 / n ; if ( Memory . randomNumber . nextDouble ( ) < w ) { StructuralRules . contraposition ( taskTerm , taskSentence , nal ) ; } double n2 = taskTerm . getComplexity ( ) ; double w2 = 1.0 / ( ( n * ( n - 1 ) ) / 2.0 ) ; if ( Memory . randomNumber . nextDouble ( ) < w2 ) { StructuralRules . contraposition ( taskTerm , taskSentence , nal ) ;
protected abstract void handleIncomingMessage ( @Nonnull final String sClientInfo , @Nonnull final DataSource aMsgData , @Nonnull final AS2Message aMsg , @Nonnull final IAS2HttpResponseHandler aResponseHandler ) throws ServletException ; public final void onRequest ( @Nonnull final HttpServletRequest aHttpRequest , @Nonnull final HttpServletResponse aHttpResponse , @Nonnull final EHttpVersion eHttpVersion , @Nonnull final EHttpMethod eHttpMethod , @Nonnull final IRequestWebScope aRequestScope ) throws ServletException , IOException { final String sClientInfo = aHttpRequest . getRemoteAddr ( ) + " : " + aHttpRequest . getRemotePort ( ) ; final AS2Message aMsg = new AS2Message ( ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_SOURCE_IP , aHttpRequest . getRemoteAddr ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_SOURCE_PORT , aHttpRequest . getRemotePort ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_DESTINATION_IP , aHttpRequest . getLocalAddr ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_DESTINATION_PORT , aHttpRequest . getLocalPort ( ) ) ; aMsg . attrs ( ) . putIn ( HTTPHelper . MA_HTTP_REQ_TYPE , aHttpRequest . getMethod ( ) ) ; aMsg . attrs ( ) . putIn ( HTTPHelper . MA_HTTP_REQ_URL , ServletHelper . getRequestRequestURI ( aHttpRequest ) ) ; aMsg . headers ( ) . setAllHeaders ( aRequestScope . headers ( ) ) ; final boolean bQuoteHeaderValues = isQuoteHeaderValues ( ) ; final AS2OutputStreamCreatorHttpServletResponse aResponseHandler = new AS2OutputStreamCreatorHttpServletResponse ( aHttpResponse , bQuoteHeaderValues ) ; final long nContentLength = aHttpRequest . getContentLengthLong ( ) ; if ( nContentLength > Integer . MAX_VALUE ) throw new IllegalStateException ( " Currently only payload with up to 2GB can be handled! " ) ; try ( final ServletInputStream aRequestIS = aHttpRequest . getInputStream ( ) ) { final StopWatch aSW = StopWatch . createdStarted ( ) ; DataSource aMsgDataSource = null ; try { final IHTTPIncomingDumper aIncomingDumper = getEffectiveHttpIncomingDumper ( ) ; aMsgDataSource = HTTPHelper . readAndDecodeHttpRequest ( new AS2InputStreamProviderServletRequest ( aRequestIS ) , aResponseHandler , aMsg , aIncomingDumper ) ; } catch ( final Exception ex ) { AS2Exception . log ( ex . getClass ( ) , true , " Failed to read Servlet Request:  " + ex . getMessage ( ) , null , null , ex . getCause ( ) ) ; } aSW . stop ( ) ; if ( aMsgDataSource = = null ) { LOGGER . error ( " Not having a data source to operate on " ) ; } else { if ( aMsgDataSource instanceof ByteArrayDataSource ) { if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " received  " + AS2IOHelper . getTransferRate ( ( ( ByteArrayDataSource ) aMsgDataSource ) . directGetBytes ( ) . length , aSW ) + "  from  " + sClientInfo + aMsg . getLoggingText ( ) ) ; } else { LOGGER . info ( " received message from  " + sClientInfo + aMsg . getLoggingText ( ) + "  in  " + aSW . getMillis ( ) + "  ms " ) ; } handleIncomingMessage ( sClientInfo , aMsgDataSource , aMsg , aResponseHandler ) ; } } } }
public void testCreateKeyStores ( ) throws GeneralSecurityException { final BCCryptoHelper x = new BCCryptoHelper ( ) ; for ( final EKeyStoreType e : EKeyStoreType . values ( ) ) {
public Object clone ( ) { return new ImplicationBefore ( name , ( ArrayList < Term > ) cloneList ( components ) , ( ArrayList < Variable > ) cloneList ( openVariables ) , ( ArrayList < Variable > ) cloneList ( closedVariables ) , complexity ) ;
public void remove ( ) { if ( last = = null ) return ; LinkedList . Node < T > p = last . prev ; LinkedList . Node < T > n = last . next ; if ( p ! = null ) p . next = n ; if ( n ! = null ) n . prev = p ; if ( last . equals ( list . head ) ) list . head = n ; if ( last . equals ( list . tail ) ) list . tail = p ; list . size - - ; }
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public X next ( ) { if ( buffer = = null ) return nextXDirect ( ) ; X n = buffer . poll ( ) ; return n ; }
public static void main ( String [ ] args ) { int repeats = 4 ; int warmups = 1 ; int extraCycles = 2048 ; int maxConcepts = 4096 ; NAR n = new DiscretinuousBagNARBuilder ( ) . setConceptBagSize ( maxConcepts ) . build ( ) ; Collection c = NALTest . params ( ) ; while ( true ) { for ( Object o : c ) {
public void writeConfig ( Config config , Writer writer ) { writeConfig ( config , new WriterOutput ( writer ) ) ; }
private T remove ( int index ) { if ( index < 0 | | index > = size ) return null ; T t = array [ index ] ; array [ index ] = array [ - - size ] ; array [ size ] = null ; heapDown ( index ) ; int shrinkSize = array . length > > 1 ; if ( shrinkSize > = MINIMUM_SIZE & & size < shrinkSize ) shrink ( ) ; return t ; }
public int yToLine ( int y ) { FontMetrics fm = painter . getFontMetrics ( ) ; int height = fm . getHeight ( ) ; return Math . max ( 0 , Math . min ( getLineCount ( ) - 1 , y / height + firstLine ) ) ;
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o instanceof com . googlecode . opennars . parser . loan . Loan . Absyn . SentOp ) { com . googlecode . opennars . parser . loan . Loan . Absyn . SentOp x = ( com . googlecode . opennars . parser . loan . Loan . Absyn . SentOp ) o ; return this . uriref_ . equals ( x . uriref_ ) ; } return false ; }
public void run ( ) { try { if ( TextUtils . isEmpty ( mDirectory ) ) {
public List < Music > getSongs ( final Artist artist ) throws MPDServerException { final List < Album > albums = getAlbums ( artist , false ) ; final List < Music > songs = new ArrayList < > ( albums . size ( ) ) ; for ( final Album album : albums ) { songs . addAll ( getSongs ( album ) ) ; } return songs ; }
public Action agent_start ( Observation o ) { randomify ( action ) ; return action ; }
Operation removeCurrentReadOp ( ) ; Operation getCurrentWriteOp ( ) ; Operation removeCurrentWriteOp ( ) ; boolean hasReadOp ( ) ; boolean hasWriteOp ( ) ; void addOp ( Operation op ) ; void insertOp ( Operation o ) ; int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; }
protected DataSource readAndDecodeHttpRequest ( @Nonnull final IAS2InputStreamProvider aISP , @Nonnull final IAS2HttpResponseHandler aResponseHandler , @Nonnull final IMessage aMsg ) throws IOException , MessagingException { DataSource aPayload = HTTPHelper . readHttpRequest ( aISP , aResponseHandler , aMsg ) ; final String sContentTransferEncoding = aMsg . getHeader ( CHttpHeader . CONTENT_TRANSFER_ENCODING , aMsg . partnership ( ) . getContentTransferEncodingReceive ( EContentTransferEncoding . AS2_DEFAULT . getID ( ) ) ) ; if ( StringHelper . hasText ( sContentTransferEncoding ) ) { final IContentTransferEncoding aCTE = EContentTransferEncoding . getFromIDCaseInsensitiveOrNull ( sContentTransferEncoding ) ; if ( aCTE = = null ) s_aLogger . warn ( " Unsupported Content-Transfer-Encoding ' " + sContentTransferEncoding + " ' is used - ignoring! " ) ; else { final IDecoder < byte [ ] , byte [ ] > aDecoder = aCTE . createDecoder ( ) ; if ( ! ( aDecoder instanceof IdentityCodec < ? > ) & & aPayload instanceof ByteArrayDataSource ) { byte [ ] actualBytes = ( ( ByteArrayDataSource ) aPayload ) . directGetBytes ( ) ; final int nOriginalContentLength = actualBytes . length ; s_aLogger . info ( " Incoming message uses Content-Transfer-Encoding ' " + sContentTransferEncoding + " ' - decoding " ) ; actualBytes = aDecoder . getDecoded ( actualBytes ) ; aPayload = new ByteArrayDataSource ( actualBytes , aPayload . getContentType ( ) , aPayload . getName ( ) ) ; aMsg . attrs ( ) . putIn ( MA_HTTP_ORIGINAL_CONTENT_TRANSFER_ENCODING , sContentTransferEncoding ) ; aMsg . attrs ( ) . putIn ( MA_HTTP_ORIGINAL_CONTENT_LENGTH , nOriginalContentLength ) ; } } } return aPayload ; }
public boolean supportsType ( Class < ? > type ) { return supportPredicate . test ( type ) ; }
Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
void learnFromInstance ( Instance inst , ModelAggregatorProcessor proc ) { this . observedClassDistribution . addToValue ( ( int ) inst . classValue ( ) , inst . weight ( ) ) ;
Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
final void stop ( ) { if ( mRemoteControlClient ! = null ) { setPlaybackState ( RemoteControlClient . PLAYSTATE_STOPPED ) ; mAudioManager . unregisterRemoteControlClient ( mRemoteControlClient ) ; } if ( mMediaButtonReceiverComponent ! = null ) { mAudioManager . unregisterMediaButtonEventReceiver ( mMediaButtonReceiverComponent ) ; } if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . JELLY_BEAN_MR2 ) { mSeekBar . stop ( ) ;
public void testArrayList ( ) { TestData data = Utils . generateTestData ( 1000 ) ; String aName = " List [array] " ; List . ArrayList < Integer > aList = new List . ArrayList < Integer > ( ) ; Collection < Integer > aCollection = aList . toCollection ( ) ; assertTrue ( ListTest . testList ( aList , aName , data . unsorted , data . invalid ) ) ; assertTrue ( JavaCollectionTest . testCollection ( aCollection , Integer . class , aName , data . unsorted , data . sorted , data . invalid ) ) ;
public static double compare ( String label , BagBuilder b , final int iterations , final int randomAccesses , final float insertRatio , int repeats , int warmups ) { Performance p = new Performance ( label , repeats , warmups ) { @Override public void init ( ) { } @Override public void run ( boolean warmup ) { AbstractBag bag = b . newBag ( ) ; randomBagIO ( bag , randomAccesses , insertRatio ) ; for ( int i = 0 ; i < iterations ; i + + ) iterate ( bag ) ; } } ; return p . getCycleTimeMS ( ) ;
public void draw ( ) { updateMouse ( ) ; if ( ! isDisplayable ( ) | | ! isVisible ( ) ) return ; updateCamera ( ) ; if ( ! updating ) { return ; } updating = false ; lastCameraUpdate = camera . lastUpdate ; background ( 0 ) ; float y = 0 ; float yMargin = camera . yScale * 0.1f ; for ( Chart c : charts ) { float h = c . height * camera . yScale ;
void setLocalDate ( String path , LocalDate value ) ; LocalDateTime getLocalDateTime ( String path ) ; void setLocalDateTime ( String path , LocalDateTime value ) ; OffsetDateTime getOffsetDateTime ( String path ) ; void setOffsetDateTime ( String path , OffsetDateTime value ) ; }
public static MimeBodyPart secureMimeBodyPart ( @Nonnull final MimeBodyPart aSrcPart , @Nonnull final EContentTransferEncoding eCTE , @Nullable final ECompressionType eCompressionType , final boolean bCompressBeforeSign , @Nullable final Consumer < MimeBodyPart > aCompressBeforeSignCallback , @Nullable final ECryptoAlgorithmSign eSignAlgorithm , @Nullable final X509Certificate aSenderCert , @Nullable final PrivateKey aSenderKey , final boolean bIncludeCertificateInSignedContent , final boolean bUseRFC3851MICAlg , @Nullable final ECryptoAlgorithmCrypt eCryptAlgorithm , @Nullable final X509Certificate aReceiverCert ) throws Exception { ValueEnforcer . notNull ( aSrcPart , " SrcPart " ) ; ValueEnforcer . notNull ( eCTE , " ContentTransferEncoding " ) ; if ( eCompressionType ! = null ) { if ( bCompressBeforeSign ) ValueEnforcer . notNull ( aCompressBeforeSignCallback , " CompressBeforeSignCallback " ) ; } if ( eSignAlgorithm ! = null ) { ValueEnforcer . notNull ( aSenderCert , " SenderCert " ) ; ValueEnforcer . notNull ( aSenderKey , " SenderKey " ) ; } if ( eCryptAlgorithm ! = null ) { ValueEnforcer . notNull ( aReceiverCert , " ReceiverCert " ) ; } MimeBodyPart aDataBP = aSrcPart ; _logMimeBodyPart ( aDataBP , " source " ) ; if ( eCompressionType ! = null & & bCompressBeforeSign ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Compressing outbound message before signing... " ) ; aDataBP = compressMimeBodyPart ( aDataBP , eCompressionType , eCTE ) ; _logMimeBodyPart ( aDataBP , " compressBeforeSign " ) ; aCompressBeforeSignCallback . accept ( aDataBP ) ; } if ( eSignAlgorithm ! = null ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Signing outbound message... " ) ; aDataBP = AS2Helper . getCryptoHelper ( ) . sign ( aDataBP , aSenderCert , aSenderKey , eSignAlgorithm , bIncludeCertificateInSignedContent , bUseRFC3851MICAlg , eCTE ) ; _logMimeBodyPart ( aDataBP , " signed " ) ; } if ( eCompressionType ! = null & & ! bCompressBeforeSign ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Compressing outbound message after signing... " ) ; aDataBP = compressMimeBodyPart ( aDataBP , eCompressionType , eCTE ) ; _logMimeBodyPart ( aDataBP , " compressAfterSign " ) ; } if ( eCryptAlgorithm ! = null ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Encrypting outbound message... " ) ; aDataBP = AS2Helper . getCryptoHelper ( ) . encrypt ( aDataBP , aReceiverCert , eCryptAlgorithm , eCTE ) ; _logMimeBodyPart ( aDataBP , " encrypted " ) ; } return aDataBP ; }
public Data combined ( Data data ) { RangeMaximumData < N > q = null ; if ( data instanceof RangeMaximumData ) { q = ( RangeMaximumData < N > ) data ; this . combined ( q ) ; } return this ; }
public Rope subSequence ( final int start , final int end ) { return null ; }
protected static void usage ( String message ) { System . err . println ( ) ; System . err . println ( message ) ; System . err . println ( ) ; System . err . println ( " Usage:  " + version . program_name + "  [options] [filename] \ n " + "   and expects a specification file on standard input if no filename is given. \ n " + "   Legal options include: \ n " + "     -package name  specify package generated classes go in [default none] \ n " + "     -parser name   specify parser class name [default  \" parser \" ] \ n " + "     -symbols name  specify name for symbol constant class [default  \" sym \" ] \ n " + "     -interface     put symbols in an interface, rather than a class \ n " + "     -nonterms      put non terminals in symbol constant class \ n " + "     -expect #      number of conflicts expected/allowed [default 0] \ n " + "     -compact_red   compact tables by defaulting to most frequent reduce \ n " + "     -nowarn        don't warn about useless productions, etc. \ n " + "     -nosummary     don't print the usual summary of parse states, etc. \ n " + "     -nopositions   don't propagate the left and right token position values \ n " + "     -noscanner     don't refer to java_cup.runtime.Scanner \ n " + "     -progress      print messages to indicate progress of the system \ n " + "     -time          print time usage summary \ n " + "     -dump_grammar  produce a human readable dump of the symbols and grammar \ n " + "     -dump_states   produce a dump of parse state machine \ n " + "     -dump_tables   produce a dump of the parse tables \ n " + "     -dump          produce a dump of all of the above \ n " + "     -version       print the version information for CUP and exit \ n " ) ; System . exit ( 1 ) ; }
public void addAll ( Collection < Music > c ) throws MPDServerException { for ( Music m : c ) this . mpd . getMpdConnection ( ) . queueCommand ( MPD_CMD_PLAYLIST_ADD , m . getFullpath ( ) ) ; this . mpd . getMpdConnection ( ) . sendCommandQueue ( ) ; this . refresh ( ) ; }
public void testOneKeyFieldName ( ) throws Exception { StructType ordersSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " order_id " , DataTypes . IntegerType , true ) , DataTypes . createStructField ( " product_name " , DataTypes . StringType , true ) , DataTypes . createStructField ( " customer_id " , DataTypes . IntegerType , true ) ) ) ; StructType customersSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " customer_id " , DataTypes . IntegerType , true ) , DataTypes . createStructField ( " name " , DataTypes . StringType , true ) ) ) ; List < Row > orderRows = Lists . newArrayList ( ) ; orderRows . add ( RowFactory . create ( 1000 , " Envelopes " , 10000 ) ) ; orderRows . add ( RowFactory . create ( 1001 , " Stamps " , 10000 ) ) ; orderRows . add ( RowFactory . create ( 1002 , " Pens " , 10000 ) ) ; orderRows . add ( RowFactory . create ( 1003 , " Paper " , 10001 ) ) ; List < Row > customerRows = Lists . newArrayList ( ) ; customerRows . add ( RowFactory . create ( 10000 , " Jane " ) ) ; customerRows . add ( RowFactory . create ( 10001 , " Joe " ) ) ; DataFrame orders = sqlc . createDataFrame ( orderRows , ordersSchema ) ; DataFrame customers = sqlc . createDataFrame ( customerRows , customersSchema ) ; Map < String , DataFrame > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " orders " , orders ) ; dependencies . put ( " customers " , customers ) ; Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( NestDeriver . NEST_FROM_CONFIG_NAME , " orders " ) ; configMap . put ( NestDeriver . NEST_INTO_CONFIG_NAME , " customers " ) ; configMap . put ( NestDeriver . KEY_FIELD_NAMES_CONFIG_NAME , Lists . newArrayList ( " customer_id " ) ) ; configMap . put ( NestDeriver . NESTED_FIELD_NAME_CONFIG_NAME , " orders " ) ; Config config = ConfigFactory . parseMap ( configMap ) ; Deriver deriver = new NestDeriver ( ) ; deriver . configure ( config ) ; DataFrame nested = deriver . derive ( dependencies ) ; assertEquals ( nested . count ( ) , 2 ) ; List < Row > jane = nested . where ( " name = 'Jane' " ) . collectAsList ( ) ; assertEquals ( jane . size ( ) , 1 ) ; Row janeRow = jane . get ( 0 ) ; assertEquals ( janeRow . getList ( janeRow . fieldIndex ( " orders " ) ) . size ( ) , 3 ) ; List < Row > joe = nested . where ( " name = 'Joe' " ) . collectAsList ( ) ; assertEquals ( joe . size ( ) , 1 ) ; Row joeRow = joe . get ( 0 ) ; assertEquals ( joeRow . getList ( joeRow . fieldIndex ( " orders " ) ) . size ( ) , 1 ) ; }
public void processBody ( Body body , Long tag ) { if ( tag = = CAR_TAG ) { m_car = body ;
public static void checkValue ( @Nonnull final Serializable aTarget , @Nonnull final String sValueName , @Nullable final Object aValue ) throws InvalidParameterException { if ( aValue = = null ) throw new InvalidParameterException ( " Value is missing " , aTarget , sValueName , null ) ;
private List < String > syncedWriteAsyncRead ( String command ) throws MPDServerException { ArrayList < String > result = new ArrayList < String > ( ) ; synchronized ( lock ) { try { writeToServer ( command ) ; } catch ( IOException e ) { disconnect ( ) ; throw new MPDConnectionException ( e ) ; } boolean dataReaded = false ; while ( ! dataReaded ) { try { result = readFromServer ( ) ; dataReaded = true ; } catch ( SocketTimeoutException e ) { try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e1 ) { throw new MPDConnectionException ( e1 ) ; } } catch ( IOException e ) { disconnect ( ) ; throw new MPDConnectionException ( e ) ; } } } return result ; }
abstract public String getName ( ) ; public String info ( ) { return toString ( ) ; } public boolean isUnknown ( ) { return getName ( ) . length ( ) = = 0 ; } public String mainText ( ) { return getName ( ) ; } public boolean nameEquals ( Item o ) { return getName ( ) . equals ( o . getName ( ) ) ; } public String sort ( ) { return getName ( ) . toLowerCase ( Locale . getDefault ( ) ) ; } public String subText ( ) { return null ; } @Override public String toString ( ) { return mainText ( ) ; } }
@Before public void setup ( ) { Parameters . DEBUG = true ; n = new NAR ( new Default ( ) ) ; i = new IdeaSet ( n ) ; }
public void doStart ( ) throws OpenAS2Exception { m_aTimer = new Timer ( true ) ; m_aTimer . scheduleAtFixedRate ( new PollTask ( ) , 0 , getInterval ( ) * 1000 ) ; }
public void write ( Kryo kryo , Output output , AttributeContentEvent event ) { output . writeLong ( event . learningNodeId , true ) ; output . writeInt ( event . obsIndex , true ) ; output . writeDouble ( event . attrVal , PRECISION , true ) ; output . writeInt ( event . classVal , true ) ; output . writeDouble ( event . weight , PRECISION , true ) ; output . writeBoolean ( event . isNominal ) ; }
public boolean containsMapInt ( java . lang . String key ) { if ( key = = null ) { throw new java . lang . NullPointerException ( ) ; } return internalGetMapInt ( ) . getMap ( ) . containsKey ( key ) ; }
protected abstract IMessage createMessage ( ) ; public void updateMessage ( @Nonnull final IMessage aMsg , @Nonnull final File aFile ) throws OpenAS2Exception { final MessageParameters aParams = new MessageParameters ( aMsg ) ; final String sDefaults = getAsString ( ATTR_DEFAULTS ) ; if ( sDefaults ! = null ) aParams . setParameters ( sDefaults ) ; final String sFilename = aFile . getName ( ) ; final String sFormat = getAsString ( ATTR_FORMAT ) ; if ( sFormat ! = null ) { final String sDelimiters = getAsString ( ATTR_DELIMITERS , " .- " ) ; aParams . setParameters ( sFormat , sDelimiters , sFilename ) ; } try { final byte [ ] aData = SimpleFileIO . getAllFileBytes ( aFile ) ; String sContentType = getAsString ( ATTR_MIMETYPE ) ; if ( sContentType = = null ) { sContentType = CMimeType . APPLICATION_OCTET_STREAM . getAsString ( ) ; } else { try { sContentType = aParams . format ( sContentType ) ; } catch ( final InvalidParameterException ex ) { s_aLogger . error ( " Bad content-type ' " + sContentType + " ' " + aMsg . getLoggingText ( ) ) ; sContentType = CMimeType . APPLICATION_OCTET_STREAM . getAsString ( ) ; } } final ByteArrayDataSource aByteSource = new ByteArrayDataSource ( aData , sContentType , null ) ; final MimeBodyPart aBody = new MimeBodyPart ( ) ; aBody . setDataHandler ( aByteSource . getAsDataHandler ( ) ) ; final String sEncodeType = aMsg . partnership ( ) . getContentTransferEncoding ( EContentTransferEncoding . AS2_DEFAULT . getID ( ) ) ; aBody . setHeader ( CHttpHeader . CONTENT_TRANSFER_ENCODING , sEncodeType ) ; aBody . setHeader ( CHttpHeader . CONTENT_TYPE , sContentType ) ; final String sSendFilename = getAsString ( ATTR_SENDFILENAME ) ; if ( " true " . equals ( sSendFilename ) ) { final String sMAFilename = aMsg . attrs ( ) . getAsString ( CFileAttribute . MA_FILENAME ) ; final String sContentDisposition = " Attachment; filename= \" " + sMAFilename + " \" " ; aBody . setHeader ( CHttpHeader . CONTENT_DISPOSITION , sContentDisposition ) ; aMsg . setContentDisposition ( sContentDisposition ) ; } aMsg . setData ( aBody ) ; } catch ( final MessagingException ex ) { throw WrappedOpenAS2Exception . wrap ( ex ) ; } if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Updating partnership for AS2 message " + aMsg . getLoggingText ( ) ) ; getSession ( ) . getPartnershipFactory ( ) . updatePartnership ( aMsg , true ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Finished updating partnership for AS2 message " ) ; aMsg . updateMessageID ( ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Updated message ID to  " + aMsg . getMessageID ( ) ) ; } @Nonnull @ReturnsMutableObject public ICommonsMap < String , Long > trackedFiles ( ) { if ( m_aTrackedFiles = = null ) m_aTrackedFiles = new CommonsHashMap < > ( ) ; return m_aTrackedFiles ; } }
public int indexOf ( final CharSequence sequence , final int fromIndex ) { final CharSequence me = this . getForSequentialAccess ( ) ; final int length = sequence . length ( ) ; if ( length = = 0 ) return - 1 ; if ( length = = 1 ) return this . indexOf ( sequence . charAt ( 0 ) , fromIndex ) ; final int [ ] bcs = new int [ 256 ] ; Arrays . fill ( bcs , length ) ; for ( int j = 0 ; j < length - 1 ; + + j ) { final char c = sequence . charAt ( j ) ; final int l = ( c & 0xFF ) ; bcs [ l ] = Math . min ( length - j - 1 , bcs [ l ] ) ; } for ( int j = fromIndex + length - 1 ; j < this . length ( ) ; ) { int x = j , y = length - 1 ; while ( true ) { final char c = me . charAt ( x ) ; if ( sequence . charAt ( y ) ! = c ) { j + = bcs [ ( me . charAt ( j ) & 0xFF ) ] ; break ; } if ( y = = 0 ) return x ; - - x ; - - y ; } } return - 1 ; }
public boolean isDesired ( DerivationContext nal , Concept concept ) { TruthValue desire = concept . getDesire ( ) ; if ( desire = = null ) { return false ; } return desire . getExpectation ( ) > nal . memory . param . decisionThreshold . get ( ) ; }
IDynamicComponent getComponent ( @Nonnull @Nonempty String sComponentID ) throws ComponentNotFoundException ; @Nonnull @ReturnsMutableCopy Map < String , IDynamicComponent > getAllComponents ( ) ; @Nonnull ICertificateFactory getCertificateFactory ( ) throws ComponentNotFoundException ; @Nonnull IPartnershipFactory getPartnershipFactory ( ) throws ComponentNotFoundException ; @Nonnull IMessageProcessor getMessageProcessor ( ) throws ComponentNotFoundException ; @Nullable Proxy getHttpProxy ( ) ; void setHttpProxy ( @Nullable Proxy aHttpProxy ) ; }
public void set ( String s ) { if ( ( last = = null ) | | ( ! last . equals ( s ) ) ) nar . addInput ( s ) ; last = s ; }
protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { if ( Parameters . BE_RATIONAL ) { return null ; } Term content = args [ 0 ] ; TruthValue truth = new TruthValue ( 1 , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) ; Sentence sentence = new Sentence ( content , Symbols . JUDGMENT_MARK , truth , new Stamp ( memory ) ) ; float quality = BudgetFunctions . truthToQuality ( truth ) ; BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY , quality ) ; return Lists . newArrayList ( new Task ( sentence , budget ) ) ;
public void automataclicked ( float x , float y ) { if ( x < 0 | | y < 0 ) { return ; } float realx = x / rendersize ; float realy = y / rendersize ; if ( realx > = cells . w | | realy > = cells . h ) { return ; } cells . readCells [ ( int ) realx ] [ ( int ) realy ] . charge = 1 ; cells . writeCells [ ( int ) realx ] [ ( int ) realy ] . charge = 1 ; }
public boolean containsAll ( Collection < ? > c ) { synchronized ( rootMonitor ) { return coll . containsAll ( c ) ;
private boolean removeBadSplitNodes ( SplitCriterion criterion , Node currentNode , double lastCheckRatio , double lastCheckSDR , double lastCheckE ) { boolean isBad = false ; if ( currentNode = = null ) { return true ; } if ( currentNode . left ! = null ) { isBad = removeBadSplitNodes ( criterion , currentNode . left , lastCheckRatio , lastCheckSDR , lastCheckE ) ; } if ( currentNode . right ! = null & & isBad ) { isBad = removeBadSplitNodes ( criterion , currentNode . left , lastCheckRatio , lastCheckSDR , lastCheckE ) ; } if ( isBad ) { double [ ] [ ] postSplitDists = new double [ ] [ ] { { currentNode . leftStatistics . getValue ( 0 ) , currentNode . leftStatistics . getValue ( 1 ) , currentNode . leftStatistics . getValue ( 2 ) } , { currentNode . rightStatistics . getValue ( 0 ) , currentNode . rightStatistics . getValue ( 1 ) , currentNode . rightStatistics . getValue ( 2 ) } } ; double [ ] preSplitDist = new double [ ] { ( currentNode . leftStatistics . getValue ( 0 ) + currentNode . rightStatistics . getValue ( 0 ) ) , ( currentNode . leftStatistics . getValue ( 1 ) + currentNode . rightStatistics . getValue ( 1 ) ) , ( currentNode . leftStatistics . getValue ( 2 ) + currentNode . rightStatistics . getValue ( 2 ) ) } ; double merit = criterion . getMeritOfSplit ( preSplitDist , postSplitDists ) ; if ( ( merit / lastCheckSDR ) < ( lastCheckRatio - ( 2 * lastCheckE ) ) ) { currentNode = null ; return true ; } } return false ; }
public void resetLearning ( ) { this . trainingWeightSeenByModel = 0.0 ; if ( isRandomizable ( ) ) { this . clustererRandom = new Random ( this . randomSeed ) ; } resetLearningImpl ( ) ; }
void Gui ( ) { hgui . Draw ( ) ; }
UnlockOperation unlock ( String key , long casId , OperationCallback operationCallback ) ; ObserveOperation observe ( String key , long casId , int index , ObserveOperation . Callback operationCallback ) ; FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetlOperation getl ( String key , int exp , GetlOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; StatsOperation keyStats ( String key , StatsOperation . Callback cb ) ; MutatorOperation mutate ( Mutator m , String key , long by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; KeyedOperation touch ( String key , int expiration , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
public boolean addAll ( Collection < ? extends K > c ) { boolean result = set . addAll ( c ) ; callback . run ( ) ; return result ; }
@Deprecated void clearEventHandlers ( ) ; @Deprecated void fireEvent ( EventType eventType , StatsKey key , Object target ) ; }
public void postLevel ( NARGraph g , int l ) { if ( compressLevels ) { if ( levelContents > 0 )
public EChange removePartner ( @Nullable final String sPartnerName ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try {
public void openLoadFile ( ) { FileDialog dialog = new FileDialog ( ( FileDialog ) null , " Load experience " , FileDialog . LOAD ) ; dialog . setVisible ( true ) ; String directoryName = dialog . getDirectory ( ) ; String fileName = dialog . getFile ( ) ; String filePath = directoryName + fileName ; try { loadFile ( filePath ) ;
public AS2ReceiverHandler createHandler ( ) { final AS2ReceiverHandler ret = super . createHandler ( ) ; ret . setSendExceptionsInMDN ( true ) ; ret . setSendExceptionStackTraceInMDN ( false ) ; return ret ; }
public int size ( ) ; public MenuItem getItem ( int index ) ; public void close ( ) ; public boolean performShortcut ( int keyCode , KeyEvent event , int flags ) ; boolean isShortcutKey ( int keyCode , KeyEvent event ) ; public boolean performIdentifierAction ( int id , int flags ) ; public void setQwertyMode ( boolean isQwerty ) ; }
public Iterator < Concept > iterator ( ) { throw new UnsupportedOperationException ( " Not supported yet. " ) ; }
public static Planner plannerFor ( Properties props ) throws Exception { String plannerName = props . getProperty ( " planner " ) ; Properties plannerProps = PropertiesUtils . prefixProperties ( props , " planner. " ) ; Planner planner ; switch ( plannerName ) { case " append " : planner = new AppendPlanner ( plannerProps ) ; break ; case " upsert " : planner = new UpsertPlanner ( plannerProps ) ; break ; case " history " : planner = new HistoryPlanner ( plannerProps ) ; break ; default : Class < ? > clazz = Class . forName ( plannerName ) ; Constructor < ? > constructor = clazz . getConstructor ( Properties . class ) ; planner = ( Planner ) constructor . newInstance ( plannerProps ) ; } return planner ; }
public void clear ( ) { final String cacheFolderPath = getAbsoluteCoverFolderPath ( ) ; if ( cacheFolderPath = = null ) return ; final File cacheFolder = new File ( cacheFolderPath ) ; if ( ! cacheFolder . exists ( ) ) { return ; } File [ ] files = cacheFolder . listFiles ( ) ; if ( files ! = null ) { for ( File f : files ) {
private static boolean testHashMap ( ) { String name = " Probing HashMap <Integer> " ; java . util . Map < Integer , String > jMap = pHashMap . toMap ( ) ; if ( ! testJavaMap ( jMap , Integer . class , name ) ) return false ; name = " Chaining HashMap <Integer> " ; jMap = cHashMap . toMap ( ) ; if ( ! testJavaMap ( jMap , Integer . class , name ) ) return false ; return true ; }
long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public final void connect ( InetAddress server , int port , String password ) throws MPDServerException { this . mpdConnection = new MPDConnectionData ( server , port , 5 , password , 10000 ) ; this . mpdIdleConnection = new MPDConnectionIdle ( server , port , password , 0 ) ; this . mpdStatusConnection = new MPDConnectionIdle ( server , port , password , 10000 ) ; }
protected final void executeAction ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) throws OpenAS2Exception { final ICommonsList < Throwable > aCauses = new CommonsArrayList < > ( ) ; IProcessorModule aModuleFound = null ; final ICommonsList < IProcessorModule > aAllModules = getAllModules ( ) ; for ( final IProcessorModule aModule : aAllModules ) if ( aModule . canHandle ( sAction , aMsg , aOptions ) ) { try { if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( "   handling action ' " + sAction + " ' with module  " + aModule ) ; aModuleFound = aModule ; aModule . handle ( sAction , aMsg , aOptions ) ; } catch ( final OpenAS2Exception ex ) { aCauses . add ( ex ) ; } } if ( aCauses . isNotEmpty ( ) ) throw new ProcessorException ( this , aCauses ) ; if ( aModuleFound = = null ) { if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( "   no modules found for ' " + sAction + " '; modules are:  " + aAllModules ) ; throw new NoModuleException ( sAction , aMsg , aOptions ) ; } if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( "   action ' " + sAction + " ' was handled by module  " + aModuleFound ) ;
public void testGetIndependentNonStreamingSteps ( ) { Step step1 = new BatchStep ( " step1 " , ConfigFactory . empty ( ) . withValue ( " dependencies " , ConfigValueFactory . fromIterable ( Sets . newHashSet ( " step3 " ) ) ) ) ; Step step2 = new StreamingStep ( " step2 " , ConfigFactory . empty ( ) . withValue ( " dependencies " , ConfigValueFactory . fromIterable ( Sets . newHashSet ( " step4 " ) ) ) ) ; Step step3 = new BatchStep ( " step3 " , ConfigFactory . empty ( ) ) ; Step step4 = new StreamingStep ( " step4 " , ConfigFactory . empty ( ) ) ; Set < Step > steps = Sets . newHashSet ( step1 , step2 , step3 , step4 ) ; assertEquals ( StepUtils . getIndependentNonStreamingSteps ( steps ) , Sets . newHashSet ( step3 ) ) ; }
public void run ( int level , int bit1Iterations , int bit2Thinking ) { bits = level ; inputAxioms ( ) ; inputProb = 0.01 ; for ( int i = 0 ; i < bit1Iterations ; i + + ) nar . step ( 1 ) ; inputProb = 0.0 ; for ( int i = 0 ; i < bit2Thinking ; i + + ) nar . step ( 1 ) ;
protected byte [ ] compress ( byte [ ] in ) { if ( in = = null ) { throw new NullPointerException ( " Can't compress null " ) ; } ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gz = null ; try { gz = new GZIPOutputStream ( bos ) ; gz . write ( in ) ; } catch ( IOException e ) { throw new RuntimeException ( " IO exception compressing data " , e ) ; } finally { CloseUtil . close ( gz ) ; CloseUtil . close ( bos ) ; } byte [ ] rv = bos . toByteArray ( ) ; getLogger ( ) . debug ( " Compressed %d bytes to %d " , in . length , rv . length ) ; return rv ; }
long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
void dispose ( ) { app . noLoop ( ) ; app . unregisterMethod ( " draw " , this ) ; app . unregisterMethod ( " pre " , this ) ; app . unregisterMethod ( " post " , this ) ; app . unregisterMethod ( " mouseEvent " , this ) ; app . unregisterMethod ( " keyEvent " , this ) ; windowControls . clear ( ) ; }
public void onCreate ( int id ) { this . id = id ; this . learningCurve = new LearningCurve ( ORDERING_MEASUREMENT_NAME ) ; measures = getMeasures ( getMeasureSelection ( ) ) ; if ( this . dumpFile ! = null ) { try { if ( dumpFile . exists ( ) ) { this . immediateResultStream = new PrintStream ( new FileOutputStream ( dumpFile , true ) , true ) ; } else { this . immediateResultStream = new PrintStream ( new FileOutputStream ( dumpFile ) , true ) ; } } catch ( FileNotFoundException e ) { this . immediateResultStream = null ; logger . error ( " File not found exception for {}:{} " , this . dumpFile . getAbsolutePath ( ) , e . toString ( ) ) ; } catch ( Exception e ) { this . immediateResultStream = null ; logger . error ( " Exception when creating {}:{} " , this . dumpFile . getAbsolutePath ( ) , e . toString ( ) ) ; } } this . firstDump = true ; }
private static void put ( com . typesafe . config . Config typesafeConfig , CommentedConfig destination ) { for ( Map . Entry < String , ConfigValue > entry : typesafeConfig . entrySet ( ) ) { List < String > path = ConfigUtil . splitPath ( entry . getKey ( ) ) ;
public static void main ( String args [ ] ) { NAR nar = new CommandLineNARBuilder ( args ) . build ( ) ; NARSwing swing = new NARSwing ( nar ) ; LogPanel outputLog = new SwingLogPanel ( swing . narControls ) ; Window outputWindow = new Window ( " Log " , outputLog ) ; outputWindow . setLocation ( swing . narControls . getLocation ( ) . x + swing . narControls . getWidth ( ) , swing . narControls . getLocation ( ) . y ) ; outputWindow . setSize ( 800 , 400 ) ; outputWindow . setVisible ( true ) ; TextInputPanel inputPanel = new TextInputPanel ( nar ) ; Window inputWindow = new Window ( " Input " , inputPanel ) ; inputWindow . setLocation ( outputWindow . getLocation ( ) . x , outputWindow . getLocation ( ) . y + outputWindow . getHeight ( ) ) ; inputWindow . setSize ( 800 , 200 ) ; inputWindow . setVisible ( true ) ; if ( args . length > 0 & & CommandLineNARBuilder . isReallyFile ( args [ 0 ] ) ) { try { nar . addInput ( new TextInput ( new File ( args [ 0 ] ) ) ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } if ( args . length > 1 ) swing . nar . start ( 0 ) ;
protected void tearDown ( ) throws Exception { client . shutdown ( ) ; client = null ; initClient ( ) ; flushPause ( ) ; assertTrue ( client . flush ( ) . get ( ) ) ; client . shutdown ( ) ; client = null ; super . tearDown ( ) ; }
protected abstract IMessage createMessage ( ) ; public void updateMessage ( final IMessage aMsg , final File aFile ) throws OpenAS2Exception { final MessageParameters aParams = new MessageParameters ( aMsg ) ; final String sDefaults = getAttributeAsString ( PARAM_DEFAULTS ) ; if ( sDefaults ! = null ) aParams . setParameters ( sDefaults ) ; final String sFilename = aFile . getName ( ) ; final String sFormat = getAttributeAsString ( PARAM_FORMAT ) ; if ( sFormat ! = null ) { final String sDelimiters = getAttributeAsString ( PARAM_DELIMITERS , " .- " ) ; aParams . setParameters ( sFormat , sDelimiters , sFilename ) ; } try { final byte [ ] aData = SimpleFileIO . readFileBytes ( aFile ) ; String sContentType = getAttributeAsString ( PARAM_MIMETYPE ) ; if ( sContentType = = null ) { sContentType = CMimeType . APPLICATION_OCTET_STREAM . getAsString ( ) ; } else { try { sContentType = AbstractParameterParser . parse ( sContentType , aParams ) ; } catch ( final InvalidParameterException ex ) { s_aLogger . error ( " Bad content-type " + sContentType + aMsg . getLoggingText ( ) ) ; sContentType = CMimeType . APPLICATION_OCTET_STREAM . getAsString ( ) ; } } final ByteArrayDataSource aByteSource = new ByteArrayDataSource ( aData , sContentType , null ) ; final MimeBodyPart aBody = new MimeBodyPart ( ) ; aBody . setDataHandler ( new DataHandler ( aByteSource ) ) ; final String sEncodeType = aMsg . getPartnership ( ) . getAttribute ( Partnership . PA_CONTENT_TRANSFER_ENCODING ) ; if ( sEncodeType ! = null ) aBody . setHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING , sEncodeType ) ; else { aBody . setHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING , " 8bit " ) ; } aBody . setHeader ( CAS2Header . HEADER_CONTENT_TYPE , sContentType ) ; final String sSendFilename = getAttributeAsString ( " sendfilename " ) ; if ( " true " . equals ( sSendFilename ) ) { final String sMAFilename = aMsg . getAttribute ( CFileAttribute . MA_FILENAME ) ; aBody . setHeader ( CAS2Header . HEADER_CONTENT_DISPOSITION , " Attachment; filename= \" " + sMAFilename + " \" " ) ; aMsg . setContentDisposition ( " Attachment; filename= \" " + sMAFilename + " \" " ) ; } aMsg . setData ( aBody ) ; } catch ( final MessagingException ex ) { throw new WrappedOpenAS2Exception ( ex ) ; } getSession ( ) . getPartnershipFactory ( ) . updatePartnership ( aMsg , true ) ; aMsg . updateMessageID ( ) ; } @Nonnull @ReturnsMutableObject ( reason = " speed " ) public Map < String , Long > getTrackedFiles ( ) { if ( m_aTrackedFiles = = null ) m_aTrackedFiles = new HashMap < String , Long > ( ) ; return m_aTrackedFiles ; } }
public boolean parse ( NAR nar , String input , TextInputParser lastHandler ) { if ( lastHandler ! = null ) return false ; char c = input . charAt ( 0 ) ; if ( c ! = Symbols . COMMENT_MARK ) { try { Task task = parseNarsese ( new StringBuffer ( input ) , nar . memory , nar . getTime ( ) ) ; if ( task ! = null ) { nar . output ( Output . IN . class , task . getSentence ( ) ) ; nar . memory . inputTask ( task ) ; return true ; } } catch ( InvalidInputException ex ) { return false ; } } return false ; }
void limitBuffer ( int incomingDataSize ) { Document doc = getDocument ( ) ; int overLength = doc . getLength ( ) + incomingDataSize - LogPanel . maxIOTextSize ; if ( overLength > 0 ) { try {
protected final void ensureLevelExists ( final int level ) { if ( this . level [ level ] = = null ) { this . level [ level ] = newLevel ( ) ;
< T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , int def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
private static boolean testHashMap ( ) { { if ( debug ) System . out . println ( " Hash Map. " ) ; HashMap < Integer , Integer > hash = new HashMap < Integer , Integer > ( ) ; for ( int i : unsorted ) { hash . put ( i , i ) ; boolean exists = hash . containsValue ( i ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + i + "  doesn't exists. " ) ; handleError ( hash ) ; return false ; } } if ( debug ) System . out . println ( hash . toString ( ) ) ; for ( int i : unsorted ) { hash . remove ( i ) ; boolean exists = hash . containsValue ( i ) ; if ( exists ) { System . err . println ( " YIKES!!  " + i + "  still exists. " ) ; handleError ( hash ) ; return false ; } } for ( int i = unsorted . length - 1 ; i > = 0 ; i - - ) { int item = unsorted [ i ] ; hash . put ( item , item ) ; boolean exists = hash . containsValue ( item ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + item + "  doesn't exists. " ) ; handleError ( hash ) ; return false ; } } if ( debug ) System . out . println ( hash . toString ( ) ) ; for ( int i : unsorted ) { hash . remove ( i ) ; boolean exists = hash . containsValue ( i ) ; if ( exists ) { System . err . println ( " YIKES!!  " + i + "  still exists. " ) ; handleError ( hash ) ; return false ; } } if ( debug ) System . out . println ( ) ; } return true ; }
public static String getNominalValueString ( InstancesHeader context , int attIndex , int valIndex ) { if ( context ! = null ) { int instAttIndex = attIndex < context . classIndex ( ) ? attIndex : attIndex + 1 ; if ( ( instAttIndex < context . numAttributes ( ) ) & & ( valIndex < context . attribute ( instAttIndex ) . numValues ( ) ) ) { return " {val  " + ( valIndex + 1 ) + " : " + context . attribute ( instAttIndex ) . value ( valIndex ) + " } " ; } } return " {val  " + ( valIndex + 1 ) + " } " ; }
public Object clone ( ) ; public Property getParentProperty ( ) ; public Property [ ] getSubProperties ( ) ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; core = new Prolog ( ) ; core . addOutputListener ( sysoutListener ) ; }
private void logRunException ( Exception e ) { if ( shutDown ) {
public void stateChanged ( MPDStatus mpdStatus , String oldState ) { } @Override public void repeatChanged ( boolean repeating ) { pRepeat . setChecked ( repeating ) ; } @Override public void randomChanged ( boolean random ) { pRandom . setChecked ( random ) ; } @Override public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } }
private void replaceValue ( RedBlackNode < T > nodeToReplace , RedBlackNode < T > nodeToReplaceWith ) { System . out . println ( " Replacing value  " + nodeToReplace . value + "  with  " + nodeToReplaceWith . value ) ; nodeToReplace . value = nodeToReplaceWith . value ; nodeToReplaceWith . value = null ; }
private static void convertedJudgment ( final TruthValue newTruth , final BudgetValue newBudget , final NAL nal ) { Statement content = ( Statement ) nal . getCurrentTask ( ) . getContent ( ) ; Statement beliefContent = ( Statement ) nal . getCurrentBelief ( ) . content ; int order = TemporalRules . reverseOrder ( beliefContent . getTemporalOrder ( ) ) ; final Term subjT = content . getSubject ( ) ; final Term predT = content . getPredicate ( ) ; final Term subjB = beliefContent . getSubject ( ) ; final Term predB = beliefContent . getPredicate ( ) ; Term otherTerm ; if ( Variables . containVarQuery ( subjT . name ( ) ) ) { otherTerm = ( predT . equals ( subjB ) ) ? predB : subjB ; content = Statement . make ( content , otherTerm , predT , order , nal . mem ( ) ) ; } if ( Variables . containVarQuery ( predT . name ( ) ) ) { otherTerm = ( subjT . equals ( subjB ) ) ? predB : subjB ; content = Statement . make ( content , subjT , otherTerm , order , nal . mem ( ) ) ; } if ( content = = null ) return ; nal . singlePremiseTask ( content , Symbols . JUDGMENT_MARK , newTruth , newBudget ) ; }
protected List < Music > genericSearch ( String searchCommand , String type , String strToFind ) throws MPDServerException { if ( ! isConnected ( ) ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } List < String > response = mpdConnection . sendCommand ( searchCommand , type , strToFind ) ; return Music . getMusicFromList ( response , true ) ; }
public abstract void add ( T value ) ; public abstract boolean remove ( T value ) ; public abstract boolean contains ( T value ) ; public abstract T get ( int index ) ; public abstract int size ( ) ; public static < T > List < T > createList ( ListType type ) { switch ( type ) { case ArrayList : return new ArrayList < T > ( ) ; default : return new LinkedList < T > ( ) ; } } public static class ArrayList < T > extends List < T > { private static final int MINIMUM_SIZE = 10 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ MINIMUM_SIZE ] ; private int size = 0 ; @Override public void add ( T value ) { if ( size > = array . length ) { array = Arrays . copyOf ( array , ( ( size * 3 ) / 2 ) + 1 ) ; } array [ size + + ] = value ; } @Override public boolean remove ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) { if ( i ! = - - size ) { System . arraycopy ( array , i + 1 , array , i , size - i ) ; } array [ size ] = null ; if ( size > = MINIMUM_SIZE & & size < array . length / 2 ) { array = Arrays . copyOf ( array , size ) ; } return true ; } } return false ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public T get ( int index ) { if ( index > = size ) return null ; return array [ index ] ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i + + ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } public static class LinkedList < T > extends List < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; @Override public void add ( T value ) { add ( new Node < T > ( value ) ) ; } private void add ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > prev = tail ; prev . nextNode = node ; node . previousNode = prev ; tail = node ; } size + + ; } @Override public boolean remove ( T value ) { Node < T > node = head ; while ( node ! = null & & ( ! node . value . equals ( value ) ) ) { node = node . nextNode ; } if ( node = = null ) return false ; if ( node . equals ( tail ) ) tail = node . previousNode ; Node < T > prev = node . previousNode ; Node < T > next = node . nextNode ; if ( prev ! = null & & next ! = null ) { prev . nextNode = next ; next . previousNode = prev ; } else if ( prev ! = null & & next = = null ) { prev . nextNode = null ; } else if ( prev = = null & & next ! = null ) { next . previousNode = null ; head = next ; } else { head = null ; } size - - ; return true ; } @Override public boolean contains ( T value ) { Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . nextNode ; } return false ; } @Override public T get ( int index ) { T result = null ; Node < T > node = head ; int i = 0 ; while ( node ! = null & & i < index ) { node = node . nextNode ; i + + ; } if ( node ! = null ) result = node . value ; return result ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . nextNode ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > previousNode = null ; private Node < T > nextNode = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( previousNode ! = null ) ? previousNode . value : " NULL " ) + "  next= " + ( ( nextNode ! = null ) ? nextNode . value : " NULL " ) ; } } } }
public void stringKeyValid ( ) throws Exception { new Expectations ( ) { { config . getString ( MorphlineTranslator . ENCODING_KEY ) ; result = " UTF-16 " ; config . getString ( MorphlineTranslator . ENCODING_MSG ) ; result = " UTF-8 " ; config . getString ( MorphlineTranslator . MORPHLINE ) ; result = getResourcePath ( MORPHLINE_FILE ) ; config . getString ( MorphlineTranslator . MORPHLINE_ID ) ; result = " encoding-key " ; config . getStringList ( MorphlineTranslator . FIELD_NAMES ) ; result = Lists . newArrayList ( " int " , " str " , " float " ) ; config . getStringList ( MorphlineTranslator . FIELD_TYPES ) ; result = Lists . newArrayList ( " int " , " string " , " float " ) ; } } ; stringMorphline . configure ( config ) ; String key = " \ u16b7 " ; Iterator < Row > result = stringMorphline . translate ( key , " The Message " ) ; Row row = result . next ( ) ; Assert . assertNotNull ( " Row is null " , result ) ; Assert . assertEquals ( " Invalid number of fields " , 3 , row . length ( ) ) ; Assert . assertEquals ( " Invalid field value " , 123 , row . get ( 0 ) ) ; Assert . assertEquals ( " Invalid field value " , " The Message " , row . get ( 1 ) ) ; Assert . assertEquals ( " Invalid field value " , 234 F , row . get ( 2 ) ) ; }
protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; }
public boolean is_superset_of ( lalr_item_set other ) throws internal_error { not_null ( other ) ; return other . is_subset_of ( this ) ; }
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { forward = false ; Term t1 = args [ 0 ] ; float priority = operation . getTask ( ) . budget . getPriority ( ) ; if ( args . length = = 2 ) { switch ( t1 . name ( ) . toString ( ) ) { case " left " : rover . rotate ( rotationSpeed ) ; break ; case " right " : rover . rotate ( - rotationSpeed ) ; break ; case " forward " : forward = true ; rover . thrust ( 0 , linearSpeed ) ; break ; case " backward " : rover . thrust ( 0 , - linearSpeed ) ; break ; case " stop " : rover . stop ( ) ; break ; case " random " : rover . thrust ( 0 , linearSpeed ) ; if ( true ) { ArrayList < String > candids = new ArrayList < > ( ) ; candids . add ( " (^motor,right). :|: " ) ; candids . add ( " (^motor,forward). :|: " ) ; int candid = ( int ) ( Math . random ( ) * candids . size ( ) - 0.001 ) ; nar . addInput ( candids . get ( candid ) ) ; if ( candid > = 3 ) rover . thrust ( 0 , linearSpeed ) ; if ( candid = = 2 ) rover . thrust ( 0 , - linearSpeed ) ; if ( candid = = 1 ) rover . rotate ( - rotationSpeed ) ; if ( candid = = 0 ) rover . rotate ( rotationSpeed ) ; } else { ArrayList < String > candids = new ArrayList < > ( ) ; candids . add ( " (^motor,right)! :|: " ) ; candids . add ( " (^motor,forward)! :|: " ) ; int candid = ( int ) ( Math . random ( ) * candids . size ( ) - 0.001 ) ; nar . addInput ( candids . get ( candid ) ) ; } break ; } } Rover . cnt = 0 ; return null ; }
public void stickerChanged ( final MPDStatus mpdStatus ) { float rating = getSongRating ( null ) ; mSongRating . setRating ( rating ) ; }
private static void asymmetricAsymmetric ( final Sentence taskSentence , final Sentence belief , int figure , final Memory memory ) { Statement taskStatement = ( Statement ) taskSentence . content ; Statement beliefStatement = ( Statement ) belief . content ; Term t1 , t2 ; Term [ ] u = new Term [ ] { taskStatement , beliefStatement } ; switch ( figure ) { case 11 :
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmEqvConc p , A arg ) { return visitDefault ( p , arg ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . LitSVarI p , A arg ) { return null ; }
public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( keyCode = = KeyEvent . KEYCODE_VOLUME_DOWN | | keyCode = = KeyEvent . KEYCODE_VOLUME_UP ) { event . startTracking ( ) ; return true ; } return super . onKeyDown ( keyCode , event ) ; }
void setMessageID ( @Nullable String sMessageID ) ; @Nonnull String generateMessageID ( ) ; void updateMessageID ( ) ; @Nonnull Partnership getPartnership ( ) ; void setPartnership ( @Nonnull Partnership aPartnership ) ; }
public boolean isSameOnList ( Item o ) { if ( null = = o ) { return false ; } return getName ( ) . equals ( o . getName ( ) ) ; }
public static Inheritance make ( final Term subject , final Term predicate , final Memory memory ) { if ( invalidStatement ( subject , predicate ) ) { return null ; } String name ; if ( ( subject instanceof Product ) & & ( predicate instanceof Operator ) ) { name = Operation . makeName ( predicate . getName ( ) , ( ( CompoundTerm ) subject ) . components , memory ) ; } else { name = makeStatementName ( subject , NativeOperator . INHERITANCE , predicate ) ; } Term t = memory . nameToTerm ( name ) ; if ( t ! = null ) { return ( Inheritance ) t ; } ArrayList < Term > arguments = argumentsToList ( subject , predicate ) ; if ( ( subject instanceof Product ) & & ( predicate instanceof Operator ) ) { return new Operation ( name , arguments ) ;
public static List < Interval > intervalTimeSequence ( final long t , final int maxTerms , final Memory memory ) { if ( maxTerms = = 1 ) return Lists . newArrayList ( intervalTime ( t , memory ) ) ; long a ; Interval first ; first = intervalTime ( t , memory ) ; a = first . getTime ( memory ) ; if ( a = = t ) return Lists . newArrayList ( first ) ; else if ( a < t ) { } else if ( ( a > t ) & & ( first . magnitude > 0 ) ) { first = intervalMagnitude ( first . magnitude - 1 ) ; a = first . getTime ( memory ) ; } List c = new ArrayList ( maxTerms ) ; c . add ( first ) ; long remaining = t - a ; c . addAll ( intervalTimeSequence ( remaining , maxTerms - 1 , memory ) ) ; Interval approx = Interval . intervalTime ( t , memory ) ; System . out . println ( t + "  =  " + c + " ; ~=  " + approx + "  (t= " + t + " , seq= " + intervalSequenceTime ( c , memory ) + " , one= " + approx . getTime ( memory ) + " ) " ) ; return c ; }
public static int i ( int from , int to ) { if ( to < from ) return 0 ; return ( abs ( random . nextInt ( ) ) % ( to - from ) ) + from ; }
public static void closeAtShutdown ( Closeable closeable ) { if ( SHUTDOWN_HOOK . addCloseable ( closeable ) ) { try {
protected void addAlbumPaths ( List < Album > albums ) { if ( ! cacheOK ( ) ) { return ; } for ( Album a : albums ) { Artist artist = a . getArtist ( ) ; String aname = ( artist = = null ? " " : artist . getName ( ) ) ; AlbumCache . AlbumDetails details = cache . getAlbumDetails ( aname , a . getName ( ) , a . hasAlbumArtist ( ) ) ; if ( details ! = null ) { a . setPath ( details . path ) ; } } Log . d ( " MPD CACHED " , " addAlbumPaths  " + albums . size ( ) ) ; }
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
protected void collectData ( final DataSet dataSet ) { dataSet . setField ( DataSet . Field . HITS , getHits ( ) ) ; dataSet . setField ( DataSet . Field . FIRST_HIT_STAMP , getFirstHitStamp ( ) ) ; dataSet . setField ( DataSet . Field . LAST_HIT_STAMP , getLastHitStamp ( ) ) ; dataSet . setField ( DataSet . Field . COMMITS , getCommits ( ) ) ; dataSet . setField ( DataSet . Field . FIRST , getFirst ( ) ) ; dataSet . setField ( DataSet . Field . LAST , getLast ( ) ) ; dataSet . setField ( DataSet . Field . MIN , getMin ( ) ) ; dataSet . setField ( DataSet . Field . MAX , getMax ( ) ) ; dataSet . setField ( DataSet . Field . SUM , getSum ( ) ) ; for ( DataRecorder dataRecorder : dataRecorders ) { try {
public void testLowerCaseUUID ( ) { ConfigurablePartitioner p = new UUIDPartitioner ( ) ; JavaPairRDD < Row , Row > base = Contexts . getSparkSession ( ) . createDataFrame ( Lists . < Row > newArrayList ( RowFactory . create ( " 00e3ddbf-22e3-430b-b1f1-8c90ff66070a " ) , RowFactory . create ( " aab6152d-bf3b-49ae-b2ae-830fa8c5a9f5 " ) , RowFactory . create ( " 176c4abb-482f-403a-acc1-bf2fce4b7e02 " ) , RowFactory . create ( " ebc0a57b-4492-4f77-8585-e5ec031c77b8 " ) , RowFactory . create ( " 7fb15b26-e2e6-41aa-a3dd-911272bfca6c " ) , RowFactory . create ( " 80942cf3-4f1c-4a6f-8ec3-df8e471d61c9 " ) , RowFactory . create ( " cd70533a-f13c-4fc0-8609-86c1c892a078 " ) , RowFactory . create ( " bc454e0f-e54b-44e4-9278-75a2dba25833 " ) , RowFactory . create ( " 62d71924-5c69-4771-8f78-0e518fae137d " ) , RowFactory . create ( " ff6c7c94-7fd7-4881-bc7f-ffd4713411a3 " ) ) , DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " uuid " , DataTypes . StringType , false ) ) ) ) . javaRDD ( ) . mapToPair ( new CopyKeyFunction ( ) ) . repartition ( 10 ) ; p . configure ( ConfigFactory . empty ( ) , base ) ; int [ ] partitionIds = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; List < Tuple2 < Row , Iterable < Row > > > [ ] results = base . groupByKey ( p ) . collectPartitions ( partitionIds ) ; assertEquals ( p . numPartitions ( ) , 10 ) ; assertEquals ( base . getNumPartitions ( ) , 10 ) ; assertEquals ( results . length , 10 ) ; assertEquals ( results [ 0 ] . size ( ) , 2 ) ; assertEquals ( results [ 1 ] . size ( ) , 0 ) ; assertEquals ( results [ 2 ] . size ( ) , 0 ) ; assertEquals ( results [ 3 ] . size ( ) , 1 ) ; assertEquals ( results [ 4 ] . size ( ) , 1 ) ; assertEquals ( results [ 5 ] . size ( ) , 1 ) ; assertEquals ( results [ 6 ] . size ( ) , 1 ) ; assertEquals ( results [ 7 ] . size ( ) , 1 ) ; assertEquals ( results [ 8 ] . size ( ) , 1 ) ; assertEquals ( results [ 9 ] . size ( ) , 2 ) ; assertTrue ( results [ 0 ] . get ( 0 ) . _1 ( ) . getString ( 0 ) . equals ( " 00e3ddbf-22e3-430b-b1f1-8c90ff66070a " ) | | results [ 0 ] . get ( 1 ) . _1 ( ) . getString ( 0 ) . equals ( " 00e3ddbf-22e3-430b-b1f1-8c90ff66070a " ) ) ; assertTrue ( results [ 0 ] . get ( 0 ) . _1 ( ) . getString ( 0 ) . equals ( " 176c4abb-482f-403a-acc1-bf2fce4b7e02 " ) | | results [ 0 ] . get ( 1 ) . _1 ( ) . getString ( 0 ) . equals ( " 176c4abb-482f-403a-acc1-bf2fce4b7e02 " ) ) ; assertEquals ( results [ 3 ] . get ( 0 ) . _1 ( ) . getString ( 0 ) , " 62d71924-5c69-4771-8f78-0e518fae137d " ) ; assertEquals ( results [ 4 ] . get ( 0 ) . _1 ( ) . getString ( 0 ) , " 7fb15b26-e2e6-41aa-a3dd-911272bfca6c " ) ; assertEquals ( results [ 5 ] . get ( 0 ) . _1 ( ) . getString ( 0 ) , " 80942cf3-4f1c-4a6f-8ec3-df8e471d61c9 " ) ; assertEquals ( results [ 6 ] . get ( 0 ) . _1 ( ) . getString ( 0 ) , " aab6152d-bf3b-49ae-b2ae-830fa8c5a9f5 " ) ; assertEquals ( results [ 7 ] . get ( 0 ) . _1 ( ) . getString ( 0 ) , " bc454e0f-e54b-44e4-9278-75a2dba25833 " ) ; assertEquals ( results [ 8 ] . get ( 0 ) . _1 ( ) . getString ( 0 ) , " cd70533a-f13c-4fc0-8609-86c1c892a078 " ) ; assertTrue ( results [ 9 ] . get ( 0 ) . _1 ( ) . getString ( 0 ) . equals ( " ebc0a57b-4492-4f77-8585-e5ec031c77b8 " ) | | results [ 9 ] . get ( 1 ) . _1 ( ) . getString ( 0 ) . equals ( " ebc0a57b-4492-4f77-8585-e5ec031c77b8 " ) ) ; assertTrue ( results [ 9 ] . get ( 0 ) . _1 ( ) . getString ( 0 ) . equals ( " ff6c7c94-7fd7-4881-bc7f-ffd4713411a3 " ) | | results [ 9 ] . get ( 1 ) . _1 ( ) . getString ( 0 ) . equals ( " ff6c7c94-7fd7-4881-bc7f-ffd4713411a3 " ) ) ;
protected void sendMDN ( final Socket aSocket , @Nonnull final AS2Message aMsg , final DispositionType aDisposition , final String sText ) { final boolean bMdnBlocked = aMsg . getPartnership ( ) . getAttribute ( CASXPartnership . PA_BLOCK_ERROR_MDN ) ! = null ; if ( ! bMdnBlocked ) {
public static boolean isRetryable ( final String command ) { return ! NON_RETRYABLE_COMMANDS . contains ( command ) ; }
private E intoBase ( E newItem ) { E oldItem = null ; int inLevel = getLevel ( newItem ) ; if ( size ( ) > capacity ) { int outLevel = 0 ; while ( itemTableEmpty [ outLevel ] ) { outLevel + + ; } if ( outLevel > inLevel ) { return newItem ; } else { oldItem = takeOutFirst ( outLevel ) ; } } ensureLevelExists ( inLevel ) ; itemTable [ inLevel ] . add ( newItem ) ; itemTableEmpty [ inLevel ] = false ; mass + = ( inLevel + 1 ) ; refresh ( ) ; return oldItem ; }
public void art2A ( ArrayList < DynamicVector < Float > > sample , in_param param , Clust results ) { DynamicVector < Float > P ; ArrayList < DynamicVector < Float > > prot = new ArrayList < DynamicVector < Float > > ( ) ; ArrayList < DynamicVector < Float > > prot_best = new ArrayList < DynamicVector < Float > > ( ) ; ArrayList < ArrayList < Integer > > prot_seq = new ArrayList < ArrayList < Integer > > ( ) ; ArrayList < ArrayList < Integer > > prot_seq_best = new ArrayList < ArrayList < Integer > > ( ) ; ArrayList < DynamicVector < Float > > used = new ArrayList < DynamicVector < Float > > ( ) ; used = new ArrayList < DynamicVector < Float > > ( ) ; prot = new ArrayList < DynamicVector < Float > > ( ) ; prot_seq = new ArrayList < ArrayList < Integer > > ( ) ; prot_best = new ArrayList < DynamicVector < Float > > ( ) ; prot_seq_best = new ArrayList < ArrayList < Integer > > ( ) ; float fluctuation = 100.0f ; float fluctuation_best = 120.0f ; int pass = 0 ; ArrayList < Boolean > changed = new ArrayList < Boolean > ( ) ; int i , j ; changed = new ArrayList < Boolean > ( ) ; for ( i = 0 ; i < sample . size ( ) ; i + + ) { changed . add ( true ) ; } while ( ( pass < param . pass ) & & ( fluctuation > param . error ) ) { int number_changed ; for ( i = 0 ; i < sample . size ( ) ; i + + ) { changed . set ( i , false ) ; } for ( i = 0 ; i < sample . size ( ) ; i + + ) { used . clear ( ) ; do { float score ; float alphaSum ; P = bestPrototype2A ( sample . get ( i ) , prot , used ) ; if ( P . array . length = = 0 ) { int prototypeIndex ; prototypeIndex = Common . instanceInSequence ( prot_seq , i ) ; if ( prototypeIndex ! = - 1 ) { removeInstance ( sample , i , prot , prototypeIndex , prot_seq , param . beta , param . vigilance ) ; } createPrototype ( sample , i , prot , prot_seq , param . vigilance ) ; changed . set ( i , true ) ; break ; } used . add ( P ) ; score = countScore ( P , sample . get ( i ) ) ; alphaSum = 0.0f ; for ( j = 0 ; j < sample . get ( i ) . array . length ; j + + ) { alphaSum + = param . alpha * sample . get ( i ) . get___idx ( j ) ; } if ( score > = alphaSum ) { if ( score > = param . vigilance ) { int prot_index ; int Pindex ; prot_index = Common . instanceInSequence ( prot_seq , i ) ; if ( prot_index ! = - 1 ) { if ( prot . get ( prot_index ) . equals ( P ) ) { break ; } else { removeInstance ( sample , i , prot , prot_index , prot_seq , param . beta , param . vigilance ) ; } } Pindex = Common . findItem ( prot , P , true ) ; addInstance ( sample . get ( i ) , prot . get ( Pindex ) , param . beta ) ; prot_seq . get ( Pindex ) . add ( i ) ; changed . set ( i , true ) ; break ; } else { continue ; } } else { int prot_index ; prot_index = Common . instanceInSequence ( prot_seq , i ) ; if ( prot_index ! = - 1 ) { removeInstance ( sample , i , prot , prot_index , prot_seq , param . beta , param . vigilance ) ; } createPrototype ( sample , i , prot , prot_seq , param . vigilance ) ; changed . set ( i , true ) ; break ; } } while ( prot . size ( ) ! = sample . size ( ) ) ; } number_changed = 0 ; for ( j = 0 ; j < changed . size ( ) ; j + + ) { if ( changed . get ( j ) ) { number_changed + + ; } } fluctuation = ( ( float ) number_changed / sample . size ( ) ) * 100 ; pass + + ; if ( fluctuation < fluctuation_best ) { prot_best = prot ; prot_seq_best = prot_seq ; fluctuation_best = fluctuation ; } } results . proto = prot_best ; results . proto_seq = prot_seq_best ; results . fluctuation = fluctuation_best ; }
public CachedData encode ( java . lang . Integer l ) { return new CachedData ( flags , tu . encodeInt ( l ) , getMaxSize ( ) ) ; }
protected void pushUpdate ( final Context context , final RemoteViews views ) { final AppWidgetManager gm = AppWidgetManager . getInstance ( context ) ; gm . updateAppWidget ( new ComponentName ( context , getClass ( ) ) , views ) ; }
public static ImageInt make ( Term [ ] argList ) { if ( argList . length < 2 ) { return null ; } Term relation = argList [ 0 ] ; Term [ ] argument = new Term [ argList . length - 1 ] ; int index = 0 , n = 0 ; for ( int j = 1 ; j < argList . length ; j + + ) { if ( argList [ j ] . toString ( ) . charAt ( 0 ) = = Symbols . IMAGE_PLACE_HOLDER ) { index = j - 1 ; argument [ n ] = relation ; } else { argument [ n ] = argList [ j ] ; } n + + ; } return new ImageInt ( argument , ( short ) index ) ; }
public void trainOnInstance ( Instance inst ) { if ( ! this . isInit ) { this . isInit = true ; InstancesHeader instances = new InstancesHeader ( dataset ) ; this . learner . setModelContext ( instances ) ; this . learner . prepareForUse ( ) ; } if ( inst . weight ( ) > 0 ) { inst . setDataset ( dataset ) ;
public static Result shout ( String artist , String message , Session session ) { return Caller . getInstance ( ) . call ( " artist.shout " , session , " artist " , artist , " message " , message ) ; }
public static void notifyUser ( final CharSequence message ) { Toast . makeText ( MPDApplication . getInstance ( ) , message , Toast . LENGTH_SHORT ) . show ( ) ; }
public void onActivityCreated ( final Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; this . mActivity = getActivity ( ) ; refreshListColorCacheHint ( ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmLit p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmStm p , A arg ) ; } }
public void testReplaceNotSerializable ( ) throws Exception { try { client . replace ( " t1 " , 5 , new Object ( ) ) ;
public String storeSync ( StoreOperation . StoreType storeType , String key , int exp , Object o ) { final SynchronizationObject < String > so = new SynchronizationObject < String > ( null ) ; storeAsync ( storeType , key , exp , o , new StoreOperation . Callback ( ) { public void storeResult ( String val ) { so . set ( val ) ; } } ) ; waitForNotNull ( so ) ; return so . get ( ) ; }
private int [ ] searchEdges ( char [ ] query ) { int start_node = 0 ; int qp = 0 ; int start_index = - 1 ; int end_index = - 1 ; boolean stop = false ; while ( ! stop & & qp < query . length ) { Edge < C > edge = Edge . find ( this , start_node , query [ qp ] ) ; if ( edge = = null ) { stop = true ; break ; } if ( start_node = = 0 ) start_index = edge . firstCharIndex ; for ( int i = edge . firstCharIndex ; i < = edge . lastCharIndex ; i + + ) { if ( qp > = query . length ) { stop = true ; break ; } else if ( query [ qp ] = = characters [ i ] ) { qp + + ; end_index = i ; } else { stop = true ; break ; } } if ( ! stop ) { start_node = edge . endNode ; if ( start_node = = - 1 ) stop = true ; } } return ( new int [ ] { start_index , end_index } ) ; }
void transitionWriteItem ( ) ; Operation getCurrentReadOp ( ) ; Operation removeCurrentReadOp ( ) ; Operation getCurrentWriteOp ( ) ; Operation removeCurrentWriteOp ( ) ; boolean hasReadOp ( ) ; boolean hasWriteOp ( ) ; void addOp ( Operation op ) ; int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; }
ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; }
public void move ( final int songId , final int to ) throws MPDServerException { mMPD . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_MOVE_ID , Integer . toString ( songId ) , Integer . toString ( to ) ) ; refresh ( ) ; }
public void initDynamicComponent ( @Nonnull final IAS2Session session , @Nullable final IStringMap parameters ) throws AS2Exception { super . initDynamicComponent ( session , parameters ) ; getAttributeAsStringRequired ( ATTR_NAME ) ; getAttributeAsStringRequired ( ATTR_DESCRIPTION ) ; if ( getUsage ( ) = = null ) setUsage ( getName ( ) + "  <command> <parameters> " ) ;
ArrayList < String > getTabList ( ) ; void pageChanged ( int position ) ; }
public void handle ( final String action , final IMessage msg , final Map < String , Object > options ) throws OpenAS2Exception { try { final File msgFile = getFile ( msg , getParameterRequired ( PARAM_FILENAME ) , action ) ; final InputStream in = msg . getData ( ) . getInputStream ( ) ; store ( msgFile , in ) ; s_aLogger . info ( " stored message to  " + msgFile . getAbsolutePath ( ) + msg . getLoggingText ( ) ) ; } catch ( final Exception e ) { throw new DispositionException ( new DispositionType ( " automatic-action " , " MDN-sent-automatically " , " processed " , " Error " , " Error storing transaction " ) , AS2ReceiverModule . DISP_STORAGE_FAILED , e ) ; } final String headerFilename = getParameterNotRequired ( PARAM_HEADER ) ; if ( headerFilename ! = null ) {
protected final short get_reduce ( int state , int sym ) { short tag ; short [ ] row = reduce_tab [ state ] ; if ( row = = null ) return - 1 ; for ( int probe = 0 ; probe < row . length ; probe + + ) { tag = row [ probe + + ] ; if ( tag = = sym | | tag = = - 1 ) { return row [ probe ] ; } } return - 1 ; }
protected String removeDiscReference ( String album ) { String cleanedAlbum = album . toLowerCase ( ) ; for ( String discReference : DISC_REFERENCES ) { cleanedAlbum = cleanedAlbum . replaceAll ( discReference + " \\ s* \\ d+ " , "   " ) ; } return cleanedAlbum ; }
public AS2ClientResponse sendSynchronous ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2ClientRequest aRequest ) { ValueEnforcer . notNull ( aSettings , " ClientSettings " ) ; ValueEnforcer . notNull ( aRequest , " ClientRequest " ) ; final AS2ClientResponse aResponse = createResponse ( ) ; IMessage aMsg = null ; final StopWatch aSW = StopWatch . createdStarted ( ) ; try { final Partnership aPartnership = buildPartnership ( aSettings ) ; aMsg = createMessage ( aPartnership , aRequest ) ; aResponse . setOriginalMessageID ( aMsg . getMessageID ( ) ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " MessageID to send:  " + aMsg . getMessageID ( ) ) ; final boolean bHasRetries = aSettings . getRetryCount ( ) > 0 ; final AS2Session aSession = createSession ( ) ; initCertificateFactory ( aSettings , aSession ) ; initPartnershipFactory ( aSession ) ; initMessageProcessor ( aSession ) ; if ( bHasRetries ) { final IProcessorResenderModule aResender = new ImmediateResenderModule ( ) ; aResender . initDynamicComponent ( aSession , null ) ; aSession . getMessageProcessor ( ) . addModule ( aResender ) ; } aSession . getMessageProcessor ( ) . startActiveModules ( ) ; try { beforeSend ( aSettings , aSession , aMsg ) ; final ICommonsMap < String , Object > aHandleOptions = new CommonsHashMap < > ( ) ; if ( bHasRetries ) aHandleOptions . put ( IProcessorResenderModule . OPTION_RETRIES , Integer . toString ( aSettings . getRetryCount ( ) ) ) ; final AS2SenderModule aSender = m_aAS2SenderModuleFactory . get ( ) ; aSender . initDynamicComponent ( aSession , null ) ; aSender . putIn ( AbstractHttpSenderModule . ATTR_CONNECT_TIMEOUT , aSettings . getConnectTimeoutMS ( ) ) ; aSender . putIn ( AbstractHttpSenderModule . ATTR_READ_TIMEOUT , aSettings . getReadTimeoutMS ( ) ) ; aSender . putIn ( AbstractHttpSenderModule . ATTR_LARGE_FILE_SUPPORT_ON , aSettings . isLargeFileSupport ( ) ) ; aMsg . headers ( ) . setAllHeaders ( aSettings . customHeaders ( ) ) ; aSession . getMessageProcessor ( ) . addModule ( aSender ) ; aSender . handle ( IProcessorSenderModule . DO_SEND , aMsg , aHandleOptions ) ; } finally { aSession . getMessageProcessor ( ) . stopActiveModules ( ) ; } } catch ( final Throwable t ) { s_aLogger . error ( " Error sending AS2 message " , t ) ; aResponse . setException ( t ) ; } finally { if ( aMsg ! = null & & aMsg . getMDN ( ) ! = null ) { aResponse . setMDN ( aMsg . getMDN ( ) ) ; } } if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Response retrieved:  " + aResponse . getAsString ( ) ) ; aResponse . setExecutionDuration ( aSW . stopAndGetDuration ( ) ) ; return aResponse ; }
NoopOperation noop ( OperationCallback cb ) ; DeleteOperation delete ( String key , OperationCallback operationCallback ) ; FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetAndTouchOperation getAndTouch ( String key , int expiration , GetAndTouchOperation . Callback cb ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetlOperation getl ( String key , int exp , GetlOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; KeyedOperation touch ( String key , int expiration , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }
public int compareTo ( final Term that ) { if ( this = = that ) return 0 ; if ( getClass ( ) ! = that . getClass ( ) ) return getClass ( ) . getSimpleName ( ) . compareTo ( that . getClass ( ) . getSimpleName ( ) ) ; final CompoundTerm thatC = ( CompoundTerm ) that ; int opDiff = operator ( ) . ordinal ( ) - thatC . operator ( ) . ordinal ( ) ; if ( opDiff ! = 0 ) return opDiff ; if ( term . length ! = thatC . term . length ) return term . length - thatC . term . length ; int tempDiff = temporalOrder - thatC . temporalOrder ; if ( tempDiff ! = 0 ) return tempDiff ; for ( int i = 0 ; i < term . length ; i + + ) { final int diff = term [ i ] . compareTo ( thatC . term [ i ] ) ; if ( diff ! = 0 ) return diff ; } return 0 ; }
public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . albums , container , false ) ; album = ( String ) this . getActivity ( ) . getIntent ( ) . getStringExtra ( " album " ) ; getActivity ( ) . setTitle ( album ) ; getActivity ( ) . findViewById ( R . id . header ) . setVisibility ( View . VISIBLE ) ; TextView title = ( TextView ) getActivity ( ) . findViewById ( R . id . headerText ) ; title . setText ( getActivity ( ) . getTitle ( ) ) ; ImageView icon = ( ImageView ) getActivity ( ) . findViewById ( R . id . headerIcon ) ; icon . setImageDrawable ( getResources ( ) . getDrawable ( R . drawable . ic_tab_albums_selected ) ) ; return view ; }
public void handle ( @Nonnull final String sAction , @Nonnull final IMessage aBaseMsg , @Nullable final Map < String , Object > aOptions ) throws OpenAS2Exception { final AS2Message aMsg = ( AS2Message ) aBaseMsg ; s_aLogger . info ( " Submitting message " + aMsg . getLoggingText ( ) ) ; checkRequired ( aMsg ) ; final int nRetries = getRetryCount ( aMsg . getPartnership ( ) , aOptions ) ; try {
private static String configToString ( Config c ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( '{' ) ; for ( Map . Entry < String , Object > entry : c . asMap ( ) . entrySet ( ) ) { final String key = entry . getKey ( ) ; final Object value = entry . getValue ( ) ; sb . append ( key ) . append ( "  =  " ) ; if ( value instanceof Config ) { sb . append ( configToString ( ( Config ) value ) ) ; } else { sb . append ( value ) ; } sb . append ( " ,  " ) ; } sb . delete ( sb . length ( ) - 2 , sb . length ( ) ) ; sb . append ( '}' ) ; return sb . toString ( ) ; }
public String toStringLong ( ) { StringBuffer buf = new StringBuffer ( "  BAG  " + getClass ( ) . getSimpleName ( ) ) ; buf . append ( "   " ) . append ( showSizes ( ) ) ; for ( int i = TOTAL_LEVEL ; i > = showLevel ; i - - ) { if ( ! itemTableEmpty [ i - 1 ] ) { buf = buf . append ( " \ n --- LEVEL  " ) . append ( i ) . append ( " : \ n  " ) ; for ( final E e : itemTable [ i - 1 ] ) { buf = buf . append ( e . toStringLong ( ) ) . append ( '\n' ) ; } } } buf . append ( " >>>> end of Bag " ) . append ( getClass ( ) . getSimpleName ( ) ) ; return buf . toString ( ) ; }
public String toString ( ) { final StringBuilder buf = new StringBuilder ( "   " ) ; for ( int i = levels - 1 ; i > = 0 ; i - - ) { if ( itemTable [ i ] ! = null & & ! itemTable [ i ] . isEmpty ( ) ) { buf . append ( " \ n --- Level  " ) . append ( ( i + 1 ) ) . append ( " : \ n " ) ; for ( final E e : itemTable [ i ] ) { buf . append ( e . toStringExternal ( ) ) . append ( '\n' ) ; } } } return buf . toString ( ) ; }
public void addClassificationAttempt ( int trueClass , double [ ] classVotes , double weight ) { if ( weight > 0.0 ) { if ( this . weightObserved = = 0 ) { reset ( classVotes . length ) ; } this . weightObserved + = weight ; int predictedClass = Utils . maxIndex ( classVotes ) ; if ( predictedClass = = trueClass ) { this . weightCorrect + = weight ; } if ( rowKappa . length > 0 ) { this . rowKappa [ predictedClass ] + = weight ; } if ( columnKappa . length > 0 ) { this . columnKappa [ trueClass ] + = weight ; } } if ( this . lastSeenClass = = trueClass ) { this . weightCorrectNoChangeClassifier + = weight ; } this . lastSeenClass = trueClass ; }
public ArrayList < Task > cutoutAppend ( int ind1 , int ind2 , ArrayList < Task > first , ArrayList < Task > second ) { ArrayList < Task > res = new ArrayList < > ( ) ; for ( int i = ind1 ; i < first . size ( ) + ind2 ; i + + ) { res . add ( first . get ( i ) ) ; } for ( Task t : second ) { res . add ( t ) ; } return res ; }
public void onDestroy ( ) { SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( activity ) ; settings . unregisterOnSharedPreferenceChangeListener ( this ) ; activity . unregisterReceiver ( MPDConnectionHandler . getInstance ( ) ) ; super . onDestroy ( ) ; }
public HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( final View view , final Query query ) { if ( ! view . hasReduce ( ) ) { throw new RuntimeException ( " This view doesn't contain a reduce function " ) ; } String uri = view . getURI ( ) + query . toString ( ) ; final CountDownLatch couchLatch = new CountDownLatch ( 1 ) ; final HttpFuture < ViewResponseReduced > crv = new HttpFuture < ViewResponseReduced > ( couchLatch , 60000 ) ; final HttpRequest request = new BasicHttpRequest ( " GET " , uri , HttpVersion . HTTP_1_1 ) ; final HttpOperation op = new ReducedOperationImpl ( request , new ReducedCallback ( ) { private ViewResponseReduced vr = null ; @Override public void receivedStatus ( OperationStatus status ) { crv . set ( vr , status ) ; } @Override public void complete ( ) { couchLatch . countDown ( ) ; } @Override public void gotData ( ViewResponseReduced response ) { vr = response ; } } ) ; crv . setOperation ( op ) ; addOp ( op ) ; return crv ; }
StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; KeyedOperation touch ( String key , int expiration , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
public void join ( DockingChild oldChild , DockingChild newChild ) { if ( oldChild ! = root ) { throw new IllegalArgumentException ( ) ; } if ( newChild = = null ) { fireDockingContainerEmpty ( ) ; return ; } root = newChild ; newChild . setDockParent ( this ) ; panel_workArea . removeAll ( ) ; panel_workArea . add ( root . getComponent ( ) , BorderLayout . CENTER ) ; revalidate ( ) ; }
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setHasOptionsMenu ( true ) ; }
public V computeIfAbsent ( K key , Function < ? super K , ? extends V > mappingFunction ) { V result = map . computeIfAbsent ( key , mappingFunction ) ; if ( result ! = null ) { callback . run ( ) ; } return result ; }
protected void cycle ( ) { updatePriorities ( ) ; if ( tasks . size ( ) = = 0 ) return ; System . out . println ( " Tasks @  " + memory . getTime ( ) ) ; for ( TaskConcept tcc : tasks ) System . out . println ( "    " + tcc . toString ( ) ) ; TaskConcept topConcept = tasks . getFirst ( ) ; Task top = topConcept . t ; Term term = top . getContent ( ) ; if ( term instanceof Operation ) { execute ( ( Operation ) term , top ) ;
IndexedTreeMap . Entry < K , V > subHighest ( ) { return absHighest ( ) ; }
static boolean isSecure ( Config config ) { boolean isSecure = UserGroupInformation . isSecurityEnabled ( ) ; if ( config . hasPath ( IS_SECURE_CONFIG_NAME ) ) { isSecure = config . getBoolean ( IS_SECURE_CONFIG_NAME ) ; } return isSecure ; }
public static < K , V > boolean testMap ( IMap < K , V > map , Type keyType , String name , Integer [ ] unsorted , Integer invalid ) { for ( int i = 0 ; i < unsorted . length ; i + + ) { Integer item = unsorted [ i ] ; K k = null ; V v = null ; if ( keyType = = Type . Integer ) { k = ( K ) item ; v = ( V ) String . valueOf ( item ) ; } else if ( keyType = = Type . String ) { k = ( K ) String . valueOf ( item ) ; v = ( V ) item ; } V added = map . put ( k , v ) ; if ( ( ! map . validate ( ) | | ( map . size ( ) ! = ( i + 1 ) ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( map ) ; return false ; } if ( ( added ! = null | | ! map . contains ( k ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists. " ) ; Utils . handleError ( map ) ; return false ; } } K invalidKey = null ; if ( keyType = = Type . Integer ) { invalidKey = ( K ) invalid ; } else if ( keyType = = Type . String ) { invalidKey = ( K ) String . valueOf ( invalid ) ; } boolean contains = map . contains ( invalidKey ) ; V removed = map . remove ( invalidKey ) ; if ( contains | | ( removed ! = null ) ) { System . err . println ( name + "  invalidity check. contains= " + contains + "  removed= " + removed ) ; Utils . handleError ( map ) ; return false ; } for ( int i = 0 ; i < unsorted . length ; i + + ) { Integer item = unsorted [ i ] ; K k = null ; if ( keyType = = Type . Integer ) { k = ( K ) item ; } else if ( keyType = = Type . String ) { k = ( K ) String . valueOf ( item ) ; } removed = map . remove ( k ) ; if ( ( ! map . validate ( ) | | ( map . size ( ) ! = ( unsorted . length - ( i + 1 ) ) ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( map ) ; return false ; } if ( map . contains ( k ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists. " ) ; Utils . handleError ( map ) ; return false ; } } int quarter = unsorted . length / 4 ; int half = unsorted . length / 2 ; for ( int i = 0 ; i < half ; i + + ) { Integer item = unsorted [ i ] ; K k = null ; V v = null ; if ( keyType = = Type . Integer ) { k = ( K ) item ; v = ( V ) String . valueOf ( item ) ; } else if ( keyType = = Type . String ) { k = ( K ) String . valueOf ( item ) ; v = ( V ) item ; } V added = map . put ( k , v ) ; if ( ( ! map . validate ( ) | | ( map . size ( ) ! = ( i + 1 ) ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( map ) ; return false ; } if ( ( added ! = null | | ! map . contains ( k ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists. " ) ; Utils . handleError ( map ) ; return false ; } } for ( int i = ( half - 1 ) ; i > = quarter ; i - - ) { Integer item = unsorted [ i ] ; K k = null ; if ( keyType = = Type . Integer ) { k = ( K ) item ; } else if ( keyType = = Type . String ) { k = ( K ) String . valueOf ( item ) ; } removed = map . remove ( k ) ; if ( ( ! map . validate ( ) | | ( map . size ( ) ! = i ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( map ) ; return false ; } if ( ( removed = = null | | map . contains ( k ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists. " ) ; Utils . handleError ( map ) ; return false ; } } for ( int i = quarter ; i < unsorted . length ; i + + ) { Integer item = unsorted [ i ] ; K k = null ; V v = null ; if ( keyType = = Type . Integer ) { k = ( K ) item ; v = ( V ) String . valueOf ( item ) ; } else if ( keyType = = Type . String ) { k = ( K ) String . valueOf ( item ) ; v = ( V ) item ; } V added = map . put ( k , v ) ; if ( ( ! map . validate ( ) | | ( map . size ( ) ! = ( i + 1 ) ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( map ) ; return false ; } if ( ( added ! = null | | ! map . contains ( k ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists. " ) ; Utils . handleError ( map ) ; return false ; } } for ( int i = unsorted . length - 1 ; i > = 0 ; i - - ) { Integer item = unsorted [ i ] ; K k = null ; if ( keyType = = Type . Integer ) { k = ( K ) item ; } else if ( keyType = = Type . String ) { k = ( K ) String . valueOf ( item ) ; } removed = map . remove ( k ) ; if ( ( ! map . validate ( ) | | ( map . size ( ) ! = i ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( map ) ; return false ; } if ( ( removed = = null | | map . contains ( k ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists. " ) ; Utils . handleError ( map ) ; return false ; } } if ( ( map . size ( ) ! = 0 ) ) { System . err . println ( name + "  YIKES!! a size mismatch. " ) ; Utils . handleError ( map ) ; return false ; } return true ; }
public abstract void setParameter ( @Nonnull String sKey , @Nonnull String sValue ) throws InvalidParameterException ; @Nullable public abstract String getParameter ( @Nonnull String sKey ) throws InvalidParameterException ; public void setParameters ( @Nonnull final String sEncodedParams ) throws InvalidParameterException { final StringTokenizer aParams = new StringTokenizer ( sEncodedParams , " =, " , false ) ; while ( aParams . hasMoreTokens ( ) ) { final String sKey = aParams . nextToken ( ) . trim ( ) ; if ( ! aParams . hasMoreTokens ( ) ) throw new InvalidParameterException ( " Invalid value " , this , sKey , null ) ; final String sValue = aParams . nextToken ( ) ; setParameter ( sKey , sValue ) ; } } public void setParameters ( @Nullable final String sFormat , @Nullable final String sDelimiters , @Nonnull final String sValue ) throws OpenAS2Exception { final List < String > aKeys = StringHelper . getExploded ( ',' , sFormat ) ; final StringTokenizer aValueTokens = new StringTokenizer ( sValue , sDelimiters , false ) ; for ( final String sKey : aKeys ) { if ( ! aValueTokens . hasMoreTokens ( ) ) throw new OpenAS2Exception ( " Invalid value: Format= " + sFormat + " , value= " + sValue ) ; if ( sKey . length ( ) > 0 ) setParameter ( sKey , aValueTokens . nextToken ( ) ) ; } } @Deprecated public static String parse ( @Nonnull final String sFormat , @Nonnull final AbstractParameterParser aParser ) throws InvalidParameterException { return aParser . format ( sFormat ) ; } @Nonnull public String format ( @Nonnull final String sFormat ) throws InvalidParameterException { if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Formatting ' " + sFormat + " ' " ) ; final StringBuilder aSB = new StringBuilder ( ) ; for ( int nNext = 0 ; nNext < sFormat . length ( ) ; + + nNext ) { int nPrev = nNext ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) { aSB . append ( sFormat . substring ( nPrev , sFormat . length ( ) ) ) ; break ; } if ( nNext > nPrev ) aSB . append ( sFormat . substring ( nPrev , nNext ) ) ; nPrev = nNext + 1 ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) throw new InvalidParameterException ( " Invalid key (missing closing $) " ) ; if ( nNext = = nPrev ) aSB . append ( " $ " ) ; else aSB . append ( getParameter ( sFormat . substring ( nPrev , nNext ) ) ) ; } if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Formatted value is now ' " + aSB . toString ( ) + " ' " ) ; return aSB . toString ( ) ; } @Override public String toString ( ) { return new ToStringGenerator ( this ) . toString ( ) ; } }
protected Iterator < AbstractTask > perceive ( final String line ) { Exception lastException = null ; for ( final TextReaction p : parsers ) { Object result = p . react ( line ) ; if ( result ! = null ) { if ( result instanceof Iterator ) { return ( Iterator < AbstractTask > ) result ; } if ( result instanceof Collection ) { return ( ( Collection < AbstractTask > ) result ) . iterator ( ) ; } if ( result instanceof AbstractTask ) { return singletonIterator ( ( AbstractTask ) result ) ; } else if ( result . equals ( Boolean . TRUE ) ) { return null ; } else if ( result instanceof Exception ) { lastException = ( Exception ) result ; } } } String errorMessage = " Invalid input:  \ ' " + line + " \ ' " ; if ( lastException ! = null ) { errorMessage + = "  :  " + lastException . toString ( ) ; } memory . emit ( Output . ERR . class , errorMessage ) ; return null ; }
public void resetLearning ( ) { this . instancesSeen = 0 L ; this . classInstances = new HashMap < Integer , Double > ( ) ; this . attributeObservers = new AutoExpandVector < AttributeClassObserver > ( ) ; }
protected Object deserialize ( byte [ ] in ) { Object rv = null ; assert in ! = null ; try { ByteArrayInputStream bis = new ByteArrayInputStream ( in ) ; ObjectInputStream is = new ObjectInputStream ( bis ) ; rv = is . readObject ( ) ; is . close ( ) ; bis . close ( ) ; } catch ( IOException e ) { getLogger ( ) . warn ( " Caught IOException decoding %d bytes of data " , in . length , e ) ; } catch ( ClassNotFoundException e ) { getLogger ( ) . warn ( " Caught CNFE decoding %d bytes of data " , in . length , e ) ; } return rv ; }
public int previousIndex ( ) { synchronized ( mLOCK ) { checkConcurrentModification ( ) ;
protected void onResume ( ) { super . onResume ( ) ; app . oMPDAsyncHelper . addStatusChangeListener ( this ) ; update ( ) ; }
protected static String makeStatementName ( final Term subject , final Operator relation , final Term predicate , StringBuilder nameBuilder ) { final String subjectName = subject . getName ( ) ; final String predicateName = predicate . getName ( ) ; int length = subjectName . length ( ) + predicateName . length ( ) + relation . toString ( ) . length ( ) + 4 ; if ( nameBuilder = = null ) { nameBuilder = new StringBuilder ( ) ; } nameBuilder . setLength ( 0 ) ; nameBuilder . ensureCapacity ( length ) ; return nameBuilder . append ( Symbols . STATEMENT_OPENER )
private static NotificationCompat . Builder buildStaticCollapsedNotification ( final Context context ) { final Intent musicPlayerActivity = new Intent ( context , MainMenuActivity . class ) ; final TaskStackBuilder stackBuilder = TaskStackBuilder . create ( context ) ; stackBuilder . addParentStack ( MainMenuActivity . class ) ; stackBuilder . addNextIntent ( musicPlayerActivity ) ; final PendingIntent notificationClick = stackBuilder . getPendingIntent ( 0 , PendingIntent . FLAG_UPDATE_CURRENT ) ; final NotificationCompat . Builder builder = new NotificationCompat . Builder ( context ) ; builder . setSmallIcon ( R . drawable . icon_bw ) ; builder . setContentIntent ( notificationClick ) ; builder . setStyle ( new NotificationCompat . BigTextStyle ( ) ) ; return builder ; }
public void writeCsvNoOptions ( ) throws Exception { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( FileSystemOutput . FORMAT_CONFIG , " csv " ) ; paramMap . put ( FileSystemOutput . PATH_CONFIG , results . getPath ( ) ) ; config = ConfigFactory . parseMap ( paramMap ) ; FileSystemOutput fileSystemOutput = new FileSystemOutput ( ) ; assertNoValidationFailures ( fileSystemOutput , config ) ; fileSystemOutput . configure ( config ) ; fileSystemOutput . applyBulkMutations ( plannedRows ) ; File [ ] files = results . listFiles ( new FilenameFilter ( ) { @Override public boolean accept ( File dir , String name ) { return name . endsWith ( " .csv " ) ; } } ) ; assertEquals ( " Incorrect number of CSV files " , 1 , files . length ) ; BufferedReader br = new BufferedReader ( new FileReader ( files [ 0 ] ) ) ; String line = br . readLine ( ) ; assertEquals ( " Invalid header " , " 0,zero,true,dog " , line ) ; }
public void event ( Class event , Object [ ] args ) { if ( event = = FrameEnd . class ) { displayedGraph . set ( nextGraph ( ) ) ;
private int split ( int originNode , int firstCharIndex , int lastCharIndex ) { if ( DEBUG ) System . out . printf ( " Splitting edge:  " + this + " \ n " ) ; remove ( this ) ; Edge < C > new_edge = new Edge < C > ( tree , this . firstCharIndex , this . firstCharIndex + lastCharIndex - firstCharIndex , originNode ) ; Link link = tree . suffixLinks . get ( new_edge . endNode ) ; if ( link = = null ) { link = new Link ( new_edge . endNode ) ; tree . suffixLinks . put ( new_edge . endNode , link ) ; } tree . suffixLinks . get ( new_edge . endNode ) . suffixNode = originNode ; this . firstCharIndex + = lastCharIndex - firstCharIndex + 1 ; this . startNode = new_edge . endNode ; insert ( this ) ; if ( DEBUG ) System . out . printf ( " Old edge:  " + this + " \ n " ) ; if ( DEBUG ) System . out . printf ( " New edge:  " + new_edge + " \ n " ) ; return new_edge . endNode ; }
public CompoundTerm clone ( Term [ ] replaced ) { return ( CompoundTerm ) make ( replaced ) ; }
protected void init_actions ( ) { action_obj = new CUP$parser$actions ( this ) ; }
public boolean invokeItem ( MenuItemImpl item ) { return mMenu . performItemAction ( item , 0 ) ; }
public void configureCurrentSystemTime ( long currentSystemTimeMillis ) { this . current = new BigDecimal ( currentSystemTimeMillis ) . multiply ( new BigDecimal ( 1000 * 1000 ) ) ; }
public T get ( int index ) { T t = list . get ( index ) ; if ( t ! = null ) return t ; throw new IndexOutOfBoundsException ( ) ; }
public void testReadMDNIssue97 ( ) throws Exception { final String sPrefix = " mdn/issue97 " ; final IReadableResource aHeaderRes = new ClassPathResource ( sPrefix + " .header " ) ; assertTrue ( aHeaderRes . exists ( ) ) ; final IReadableResource aPayloadRes = new ClassPathResource ( sPrefix + " .payload " ) ; assertTrue ( aPayloadRes . exists ( ) ) ; if ( false ) { final IReadableResource aCertRes = new ClassPathResource ( sPrefix + " .pem " ) ; assertTrue ( aCertRes . exists ( ) ) ; } final HttpHeaderMap aHeaders = new HttpHeaderMap ( ) ; try ( NonBlockingBufferedReader aBR = new NonBlockingBufferedReader ( aHeaderRes . getReader ( StandardCharsets . ISO_8859_1 ) ) ) { String s ; while ( ( s = aBR . readLine ( ) ) ! = null ) { final int i = s . indexOf ( ':' ) ; final String sName = s . substring ( 0 , i ) . trim ( ) ; final String sValue = s . substring ( i + 1 ) . trim ( ) ; aHeaders . addHeader ( sName , sValue ) ; } } if ( false ) assertEquals ( " <MOKOsi42435716cf621589dnode1POP000046@sfgt1.unix.fina.hr> " , aHeaders . getFirstHeaderValue ( " Message-ID " ) ) ; final AS2Message aMsg = new AS2Message ( ) ; final IMessageMDN aMDN = new AS2MessageMDN ( aMsg ) ; aMDN . headers ( ) . addAllHeaders ( aHeaders ) ; final MimeBodyPart aPart = new MimeBodyPart ( AS2HttpHelper . getAsInternetHeaders ( aMDN . headers ( ) ) , StreamHelper . getAllBytes ( aPayloadRes ) ) ; assertNotNull ( aPart ) ; aMsg . getMDN ( ) . setData ( aPart ) ; final ICryptoHelper aCryptoHelper = AS2Helper . getCryptoHelper ( ) ; assertFalse ( aCryptoHelper . isSigned ( aPart ) ) ; assertFalse ( aCryptoHelper . isEncrypted ( aPart ) ) ; assertFalse ( aCryptoHelper . isCompressed ( aPart . getContentType ( ) ) ) ; try ( final AS2ResourceHelper aResHelper = new AS2ResourceHelper ( ) ) {
Set < String > getAllPartnerNames ( ) ; @Nonnull @ReturnsMutableCopy List < ? extends IStringMap > getAllPartners ( ) ; @Nonnull IPartnerMap getPartnerMap ( ) ; void addPartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nonnull EChange removePartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nonnull Partnership getPartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nullable Partnership getPartnershipByName ( @Nullable String sName ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllPartnershipNames ( ) ; @Nonnull @ReturnsMutableCopy List < Partnership > getAllPartnerships ( ) ; @Nonnull IPartnershipMap getPartnershipMap ( ) ; void updatePartnership ( @Nonnull IMessage aMsg , boolean bOverwrite ) throws OpenAS2Exception ; void updatePartnership ( @Nonnull IMessageMDN aMdn , boolean bOverwrite ) throws OpenAS2Exception ; }
public final static float aveAri ( final float a , final float b ) { return ( a + b ) / 2f ; }
public Shape3D existsVertex ( Term e , Group g ) { Shape3D existing = objShapes . get ( e ) ; if ( existing ! = null ) { return existing ; } Cylinder s = new Cylinder ( 5 , 100 ) ; s . setRotationAxis ( Rotate . X_AXIS ) ; s . setRotate ( 90.0 ) ; g . getChildren ( ) . add ( s ) ; objShapes . put ( e , s ) ; return s ; }
public boolean checkAsyncMDN ( final AS2Message aMsg ) { try { final String sReturnMIC = aMsg . getMDN ( ) . getAttribute ( AS2MessageMDN . MDNA_MIC ) ; final String sOrigMessageID = aMsg . getMDN ( ) . getAttribute ( AS2MessageMDN . MDNA_ORIG_MESSAGEID ) ; final String sPendingInfoFile = getModule ( ) . getSession ( ) . getMessageProcessor ( ) . getAttributeAsString ( ATTR_PENDINGMDNINFO ) + " / " + IOHelper . getFilenameFromMessageID ( sOrigMessageID ) ; final NonBlockingBufferedReader aPendingInfoReader = new NonBlockingBufferedReader ( new FileReader ( sPendingInfoFile ) ) ; String sOriginalMIC ; File aPendingFile ; try { sOriginalMIC = aPendingInfoReader . readLine ( ) ; aPendingFile = new File ( aPendingInfoReader . readLine ( ) ) ; } finally { StreamHelper . close ( aPendingInfoReader ) ; } final String sDisposition = aMsg . getMDN ( ) . getAttribute ( AS2MessageMDN . MDNA_DISPOSITION ) ; s_aLogger . info ( " received MDN [ " + sDisposition + " ] " + aMsg . getLoggingText ( ) ) ; if ( sOriginalMIC = = null | | ! sReturnMIC . replaceAll ( " \\ s+ " , " " ) . equals ( sOriginalMIC . replaceAll ( " \\ s+ " , " " ) ) ) { s_aLogger . info ( " MIC IS NOT MATCHED, original mic:  " + sOriginalMIC + "  return mic:  " + sReturnMIC + aMsg . getLoggingText ( ) ) ; return false ; } s_aLogger . info ( " mic is matched, mic:  " + sReturnMIC + aMsg . getLoggingText ( ) ) ; final File aPendingInfoFile = new File ( sPendingInfoFile ) ; s_aLogger . info ( " delete pendinginfo file :  " + aPendingInfoFile . getName ( ) + "  from pending folder :  " + getModule ( ) . getSession ( ) . getMessageProcessor ( ) . getAttributeAsString ( ATTR_PENDINGMDN ) + aMsg . getLoggingText ( ) ) ; aPendingInfoFile . delete ( ) ; s_aLogger . info ( " delete pending file :  " + aPendingFile . getName ( ) + "  from pending folder :  " + aPendingFile . getParent ( ) + aMsg . getLoggingText ( ) ) ; aPendingFile . delete ( ) ; } catch ( final Exception ex ) { s_aLogger . error ( " Error checking async MDN " , ex ) ; return false ; } return true ; }
public void testServer ( ) { OperationException oe = new OperationException ( Operation . ErrorType . SERVER , " SERVER_ERROR figures " ) ; assertSame ( Operation . ErrorType . SERVER , oe . getType ( ) ) ; assertEquals ( " OperationException: SERVER: figures " , String . valueOf ( oe ) ) ; }
void log ( Level level , Object message ) ; void debug ( Object message , Throwable exception ) ; void debug ( Object message ) ; void debug ( String message , Object . . . args ) ; void info ( Object message , Throwable exception ) ; void info ( Object message ) ; void info ( String message , Object . . . args ) ; void warn ( Object message , Throwable exception ) ; void warn ( Object message ) ; void warn ( String message , Object . . . args ) ; void error ( Object message , Throwable exception ) ; void error ( Object message ) ; void error ( String message , Object . . . args ) ; void fatal ( Object message , Throwable exception ) ; void fatal ( Object message ) ; void fatal ( String message , Object . . . args ) ; }
public static synchronized FileWatcher defaultInstance ( ) { if ( DEFAULT_INSTANCE = = null | | ! DEFAULT_INSTANCE . running ) { DEFAULT_INSTANCE = new FileWatcher ( ) ; } return DEFAULT_INSTANCE ; }
boolean isWifi ( ) { final ConnectivityManager conMan = ( ConnectivityManager ) sApp . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; final NetworkInfo . State wifi = conMan . getNetworkInfo ( 1 ) . getState ( ) ; return ( wifi = = NetworkInfo . State . CONNECTED | | wifi = = NetworkInfo . State . CONNECTING ) ; }
public void testBackfill ( ) throws Exception { if ( TestConfig . isMembase ( ) ) { TapClient tc = new TapClient ( AddrUtil . getAddresses ( TestConfig . IPV4_ADDR + " :11210 " ) ) ;
public void write ( File file , boolean append ) throws IOException { new MinimalJsonWriter ( ) . writeConfig ( this , file , append ) ; }
public static void compareDiscreteContinuousBag ( String examplePath ) { System . out . print ( " DISCRETE: " ) ; perfNAL ( new DefaultNARBuilder ( ) . build ( ) , examplePath , extraCycles , repeats , warmups , true ) ; System . out . print ( " CONTINUOUS: \ t " ) ; perfNAL ( new ContinuousBagNARBuilder ( ) . build ( ) , examplePath , extraCycles , repeats , warmups , true ) ; System . out . print ( " DISCRETE: " ) ; perfNAL ( new DefaultNARBuilder ( ) . build ( ) , examplePath , extraCycles , repeats , warmups , true ) ; System . out . println ( ) ;
public void testExample1_1 ( ) { testNAL ( " nal1.1.nal " ) ; perfNAL ( " nal1.1.nal " , 0 , 25 , 1 ) ; }
public void defineList ( List < String > path , Supplier < List < ? > > defaultValueSupplier , Predicate < Object > elementValidator ) { define ( path , defaultValueSupplier , o - > { if ( ! ( o instanceof List ) ) { return false ; }
public static final long sequenceTotalUsingLoop ( int start , int length ) { long result = 0 L ; while ( length > 0 ) { result + = start + + ; length - - ; } return result ; }
public void initDynamicComponent ( @Nonnull final IAS2Session aSession , @Nullable final IStringMap aParameters ) throws OpenAS2Exception { m_aSession = ValueEnforcer . notNull ( aSession , " Session " ) ; attrs ( ) . putAllIn ( aParameters ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmPar p , A arg ) { R r = leaf ( arg ) ; r = combine ( p . stm_1 . accept ( this , arg ) , r , arg ) ; r = combine ( p . stm_2 . accept ( this , arg ) , r , arg ) ; return r ; }
boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; Enumeration < String > getAttributeNames ( ) ; Set < String > getAllAttributeNames ( ) ; Collection < String > getAllAttributeValues ( ) ; int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; Iterator < Entry < String , String > > iterator ( ) ; }
static private nars . prolog . Term convertConstantNarsTermToPrologTerm ( Term term ) { String termAsString = term . name ( ) . toString ( ) ; if ( termAsString . length ( ) = = 0 ) { throw new RuntimeException ( " term length was zero! " ) ; } if ( termAsString . charAt ( 0 ) = = '"' ) { String stringOfNarsTerm = getStringOfTerm ( term ) ; return new nars . prolog . Struct ( stringOfNarsTerm ) ; } if ( containsDot ( termAsString ) ) { double doubleValue = Double . parseDouble ( termAsString ) ;
public FlushOperation flush ( int delay , OperationCallback cb ) { return new FlushOperationImpl ( delay , cb ) ; }
public void actionPerformed ( ActionEvent event ) { solve ( ) ; }
public static final float hashFloat ( final int h ) { return ( ( float ) h ) / ( ( ( float ) Integer . MAX_VALUE ) - ( ( float ) Integer . MIN_VALUE ) ) ; }
public void onClick ( DialogInterface dialog , int whichButton ) { final String name = input . getText ( ) . toString ( ) . trim ( ) ; if ( null ! = name & & name . length ( ) > 0 ) { mApp . oMPDAsyncHelper . execAsync ( new Runnable ( ) {
public void removePropertySheetChangeListener ( PropertyChangeListener listener ) { model . removePropertyChangeListener ( listener ) ; }
public static Term sop ( final Statement s , final String operatorName ) { return Inheritance . make ( Product . make ( getMetaTerm ( s . getSubject ( ) ) , getMetaTerm ( s . getPredicate ( ) ) ) , Term . get ( operatorName ) ) ; }
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { if ( args . length < 2 ) { return null ; } if ( ( ( args . length - 2 ) % 2 ) ! = 0 ) { return null ; } if ( ! ( args [ 0 ] instanceof Term ) ) { return null ; } if ( ! ( args [ 1 ] instanceof Term ) ) { return null ; } if ( ! context . prologInterpreters . containsKey ( args [ 1 ] ) ) { return null ; } Prolog prologInterpreter = context . prologInterpreters . get ( args [ 1 ] ) ; Term queryTerm = ( Term ) args [ 0 ] ; String query = getStringOfTerm ( queryTerm ) ; String [ ] variableNames = getVariableNamesOfArgs ( args ) ; nars . prolog . Term [ ] resolvedVariableValues = prologParseAndExecuteAndDereferenceInput ( prologInterpreter , query , variableNames ) ; memory . output ( Prolog . class , query + "  | TODO " ) ; Term [ ] resultTerms = getResultVariablesFromPrologVariables ( resolvedVariableValues , args ) ; int i ; Term [ ] resultInnerProductTerms = new Term [ 2 + resultTerms . length * 2 ] ; resultInnerProductTerms [ 0 ] = args [ 0 ] ; resultInnerProductTerms [ 1 ] = args [ 1 ] ; for ( i = 0 ; i < resultTerms . length ; i + + ) { resultInnerProductTerms [ 2 + i * 2 + 0 ] = args [ 2 + i * 2 ] ; resultInnerProductTerms [ 2 + i * 2 + 1 ] = resultTerms [ i ] ; } Inheritance operatorInheritance = Operation . make ( Product . make ( resultInnerProductTerms , memory ) , this , memory ) ; Inheritance resultInheritance = Inheritance . make ( operatorInheritance , new Term ( " prolog_evaluation " ) , memory ) ; memory . output ( Task . class , resultInheritance ) ; ArrayList < Task > results = new ArrayList < > ( 1 ) ; results . add ( memory . newTask ( resultInheritance , Symbols . JUDGMENT_MARK , 1f , 0.99f , Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY ) ) ; return results ; }
protected void testNAL ( final String path ) { Memory . resetStatic ( ) ; final NAR n = newNAR ( ) ; final List < Expect > expects = new ArrayList ( ) ; String example = getExample ( path ) ; List < Expect > extractedExpects = getExpectations ( n , example , saveSimilar ) ; for ( Expect e1 : extractedExpects ) expects . add ( ( Expect ) n . addOutput ( e1 ) ) ; if ( output ) new TextOutput ( n , System . out ) ; n . addInput ( new TextInput ( example ) ) ; boolean error = false ; try { n . finish ( minCycles ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; error = true ; } catch ( Throwable e ) { error = true ; } boolean success = expects . size ( ) > 0 & & ( ! error ) ; for ( Expect e : expects ) { if ( ! e . realized ) success = false ; } if ( ( ! success ) | | ( success & & showSuccess ) ) { System . err . println ( '\n' + path + "  @ " + n . getTime ( ) ) ; for ( Expect e : expects ) { System . err . println ( "    " + e ) ; } } assertTrue ( path , success ) ;
public void testMultipleArrivingOneExistingWhereAllArrivingLaterThanExisting ( ) { p = new EventTimeHistoryPlanner ( ) ; assertNoValidationFailures ( p , config ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES , " " ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 200L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world! " , 300L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world? " , 400L ) ) ; key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 4 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " startdate " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " enddate " ) , 199L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " startdate " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " enddate " ) , 299L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 2 ) ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " startdate " ) , 300L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " enddate " ) , 399L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 3 ) ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) , " startdate " ) , 400L ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) , " enddate " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES ) ; }
IAS2Session getSession ( ) ; @Nullable String getUsage ( ) ; void setUsage ( @Nullable String usage ) ; CommandResult execute ( Object [ ] params ) ; }
private boolean addChild ( Node < T > child ) { child . parent = this ; children [ childrenSize + + ] = child ; Arrays . sort ( children , 0 , childrenSize , comparator ) ; return true ; }
public void keyPressed ( char argKeyChar , int argKeyCode ) { switch ( argKeyChar ) { case 'c' :
public void start ( ) { nar . memory . event . on ( Events . CycleStop . class , this ) ; nar . memory . event . on ( Events . ConceptRemove . class , this ) ; nar . memory . event . on ( Events . ConceptBeliefAdd . class , this ) ; nar . memory . event . on ( Events . ConceptBeliefRemove . class , this ) ; }
public void testMultipleArrivingOneExistingWhereOneArrivingSameTimeAsExistingWithSameValuesAndRestArrivingLaterThanExisting ( ) { p = new BitemporalHistoryPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , FAR_FUTURE_MILLIS , 1L , FAR_FUTURE_MILLIS , CURRENT_FLAG_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " hello " , 100L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 200L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world! " , 300L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 4 ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . UPDATE ) ; assertEquals ( planned . get ( 1 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( planned . get ( 2 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( planned . get ( 3 ) . getMutationType ( ) , MutationType . INSERT ) ; Long systemStart1 = ( Long ) RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemstart " ) ; Long systemStart2 = ( Long ) RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " systemstart " ) ; Long systemStart3 = ( Long ) RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " systemstart " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemstart " ) , 1L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " systemend " ) , RowUtils . precedingTimestamp ( systemStart1 ) ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " eventend " ) , 199L ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " eventstart " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " eventend " ) , 299L ) ; assertTrue ( systemStart2 > = preplanSystemTime ) ; assertTrue ( systemStart2 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_NO ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " value " ) , " world! " ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " eventstart " ) , 300L ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " eventend " ) , FAR_FUTURE_MILLIS ) ; assertTrue ( systemStart3 > = preplanSystemTime ) ; assertTrue ( systemStart3 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " systemend " ) , FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 3 ) . getRow ( ) , " currentflag " ) , CURRENT_FLAG_YES ) ; }
private static < T extends Comparable < T > > void merge ( int aStart , int aLength , int bStart , int bLength , T [ ] unsorted ) { int count = 0 ; T [ ] output = ( T [ ] ) new Comparable [ aLength + bLength ] ; int i = aStart ; int j = bStart ; while ( i < aStart + aLength | | j < bStart + bLength ) { T a = null ; if ( i < ( aStart + aLength ) ) { a = unsorted [ i ] ; } T b = null ; if ( j < ( bStart + bLength ) ) { b = unsorted [ j ] ; } if ( a ! = null & & b = = null ) { output [ count + + ] = a ; i + + ; } else if ( b ! = null & & a = = null ) { output [ count + + ] = b ; j + + ; } else if ( b . compareTo ( a ) < = 0 ) { output [ count + + ] = b ; j + + ; } else { output [ count + + ] = a ; i + + ; } } int x = 0 ; for ( int y = aStart ; y < ( aStart + aLength + bLength ) ; y + + ) { unsorted [ y ] = output [ x + + ] ;
protected void waitForIt ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException { sync . waitUntilTrue ( new SynchronizationObject . Predicate < Object > ( ) {
public void run ( ) { while ( running ) { if ( ! reconfiguring ) { try { handleIO ( ) ; } catch ( Exception e ) { logRunException ( e ) ; } } } getLogger ( ) . info ( " Shut down memcached client " ) ; }
public void conceptsStartPlay ( BagObserver bagObserver , String s ) { bagObserver . setBag ( concepts ) ; concepts . addBagObserver ( bagObserver , s ) ; }
public void enqueueStringMessage ( String queue , byte [ ] message ) { enqueueMessage ( queue , null , message ) ; }
public static void main ( String [ ] args ) { NAR n = new NAR ( ) ; new TextInput ( n , " <a --> b>. " ) ; new TextInput ( n , " <b --> c>. " ) ; new TextInput ( n , " <d <-> c>. %0.75;0.90% " ) ; new TextInput ( n , " <a --> c>? " ) ; n . run ( 12 ) ; new TextInput ( n , " <a --> d>? " ) ; n . run ( 12 ) ; Window w = new Window ( " GraphPanel " , new GraphPanel ( n ) ) { @Override protected void close ( ) { } } ; w . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; w . setSize ( 1200 , 900 ) ; w . setVisible ( true ) ; }
public static void run ( final String userCommand , final int i ) { run ( MPDApplication . getInstance ( ) . oMPDAsyncHelper . oMPD , userCommand , ( long ) i ) ; }
private double randWeight ( ) { return d ( - maxWeight , maxWeight ) ; }
public final static float aveGeo ( final float . . . arr ) { float product = 1 ; for ( final float f : arr ) { product * = f ; } if ( arr . length = = 2 ) { return ( float ) sqrt ( arr [ 0 ] * arr [ 1 ] ) ; } return ( float ) pow ( product , 1.00 / arr . length ) ; }
public boolean onCreateActionMode ( ActionMode mode , Menu menu ) { final MenuInflater inflater = mode . getMenuInflater ( ) ; inflater . inflate ( R . menu . mpd_queuemenu , menu ) ; return true ; }
public void trackChanged ( MPDTrackChangedEvent event ) { MPDStatus status = event . getMpdStatus ( ) ; if ( status ! = null ) {
public Output addOutput ( Output channel ) { newOutputChannels . add ( channel ) ; return channel ; }
protected String executeRequest ( HttpRequestBase request ) { StringBuilder builder = new StringBuilder ( ) ; HttpResponse response ; StatusLine statusLine ; int statusCode ; HttpEntity entity = null ; InputStream content = null ; BufferedReader reader ; String line ; try { response = client . execute ( request ) ; statusLine = response . getStatusLine ( ) ; statusCode = statusLine . getStatusCode ( ) ; entity = response . getEntity ( ) ; content = entity . getContent ( ) ; if ( statusCode = = 200 | | statusCode = = 307 | | statusCode = = 302 ) { reader = new BufferedReader ( new InputStreamReader ( content ) ) ; while ( ( line = reader . readLine ( ) ) ! = null ) { builder . append ( line ) ; } } else { Log . e ( getName ( ) , " Failed to download cover : HTTP status code :  " + statusCode ) ; } } catch ( Exception e ) { Log . e ( getName ( ) , " Failed to download cover : " + e ) ; } finally { if ( request ! = null & & ! request . isAborted ( ) ) { request . abort ( ) ; } } Log . d ( getName ( ) , " Http response :  " + builder ) ; return builder . toString ( ) ; }
public KeyStore loadKeyStore ( @Nonnull final String sFilename , @Nonnull final char [ ] aPassword ) throws Exception { final InputStream aIS = FileUtils . getInputStream ( sFilename ) ; try {
private void pushUpdate ( Context context , int [ ] appWidgetIds , RemoteViews views ) { final AppWidgetManager gm = AppWidgetManager . getInstance ( context ) ; if ( appWidgetIds ! = null ) { gm . updateAppWidget ( appWidgetIds , views ) ;
public static QueueSource queueSourceFor ( Properties props ) throws Exception { QueueSource qs = null ; String queueSourceName = props . getProperty ( " source " ) ; if ( queueSourceName . equals ( " kafka " ) ) { qs = new KafkaQueueSource ( props ) ; } else { Class < ? > clazz = Class . forName ( queueSourceName ) ; Constructor < ? > constructor = clazz . getConstructor ( ) ; qs = ( QueueSource ) constructor . newInstance ( props ) ; } return qs ; }
public void onConcept ( NARGraph g , Concept c ) { super . onConcept ( g , c ) ; priority = c . getPriority ( ) ; level = ( float ) ( priority * 100.0 ) ; if ( mode = = 0 ) { index = concepts . entryIndex ( c ) ; } else { if ( ( lastTerm ! = null ) & & ( c . term . equals ( lastTerm ) ) ) { lastTermVertex . position ( level , index , priority ) ; lastTermVertex . visible = false ; } else index + + ; } VertexDisplay d = updateVertex ( c ) ; d . position ( level , index , priority ) ; deadVertices . remove ( c ) ; if ( currentConcept ! = null ) if ( c . equals ( currentConcept ) ) d . boost = 1.0f ; levelContents + + ; lastTerm = null ; lastTermVertex = null ; }
public int get ( String key ) { if ( root = = null ) return Integer . MIN_VALUE ; Node n = root ; int length = ( key . length ( ) - 1 ) ; for ( int i = 0 ; i < = length ; i + + ) { char c = key . charAt ( i ) ; int index = n . containsChild ( c ) ; if ( index > = 0 ) { n = n . getChild ( index ) ; } else { return Integer . MIN_VALUE ; } } if ( n ! = null ) return n . value ; return Integer . MIN_VALUE ; }
public void hideCategory ( JPanel p ) { content . remove ( p ) ; validate ( ) ; repaint ( ) ; }
public NAR build ( ) { Param p = newParam ( ) ; Operator [ ] operators = DefaultOperators . get ( ) ; Memory m = new Memory ( p , newConceptProcessor ( p , getConceptBuilder ( ) ) , newNovelTaskBag ( p ) , operators ) ; for ( Operator o : ExampleOperators . get ( ) ) { m . addOperator ( o ) ; } return new NAR ( m , new Perception ( new DefaultTextPerception ( m ) ) ) ;
public void test2 ( ) throws Narsese . InvalidInputException { NAR n = new NAR ( new Plugins ( ) ) ; Map < Term , Term > h = new HashMap ( ) ; h . put ( np . parseTerm ( " $1 " ) , np . parseTerm ( " 0 " ) ) ; CompoundTerm c = ( ( CompoundTerm ) np . parseTerm ( " <(*,$1) --> num> " ) ) . applySubstituteToCompound ( h ) ; assertTrue ( c ! = null ) ; }
public void backingMap ( ) { Config config = Config . of ( LinkedHashMap : : new , InMemoryFormat . withUniversalSupport ( ) ) ; LinkedHashMap < String , String > mappings = new LinkedHashMap < > ( ) ; for ( int i = 0 ; i < 26 ; i + + ) { mappings . put ( Character . toString ( ( char ) ( 'a' + i ) ) , Character . toString ( ( char ) ( 'z' - i ) ) ) ; } for ( Entry < String , String > e : mappings . entrySet ( ) ) { config . set ( e . getKey ( ) , e . getValue ( ) ) ; } List < Entry < String , String > > input = new ArrayList < > ( mappings . entrySet ( ) ) ; List < Entry < String , Object > > output = new ArrayList < > ( config . valueMap ( ) . entrySet ( ) ) ; assertEquals ( input . size ( ) , output . size ( ) ) ; for ( int i = 0 ; i < input . size ( ) ; i + + ) { assertEquals ( input . get ( i ) , output . get ( i ) , " Map values mismatched at index:  " + i ) ;
public void setAttributes ( @Nullable final IStringMap aAttributes ) { m_aAttributes . setAttributes ( aAttributes ) ; }
CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public double proportion ( ) { return proportion ( get ( ) ) ; }
public void setFilename ( final String filename ) { getParameters ( ) . put ( PARAM_FILENAME , filename ) ; }
public void testBroadcastAfterShutdown ( ) throws Exception { client . shutdown ( ) ; try { Future < ? > f = client . flush ( ) ;
public static String getobj ( int x , int y ) { for ( GridObject gridi : space . objects ) { if ( gridi instanceof LocalGridObject ) { LocalGridObject gridu = ( LocalGridObject ) gridi ; if ( gridu . x = = x & & gridu . y = = y ) return gridu . doorname ; } } return " " ; }
public List < FilesystemTreeEntry > getDir ( String path ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; List < String > resonse = mpdConnection . sendCommand ( MPD_CMD_LSDIR , path ) ; LinkedList < String > lineCache = new LinkedList < String > ( ) ; LinkedList < FilesystemTreeEntry > result = new LinkedList < FilesystemTreeEntry > ( ) ; for ( String line : resonse ) { if ( ( line . startsWith ( " file:  " ) | | line . startsWith ( " directory:  " ) | | line . startsWith ( " playlist:  " ) ) & & lineCache . size ( ) > 0 ) { result . add ( new Music ( lineCache ) ) ; lineCache . clear ( ) ; } if ( line . startsWith ( " playlist:  " ) ) { } else if ( line . startsWith ( " directory:  " ) ) { line = line . substring ( " directory:  " . length ( ) ) ; result . add ( rootDirectory . makeDirectory ( line ) ) ; } else if ( line . startsWith ( " file:  " ) ) { lineCache . add ( line ) ; } } if ( lineCache . size ( ) > 0 ) { result . add ( new Music ( lineCache ) ) ; } return result ; }
public static DecoratedCausalGraph convert ( InputGraph input ) { DecoratedCausalGraph resultGraph ; int [ ] numberOfInputEdges ; int [ ] numberOfOutputEdges ; int nodeIndex ; int [ ] incommingEdgesIndices ; int [ ] outgoingEdgesIndices ; numberOfInputEdges = new int [ input . numberOfNodes ] ; numberOfOutputEdges = new int [ input . numberOfNodes ] ; resultGraph = new DecoratedCausalGraph ( ) ; resultGraph . nodes = createNodes ( input . numberOfNodes ) ; for ( InputGraph . Connection iterationConnection : input . connections ) { numberOfOutputEdges [ iterationConnection . sourceIndex ] + + ; numberOfInputEdges [ iterationConnection . destinationIndex ] + + ; } nodeIndex = 0 ; for ( DecoratedCausalGraph . Node iterationNode : resultGraph . nodes ) { iterationNode . incommingEdgeElementIndices = new int [ numberOfInputEdges [ nodeIndex ] ] ; iterationNode . outgoingEdgeElementIndices = new int [ numberOfOutputEdges [ nodeIndex ] ] ; nodeIndex + + ; } incommingEdgesIndices = new int [ input . numberOfNodes ] ; outgoingEdgesIndices = new int [ input . numberOfNodes ] ; for ( InputGraph . Connection iterationConnection : input . connections ) { int incommingArrayIndex ; int outgoingArrayIndex ; incommingArrayIndex = incommingEdgesIndices [ iterationConnection . destinationIndex ] ; outgoingArrayIndex = outgoingEdgesIndices [ iterationConnection . sourceIndex ] ; resultGraph . nodes . get ( iterationConnection . destinationIndex ) . incommingEdgeElementIndices [ incommingArrayIndex ] = iterationConnection . sourceIndex ; resultGraph . nodes . get ( iterationConnection . sourceIndex ) . outgoingEdgeElementIndices [ outgoingArrayIndex ] = iterationConnection . destinationIndex ; incommingEdgesIndices [ iterationConnection . destinationIndex ] + + ; outgoingEdgesIndices [ iterationConnection . sourceIndex ] + + ; } return resultGraph ; }
public void putAll ( Map < ? extends K , ? extends V > m ) { map . putAll ( m ) ; callback . run ( ) ; }
protected float calcAngletoValue ( float a ) { if ( a < startAng ) a + = 360 ; float v = ( a - startAng ) / ( endAng - startAng ) ; return v ; }
public boolean equals ( final Object that ) { if ( that instanceof Sentence ) { final Sentence t = ( Sentence ) that ; return content . equals ( t . content ) & & punctuation = = t . punctuation & & truth . equals ( t . truth ) & & stamp . equals ( t . stamp ) ; } return false ; }
public void event ( Class event , Object [ ] args ) { long time = nar . time ( ) ; if ( event = = CycleEnd . class ) { if ( time % cyclesPerTrain = = 0 ) {
public void clicked ( int x , int y , Grid2DSpace space ) { if ( ( int ) x = = 0 | | ( int ) y = = 0 | | ( int ) x = = w - 1 | | ( int ) y = = h - 1 ) return ; if ( oper . equals ( " perceive " ) ) { readCells [ ( int ) x ] [ ( int ) y ] . name = " place " + entityID . toString ( ) ; writeCells [ ( int ) x ] [ ( int ) y ] . name = " place " + entityID . toString ( ) ; entityID + + ; return ; } if ( ! " " . equals ( oper ) ) { if ( ! " " . equals ( readCells [ x ] [ y ] . name ) & & ! " pick " . equals ( oper ) ) { nar . addInput ( " (^ " + oper + " , " + readCells [ x ] [ y ] . name + " ). :|: " ) ; nar . step ( 1 ) ; TestChamber . operateObj ( readCells [ x ] [ y ] . name , oper ) ; } String s = TestChamber . getobj ( x , y ) ; if ( ! s . equals ( " " ) ) { nar . addInput ( " (^ " + oper + " , " + s + " ). :|: " ) ; nar . step ( 1 ) ; TestChamber . operateObj ( s , oper ) ; } return ; } if ( ! " " . equals ( wish ) ) { if ( ! " " . equals ( readCells [ x ] [ y ] . name ) ) { nar . addInput ( " <(*,Self, " + readCells [ x ] [ y ] . name + " ) -->  " + wish + " >! " ) ; nar . step ( 1 ) ; } String s = TestChamber . getobj ( x , y ) ; if ( ! s . equals ( " " ) ) { nar . addInput ( " <(*,Self, " + s + " ) -->  " + wish + " >! " ) ; nar . step ( 1 ) ; } return ; } if ( ! " " . equals ( doorname ) & & selected . material = = Material . Door ) { space . add ( new Key ( ( int ) x , ( int ) y , doorname . replace ( " door " , " key " ) ) ) ; nar . addInput ( " < " + doorname . replace ( " door " , " key " ) + "  --> key>. " ) ; doorname = " " ; return ; } if ( ! ( selected . material = = Material . Door ) ) doorname = " " ; readCells [ ( int ) x ] [ ( int ) y ] . charge = selected . charge ; writeCells [ ( int ) x ] [ ( int ) y ] . charge = selected . charge ; readCells [ ( int ) x ] [ ( int ) y ] . logic = selected . logic ; writeCells [ ( int ) x ] [ ( int ) y ] . logic = selected . logic ; readCells [ ( int ) x ] [ ( int ) y ] . material = selected . material ; writeCells [ ( int ) x ] [ ( int ) y ] . material = selected . material ; readCells [ ( int ) x ] [ ( int ) y ] . machine = selected . machine ; writeCells [ ( int ) x ] [ ( int ) y ] . machine = selected . machine ; if ( selected . material = = Material . Door | | selected . logic = = Logic . OFFSWITCH | | selected . logic = = Logic . SWITCH ) {
protected static final < O extends Object > Interval < O > createFromList ( List < IntervalData < O > > intervals ) { Interval < O > newInterval = new Interval < O > ( ) ; int half = intervals . size ( ) / 2 ; IntervalData < O > middle = intervals . get ( half ) ; newInterval . center = ( ( middle . start + middle . end ) / 2 ) ; List < IntervalData < O > > leftIntervals = new ArrayList < IntervalData < O > > ( ) ; List < IntervalData < O > > rightIntervals = new ArrayList < IntervalData < O > > ( ) ; for ( IntervalData < O > interval : intervals ) { if ( interval . end < newInterval . center ) { leftIntervals . add ( interval ) ; } else if ( interval . start > newInterval . center ) { rightIntervals . add ( interval ) ; } else { newInterval . overlap . add ( interval ) ; } } if ( leftIntervals . size ( ) > 0 ) newInterval . left = createFromList ( leftIntervals ) ; if ( rightIntervals . size ( ) > 0 ) newInterval . right = createFromList ( rightIntervals ) ; return newInterval ; }
protected void become ( String s , Object [ ] args ) { if ( ! state . equals ( " end " ) ) { state = s ;
public void addWatch ( Path file , Runnable changeHandler ) throws IOException { file = file . toAbsolutePath ( ) ; Path dir = file . getParent ( ) ; WatchedDir watchedDir = watchedDirs . computeIfAbsent ( dir , k - > new WatchedDir ( dir ) ) ; WatchKey watchKey = dir . register ( watchedDir . watchService , StandardWatchEventKinds . ENTRY_MODIFY ) ; watchedFiles . computeIfAbsent ( file , k - > new WatchedFile ( watchedDir , watchKey , changeHandler ) ) ;
StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }
public double [ ] normalizedInstance ( Instance inst ) { double [ ] normalizedInstance = new double [ inst . numAttributes ( ) ] ; for ( int j = 0 ; j < inst . numAttributes ( ) - 1 ; j + + ) { int instAttIndex = modelAttIndexToInstanceAttIndex ( j , inst ) ; double mean = perceptronattributeStatistics . getValue ( j ) / perceptronYSeen ; double sd = computeSD ( squaredperceptronattributeStatistics . getValue ( j ) , perceptronattributeStatistics . getValue ( j ) , perceptronYSeen ) ; if ( sd > SD_THRESHOLD ) normalizedInstance [ j ] = ( inst . value ( instAttIndex ) - mean ) / sd ; else normalizedInstance [ j ] = inst . value ( instAttIndex ) - mean ; } return normalizedInstance ; }
public void updateFromItems ( ) { if ( items ! = null ) {
public T next ( ) { if ( queue . firstIndex + index < queue . lastIndex ) { last = queue . firstIndex + index ; return queue . array [ ( queue . firstIndex + index + + ) % queue . array . length ] ; } return null ; }
public String toString ( ) { return ToStringGenerator . getDerived ( super . toString ( ) ) . append ( " message " , m_aMessage )
public void onPulled ( float percentagePulled ) { } public void onRefreshStarted ( ) { } public void onReleaseToRefresh ( ) { } public void onRefreshMinimized ( ) { } public abstract boolean showHeaderView ( ) ; public abstract boolean hideHeaderView ( ) ; public void onConfigurationChanged ( Activity activity , Configuration newConfig ) { } }
public abstract void unregisterService ( ServiceInfo info ) ; public abstract void unregisterAllServices ( ) ; public abstract void registerServiceType ( String type ) ; public abstract ServiceInfo [ ] list ( String type ) ; public abstract ServiceInfo [ ] list ( String type , long timeout ) ; public abstract Map < String , ServiceInfo [ ] > listBySubtype ( String type ) ; public abstract Map < String , ServiceInfo [ ] > listBySubtype ( String type , long timeout ) ; public abstract void addNetworkTopologyListener ( NetworkTopologyListener listener ) ; public abstract void removeNetworkTopologyListener ( NetworkTopologyListener listener ) ; public abstract NetworkTopologyListener [ ] networkListeners ( ) ; }
static CommentedConfig concurrentCopy ( UnmodifiableCommentedConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleCommentedConfig ( config , format , true ) ; }
public long estimatedRemainingInstances ( ) { double progressFraction = this . fileProgressMonitor . getProgressFraction ( ) ; if ( ( progressFraction > 0.0 ) & & ( this . numInstancesRead > 0 ) ) { return ( long ) ( ( this . numInstancesRead / progressFraction ) - this . numInstancesRead ) ; } return - 1 ; }
public String toString ( ) { StringBuilder s = new StringBuilder ( ) ; s . append ( content . toString ( ) ) ; s . append ( punctuation + "   " ) ; if ( truth ! = null ) { s . append ( truth . toString ( ) ) ; } s . append ( stamp . toString ( ) ) ; return s . toString ( ) ; }
public boolean isHowQuestionGenerationOnDecisionMaking ( ) { return Parameters . HOW_QUESTION_GENERATION_ON_DECISION_MAKING ; }
public View onLayoutInflation ( Context context , View targetView , List < ? extends Item > items ) { targetView . findViewById ( R . id . track_artist ) . setVisibility ( showArtist ? View . VISIBLE : View . GONE ) ; return targetView ; }
public void onConceptNew ( Concept concept ) { ConceptCreation cc = new ConceptCreation ( concept , t ) ; List < InferenceEvent > lc = new ArrayList ( 1 ) ; lc . add ( cc ) ; this . concept . put ( concept , lc ) ; addEvent ( cc ) ; }
private void jButton9ActionPerformed ( java . awt . event . ActionEvent evt ) { jButton9 . setText ( " X " ) ; }
public static void printCSVLine ( PrintStream out , List < String > o ) { StringJoiner line = new StringJoiner ( " ,  " , " " , " " ) ; for ( String x : o ) line . add ( x ) ; out . println ( line . toString ( ) ) ; }
public List < Music > search ( final String [ ] args ) throws IOException , MPDException { return genericSearch ( MPDCommand . MPD_CMD_SEARCH , args , true ) ; }
public String toString ( ) { String result ; result = " transition on  " + on_symbol ( ) . name ( ) + "  to state [ " ; result + = _to_state . index ( ) ; result + = " ] " ; return result ; }
public void setText ( final String string ) { m_sText = string ; }
public T get ( long l , TimeUnit tu ) throws InterruptedException , ExecutionException , TimeoutException { return content ; }
void add ( List < String > path , Object value ) ; default void add ( String path , Object value ) { add ( split ( path , '.' ) , value ) ; } default void putAll ( UnmodifiableConfig config ) { valueMap ( ) . putAll ( config . valueMap ( ) ) ; } default < T > T remove ( String path ) { return remove ( split ( path , '.' ) ) ; } < T > T remove ( List < String > path ) ; void clear ( ) ; default UnmodifiableConfig unmodifiable ( ) { return new UnmodifiableConfig ( ) { @Override public < T > T get ( List < String > path ) { return Config . this . get ( path ) ; } @Override public boolean contains ( List < String > path ) { return Config . this . contains ( path ) ; } @Override public int size ( ) { return Config . this . size ( ) ; } @Override public Map < String , Object > valueMap ( ) { return Collections . unmodifiableMap ( Config . this . valueMap ( ) ) ; } @Override public Set < ? extends Entry > entrySet ( ) { return Config . this . entrySet ( ) ; } @Override public ConfigFormat < ? , ? , ? > configFormat ( ) { return Config . this . configFormat ( ) ; } } ; } default Config checked ( ) { return new CheckedConfig ( this ) ; } Map < String , Object > valueMap ( ) ; @Override Set < ? extends Entry > entrySet ( ) ; interface Entry extends UnmodifiableConfig . Entry { < T > T setValue ( Object value ) ; } static Config of ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format ) ; } static Config inMemory ( ) { return new SimpleConfig ( InMemoryFormat . defaultInstance ( ) ) ; } static Config wrap ( Map < String , Object > map , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( map , format ) ; } static Config copy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) ) ; } static Config copy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( config , format ) ; } }
public void testAveragePriority ( int capacity ) { final float priorityEpsilon = 0.1f ; ContinuousBag < NullItem , CharSequence > c = new ContinuousBag ( capacity , false ) ; LevelBag < NullItem , CharSequence > d = new LevelBag < NullItem , CharSequence > ( capacity , 10 ) ; assertEquals ( c . getMass ( ) , d . getMass ( ) , 0 ) ; assertEquals ( c . getAveragePriority ( ) , d . getAveragePriority ( ) , 0 ) ; c . putIn ( new NullItem ( .25f ) ) ; d . putIn ( new NullItem ( .25f ) ) ; assertTrue ( c . getMass ( ) ! = d . getMass ( ) ) ; assertEquals ( c . getAveragePriority ( ) , d . getAveragePriority ( ) , priorityEpsilon ) ; c . clear ( ) ; d . clear ( ) ; assert ( c . getAveragePriority ( ) = = 0.01f ) ; assert ( d . getAveragePriority ( ) = = 0.01f ) ; c . putIn ( new NullItem ( .25f ) ) ; d . putIn ( new NullItem ( .25f ) ) ; c . putIn ( new NullItem ( .87f ) ) ; d . putIn ( new NullItem ( .87f ) ) ; assertEquals ( c . getAveragePriority ( ) , d . getAveragePriority ( ) , priorityEpsilon ) ;
public static final String reverseWordsWithAdditionalStorage ( String string ) { StringBuilder builder = new StringBuilder ( ) ; char c ; int last = string . length ( ) ; int length = string . length ( ) - 1 ; StringBuilder temp = new StringBuilder ( ) ; for ( int i = length ; i > = 0 ; i - - ) { c = string . charAt ( i ) ; if ( c = = SPACE | | i = = 0 ) { int index = ( i = = 0 ) ? 0 : i + 1 ; temp . append ( string . substring ( index , last ) ) ; if ( index ! = 0 ) temp . append ( c ) ; builder . append ( temp ) ; temp . delete ( 0 , temp . length ( ) ) ; last = i ; } } return builder . toString ( ) ; }
public void switchBackground ( ) { } public void resetBackground ( ) { } public static class NullInferenceRecorder implements InferenceRecorder { @Override public boolean isActive ( ) { return false ; } @Override public void init ( ) { } @Override public void show ( ) { } @Override public void play ( ) { } @Override public void stop ( ) { } @Override public void append ( String s ) { } @Override public void openLogFile ( ) { } @Override public void closeLogFile ( ) { } @Override public boolean isLogging ( ) { return false ; } } }
public void startAnnouncer ( ) { DNSTaskStarter . Factory . getInstance ( ) . getStarter ( this . getDns ( ) ) . startAnnouncer ( ) ; }
public com . cloudera . labs . envelope . translate . ProtobufSingleMessage . SingleExample . NestedExampleOrBuilder getRepeatingMessageOrBuilder ( int index ) { if ( repeatingMessageBuilder_ = = null ) { return repeatingMessage_ . get ( index ) ; } else {
void setAttribute ( @Nonnull String sKey , @Nullable String sValue ) ; void setAttributes ( @Nullable IStringMap aAttributes ) ; @Nullable String getHeader ( @Nonnull String sKey ) ; @Nullable String getHeader ( @Nonnull String sKey , @Nullable String sDelimiter ) ; @Nonnull @ReturnsMutableObject ( " design " ) InternetHeaders getHeaders ( ) ; @Nonnull @Nonempty String getHeadersDebugFormatted ( ) ; void setHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void addHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void setHeaders ( @Nullable InternetHeaders aHeaders ) ; @Nullable String getMessageID ( ) ; void setMessageID ( @Nullable String sMessageID ) ; @Nonnull String generateMessageID ( ) ; void updateMessageID ( ) ; @Nonnull @ReturnsMutableObject ( " Design " ) Partnership getPartnership ( ) ; void setPartnership ( @Nonnull Partnership aPartnership ) ; }
protected void stopEngine ( ) { consoleManager . stopEngine ( ) ; enableSolutionCommands ( false ) ; enableStopButton ( false ) ; setStatusMessage ( " Ready. " ) ; }
public List < Album > getAlbums ( Artist artist , boolean trackCountNeeded ) throws MPDServerException { return getAlbums ( artist , trackCountNeeded , useAlbumArtist ) ; }
public void render ( Graphics g ) { if ( ! okToRender ) return ; boolean changed = firstTime ; float c = ( float ) 128 / 255 ; bgcolor = isVectors ? Color . white : new Color ( c , c , c ) ; if ( firstTime ) { firstTime = false ; createKeyMaps ( ) ; nVertices = vertexVector . size ( ) / 3 ; vertexArray = new double [ nVertices ] [ 3 ] ; for ( int v = 0 ; v < nVertices ; v + + ) for ( int j = 0 ; j < 3 ; j + + ) vertexArray [ v ] [ j ] = ( ( Double ) vertexVector . elementAt ( 3 * v + j ) ) . doubleValue ( ) ; nShapes = shapesVector . size ( ) ; shape = new int [ nShapes ] [ ] [ ] ; for ( int i = 0 ; i < nShapes ; i + + ) { shapeVector = shapes ( i ) ; shape [ i ] = new int [ shapeVector . size ( ) ] [ ] ; for ( int j = 0 ; j < shape [ i ] . length ; j + + ) { face = ( Vector ) shapeVector . elementAt ( j ) ; shape [ i ] [ j ] = new int [ face . size ( ) ] ; for ( int k = 0 ; k < shape [ i ] [ j ] . length ; k + + ) shape [ i ] [ j ] [ k ] = ( ( Integer ) face . elementAt ( k ) ) . intValue ( ) ; } } nFlexes = flexVector . size ( ) ; flexData = new double [ nFlexes ] [ ] [ ] ; flexShape = new int [ nFlexes ] [ ] ; flexSymmetry = new int [ nFlexes ] ; flexTarget = new double [ 2 ] [ nFlexes ] ; flexValue = new double [ 2 ] [ nFlexes ] ; flexSettle = new double [ nFlexes ] ; for ( int f = 0 ; f < nFlexes ; f + + ) { flx = ( Vector ) flexVector . elementAt ( f ) ; flexData [ f ] = new double [ flx . size ( ) ] [ ] ; flexShape [ f ] = new int [ flx . size ( ) ] ; flexSymmetry [ f ] = ( ( Integer ) flexSymmetryVector . elementAt ( f ) ) . intValue ( ) ; for ( int j = 0 ; j < flexShape [ f ] . length ; j + + ) { ixyz = ( Vector ) flx . elementAt ( j ) ; flexShape [ f ] [ j ] = ( ( Integer ) ixyz . elementAt ( 0 ) ) . intValue ( ) ; flexData [ f ] [ j ] = new double [ 3 ] ; for ( int k = 1 ; k < ixyz . size ( ) ; k + + ) flexData [ f ] [ j ] [ k - 1 ] = ( ( Double ) ixyz . elementAt ( k ) ) . doubleValue ( ) ; } flexSettle [ f ] = ( ( Double ) flexSettleVector . elementAt ( f ) ) . doubleValue ( ) ; } flexTarget [ 0 ] [ 3 ] = flexTarget [ 1 ] [ 3 ] = - 1 ; double [ ] jtrAmpl = { .08 , .04 , 0 , 0 , 0 , .1 , .07 , .07 , .15 } ; double [ ] jtrFreq = { .25 , .25 , 0 , 0 , 0 , .5 , .5 , .5 , .5 } ; jitterAmpl = new double [ nFlexes ] ; jitterFreq = new double [ nFlexes ] ; for ( int f = 0 ; f < jtrAmpl . length & & f < nFlexes ; f + + ) { jitterAmpl [ f ] = jtrAmpl [ f ] ; jitterFreq [ f ] = jtrFreq [ f ] ; } pts = new double [ 2 ] [ nVertices ] [ 3 ] ; } int nFlexes = flexValue [ 0 ] . length ; double move_p = 0.95 ; long currTime = System . currentTimeMillis ( ) ; double secdiff = ( currTime - lastTime ) / 1000.0 ; lastTime = currTime ; double uipf , move_inc ; for ( int s = 0 ; s < 2 ; s + + ) for ( int f = 0 ; f < nFlexes ; f + + ) { uipf = secdiff / flexSettle [ f ] ; move_inc = 1.0 - Math . pow ( ( 1.0 - move_p ) , uipf ) ; flexValue [ s ] [ f ] + = move_inc * ( flexTarget [ s ] [ f ] - flexValue [ s ] [ f ] ) ; if ( addNoise & & jitterAmpl [ f ] ! = 0 ) flexValue [ s ] [ f ] + = jitterAmpl [ f ] * ImprovMath . noise ( jitterFreq [ f ] * t + 10 * f ) ; t + = .005 ; } blinkValue = pulse ( t / 2 + ImprovMath . noise ( t / 1.5 ) + .5 * ImprovMath . noise ( t / 3 ) , .05 ) ; doRender ( g , flexValue , blinkValue , isVectors , doShade , shiftAxis ) ;
public void run ( ) { try { int songId = - 1 ;
protected void resizeRenderer ( int newWidth , int newHeight ) { if ( ( newWidth > 0 ) & & ( newHeight > 0 ) ) { super . resizeRenderer ( newWidth , newHeight ) ;
public void readWriteReadAgain ( ) { File file = new File ( " test.toml " ) ; CommentedConfig parsed = new TomlParser ( ) . parse ( file , FileNotFoundAction . THROW_ERROR ) ; System . out . println ( " --- parsed ---  \ n " + parsed ) ; System . out . println ( " -------------------------------------------- " ) ; assertNull ( parsed . getComment ( " without_comment " ) ) ; assertNotNull ( parsed . getComment ( " with_comments " ) ) ; assertTrue ( parsed . getComment ( " with_comments " ) . contains ( " \ n " ) ) ; java . io . StringWriter sw = new StringWriter ( ) ; TomlWriter writer = new TomlWriter ( ) ; writer . write ( parsed , sw ) ; System . out . println ( " --- written ---  \ n " + sw ) ; System . out . println ( " -------------------------------------------- " ) ; CommentedConfig reparsed = new TomlParser ( ) . parse ( new StringReader ( sw . toString ( ) ) ) ; System . out . println ( " --- reparsed ---  \ n " + reparsed ) ; assertEquals ( parsed , reparsed ) ; }
public < T > OperationFuture < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) { return asyncCAS ( key , casId , 0 , value , tc ) ; }
public void readInputFormatMissingTranslator ( ) { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( FileSystemInput . FORMAT_CONFIG , " input-format " ) ; paramMap . put ( FileSystemInput . PATH_CONFIG , FileSystemInput . class . getResource ( CSV_DATA ) . getPath ( ) ) ; paramMap . put ( FileSystemInput . INPUT_FORMAT_TYPE_CONFIG , TextInputFormat . class . getCanonicalName ( ) ) ; config = ConfigFactory . parseMap ( paramMap ) ; FileSystemInput formatInput = new FileSystemInput ( ) ; assertValidationFailures ( formatInput , config ) ; }
public int hashCode ( ) { int hashCode = 1 ; synchronized ( LOCK ) { for ( final Iterator < ? > itr = this . iterator ( ) ; itr . hasNext ( ) ; ) { final Object obj = itr . next ( ) ; hashCode = 31 * hashCode + ( obj = = null ? 0 : obj . hashCode ( ) ) ; } } return hashCode ; }
public Builder setRepeatingEnumValue ( int index , int value ) { ensureRepeatingEnumIsMutable ( ) ; repeatingEnum_ . set ( index , value ) ; onChanged ( ) ; return this ; }
public abstract INetModuleHandler createHandler ( ) ; public void handleError ( @Nonnull final IMessage aMsg , @Nonnull final OpenAS2Exception aSrcEx ) { if ( LOGGER . isTraceEnabled ( ) ) LOGGER . trace ( " Handling error in  " + ClassHelper . getClassLocalName ( this . getClass ( ) ) + "  for message with ID  " + aMsg . getMessageID ( ) + "  and exception  " + ClassHelper . getClassLocalName ( aSrcEx . getClass ( ) ) + "  with error  " + aSrcEx . getMessage ( ) ) ; aSrcEx . setSourceMsg ( aMsg ) . terminate ( ) ; try { final CompositeParameters aParams = new CompositeParameters ( false ) . add ( " date " , new DateParameters ( ) ) . add ( " msg " , new MessageParameters ( aMsg ) ) ; final String sErrorFilename = aParams . format ( attrs ( ) . getAsString ( ATTR_ERROR_FORMAT , DEFAULT_ERROR_FORMAT ) ) ; final String sErrorDirectory = aParams . format ( attrs ( ) . getAsString ( ATTR_ERROR_DIRECTORY ) ) ; if ( StringHelper . hasText ( sErrorDirectory ) ) { final File aMsgErrorFile = AS2IOHelper . getUniqueFile ( AS2IOHelper . getDirectoryFile ( sErrorDirectory ) , FilenameHelper . getAsSecureValidFilename ( sErrorFilename ) ) ; final boolean bStoreBody = attrs ( ) . getAsBoolean ( ATTR_ERROR_STORE_BODY , false ) ; try ( final OutputStream aFOS = FileHelper . getOutputStream ( aMsgErrorFile ) ) { final String sMsgText = aMsg . getAsString ( ) ; aFOS . write ( sMsgText . getBytes ( ) ) ; if ( bStoreBody ) StreamHelper . copyInputStreamToOutputStream ( aMsg . getData ( ) . getInputStream ( ) , aFOS ) ; } new InvalidMessageException ( " Stored invalid message to  " + aMsgErrorFile . getAbsolutePath ( ) ) . terminate ( ) ; } else { LOGGER . warn ( " No error directory present, so ignoring the error " ) ; } } catch ( final Exception ex ) { WrappedOpenAS2Exception . wrap ( ex ) . setSourceMsg ( aMsg ) . terminate ( ) ; } } protected static final class ConnectionThread extends Thread { private final AbstractActiveNetModule m_aOwner ; private final Socket m_aSocket ; public ConnectionThread ( @Nonnull final AbstractActiveNetModule aOwner , @Nonnull @WillClose final Socket aSocket ) { super ( " AS2ConnectionThread- " + ClassHelper . getClassLocalName ( aOwner ) ) ; m_aOwner = aOwner ; m_aSocket = aSocket ; } @Override public void run ( ) { LOGGER . info ( " AS2ConnectionThread: run " ) ; m_aOwner . createHandler ( ) . handle ( m_aOwner , m_aSocket ) ; try { m_aSocket . close ( ) ; } catch ( final IOException ex ) { WrappedOpenAS2Exception . wrap ( ex ) . terminate ( ) ; } finally { LOGGER . info ( " AS2ConnectionThread: done running " ) ; } } } protected static class MainThread extends Thread { private final AbstractActiveNetModule m_aOwner ; private final ServerSocket m_aServerSocket ; private volatile boolean m_bTerminated ; public MainThread ( @Nonnull final AbstractActiveNetModule aOwner , @Nullable final String sAddress , @Nonnegative final int nPort ) throws IOException { super ( " AS2MainThread- " + ClassHelper . getClassLocalName ( aOwner ) ) ; m_aOwner = aOwner ; m_aServerSocket = new ServerSocket ( ) ; final InetSocketAddress aAddr = sAddress = = null ? new InetSocketAddress ( nPort ) : new InetSocketAddress ( sAddress , nPort ) ; m_aServerSocket . bind ( aAddr ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " Inited  " + getName ( ) + "  at  " + aAddr ) ; } @OverrideOnDemand protected Socket createAcceptSocket ( ) throws IOException { final Socket aSocket = m_aServerSocket . accept ( ) ; aSocket . setSoLinger ( true , 60 ) ; return aSocket ; } @Override public void run ( ) { LOGGER . info ( " AS2MainThread: run " ) ; while ( ! m_bTerminated & & ! isInterrupted ( ) ) { try { final Socket aSocket = createAcceptSocket ( ) ; new ConnectionThread ( m_aOwner , aSocket ) . start ( ) ; } catch ( final Exception ex ) { if ( ! m_bTerminated ) m_aOwner . forceStop ( ex ) ; } } LOGGER . info ( " AS2MainThread: done running " ) ; } public void terminate ( ) { if ( ! m_bTerminated ) { m_bTerminated = true ; if ( m_aServerSocket ! = null ) try { m_aServerSocket . close ( ) ; } catch ( final IOException ex ) { m_aOwner . forceStop ( ex ) ; } } } } }
public static int angle ( int targetAngle ) { while ( targetAngle > 180 ) targetAngle - = 360 ; while ( targetAngle < = - 180 ) targetAngle + = 360 ; return targetAngle ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmLit p , A arg ) { p . literal_ . accept ( new LiteralVisitor < R , A > ( ) , arg ) ; return null ; }
public boolean equals ( final Object that ) { if ( that instanceof Sentence ) { final Sentence t = ( Sentence ) that ; return content . equals ( t . content ) & & punctuation = = t . punctuation & & truth . equals ( t . truth ) & & getStamp ( ) . equals ( t . getStamp ( ) ) ; } return false ; }
void configureFieldNames ( List < String > fieldNames ) ; void configureCurrentSystemTime ( long currentSystemTimeMillis ) ; StructType getSchema ( ) ; Row setFarFutureTime ( Row row ) ; Row setCurrentSystemTime ( Row row ) ; Row setPrecedingSystemTime ( Row row ) ; Row getTime ( Row row ) ; Row getPrecedingTime ( Row row ) ; Row appendFields ( Row row ) ; }
public void transformTask ( Task task , TaskLink tLink ) { CompoundTerm content = ( CompoundTerm ) task . getContent ( ) . clone ( ) ; short [ ] indices = tLink . getIndices ( ) ; Term inh = null ; if ( indices . length = = 2 ) { inh = content ; } else if ( indices . length = = 3 ) { if ( ( content instanceof Implication ) & & ( content . componentAt ( 0 ) instanceof Conjunction ) ) inh = ( ( CompoundTerm ) content . componentAt ( 0 ) ) . componentAt ( indices [ 0 ] ) ; else inh = content . componentAt ( indices [ 0 ] ) ; } if ( inh instanceof Inheritance ) structuralrules . transformProductImage ( ( Inheritance ) inh , content , indices , task ) ;
public void onTaskRemove ( Task task , String reason ) { append ( " Task Remove " , reason + " :  " + task ) ; }
public T previous ( ) { if ( index > = 0 ) return list . array [ index - - ] ; return null ; }
private boolean isDragItem ( View item ) { return ( mDraggingEnabled & & item . findViewById ( R . id . icon ) ! = null ) ; }
private void loadServerStreams ( ) { HttpURLConnection connection = null ; try { SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( getActivity ( ) ) ;
private void applyViewVisibility ( SharedPreferences sharedPreferences , View view , String property ) { if ( view = = null ) { return ; } view . setVisibility ( sharedPreferences . getBoolean ( property , false ) ? View . VISIBLE : View . GONE ) ; }
private static void addEntry ( JarOutputStream jo , File file , String baseDir , String rootDir ) { try { BufferedInputStream bi = new BufferedInputStream ( new FileInputStream ( file ) ) ;
public boolean onCreateOptionsMenu ( Menu menu ) { boolean result = super . onCreateOptionsMenu ( menu ) ; menu . add ( 0 , MAIN , 0 , R . string . mainMenu ) . setIcon ( android . R . drawable . ic_menu_revert ) ; menu . add ( 0 , CLEAR , 1 , R . string . clear ) . setIcon ( android . R . drawable . ic_menu_close_clear_cancel ) ; menu . add ( 0 , REMOVE , 2 , R . string . removeSong ) . setIcon ( android . R . drawable . ic_menu_delete ) ; return result ; }
Collection < Operation > destroyInputQueue ( ) ; void setupResend ( ) ; void fillWriteBuffer ( boolean optimizeGets ) ; void transitionWriteItem ( ) ; Operation getCurrentReadOp ( ) ; Operation removeCurrentReadOp ( ) ; Operation getCurrentWriteOp ( ) ; Operation removeCurrentWriteOp ( ) ; boolean hasReadOp ( ) ; boolean hasWriteOp ( ) ; void addOp ( Operation op ) ; void insertOp ( Operation o ) ; int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; }
public static void main ( String [ ] args ) throws SocketException , UnknownHostException , IOException , InterruptedException , InstantiationException , InvocationTargetException , ParserConfigurationException , NoSuchMethodException , SAXException , ClassNotFoundException , IllegalAccessException , ParseException { if ( ( args . length - 3 ) % 5 ! = 0 ) { System . out . println ( " expected arguments: file cycles listenPort targetIP1 targetPort1 prioThres1 mustContainTerm1 sendInput1 ... targetIPN targetPortN prioThresN mustContainTermN sendInputN " ) ; System . exit ( 0 ) ; } int nar1port = Integer . parseInt ( args [ 2 ] ) ; log ( " creating Reasoner... " ) ; Nar nar = new Nar ( ) ; log ( " creating NarNode... " ) ; NarNode nar1 = new NarNode ( nar , nar1port ) ; List < TargetNar > redirections = new ArrayList < TargetNar > ( ) ; for ( int i = 3 ; i < args . length ; i + = 5 ) { Term T = args [ i + 3 ] . equals ( " null " ) ? null : new Term ( args [ i + 3 ] ) ; redirections . add ( new TargetNar ( args [ i ] , Integer . parseInt ( args [ i + 1 ] ) , Float . parseFloat ( args [ i + 2 ] ) , T , Boolean . parseBoolean ( args [ i + 4 ] ) ) ) ; } for ( TargetNar target : redirections ) { nar1 . addRedirectionTo ( target ) ; } log ( " running Shell... " ) ; new Shell ( nar1 . nar ) . run ( new String [ ] { args [ 0 ] , args [ 1 ] } ) ; }
void handleRead ( ByteBuffer data ) ; void handleLine ( String line ) ; }
public void testRemovalDistribution ( int capacity , boolean random ) { int samples = 128 * capacity ; int count [ ] = new int [ capacity ] ; SortedIndex < NullItem > items = new ArraySortedIndex < > ( ) ; CurveBag < NullItem , CharSequence > f = new CurveBag ( capacity , curve , random , items ) ; for ( int i = 0 ; i < capacity ; i + + ) { f . putIn ( new NullItem ( ) ) ; } assertEquals ( f . size ( ) , f . getCapacity ( ) ) ; for ( int i = 0 ; i < samples ; i + + ) { count [ f . nextRemovalIndex ( ) ] + + ; } assert ( semiMonotonicallyIncreasing ( count ) ) ;
public void onTabReselected ( Tab tab , FragmentTransaction ft ) { return ; }
Set < ? extends Entry > entrySet ( ) ; interface Entry extends Config . Entry , UnmodifiableCommentedConfig . Entry { String setComment ( String comment ) ; String removeComment ( ) ; } }
protected void reprocess ( E x ) { int r = forgetRate ( ) ; if ( r > 0 ) { BudgetFunctions . forget ( x . budget , forgetRate ( ) , RELATIVE_THRESHOLD ) ;
public Object clone ( ) { if ( truth = = null ) { return new Sentence ( content . clone ( ) , punctuation , null , ( Stamp ) stamp . clone ( ) ) ; } return new Sentence ( content . clone ( ) , punctuation , new TruthValue ( truth ) , ( Stamp ) stamp . clone ( ) ) ; }
void initDynamicComponent ( ISession aSession , IStringMap aParameters ) throws OpenAS2Exception ; }
public void repeatChanged ( boolean repeating ) { } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Log . d ( TAG , " StreamingService.stateChanged() " ) ; Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd = = null ) { return ; } String state = statusMpd . getState ( ) ; if ( state = = null | | state . equals ( prevMpdState ) ) { return ; } if ( state . equals ( MPDStatus . MPD_STATE_PLAYING ) ) { isPaused = false ; beginStreaming ( ) ; isPlaying = true ; } else { prevMpdState = state ; isPlaying = false ; stopStreaming ( ) ; } } public void stop ( ) { Log . d ( TAG , " StreamingService.stop() " ) ; stopStreaming ( ) ; die ( ) ; } public void stopStreaming ( ) { Log . d ( TAG , " StreamingService.stopStreaming() " ) ; prevMpdState = " " ; if ( mediaPlayer = = null ) { return ; } mediaPlayer . stop ( ) ; } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { Log . d ( TAG , " StreamingService.trackChanged() " ) ; prevMpdState = " " ; } @Override public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } }
public void onDestroy ( ) { Log . d ( TAG , " Removing connection lock " ) ; app . removeConnectionLock ( this ) ; app . oMPDAsyncHelper . removeStatusChangeListener ( this ) ; stopForeground ( true ) ; delayedStopHandler . removeCallbacksAndMessages ( null ) ; if ( mAlbumCover ! = null & & ! mAlbumCover . isRecycled ( ) ) { mAlbumCover . recycle ( ) ; } if ( mNotificationManager ! = null ) { mNotificationManager . cancel ( NOTIFICATION_ID ) ; } giveUpAudioFocus ( ) ; if ( mAudioManager ! = null ) { if ( mRemoteControlClient ! = null ) { mRemoteControlClient . setPlaybackState ( RemoteControlClient . PLAYSTATE_STOPPED ) ; mAudioManager . unregisterRemoteControlClient ( mRemoteControlClient ) ; } if ( mMediaButtonReceiverComponent ! = null ) { mAudioManager . unregisterMediaButtonEventReceiver ( mMediaButtonReceiverComponent ) ; } } app . getApplicationState ( ) . notificationMode = false ; }
public void paintBlock ( int x , int y ) { int light = ( int ) ( .1 * blockArray [ x ] [ y ] . light ) ; if ( light > 200 ) { light = 200 ; } if ( light < 0 ) { light = 0 ; } if ( blockArray [ x ] [ y ] . type = = 0 ) { for ( int x_I = 0 ; x_I < 8 ; x_I + + ) {
public void handle ( @Nonnull final AbstractActiveNetModule aOwner , @Nonnull final Socket aSocket ) { final String sClientInfo = getClientInfo ( aSocket ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " Incoming connection  " + sClientInfo ) ; final AS2Message aMsg = createMessage ( aSocket ) ; final boolean bQuoteHeaderValues = m_aReceiverModule . isQuoteHeaderValues ( ) ; final IAS2HttpResponseHandler aResponseHandler = new AS2HttpResponseHandlerSocket ( aSocket , bQuoteHeaderValues ) ; final StopWatch aSW = StopWatch . createdStarted ( ) ; DataSource aMsgDataSource = null ; try { final IHTTPIncomingDumper aIncomingDumper = getEffectiveHttpIncomingDumper ( ) ; aMsgDataSource = readAndDecodeHttpRequest ( new AS2InputStreamProviderSocket ( aSocket ) , aResponseHandler , aMsg , aIncomingDumper ) ; } catch ( final Exception ex ) { new AS2NetException ( aSocket . getInetAddress ( ) , aSocket . getPort ( ) , ex ) . terminate ( ) ; } aSW . stop ( ) ; if ( aMsgDataSource ! = null ) if ( aMsgDataSource instanceof ByteArrayDataSource ) { if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " received  " + AS2IOHelper . getTransferRate ( ( ( ByteArrayDataSource ) aMsgDataSource ) . directGetBytes ( ) . length , aSW ) + "  from  " + sClientInfo + aMsg . getLoggingText ( ) ) ; } else { LOGGER . info ( " received message from  " + sClientInfo + aMsg . getLoggingText ( ) + "  in  " + aSW . getMillis ( ) + "  ms " ) ; } handleIncomingMessage ( sClientInfo , aMsgDataSource , aMsg , aResponseHandler ) ; }
public void event ( Class event , Object [ ] args ) { if ( event = = Events . InduceSucceedingEvent . class ) { Task newEvent = ( Task ) args [ 0 ] ; this . nal = ( NAL ) args [ 1 ] ; if ( newEvent . sentence . truth ! = null ) { float newTaskExpectation = newEvent . sentence . truth . getExpectation ( ) ; if ( newTaskExpectation > 0.5 ) newTasks . add ( newEvent . getContent ( ) ) ; } } if ( nal ! = null & & event = = CycleEnd . class ) { updateAnticipations ( ) ;
public Object clone ( ) { return new TruthValue ( getFrequency ( ) , getConfidence ( ) , getAnalytic ( ) ) ; }
public void onMouseClick ( GridButtonPanel . ConceptButton c , boolean press , int wheelRotation ) { int x = c . bx ; int y = c . by ; int i = index ( c ) ; if ( ( playing ! = HUMAN ) | | field [ i ] ! = 0 ) { return ; } nar . addInput ( " < " + i + "  --> set>. :|: " ) ; c . setText ( " X " ) ; field [ i ] = 1 ; updateField ( ) ; playing = ! playing ; }
private void saveCovers ( ) { saveCovers ( COVERS_FILE_NAME , coverUrlMap ) ; }
void cancel ( ) ; void timeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }
private static String parseXml ( String data , List < String > handlers ) { try { XmlPullParserFactory factory = XmlPullParserFactory . newInstance ( ) ; XmlPullParser xpp = factory . newPullParser ( ) ; xpp . setInput ( new StringReader ( data ) ) ; int eventType = xpp . getEventType ( ) ; boolean inLocation = false ; while ( eventType ! = XmlPullParser . END_DOCUMENT ) { if ( XmlPullParser . START_TAG = = eventType ) { inLocation = xpp . getName ( ) . equals ( " location " ) ; } else if ( inLocation & & XmlPullParser . TEXT = = eventType ) { String text = xpp . getText ( ) ; for ( String handler : handlers ) { if ( text . startsWith ( handler + " :// " ) ) { return text ; } } } eventType = xpp . next ( ) ; } } catch ( Exception e ) { } return null ; }
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { return asyncGetBulk ( keys , transcoder ) ; }
String readUTF ( byte data [ ] , int off , int len ) { int offset = off ; StringBuffer buf = new StringBuffer ( ) ; for ( int end = offset + len ; offset < end ; ) { int ch = data [ offset + + ] & 0xFF ; switch ( ch > > 4 ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : break ; case 12 : case 13 : if ( offset > = len ) { return null ; } ch = ( ( ch & 0x1F ) < < 6 ) | ( data [ offset + + ] & 0x3F ) ; break ; case 14 : if ( offset + 2 > = len ) { return null ; } ch = ( ( ch & 0x0f ) < < 12 ) | ( ( data [ offset + + ] & 0x3F ) < < 6 ) | ( data [ offset + + ] & 0x3F ) ; break ; default : if ( offset + 1 > = len ) { return null ; } ch = ( ( ch & 0x3F ) < < 4 ) | ( data [ offset + + ] & 0x0f ) ; break ; } buf . append ( ( char ) ch ) ; } return buf . toString ( ) ; }
protected Node < T > addValue ( T id ) { Node < T > nodeToReturn = super . addValue ( id ) ; Node < T > nodeAdded = nodeToReturn ; if ( nodeAdded ! = null ) { while ( nodeAdded . parent ! = null ) { this . splay ( nodeAdded ) ; } } return nodeToReturn ; }
private static boolean testLinkedStack ( ) { String lName = " Stack [linked] " ; Stack . LinkedStack < Integer > lStack = new Stack . LinkedStack < Integer > ( ) ; Collection < Integer > lCollection = lStack . toCollection ( ) ; if ( ! testJavaCollection ( lCollection , Integer . class , lName ) ) return false ; return true ; }
public void downloadCover ( String artist , String album ) { CoverInfo info = new CoverInfo ( ) ; info . sArtist = artist ; info . sAlbum = album ; oCoverAsyncWorker . obtainMessage ( EVENT_DOWNLOADCOVER , info ) . sendToTarget ( ) ; }
protected InputStream getHeaderStream ( @Nonnull final IMessage aMsg , @Nonnull final Charset aCharset ) { final StringBuilder aSB = new StringBuilder ( ) ; aSB . append ( " Headers: " + HTTPHelper . EOL ) ; final Enumeration < ? > aHeaderLines = aMsg . getHeaders ( ) . getAllHeaderLines ( ) ; while ( aHeaderLines . hasMoreElements ( ) ) { final String sHeaderLine = ( String ) aHeaderLines . nextElement ( ) ; aSB . append ( sHeaderLine ) . append ( HTTPHelper . EOL ) ; } aSB . append ( HTTPHelper . EOL ) ; aSB . append ( " Attributes: " + HTTPHelper . EOL ) ; for ( final Map . Entry < String , String > attrEntry : aMsg . getAllAttributes ( ) ) { aSB . append ( attrEntry . getKey ( ) ) . append ( " :  " ) . append ( attrEntry . getValue ( ) ) . append ( HTTPHelper . EOL ) ; } return new NonBlockingByteArrayInputStream ( aSB . toString ( ) . getBytes ( aCharset ) ) ; }
public void clicked ( int x , int y , Grid2DSpace space ) { if ( ( int ) x = = 0 | | ( int ) y = = 0 | | ( int ) x = = w - 1 | | ( int ) y = = h - 1 ) return ; if ( ! doorname . equals ( " " ) & & ! doorname . contains ( " { " ) ) { doorname = " { " + doorname + " } " ; } if ( oper . equals ( " perceive " ) ) { readCells [ ( int ) x ] [ ( int ) y ] . name = " {place " + entityID . toString ( ) + " } " ; writeCells [ ( int ) x ] [ ( int ) y ] . name = " {place " + entityID . toString ( ) + " } " ; if ( TestChamber . staticInformation ) nar . addInput ( " < " + " {place " + entityID . toString ( ) + " } --> place>. " ) ; if ( TestChamber . curiousity ) { space . nar . addInput ( " <(^go-to,{SELF}, " + " {place " + entityID . toString ( ) + " }) =/> <{SELF} --> [curious]>>. " ) ; } entityID + + ; return ; } if ( ! " " . equals ( oper ) ) { if ( ! " " . equals ( readCells [ x ] [ y ] . name ) & & ! " pick " . equals ( oper ) ) { if ( allow_imitating ) { nar . addInput ( " (^ " + oper + " ,{SELF}, " + readCells [ x ] [ y ] . name + " )! :|: " ) ; } else { nar . addInput ( " (^ " + oper + " ,{SELF}, " + readCells [ x ] [ y ] . name + " ). :|: " ) ; TestChamber . operateObj ( readCells [ x ] [ y ] . name , oper ) ; } } String s = TestChamber . getobj ( x , y ) ; if ( ! s . equals ( " " ) ) { if ( allow_imitating ) { nar . addInput ( " (^ " + oper + " ,{SELF}, " + s + " )! :|: " ) ; } else { nar . addInput ( " (^ " + oper + " ,{SELF}, " + s + " ). :|: " ) ; TestChamber . operateObj ( s , oper ) ; } } return ; } if ( ! " " . equals ( wish ) ) { boolean inverse = false ; if ( wish . equals ( " closed " ) | | wish . equals ( " off " ) ) { inverse = true ; } String wishreal = wish . replace ( " closed " , " opened " ) . replace ( " off " , " on " ) ; if ( ! " " . equals ( readCells [ x ] [ y ] . name ) ) { if ( ! inverse ) { String inp = " < " + readCells [ x ] [ y ] . name + "  --> [ " + wishreal + " ]>! :|: " ; nar . addInput ( inp ) ; lastWish = inp ; } else { String inp = " (--,< " + readCells [ x ] [ y ] . name + "  --> [ " + wishreal + " ]>)! :|: %1.00;0.90% " ; nar . addInput ( inp ) ; lastWish = inp ; } } String s = TestChamber . getobj ( x , y ) ; if ( ! s . equals ( " " ) ) { if ( ! inverse ) { String inp = " < " + s + "  --> [ " + wishreal + " ]>! :|: " ; nar . addInput ( inp ) ; lastWish = inp ; } else { String inp = " (--,< " + s + "  --> [ " + wishreal + " ]>)! :|: %1.00;0.90% " ; nar . addInput ( inp ) ; lastWish = inp ; } } return ; } if ( ! " " . equals ( doorname ) & & selected . material = = Material . Door ) { space . add ( new Key ( ( int ) x , ( int ) y , doorname . replace ( " door " , " key " ) ) ) ; if ( TestChamber . staticInformation ) nar . addInput ( " < " + doorname . replace ( " door " , " key " ) + "  --> key>. " ) ; if ( TestChamber . curiousity ) { space . nar . addInput ( " <(^go-to,{SELF}, " + doorname . replace ( " door " , " key " ) + " ) =/> <{SELF} --> [curious]>>. " ) ; space . nar . addInput ( " <(^pick,{SELF}, " + doorname . replace ( " door " , " key " ) + " ) =/> <{SELF} --> [curious]>>. " ) ; } doorname = " " ; return ; } if ( selected . material = = Material . Pizza ) { doorname = " {pizza " + entityID . toString ( ) + " } " ; } if ( ! " " . equals ( doorname ) & & selected . material = = Material . Pizza ) { space . add ( new Pizza ( ( int ) x , ( int ) y , doorname ) ) ; if ( TestChamber . staticInformation ) nar . addInput ( " < " + doorname + "  --> pizza>. " ) ; if ( TestChamber . curiousity ) { space . nar . addInput ( " <(^go-to,{SELF}, " + doorname + " ) =/> <{SELF} --> [curious]>>. " ) ; } entityID + + ; doorname = " " ; return ; } if ( ! ( selected . material = = Material . Door ) & & ! ( selected . material = = Material . Pizza ) ) doorname = " " ; readCells [ ( int ) x ] [ ( int ) y ] . charge = selected . charge ; writeCells [ ( int ) x ] [ ( int ) y ] . charge = selected . charge ; readCells [ ( int ) x ] [ ( int ) y ] . logic = selected . logic ; writeCells [ ( int ) x ] [ ( int ) y ] . logic = selected . logic ; readCells [ ( int ) x ] [ ( int ) y ] . material = selected . material ; writeCells [ ( int ) x ] [ ( int ) y ] . material = selected . material ; readCells [ ( int ) x ] [ ( int ) y ] . machine = selected . machine ; writeCells [ ( int ) x ] [ ( int ) y ] . machine = selected . machine ; if ( selected . material = = Material . Pizza | | selected . material = = Material . Door | | selected . logic = = Logic . OFFSWITCH | | selected . logic = = Logic . SWITCH | | selected . machine = = Machine . Light | | selected . machine = = Machine . Turret ) {
public void onChanged ( ) { notifyDataSetChanged ( ) ; }
int getAttributeAsInt ( @Nullable String sName , int nDefault ) ; long getAttributeAsLong ( @Nullable String sName ) ; long getAttributeAsLong ( @Nullable String sName , long nDefault ) ; double getAttributeAsDouble ( @Nullable String sName ) ; double getAttributeAsDouble ( @Nullable String sName , double dDefault ) ; boolean getAttributeAsBoolean ( @Nullable String sName ) ; boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; Enumeration < String > getAttributeNames ( ) ; Set < String > getAllAttributeNames ( ) ; Collection < String > getAllAttributeValues ( ) ; int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; Iterator < Entry < String , String > > iterator ( ) ; }
int getServersCount ( ) ; HashAlgorithm getHashAlgorithm ( ) ; String getServer ( int serverIndex ) ; int getVbucketByKey ( String key ) ; int getMaster ( int vbucketIndex ) ; int getReplica ( int vbucketIndex , int replicaIndex ) ; int foundIncorrectMaster ( int vbucket , int wrongServer ) ; ConfigDifference compareTo ( Config config ) ; List < String > getServers ( ) ; List < VBucket > getVbuckets ( ) ; ConfigType getConfigType ( ) ; }
public static boolean revisible ( final Sentence s1 , final Sentence s2 ) { return ( s1 . equalsContent ( s2 ) & & s1 . getRevisible ( ) & & TemporalRules . matchingOrder ( s1 . getTemporalOrder ( ) , s2 . getTemporalOrder ( ) ) ) ;
public void clicked ( float x , float y ) { readCells [ ( int ) x ] [ ( int ) y ] . charge = selected . charge ; writeCells [ ( int ) x ] [ ( int ) y ] . charge = selected . charge ; readCells [ ( int ) x ] [ ( int ) y ] . logic = selected . logic ; writeCells [ ( int ) x ] [ ( int ) y ] . logic = selected . logic ; readCells [ ( int ) x ] [ ( int ) y ] . material = selected . material ; writeCells [ ( int ) x ] [ ( int ) y ] . material = selected . material ; readCells [ ( int ) x ] [ ( int ) y ] . machine = selected . machine ; writeCells [ ( int ) x ] [ ( int ) y ] . machine = selected . machine ; }
public String toStringLong ( ) { final StringBuilder s = new StringBuilder ( ) ; s . append ( super . toString ( ) ) . append ( ' ' ) . append ( sentence . stamp . name ( ) ) ; if ( bestSolution ! = null ) { s . append ( "    \ n solution:  " ) . append ( bestSolution . toString ( ) ) ; } return s . toString ( ) ; }
public void before ( ) { arriving = Lists . newArrayList ( ) ; existing = Lists . newArrayList ( ) ; keySchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " key " , DataTypes . StringType , false ) ) ) ; arrivingSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " key " , DataTypes . StringType , false ) , DataTypes . createStructField ( " value " , DataTypes . StringType , true ) , DataTypes . createStructField ( " timestamp " , DataTypes . LongType , false ) ) ) ; existingSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " key " , DataTypes . StringType , false ) , DataTypes . createStructField ( " value " , DataTypes . StringType , false ) , DataTypes . createStructField ( " timestamp " , DataTypes . LongType , false ) , DataTypes . createStructField ( " eventstart " , DataTypes . LongType , false ) , DataTypes . createStructField ( " eventend " , DataTypes . LongType , false ) , DataTypes . createStructField ( " systemstart " , DataTypes . LongType , false ) , DataTypes . createStructField ( " systemend " , DataTypes . LongType , false ) , DataTypes . createStructField ( " currentflag " , DataTypes . StringType , false ) ) ) ; configMap = Maps . newHashMap ( ) ; configMap . put ( KEY_FIELD_NAMES_CONFIG_NAME , Lists . newArrayList ( " key " ) ) ; configMap . put ( VALUE_FIELD_NAMES_CONFIG_NAME , Lists . newArrayList ( " value " ) ) ; configMap . put ( TIMESTAMP_FIELD_NAME_CONFIG_NAME , " timestamp " ) ; configMap . put ( EVENT_TIME_EFFECTIVE_FROM_FIELD_NAME_CONFIG_NAME , " eventstart " ) ; configMap . put ( EVENT_TIME_EFFECTIVE_TO_FIELD_NAME_CONFIG_NAME , " eventend " ) ; configMap . put ( SYSTEM_TIME_EFFECTIVE_FROM_FIELD_NAME_CONFIG_NAME , " systemstart " ) ; configMap . put ( SYSTEM_TIME_EFFECTIVE_TO_FIELD_NAME_CONFIG_NAME , " systemend " ) ; configMap . put ( CURRENT_FLAG_FIELD_NAME_CONFIG_NAME , " currentflag " ) ; config = ConfigFactory . parseMap ( configMap ) ; preplanSystemTime = System . currentTimeMillis ( ) ; }
public List < Item > getPlaylists ( boolean sort ) throws MPDServerException { if ( ! isConnected ( ) ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } List < Item > result = new ArrayList < > ( ) ; List < String > response = mpdConnection . sendCommand ( MPDCommand . MPD_CMD_LISTPLAYLISTS ) ; for ( String line : response ) { if ( line . startsWith ( " playlist " ) ) { String name = line . substring ( " playlist:  " . length ( ) ) ; if ( null ! = name & & ! name . equals ( STREAMS_PLAYLIST ) ) { result . add ( new Playlist ( name ) ) ; } } } if ( sort ) { Collections . sort ( result ) ; } return result ; }
MetricCollector getMetricCollector ( ) ; long getAuthWaitTime ( ) ; }
public static Term cloneDeepReplaceIntervals ( Term T ) { T = T . cloneDeep ( ) ; if ( T instanceof CompoundTerm ) { ReplaceIntervals ( ( CompoundTerm ) T ) ; } return T ; }
private void connect ( ) { try { mMPD . connect ( mConInfo . server , mConInfo . port , mConInfo . password ) ;
< T > OperationFuture < CASResponse > asyncCAS ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; CASResponse cas ( String key , long casId , int exp , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public int delete ( Uri uri , String where , String [ ] whereArgs ) { SQLiteDatabase db = mOpenHelper . getWritableDatabase ( ) ; int count ; switch ( sUriMatcher . match ( uri ) ) { case SERVERS : count = db . delete ( SERVERS_TABLE_NAME , where , whereArgs ) ; break ; case SERVER_ID : String noteId = uri . getPathSegments ( ) . get ( 1 ) ; count = db . delete ( SERVERS_TABLE_NAME , ServerColumns . _ID + " = " + noteId + ( ! TextUtils . isEmpty ( where ) ? "  AND ( " + where + ')' : " " ) , whereArgs ) ; break ; default : throw new IllegalArgumentException ( " Unknown URI  " + uri ) ; } getContext ( ) . getContentResolver ( ) . notifyChange ( uri , null ) ; return count ; }
public boolean isAlbumInGenre ( final Album album , final Genre genre ) throws MPDServerException { final List < String > response ; final Artist artist = album . getArtist ( ) ; final String artistName ; final String artistType ; if ( album . hasAlbumArtist ( ) ) { artistType = MPDCommand . MPD_TAG_ALBUM_ARTIST ; } else { artistType = MPDCommand . MPD_TAG_ARTIST ; } if ( artist = = null ) { artistName = " " ; } else { artistName = artist . getName ( ) ; } response = mConnection . sendCommand ( new MPDCommand ( MPDCommand . MPD_CMD_LIST_TAG , MPDCommand . MPD_TAG_ALBUM , MPDCommand . MPD_TAG_ALBUM , album . getName ( ) , artistType , artistName , MPDCommand . MPD_TAG_GENRE , genre . getName ( ) ) ) ; return ! response . isEmpty ( ) ; }
public boolean canHandle ( final String action , final IMessage msg , final Map < String , Object > options ) { if ( ! action . equals ( IProcessorSenderModule . DO_SENDMDN ) ) return false ; return msg instanceof AS2Message ; }
private synchronized KuduTable connectToTable ( ) throws KuduException { if ( client = = null ) { LOG . info ( " Connecting to Kudu " ) ; String masterAddresses = config . getString ( CONNECTION_CONFIG_NAME ) ; client = new KuduClient . KuduClientBuilder ( masterAddresses ) . build ( ) ; session = client . newSession ( ) ; session . setFlushMode ( FlushMode . AUTO_FLUSH_BACKGROUND ) ; session . setMutationBufferSpace ( 10000 ) ; LOG . info ( " Connection to Kudu established " ) ; } String tableName = config . getString ( TABLE_CONFIG_NAME ) ; KuduTable table = getTable ( tableName ) ; return table ; }
public List < Album > listAllAlbumsGrouped ( boolean useAlbumArtist , boolean includeUnknownAlbum ) throws MPDServerException { List < String > response = mpdConnection . sendCommand ( listAllAlbumsGroupedCommand ( useAlbumArtist ) ) ; final String artistResponse = useAlbumArtist ? " AlbumArtist:  " : " Artist:  " ; final String albumResponse = " Album:  " ; ArrayList < Album > result = new ArrayList < > ( ) ; Album currentAlbum = null ; for ( String line : response ) { if ( line . startsWith ( artistResponse ) ) { if ( currentAlbum ! = null ) { currentAlbum . setArtist ( new Artist ( line . substring ( artistResponse . length ( ) ) ) ) ; } } else if ( line . startsWith ( albumResponse ) ) { String name = line . substring ( albumResponse . length ( ) ) ; if ( ! name . isEmpty ( ) | | includeUnknownAlbum ) { currentAlbum = new Album ( name , null ) ; currentAlbum . setHasAlbumArtist ( useAlbumArtist ) ; result . add ( currentAlbum ) ; } else { currentAlbum = null ; } } } Collections . sort ( result ) ; return result ; }
public void initDynamicComponent ( final ISession aSession , final IStringMap aOptions ) throws OpenAS2Exception { super . initDynamicComponent ( aSession , aOptions ) ; getParameterRequired ( PARAM_OUTBOX_DIRECTORY ) ; getParameterRequired ( PARAM_ERROR_DIRECTORY ) ; }
Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public int compareTo ( Node node ) { if ( node = = null ) return - 1 ; int length = string . length ; if ( node . string . length < length ) length = node . string . length ; for ( int i = 0 ; i < length ; i + + ) { Character a = string [ i ] ; Character b = node . string [ i ] ; int c = a . compareTo ( b ) ; if ( c ! = 0 ) return c ; } if ( this . type = = BLACK & & node . type = = WHITE ) return - 1 ; else if ( node . type = = BLACK & & this . type = = WHITE ) return 1 ; if ( this . getChildrenSize ( ) < node . getChildrenSize ( ) ) return - 1 ; else if ( this . getChildrenSize ( ) > node . getChildrenSize ( ) ) return 1 ; return 0 ; }
public Data copy ( ) { return new RangeMinimumData < N > ( start , end , minimum ) ; }
public static boolean before ( TimeModel timeModel , Row first , Row second ) { return timeModel . compare ( first , second ) < 0 ; }
protected void processFile ( @Nonnull final File aFile ) throws OpenAS2Exception { LOGGER . info ( " processing  " + aFile . getAbsolutePath ( ) ) ; final IMessage aMsg = createMessage ( ) ; aMsg . attrs ( ) . putIn ( CFileAttribute . MA_FILEPATH , aFile . getAbsolutePath ( ) ) ; aMsg . attrs ( ) . putIn ( CFileAttribute . MA_FILENAME , aFile . getName ( ) ) ; aMsg . attrs ( ) . putIn ( CFileAttribute . MA_PENDING_FILENAME , aFile . getName ( ) ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " AS2Message was created " ) ; try {
protected String executeGetRequestWithConnection ( String request ) { URL url = CoverManager . buildURLForConnection ( request ) ; HttpURLConnection connection = null ; InputStream inputStream = null ; int statusCode ; BufferedReader bis ; String result ; String line ; try { connection = ( HttpURLConnection ) url . openConnection ( ) ;
public void testBag ( final boolean arraylist , final int levels , final int capacity , final AtomicDouble forgetRate ) { totalPriority = 0 ; totalMass = 0 ; totalMaxItemsPerLevel = totalMinItemsPerLevel = 0 ; Performance p = new Performance ( ( arraylist ? " DequeArray " : " LinkedList " ) + " , " + levels + " , " + capacity , repeats , warmups ) { @Override public void init ( ) { } @Override public void run ( boolean warmup ) { LevelBag < NullItem , CharSequence > b = new LevelBag ( levels , capacity ) { } ; randomBagIO ( b , randomAccesses , insertRatio ) ; if ( ! warmup ) { totalPriority + = b . getAveragePriority ( ) ; totalMass + = b . getMass ( ) ; totalMinItemsPerLevel + = b . getMinItemsPerLevel ( ) ; totalMaxItemsPerLevel + = b . getMaxItemsPerLevel ( ) ; } } } . printCSV ( true ) ; System . out . print ( ( totalMaxItemsPerLevel / p . repeats ) + " , " ) ; System . out . print ( totalPriority / p . repeats + " , " ) ; System . out . print ( totalMass / repeats / levels + " , " ) ; System . out . println ( ) ; }
public Builder toBuilder ( ) { return this = = DEFAULT_INSTANCE ? new Builder ( ) : new Builder ( ) . mergeFrom ( this ) ;
private boolean iteratorQueueEmpty ( ) { return q < iteratorQueue . length ; }
void event ( final EventEmitter . EventObserver e , final boolean enabled , final Class . . . events ) ; void emit ( final Class c , final Object . . . o ) ; }
abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } protected int forgetRate ( ) { if ( forgettingRate ! = null ) { return forgettingRate . get ( ) ; } return - 1 ; } protected void forget ( final E x ) { int r = forgetRate ( ) ; if ( r > 0 ) { BudgetFunctions . forget ( x . budget , r , RELATIVE_THRESHOLD ) ; } } public final boolean putBack ( final E oldItem , final boolean insertIntoNameTable ) { forget ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public final boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( boolean forget ) { final E x = takeOut ( false ) ; if ( x ! = null ) { if ( forget ) { forget ( x ) ; } boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else { return null ; } } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( CharSequence key ) ; }
public void testSequence1 ( ) { setupNodes ( 4 ) ; assertSequence ( " dustin " , 0 , 2 , 1 , 2 , 3 , 2 , 0 ) ; }
public void onCreate ( ) { Log . i ( TAG , " debug: Creating service " ) ; mNotificationManager = ( NotificationManager ) getSystemService ( NOTIFICATION_SERVICE ) ; mAudioManager = ( AudioManager ) getSystemService ( AUDIO_SERVICE ) ; if ( android . os . Build . VERSION . SDK_INT > = 8 ) mAudioFocusHelper = new AudioFocusHelper ( getApplicationContext ( ) , this ) ; else mAudioFocus = AudioFocus . Focused ; mDummyAlbumArt = BitmapFactory . decodeResource ( getResources ( ) , R . drawable . no_cover_art_light ) ; mMediaButtonReceiverComponent = new ComponentName ( this , RemoteControlReceiver . class ) ; }
public < T > OperationFuture < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( key , latch , operationTimeout , executorService ) ; Operation op = opFact . getAndTouch ( key , exp , new GetAndTouchOperation . Callback ( ) { private CASValue < T > val ; @Override public void receivedStatus ( OperationStatus status ) { rv . set ( val , status ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } @Override public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert k . equals ( key ) : " Wrong key returned " ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }
default void parse ( File file , Config destination , ParsingMode parsingMode , FileNotFoundAction nefAction ) { parse ( file , destination , parsingMode , nefAction , StandardCharsets . UTF_8 ) ; }
public ProcessingItem connectInputShuffleStream ( Stream inputStream ) { return null ; }
public String toString ( ) { final StringBuffer buff = new StringBuffer ( ) ; buff . append ( " [index=' " ) . append ( this . index ) . append ( " ' " ) ; buff . append ( " , prev= " ) ; if ( this . prevNode = = null ) { buff . append ( " null " ) ; } else { buff . append ( " ' " ) . append ( this . prevNode ) . append ( " ' " ) ; } buff . append ( " , next= " ) ; if ( this . nextNode = = null ) { buff . append ( " null " ) ; } else { buff . append ( " ' " ) . append ( this . nextNode ) . append ( " ' " ) ; } buff . append ( " ] " ) ; return buff . toString ( ) ; }
private static String parseXml ( final String data , final List < String > handlers ) { try { final XmlPullParserFactory factory = XmlPullParserFactory . newInstance ( ) ; final XmlPullParser xpp = factory . newPullParser ( ) ; xpp . setInput ( new StringReader ( data ) ) ; int eventType = xpp . getEventType ( ) ; boolean inLocation = false ; while ( eventType ! = XmlPullParser . END_DOCUMENT ) { if ( XmlPullParser . START_TAG = = eventType ) { inLocation = " location " . equals ( xpp . getName ( ) ) ; } else if ( inLocation & & XmlPullParser . TEXT = = eventType ) { final String text = xpp . getText ( ) ; for ( final String handler : handlers ) { if ( text . startsWith ( handler + " :// " ) ) { return text ; } } } eventType = xpp . next ( ) ; } } catch ( final Exception e ) { Log . e ( TAG , " Failed to parse an XML stream file. " , e ) ; } return null ; }
public void connectionStateChanged ( boolean connected , boolean connectionLost ) { if ( isDetached ( ) | | songTitle = = null | | songArtist = = null ) return ; connected = ( ( MPDApplication ) getActivity ( ) . getApplication ( ) ) . oMPDAsyncHelper . oMPD . isConnected ( ) ; if ( connected ) { songTitle . setText ( getResources ( ) . getString ( R . string . noSongInfo ) ) ; songArtist . setText ( " " ) ; } else { songTitle . setText ( getResources ( ) . getString ( R . string . notConnected ) ) ; songArtist . setText ( " " ) ; } return ; }
public void handle ( Event event ) { Row mutation = new RowWithSchema ( getSchema ( ) , event . getId ( ) , event . getTimestamp ( ) , event . getEventType ( ) , event . getMessage ( ) , Contexts . getPipelineID ( ) , Contexts . getApplicationID ( ) ) ; mutation = PlannerUtils . setMutationType ( mutation , MutationType . INSERT ) ; List < Row > mutations = Lists . newArrayList ( mutation ) ; try { randomOutput . applyRandomMutations ( mutations ) ;
public void setMicalgImportance ( final String micalgImportance ) { m_sMicalgImportance = micalgImportance ; }
public ServletRegistrationBean < AS2MDNReceiveServlet > servletRegistrationBeanMDN ( ) { _initScope ( ) ; final ServletRegistrationBean < AS2MDNReceiveServlet > bean = new ServletRegistrationBean < > ( new AS2MDNReceiveServlet ( ) , " /as2mdn " ) ; final Map < String , String > aInitParams = new HashMap < > ( ) ; aInitParams . put ( AbstractAS2ReceiveXServletHandler . SERVLET_INIT_PARAM_AS2_SERVLET_CONFIG_FILENAME , " config/config.xml " ) ; bean . setInitParameters ( aInitParams ) ; return bean ; }
public static final TruthValue desireDed ( final TruthValue v1 , final TruthValue v2 , Parameters narParameters ) { final float f1 = v1 . getFrequency ( ) ; final float f2 = v2 . getFrequency ( ) ; final double c1 = v1 . getConfidence ( ) ; final double c2 = v2 . getConfidence ( ) ; final float f = ( float ) and ( f1 , f2 ) ; final double c = and ( c1 , c2 ) ; return new TruthValue ( f , c , narParameters ) ; }
public static void main ( String [ ] args ) { NAR nar = new DefaultNARBuilder ( ) . build ( ) ; new NARPhysics < Rover > ( nar , new Rover ( nar ) ) { } ; nar . param ( ) . duration . set ( 50 ) ; nar . start ( 50 , 25 ) ;
public void commit ( double value ) { if ( ! active ) return ; super . commit ( ) ; setValue ( value ) ; commit ( ) ; }
private void updateNotification ( int state ) { Log . d ( TAG , " update notification:  " + mCurrentMusic . getArtist ( ) + "  -  " + mCurrentMusic . getTitle ( ) + " , state:  " + state ) ; final Intent musicPlayerActivity = new Intent ( getApplicationContext ( ) , MainMenuActivity . class ) ; TaskStackBuilder stackBuilder = TaskStackBuilder . create ( this ) ; stackBuilder . addParentStack ( MainMenuActivity . class ) ; stackBuilder . addNextIntent ( musicPlayerActivity ) ; final Intent playPause = new Intent ( this , NotificationService . class ) ; playPause . setAction ( NotificationService . ACTION_TOGGLE_PLAYBACK ) ; final PendingIntent piPlayPause = PendingIntent . getService ( this , 0 , playPause , 0 ) ; final Intent prev = new Intent ( this , NotificationService . class ) ; prev . setAction ( ACTION_PREVIOUS ) ; final PendingIntent piPrev = PendingIntent . getService ( this , 0 , prev , 0 ) ; final Intent next = new Intent ( this , NotificationService . class ) ; next . setAction ( NotificationService . ACTION_SKIP ) ; final PendingIntent piNext = PendingIntent . getService ( this , 0 , next , 0 ) ; final Intent closeNotification = new Intent ( this , NotificationService . class ) ; closeNotification . setAction ( NotificationService . ACTION_CLOSE_NOTIFICATION ) ; final PendingIntent piCloseNotification = PendingIntent . getService ( this , 0 , closeNotification , 0 ) ; PendingIntent piClick = stackBuilder . getPendingIntent ( 0 , PendingIntent . FLAG_UPDATE_CURRENT ) ; final int playPauseResId = state = = RemoteControlClient . PLAYSTATE_PLAYING ? R . drawable . ic_media_pause : R . drawable . ic_media_play ; RemoteViews collapsedNotification = buildCollapsedNotification ( piPlayPause , piNext , piCloseNotification , playPauseResId ) ; RemoteViews expandedNotification = null ; if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . JELLY_BEAN ) { expandedNotification = buildExpandedNotification ( piPrev , piPlayPause , piNext , piCloseNotification , playPauseResId ) ; } if ( mAlbumCover ! = null ) { collapsedNotification . setImageViewUri ( R . id . notificationIcon , Uri . parse ( mAlbumCoverPath ) ) ; if ( expandedNotification ! = null ) expandedNotification . setImageViewUri ( R . id . notificationIcon , Uri . parse ( mAlbumCoverPath ) ) ; } if ( mNotification = = null ) { final NotificationCompat . Builder builder = new NotificationCompat . Builder ( this ) ; builder . setSmallIcon ( R . drawable . icon_bw ) ; builder . setContentIntent ( piClick ) ; builder . setContent ( collapsedNotification ) ; builder . setStyle ( new NotificationCompat . BigTextStyle ( ) ) ; mNotification = builder . build ( ) ; } setBigContentView ( mNotification , expandedNotification ) ; mNotificationManager . notify ( NOTIFICATION_ID , mNotification ) ; startForeground ( NOTIFICATION_ID , mNotification ) ; }
public void initialize ( Prolog vm ) { dynamicDBase = new ClauseDatabase ( ) ; staticDBase = new ClauseDatabase ( ) ; retractDBase = new ClauseDatabase ( ) ; engine = vm ; primitiveManager = engine . getPrimitiveManager ( ) ; }
public void load ( final String sFilename , final char [ ] aPassword ) throws OpenAS2Exception { try {
public < C > void on ( final Class < ? extends C > event , final Observer < ? extends C > o ) { if ( null = = event | | null = = o ) return ; if ( events . containsKey ( event ) ) events . get ( event ) . add ( o ) ;
public D query ( long start , long end , D result ) { if ( start = = this . start & & end = = this . end ) { for ( D d : this . range ) { if ( result = = null ) result = ( D ) d . copy ( ) ; result . combined ( d ) ; } return result ; } if ( this . hasChildren ( ) ) { long middle = this . start + this . half ; if ( start < middle & & end > = middle ) { result = ( D ) ( ( OverlappingSegment < D > ) this . getLeftChild ( ) ) . query ( start , middle - 1 , result ) ; result = ( D ) ( ( OverlappingSegment < D > ) this . getRightChild ( ) ) . query ( middle , end , result ) ; } else if ( end < middle ) { result = ( D ) ( ( OverlappingSegment < D > ) this . getLeftChild ( ) ) . query ( start , end , result ) ; } else if ( start > = middle ) { result = ( D ) ( ( OverlappingSegment < D > ) this . getRightChild ( ) ) . query ( start , end , result ) ; } } return result ; }
public boolean equals ( Object obj ) { if ( ! ( obj instanceof RangeMaximumData ) ) return false ; RangeMaximumData < N > data = ( RangeMaximumData < N > ) obj ; if ( this . start = = data . start & & this . end = = data . end & & this . maximum . equals ( data . maximum ) ) return true ; return false ; }
public boolean hasWindowFocus ( ) { return mHijackFocus | | super . hasWindowFocus ( ) ; }
public void receiveProvidedSchema ( StructType providedSchema ) { if ( providedSchema . equals ( SchemaUtils . binaryValueSchema ( ) ) ) { received = true ;
public Builder mergeFrom ( com . google . protobuf . Message other ) { if ( other instanceof com . cloudera . labs . envelope . input . translate . ProtobufMultipleMessage . OtherExample ) { return mergeFrom ( ( com . cloudera . labs . envelope . input . translate . ProtobufMultipleMessage . OtherExample ) other ) ;
public RadixNode < K , V > get ( K string ) { Node < K > k = this . getNode ( string ) ; if ( k instanceof RadixNode ) { RadixNode < K , V > r = ( RadixNode < K , V > ) k ; return r ; } return null ; }
public void resetLearning ( ) { m_n = 1 ; x_mean = 0.0 ; sum = 0.0 ; delta = this . deltaOption . getValue ( ) ; lambda = this . lambdaOption . getValue ( ) ; }
private void refreshAllConnections ( ) { new Thread ( new Runnable ( ) { @Override
abstract public Set < CharSequence > keySet ( ) ; abstract public int getCapacity ( ) ; abstract public float getMass ( ) ; abstract public boolean putIn ( final E newItem , boolean insertIntoNameTable ) ; public boolean putIn ( final E newItem ) { return putIn ( newItem , true ) ; } abstract public int size ( ) ; abstract public E takeOut ( boolean removeFromNameTable ) ; abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } public void addBagObserver ( BagObserver < E > bagObserver , String title ) { this . bagObserver = bagObserver ; bagObserver . post ( toString ( ) ) ; bagObserver . setTitle ( title ) ; bagObserver . setBag ( this ) ; } protected int forgetRate ( ) { if ( forgettingRate ! = null ) { return forgettingRate . get ( ) ; } return - 1 ; } public void play ( ) { if ( bagObserver ! = null ) { bagObserver . post ( toString ( ) ) ; } } protected void reprocess ( E x ) { int r = forgetRate ( ) ; if ( r > 0 ) { BudgetFunctions . forget ( x . budget , forgetRate ( ) , RELATIVE_THRESHOLD ) ; } } public void stop ( ) { if ( bagObserver ! = null ) { bagObserver . stop ( ) ; } } public boolean putBack ( final E oldItem , boolean insertIntoNameTable ) { reprocess ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( ) { final E x = takeOut ( false ) ; if ( x ! = null ) { reprocess ( x ) ; boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else return null ; } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( CharSequence key ) ; }
void exception ( String message ) { mediator . exception ( message ) ; }
public void initDynamicComponent ( @Nonnull final IAS2Session aSession , @Nullable final IStringMap aOptions ) throws AS2Exception { super . initDynamicComponent ( aSession , aOptions ) ; try { final String sKeyStoreType = attrs ( ) . getAsString ( ATTR_TYPE ) ; final EKeyStoreType eKeyStoreType = EKeyStoreType . getFromIDCaseInsensitiveOrDefault ( sKeyStoreType , DEFAULT_KEY_STORE_TYPE ) ; m_aRWLock . writeLock ( ) . lock ( ) ; try { m_aKeyStore = createNewKeyStore ( eKeyStoreType ) ; if ( m_aKeyStore = = null ) throw new InitializationException ( " Failed to create new keystore with type  " + eKeyStoreType ) ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } } catch ( final GeneralSecurityException ex ) { throw WrappedAS2Exception . wrap ( ex ) ; } final String sFilename = getFilename ( ) ; if ( StringHelper . hasText ( sFilename ) ) load ( sFilename , getPassword ( ) ) ;
protected void planTask ( NAL nal , ParticlePlan plan , Concept c , Task task , Term target , char punctuation ) { Task newTask = planTask ( plan , c , task , target , punctuation ) ; if ( memory . getRecorder ( ) . isActive ( ) ) memory . getRecorder ( ) . append ( " Plan Add " , newTask . toString ( ) ) ; if ( punctuation = = '!' ) memory . executive . addTask ( c , newTask ) ;
public static boolean simultaneous ( TimeModel timeModel , Row first , Row second ) { return timeModel . compare ( first , second ) = = 0 ; }
public void beGood ( ) { nar . addInput ( " <SELF --> [good]>! " ) ; nar . addInput ( " <SELF --> [bad]>! %0% " ) ; }
public boolean parse ( NAR nar , String input , InputParser lastHandler ) { if ( ! nar . isPaused ( ) ) { if ( input . equals ( Symbols . STOP_COMMAND ) ) { nar . output ( " stopping. " ) ; nar . pause ( ) ; return true ; } } return false ; }
public void onStart ( Intent intent , int startId ) { onStartCommand ( intent , 0 , startId ) ; }
public void testAvroTranslationWithLiteralSchema ( ) throws Exception { Schema schema = SchemaBuilder . record ( " test " ) . fields ( ) . optionalString ( " field1 " ) . optionalInt ( " field2 " ) . endRecord ( ) ; Record record = new Record ( schema ) ; record . put ( " field1 " , " hello " ) ; record . put ( " field2 " , 100 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; BinaryEncoder encoder = EncoderFactory . get ( ) . binaryEncoder ( out , null ) ; DatumWriter < Record > writer = new GenericDatumWriter < Record > ( schema ) ; writer . write ( record , encoder ) ; encoder . flush ( ) ; byte [ ] a = out . toByteArray ( ) ; out . close ( ) ; Config config = ConfigFactory . empty ( ) . withValue ( AvroTranslator . AVRO_LITERAL_CONFIG , ConfigValueFactory . fromAnyRef ( schema . toString ( ) ) ) ; AvroTranslator t = new AvroTranslator ( ) ; assertNoValidationFailures ( t , config ) ; t . configure ( config ) ; Row r = t . translate ( null , a ) . iterator ( ) . next ( ) ; assertEquals ( r , RowFactory . create ( " hello " , 100 ) ) ; }
public void submit ( Set < Step > dependencySteps ) throws Exception { Contexts . getSparkSession ( ) . sparkContext ( ) . setJobDescription ( " Step:  " + getName ( ) ) ; Dataset < Row > data ; if ( hasInput ( ) ) { data = ( ( BatchInput ) getInput ( ) ) . read ( ) ; } else if ( hasDeriver ( ) ) { Map < String , Dataset < Row > > dependencies = StepUtils . getStepDataFrames ( dependencySteps ) ; data = getDeriver ( ) . derive ( dependencies ) ; } else { throw new RuntimeException ( " Batch step ' " + getName ( ) + " ' must contain either an input or a deriver. " ) ; } if ( doesRepartition ( ) ) { data = repartition ( data ) ; } setData ( data ) ; setSubmitted ( true ) ; }
public void set ( int index , int val ) { if ( index < 0 | | index > = size ( ) ) throw new IndexOutOfBoundsException ( ) ; index + + ; int diff = val - values . get ( index ) ; values . set ( index , val ) ; while ( index < = size ( ) ) { int oldPrefSum = prefSums . get ( index ) ;
public NoopOperation noop ( OperationCallback cb ) { return new VersionOperationImpl ( cb ) ; }
private static int findMax ( int [ ] array ) { int max = Integer . MIN_VALUE ; for ( int e : array ) { if ( e > max ) max = e ; } return max ; }
private static AS2Message _createMessage ( @Nonnull final Partnership aPartnership , @Nonnull final AS2ClientRequest aRequest ) throws MessagingException , OpenAS2Exception { final AS2Message aMsg = new AS2Message ( ) ; aMsg . setContentType ( aRequest . getContentType ( ) ) ; aMsg . setSubject ( aRequest . getSubject ( ) ) ; aMsg . setPartnership ( aPartnership ) ; aMsg . setMessageID ( aMsg . generateMessageID ( ) ) ; aMsg . setAttribute ( CPartnershipIDs . PA_AS2_URL , aPartnership . getAttribute ( CPartnershipIDs . PA_AS2_URL ) ) ; aMsg . setAttribute ( CPartnershipIDs . PID_AS2 , aPartnership . getReceiverID ( CPartnershipIDs . PID_AS2 ) ) ; aMsg . setAttribute ( CPartnershipIDs . PID_EMAIL , aPartnership . getSenderID ( CPartnershipIDs . PID_EMAIL ) ) ; final MimeBodyPart aPart = new MimeBodyPart ( ) ; aRequest . applyDataOntoMimeBodyPart ( aPart ) ; aMsg . setData ( aPart ) ; return aMsg ; }
public void observeAttributeClass ( double attVal , double classVal , double weight ) { if ( Double . isNaN ( attVal ) ) { } else {
public void adjustVolume ( int modifier ) throws MPDServerException { if ( mpdConnection = = null ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } String [ ] args = new String [ 1 ] ; args [ 0 ] = Integer . toString ( modifier ) ; mpdConnection . sendCommand ( MPD_CMD_VOLUME , args ) ; }
void copyFrom ( Cell c ) { this . material = c . material ; this . height = c . height ; this . machine = c . machine ; this . charge = c . charge ; this . chargeFront = c . chargeFront ; this . light = c . light ; }
public static void main ( String [ ] arg ) { NAR nar = new DefaultNARBuilder ( ) . realtime ( ) . build ( ) ; nar . param ( ) . duration . set ( 50 ) ; nar . param ( ) . decisionThreshold . set ( 0.1 ) ; nar . param ( ) . noiseLevel . set ( 0 ) ; nar . param ( ) . conceptForgetDurations . set ( 50 ) ; NARio nario = new NARio ( nar ) ; new NARSwing ( nar ) ; nar . start ( 50 , 500 ) ; }
private String processAdverb ( String sumokbname , String mixedCase , String input , String synset ) { StringBuilder result = new StringBuilder ( ) ; String synsetBlock ; synsetBlock = ( String ) adverbSynsetHash . get ( input ) ; result . append ( sumoDisplay ( synsetBlock , mixedCase , " adverb " , sumokbname , synset ) ) ; return ( result . toString ( ) ) ; }
public Builder append ( char [ ] chars , int start , int length ) { write ( chars , start , length ) ; return this ; }
private BiFunction < InternalV , InternalV , InternalV > transform2 ( BiFunction < ? super ExternalV , ? super ExternalV , ? extends ExternalV > remappingFunction ) { return ( internalV1 , internalV2 ) - > writeTransformation . apply ( remappingFunction . apply ( readTransformation . apply ( internalV1 ) ,
public Object visit ( ConjunctionParallel p , LoanParser arg ) { ArrayList < Term > components = p . components ; Iterator < Term > iter = components . iterator ( ) ; Term t = iter . next ( ) ; Stm s = wrapTerm ( t . accept ( this , arg ) ) ; while ( iter . hasNext ( ) ) { s = new StmPar ( s , wrapTerm ( iter . next ( ) . accept ( this , arg ) ) ) ; } return s ; }
public void bindItemView ( MenuItemImpl item , MenuView . ItemView itemView ) { itemView . initialize ( item , 0 ) ; final ActionMenuView menuView = ( ActionMenuView ) mMenuView ; ActionMenuItemView actionItemView = ( ActionMenuItemView ) itemView ; actionItemView . setItemInvoker ( menuView ) ; }
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { if ( args . length = = 2 ) { long now = nar . time ( ) ; if ( now - lastMovementAt < minCyclesPerMovement ) { moving ( ) ; return null ; } if ( args [ 0 ] . toString ( ) . equals ( " left " ) ) { x - = 3 ; if ( x < setpoint ) { System . out . println ( " BAD: \ n " + operation . getTask ( ) . getExplanation ( ) ) ; bad ( ) ; } else { good ( ) ; } } if ( args [ 0 ] . toString ( ) . equals ( " right " ) ) { x + = 3 ; if ( x > setpoint ) { System . out . println ( " BAD: \ n " + operation . getTask ( ) . getExplanation ( ) ) ; bad ( ) ; } else { good ( ) ; } } movement + + ; lastMovementAt = now ; } return null ; }
public List < Item > getPlaylists ( final boolean sort ) throws MPDServerException { final List < String > response = mConnection . sendCommand ( MPDCommand . MPD_CMD_LISTPLAYLISTS ) ; final List < Item > result = new ArrayList < > ( response . size ( ) ) ; for ( final String [ ] pair : Tools . splitResponse ( response ) ) { if ( " playlist " . equals ( pair [ KEY ] ) ) { if ( null ! = pair [ VALUE ] & & ! STREAMS_PLAYLIST . equals ( pair [ VALUE ] ) ) { result . add ( new PlaylistFile ( pair [ VALUE ] ) ) ; } } } if ( sort ) { Collections . sort ( result ) ; } return result ; }
public final boolean onPrepareOptionsMenu ( android . view . Menu menu ) { return getSherlock ( ) . dispatchPrepareOptionsMenu ( menu ) ; }
abstract public void update ( Effect nextEffect ) ; @Override public void draw ( ) { cx = ( cx * ( 1.0f - animationLerpRate ) ) + ( x * animationLerpRate ) ; cy = ( cy * ( 1.0f - animationLerpRate ) ) + ( y * animationLerpRate ) ; cheading = ( cheading * ( 1.0f - animationLerpRate / 2.0f ) ) + ( heading * animationLerpRate / 2.0f ) ; float scale = ( float ) Math . sin ( space . getTime ( ) / 7f ) * 0.05f + 1.0f ; space . pushMatrix ( ) ; space . translate ( cx , cy ) ; space . scale ( scale * 0.8f ) ; if ( ! ( nar . memory . next_task . isEmpty ( ) ) ) { space . fill ( Color . RED . getRGB ( ) , 255 ) ; } else { space . fill ( Color . ORANGE . getRGB ( ) , 255 ) ; } space . ellipse ( 0 , 0 , 1 , 1 ) ; space . fill ( Color . BLUE . getRGB ( ) , 255 ) ; space . rotate ( ( float ) ( Math . PI / 180 f * cheading ) ) ; space . translate ( - 0.15f , 0.4f ) ; space . ellipse ( 0 , 0 , 0.2f , 0.2f ) ; space . translate ( 0.3f , 0.0f ) ; space . ellipse ( 0 , 0 , 0.2f , 0.2f ) ; space . popMatrix ( ) ; } }
char readChar ( ) ; default int readAndSkip ( char [ ] toSkip ) { int c ; do { c = read ( ) ; } while ( c ! = - 1 & & Utils . arrayContains ( toSkip , ( char ) c ) ) ; return c ; } default char readCharAndSkip ( char [ ] toSkip ) { char c ; do { c = readChar ( ) ; } while ( Utils . arrayContains ( toSkip , c ) ) ; return c ; } default CharsWrapper read ( int n ) { CharsWrapper . Builder builder = new CharsWrapper . Builder ( n ) ; for ( int i = 0 ; i < n ; i + + ) { int next = read ( ) ; if ( next = = - 1 ) { break ; } builder . append ( ( char ) next ) ; } return builder . build ( ) ; } default CharsWrapper readChars ( int n ) { char [ ] chars = new char [ n ] ; for ( int i = 0 ; i < n ; i + + ) { int next = read ( ) ; if ( next = = - 1 ) { throw ParsingException . notEnoughData ( ) ; } chars [ i ] = ( char ) next ; } return new CharsWrapper ( chars ) ; } CharsWrapper readUntil ( char [ ] stop ) ; CharsWrapper readCharsUntil ( char [ ] stop ) ; int peek ( ) ; int peek ( int n ) ; char peekChar ( ) ; char peekChar ( int n ) ; void skipPeeks ( ) ; void pushBack ( char c ) ; }
public String [ ] getCoverUrl ( AlbumInfo albumInfo ) throws Exception { String albumResponse ; List < String > albumIds ; String coverResponse ; String coverUrl ; try { albumResponse = executeGetRequest ( " http://ws.spotify.com/search/1/album.json?q= " + albumInfo . getArtist ( ) + "   " + albumInfo . getAlbum ( ) ) ; albumIds = extractAlbumIds ( albumResponse ) ; for ( String albumId : albumIds ) { coverResponse = executeGetRequest ( " https://embed.spotify.com/oembed/?url=http://open.spotify.com/album/ " + albumId ) ; coverUrl = extractImageUrl ( coverResponse ) ; if ( ! isNullOrEmpty ( coverUrl ) ) { coverUrl = coverUrl . replace ( " /cover/ " , " /640/ " ) ; return new String [ ] { coverUrl } ; } } } catch ( Exception e ) { Log . e ( SpotifyCover . class . toString ( ) , " Failed to get cover URL from Spotify " ) ; } return new String [ 0 ] ; }
public static void main ( String [ ] args ) throws Exception { new GeneticSearchApache ( ) ; }
static StampedConfig . Accumulator newAccumulator ( ) { return new StampedConfig . Accumulator ( InMemoryCommentedFormat . defaultInstance ( ) , Config . getDefaultMapCreator ( false ) ) ;
public Rope padEnd ( final int toWidth , final char padChar ) { final int toPad = toWidth - this . length ( ) ; if ( toPad < 1 ) return this ; return Rope . cat ( this ,
public void stopStreaming ( ) { oldStatus = " " ; if ( mediaPlayer = = null ) return ; mediaPlayer . stop ( ) ; stopForeground ( true ) ; }
abstract public E takeOut ( boolean removeFromNameTable ) ; abstract public E pickOut ( final String key ) ; public void printAll ( ) { for ( String k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } public void addBagObserver ( BagObserver < E > bagObserver , String title ) { this . bagObserver = bagObserver ; bagObserver . post ( toString ( ) ) ; bagObserver . setTitle ( title ) ; bagObserver . setBag ( this ) ; } protected int forgetRate ( ) { if ( forgettingRate ! = null ) { return forgettingRate . get ( ) ; } return - 1 ; } public void play ( ) { if ( bagObserver ! = null ) { bagObserver . post ( toString ( ) ) ; } } protected void reprocess ( E x ) { int r = forgetRate ( ) ; if ( r > 0 ) { BudgetFunctions . forget ( x . budget , forgetRate ( ) , RELATIVE_THRESHOLD ) ; } } public void stop ( ) { if ( bagObserver ! = null ) { bagObserver . stop ( ) ; } } public boolean putBack ( final E oldItem , boolean insertIntoNameTable ) { reprocess ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( ) { final E x = takeOut ( false ) ; if ( x ! = null ) { reprocess ( x ) ; boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else return null ; } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; public abstract Iterator < E > iterator ( ) ; }
< T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
public abstract void add ( T value ) ; public abstract boolean remove ( T value ) ; public abstract boolean contains ( T value ) ; public abstract T get ( int index ) ; public abstract int size ( ) ; public static < T > List < T > createList ( ListType type ) { switch ( type ) { case ArrayList : return new ArrayList < T > ( ) ; default : return new LinkedList < T > ( ) ; } } public static class LinkedList < T > extends List < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; @Override public void add ( T value ) { add ( new Node < T > ( value ) ) ; } private void add ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > prev = tail ; prev . nextNode = node ; node . previousNode = prev ; tail = node ; } size + + ; } @Override public boolean remove ( T value ) { Node < T > node = head ; while ( node ! = null & & ( ! node . value . equals ( value ) ) ) { node = node . nextNode ; } if ( node = = null ) return false ; if ( node . equals ( tail ) ) tail = node . previousNode ; Node < T > prev = node . previousNode ; Node < T > next = node . nextNode ; if ( prev ! = null & & next ! = null ) { prev . nextNode = next ; next . previousNode = prev ; } else if ( prev ! = null & & next = = null ) { prev . nextNode = null ; } else if ( prev = = null & & next ! = null ) { next . previousNode = null ; head = next ; } else { head = null ; } size - - ; return true ; } @Override public boolean contains ( T value ) { Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . nextNode ; } return false ; } @Override public T get ( int index ) { T result = null ; Node < T > node = head ; int i = 0 ; while ( node ! = null & & i < index ) { node = node . nextNode ; i + + ; } if ( node ! = null ) result = node . value ; return result ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . nextNode ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > previousNode = null ; private Node < T > nextNode = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( previousNode ! = null ) ? previousNode . value : " NULL " ) + "  next= " + ( ( nextNode ! = null ) ? nextNode . value : " NULL " ) ; } } } public static class ArrayList < T > extends List < T > { private static final int GROW_IN_CHUNK_SIZE = 50 ; private static final int SHRINK_IN_CHUNK_SIZE = 50 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int size = 0 ; @Override public void add ( T value ) { if ( size > = array . length ) { T [ ] temp = Arrays . copyOf ( array , size + GROW_IN_CHUNK_SIZE ) ; temp [ size + + ] = value ; array = temp ; } else { array [ size + + ] = value ; } } @Override public boolean remove ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) { for ( int j = i + 1 ; j < size ; j + + ) { array [ j - 1 ] = array [ j ] ; } array [ - - size ] = null ; if ( array . length - size > = SHRINK_IN_CHUNK_SIZE ) { T [ ] temp = Arrays . copyOf ( array , size ) ; array = temp ; } return true ; } } return false ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public T get ( int index ) { if ( index > = size ) return null ; return array [ index ] ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i + + ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } }
public static void main ( String [ ] args ) { NAR nar = new DefaultNARBuilder ( ) . build ( ) ; new NARPhysics < Rover > ( nar , new Rover ( nar ) ) { } ; nar . param ( ) . duration . set ( 50 ) ; nar . start ( 50 , 1 ) ; nar . param ( ) . noiseLevel . set ( 0 ) ; new NWindow ( " Tasks " , new TaskTree ( nar ) ) . show ( 300 , 600 ) ; }
public static boolean tooMuchTemporalStatements ( Term t ) { if ( t = = null ) { return true ; } return t . containedTemporalRelations ( ) > 1 ;
public void clearAttributes ( int beginIdx , int endIdx ) { ListIterator < AttributeRun > iter = atrun . listIterator ( ) ; AttributeRun ar ; while ( iter . hasNext ( ) ) { ar = iter . next ( ) ; if ( ! ( beginIdx > = ar . end & & endIdx > = ar . start ) ) { int s = Math . max ( beginIdx , ar . start ) ; int e = Math . min ( endIdx , ar . end ) ; if ( ar . start = = s & & ar . end = = e ) iter . remove ( ) ; else if ( ar . start = = s ) ar . start = e ; else if ( ar . end = = e ) ar . end = s ; else { AttributeRun ar2 = new AttributeRun ( ar . atype , ar . value , e , ar . end ) ; iter . add ( ar2 ) ; ar . end = s ; } } } invalidText = true ; }
public boolean contains ( T value ) { if ( array . length = = 0 ) return false ; for ( int i = 0 ; i < size ; i + + ) { T node = array [ i ] ; if ( node . equals ( value ) ) return true ; } return false ; }
Row convertFromResult ( Result result ) ; Put convertToPut ( Row row ) ; Delete convertToDelete ( Row row ) ; List < Row > convertFromResults ( Iterable < Result > results ) ; List < Put > convertToPuts ( List < Row > rows ) ; List < Delete > convertToDeletes ( List < Row > rows ) ; }
protected void plan ( Concept c , Task task , Term target , int particles , double searchDistance , char punctuation , int maxTasks ) { if ( ! implication . containsVertex ( target ) ) return ; TreeSet < ParticlePlan > plans = particlePlan ( target , searchDistance , particles ) ; int n = 0 ; for ( ParticlePlan p : plans ) { planTask ( p , c , task , target , punctuation ) ;
public void removeServiceTypeListener ( ServiceTypeListener listener ) { ServiceTypeListenerStatus status = new ServiceTypeListenerStatus ( listener , ListenerStatus . ASYNCHONEOUS ) ; _typeListeners . remove ( status ) ; }
private static boolean isCommonVariable ( final Variable v ) { String s = v . getName ( ) ; return s . charAt ( s . length ( ) - 1 ) = = '$' ; }
private void populateTree ( int [ ] nodes ) { int rootIndex = getRandom ( nodes . length ) ; int rootValue = nodes [ rootIndex ] ; Node newNode = new Node ( null , rootValue ) ; add ( newNode , true ) ; for ( int node : nodes ) { if ( node ! = rootValue ) {
private List < EventHandler > getEventHandlers ( final StatsKey key , final boolean create ) { if ( sessionEventHandlers = = null ) { return null ; } List < EventHandler > eventHandlers = null ; if ( key ! = null ) { eventHandlers = sessionEventHandlers . get ( key ) ; } if ( eventHandlers = = null & & create ) { eventHandlers = createEventHandlerList ( ) ; List < EventHandler > old = sessionEventHandlers . putIfAbsent ( key , eventHandlers ) ; if ( old ! = null ) { eventHandlers = old ; } } return eventHandlers ; }
public Concept conceptualize ( BudgetValue budget , final Term term , boolean createIfMissing ) { Concept concept = concepts . take ( term ) ; if ( ( concept = = null ) & & ( subcon ! = null ) ) { concept = subcon . take ( term ) ; if ( concept ! = null ) { concept . budget . setLastForgetTime ( memory . time ( ) ) ; memory . emit ( Events . ConceptRemember . class , concept ) ; } } if ( ( concept = = null ) & & ( createIfMissing ) ) { concept = conceptBuilder . newConcept ( budget , term , memory ) ; if ( memory . logic ! = null ) memory . logic . CONCEPT_NEW . commit ( term . getComplexity ( ) ) ; memory . emit ( Events . ConceptNew . class , concept ) ; } else if ( concept ! = null ) { BudgetFunctions . activate ( concept . budget , budget , Activating . TaskLink ) ; } else { return null ; } Concept displaced = concepts . putBack ( concept , memory . param . conceptForgetDurations . getCycles ( ) , memory ) ; if ( displaced = = null ) {
public Iterator < ? extends Item > perceive ( final Object o ) { Exception error ; try { if ( o instanceof String ) { return perceive ( ( String ) o ) ; } else if ( o instanceof Sentence ) { Sentence s = ( Sentence ) o ; return perceive ( s . term . toString ( ) + s . punctuation + "   " + s . truth . toString ( ) ) ; } else if ( o instanceof Task ) { return Iterators . forArray ( ( Task ) o ) ; } error = new IOException ( " Input unrecognized:  " + o + "  [ " + o . getClass ( ) + " ] " ) ; } catch ( Exception e ) { if ( Parameters . DEBUG ) throw e ; error = e ; } return singletonIterator ( new Echo ( Output . ERR . class , error ) ) ; }
public void configure ( Config config ) { this . config = config ; this . timestampTimeModel = getTimestampTimeModel ( true ) ; this . eventEffectiveFromTimeModel = getEventEffectiveFromTimeModel ( true ) ; this . eventEffectiveToTimeModel = getEventEffectiveToTimeModel ( true ) ; this . systemEffectiveFromTimeModel = getSystemEffectiveFromTimeModel ( true ) ; this . systemEffectiveToTimeModel = getSystemEffectiveToTimeModel ( true ) ; }
public int hashCode ( ) { int hash = 5 ; hash = 67 * hash + ( this . content ! = null ? this . content . hashCode ( ) : 0 ) ; hash = 67 * hash + this . punctuation ; hash = 67 * hash + ( this . truth ! = null ? this . truth . hashCode ( ) : 0 ) ; hash = 67 * hash + ( this . getStamp ( ) ! = null ? this . getStamp ( ) . hashCode ( ) : 0 ) ; return hash ; }
public String toLabel ( ) ; } public static enum AddOrRemove { Add , Remove } public static class TaskEvent extends InferenceEvent implements HasLabel { public final Task task ; public final AddOrRemove type ; public final String reason ; public float priority ; public TaskEvent ( Task t , long when , AddOrRemove type , String reason ) { super ( when ) ; this . task = t ; this . type = type ; this . reason = reason ; this . priority = t . getPriority ( ) ; } @Override public String toString ( ) { return " Task  " + type + "  ( " + reason + " ):  " + task . toStringExternal ( ) ; } @Override public String toLabel ( ) { return " Task  " + type + "  ( " + reason + " ): \ n " + task . name ( ) ; } } public NARTrace ( NAR n ) { super ( n , true ) ; this . nar = n ; Memory memory = nar . memory ; senses = new MultiSense ( memory . logic , memory . resource ) ; senses . setActive ( true ) ; senses . update ( memory ) ; for ( String x : senses . keySet ( ) ) { TimeSeries ch = new TimeSeries ( x , NARSwing . getColor ( x + " _EsfDF_SDF_SD " , 0.8f , 0.8f ) , chartHistorySize ) ; charts . put ( x , ch ) ; } } public void addEvent ( InferenceEvent e ) { List < InferenceEvent > timeslot = time . get ( t ) ; if ( timeslot = = null ) { timeslot = new ArrayList ( ) ; time . put ( t , timeslot ) ; } timeslot . add ( e ) ; } @Override public boolean isActive ( ) { return active ; } public void reset ( ) { time . clear ( ) ; concept . clear ( ) ; } @Override public void event ( final Class event , final Object [ ] arguments ) { if ( event = = Events . TaskAdd . class ) { onTaskAdd ( ( Task ) arguments [ 0 ] , ( String ) arguments [ 1 ] ) ; } else if ( event = = Events . TaskRemove . class ) { onTaskRemove ( ( Task ) arguments [ 0 ] , ( String ) arguments [ 1 ] ) ; } else super . event ( event , arguments ) ; } @Override public void onConceptAdd ( Concept concept ) { ConceptNew cc = new ConceptNew ( concept , t ) ; addEvent ( cc ) ; List < InferenceEvent > lc = new ArrayList ( 1 ) ; lc . add ( cc ) ; this . concept . put ( concept , lc ) ; } @Override public void onCycleStart ( long clock ) { this . t = clock ; } @Override public void onCycleEnd ( long time ) { senses . update ( nar . memory ) ; for ( Map . Entry < String , TimeSeries > e : charts . entrySet ( ) ) { String f = e . getKey ( ) ; TimeSeries ch = e . getValue ( ) ; Object value = senses . get ( f ) ; if ( value instanceof Double ) { ch . push ( time , ( ( Number ) value ) . floatValue ( ) ) ; } else if ( value instanceof Float ) { ch . push ( time , ( ( Number ) value ) . floatValue ( ) ) ; } else if ( value instanceof Integer ) { ch . push ( time , ( ( Number ) value ) . floatValue ( ) ) ; } else if ( value instanceof Long ) { ch . push ( time , ( ( Number ) value ) . floatValue ( ) ) ; } } } @Override public void onTaskAdd ( Task task , String reason ) { TaskEvent ta = new TaskEvent ( task , t , AddOrRemove . Add , reason ) ; addEvent ( ta ) ; } @Override public void onTaskRemove ( Task task , String reason ) { TaskEvent tr = new TaskEvent ( task , t , AddOrRemove . Remove , reason ) ; addEvent ( tr ) ; } @Override public void output ( Class channel , Object . . . signal ) { addEvent ( new OutputEvent ( t , channel , signal ) ) ; } public void printTime ( ) { printTime ( System . out ) ; } public void printTime ( PrintStream out ) { for ( Long w : time . keySet ( ) ) { List < InferenceEvent > events = time . get ( w ) ; if ( events . isEmpty ( ) ) { continue ; } out . println ( w + "  --------- \\ " ) ; for ( InferenceEvent e : events ) { System . out . println ( "    " + e ) ; } out . println ( w + "  ---------/ \ n " ) ; } } abstract public static class CycleTimeSeries extends TimeSeries implements Observer { private final NAR nar ; public CycleTimeSeries ( NAR n , String theName , int historySize ) { super ( theName , NARSwing . getColor ( theName , 0.9f , 1f ) , historySize ) ; this . nar = n ; n . on ( CycleEnd . class , this ) ; } public CycleTimeSeries ( NAR n , String theName , float min , float max , int historySize ) { this ( n , theName , historySize ) ; setRange ( min , max ) ; } @Override public void event ( Class event , Object [ ] arguments ) { long time = nar . time ( ) ; push ( nar . time ( ) , next ( time , nar ) ) ; } public abstract float next ( long time , NAR nar ) ; } public static class ConceptBagTimeSeries extends CycleTimeSeries { public final Mode mode ; private final Iterable < Concept > concepts ; public static enum Mode { ConceptPriorityTotal , TaskLinkPriorityMean , TermLinkPriorityMean } ; public ConceptBagTimeSeries ( NAR n , Iterable < Concept > concepts , int historySize , Mode mode ) { super ( n , " Concepts:  " + mode , historySize ) ; this . mode = mode ; this . concepts = concepts ; } @Override public float next ( long time , NAR nar ) { float r = 0 ; int numConcepts = 0 ; for ( Concept c : concepts ) { switch ( mode ) { case ConceptPriorityTotal : r + = c . getPriority ( ) ; break ; case TermLinkPriorityMean : r + = c . termLinks . getTotalPriority ( ) ; break ; case TaskLinkPriorityMean : r + = c . taskLinks . getTotalPriority ( ) ; break ; } numConcepts + + ; } switch ( mode ) { case TermLinkPriorityMean : case TaskLinkPriorityMean : if ( numConcepts > 0 ) r / = numConcepts ; break ; } return r ; } } public static class ConceptTimeSeries extends CycleTimeSeries { public final Mode mode ; private final String conceptString ; private final Term conceptTerm ; private Concept concept ; public static enum Mode { Priority , Duration , BeliefConfidenceMax } ; public ConceptTimeSeries ( NAR n , String concept , int historySize , Mode mode ) throws Narsese . InvalidInputException { super ( n , concept + " :  " + mode , 0 , 1 , historySize ) ; this . mode = mode ; this . conceptString = concept ; this . conceptTerm = new Narsese ( n ) . parseTerm ( conceptString ) ; this . concept = null ; } @Override public float next ( final long time , final NAR nar ) { if ( concept = = null ) { concept = nar . memory . concept ( conceptTerm ) ; if ( concept = = null ) { return 0 ; } } switch ( mode ) { case Priority : return concept . getPriority ( ) ; case Duration : return concept . getDurability ( ) ; case BeliefConfidenceMax : if ( concept . beliefs . size ( ) > 0 ) { return concept . beliefs . get ( 0 ) . truth . getConfidence ( ) ; } return 0 ; } return 0f ; } } }
public boolean allow ( final Sentence s ) { float conf = s . truth . getConfidence ( ) ; if ( conf > minConfidence ) return true ; return false ; }
@Test public void testDistributorProbabilities ( ) { int levels = 20 ; Distributor d = Distributor . get ( levels ) ; int [ ] count = new int [ levels ] ; double total = 0 ; for ( short x : d . order ) { count [ x ] + + ; total + + ; } List < Double > probability = new ArrayList ( levels ) ; for ( int i = 0 ; i < levels ; i + + ) { probability . add ( count [ i ] / total ) ; } List < Double > probabilityActiveAdjusted = new ArrayList ( levels ) ; double activeIncrease = 0.009 ; double dormantDecrease = ( ( 0.1 * levels ) * activeIncrease ) / ( ( 1.0 - 0.1 ) * levels ) ; for ( int i = 0 ; i < levels ; i + + ) { double p = count [ i ] / total ;
public < T > Future < T > submit ( final Class < ? > source , final Callable < T > task ) { return executor . submit ( task ) ; }
CommentedConfig createSubConfig ( ) ; static CommentedConfig of ( ConfigFormat < ? extends CommentedConfig , ? super CommentedConfig , ? super CommentedConfig > format ) { return new SimpleCommentedConfig ( format ) ; } static CommentedConfig inMemory ( ) { return new SimpleCommentedConfig ( InMemoryCommentedFormat . defaultInstance ( ) ) ; } static CommentedConfig wrap ( Map < String , Object > map , ConfigFormat < ? , ? , ? > format ) { return new SimpleCommentedConfig ( map , format ) ; } static CommentedConfig copy ( UnmodifiableConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) ) ; } static CommentedConfig copy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleCommentedConfig ( config , format ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleCommentedConfig ( config , format ) ; } }
public void post ( ) { if ( GUI . cursorChangeEnabled ) { if ( GControl . cursorIsOver ! = null ) app . cursor ( GControl . cursorIsOver . cursorOver ) ; else app . cursor ( GUI . mouseOff ) ; } if ( isGWindow ) ( ( GWinApplet ) app ) . post ( ) ; for ( GControl control : windowControls ) { if ( ( control . registeredMethods & POST_METHOD ) = = POST_METHOD ) control . post ( ) ; } synchronized ( this ) {
private void processInstanceEvent ( InstanceContentEvent instanceEvent ) { Instance instance = instanceEvent . getInstance ( ) ; boolean predictionCovered = false ; boolean trainingCovered = false ; boolean continuePrediction = instanceEvent . isTesting ( ) ; boolean continueTraining = instanceEvent . isTraining ( ) ; ErrorWeightedVote errorWeightedVote = newErrorWeightedVote ( ) ; Iterator < PassiveRule > ruleIterator = this . ruleSet . iterator ( ) ; while ( ruleIterator . hasNext ( ) ) { if ( ! continuePrediction & & ! continueTraining ) break ; PassiveRule rule = ruleIterator . next ( ) ; if ( rule . isCovering ( instance ) = = true ) { predictionCovered = true ; if ( continuePrediction ) { double [ ] vote = rule . getPrediction ( instance ) ; double error = rule . getCurrentError ( ) ; errorWeightedVote . addVote ( vote , error ) ; if ( ! this . unorderedRules ) continuePrediction = false ; } if ( continueTraining ) { if ( ! isAnomaly ( instance , rule ) ) { trainingCovered = true ; rule . updateStatistics ( instance ) ; sendInstanceToRule ( instance , rule . getRuleNumberID ( ) ) ; if ( ! this . unorderedRules ) continueTraining = false ; } } } } if ( predictionCovered ) { ResultContentEvent rce = newResultContentEvent ( errorWeightedVote . computeWeightedVote ( ) , instanceEvent ) ; resultStream . put ( rce ) ; } else if ( instanceEvent . isTesting ( ) ) { double [ ] vote = defaultRule . getPrediction ( instance ) ; ResultContentEvent rce = newResultContentEvent ( vote , instanceEvent ) ; resultStream . put ( rce ) ; } if ( ! trainingCovered & & instanceEvent . isTraining ( ) ) {
public static Term make ( Term [ ] argList ) { return make ( argList , TemporalRules . ORDER_NONE ) ; }
private static Term parseAtomicTerm ( String s0 ) throws InvalidInputException { String s = s0 . trim ( ) ; if ( s . length ( ) = = 0 ) { throw new InvalidInputException ( " missing term " ) ; } if ( s . contains ( "   " ) ) { throw new InvalidInputException ( " invalid term " ) ; } char c = s . charAt ( 0 ) ; if ( c = = Symbols . INTERVAL_PREFIX ) { return new Interval ( s ) ; } if ( Variable . containVar ( s ) ) { return new Variable ( s ) ;
boolean supportsType ( Class < ? > type ) ; Map < String , Object > valueMap ( ) ; }
public boolean contains ( T value ) { return ( getNode ( value ) ! = null ) ; }
public SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) { throw new UnsupportedOperationException ( ) ; }
public final boolean putBack ( final E oldItem , final boolean insertIntoNameTable ) { reprocess ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; }
private boolean isConnectedToWIFI ( final Bundle bundle ) { final String potentialSSID = bundle . getString ( ConnectivityManager . EXTRA_EXTRA_INFO ) ; final String hostPreferenceName = potentialSSID . substring ( 1 , potentialSSID . length ( ) - 1 ) + " hostname " ; final String hostname = mSettings . getString ( hostPreferenceName , null ) ; return isLinkedToHostname ( hostname ) ; }
void fillWriteBuffer ( boolean optimizeGets ) ; void transitionWriteItem ( ) ; Operation getCurrentReadOp ( ) ; Operation removeCurrentReadOp ( ) ; Operation getCurrentWriteOp ( ) ; Operation removeCurrentWriteOp ( ) ; boolean hasReadOp ( ) ; boolean hasWriteOp ( ) ; void addOp ( Operation op ) ; void insertOp ( Operation o ) ; int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; boolean isAuthenticated ( ) ; long lastReadDelta ( ) ; void completedRead ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; }
public void addTab ( ActionBar . Tab tab , boolean setSelected ) { TabView tabView = createTabView ( tab , false ) ; mTabLayout . addView ( tabView , new IcsLinearLayout . LayoutParams ( 0 , LayoutParams . MATCH_PARENT , 1 ) ) ; if ( mTabSpinner ! = null ) { ( ( TabAdapter ) mTabSpinner . getAdapter ( ) ) . notifyDataSetChanged ( ) ; } if ( setSelected ) { tabView . setSelected ( true ) ; } if ( mAllowCollapse ) { requestLayout ( ) ;
public void storePartnership ( ) throws OpenAS2Exception { final String sFilename = getFilename ( ) ; if ( ! attrs ( ) . containsKey ( ATTR_DISABLE_BACKUP ) ) { final File aBackupFile = _getUniqueBackupFile ( sFilename ) ; if ( LOGGER . isWarnEnabled ( ) ) LOGGER . info ( " backing up  " + sFilename + "  to  " + aBackupFile . getName ( ) ) ; final File aSourceFile = new File ( sFilename ) ; AS2IOHelper . getFileOperationManager ( ) . renameFile ( aSourceFile , aBackupFile ) ; } final IMicroDocument aDoc = new MicroDocument ( ) ; final IMicroElement eRoot = aDoc . appendElement ( " partnerships " ) ; for ( final IPartner aPartner : getAllPartners ( ) ) { final IMicroElement ePartner = eRoot . appendElement ( " partner " ) ; for ( final Map . Entry < String , String > aAttr : aPartner ) ePartner . setAttribute ( aAttr . getKey ( ) , aAttr . getValue ( ) ) ; } for ( final Partnership aPartnership : getAllPartnerships ( ) ) { final IMicroElement ePartnership = eRoot . appendElement ( " partnership " ) ; ePartnership . setAttribute ( ATTR_PARTNERSHIP_NAME , aPartnership . getName ( ) ) ; final IMicroElement eSender = ePartnership . appendElement ( " sender " ) ; for ( final Map . Entry < String , String > aAttr : aPartnership . getAllSenderIDs ( ) . entrySet ( ) ) eSender . setAttribute ( aAttr . getKey ( ) , aAttr . getValue ( ) ) ; final IMicroElement eReceiver = ePartnership . appendElement ( " receiver " ) ; for ( final Map . Entry < String , String > aAttr : aPartnership . getAllReceiverIDs ( ) . entrySet ( ) ) eReceiver . setAttribute ( aAttr . getKey ( ) , aAttr . getValue ( ) ) ; for ( final Map . Entry < String , String > aAttr : aPartnership . getAllAttributes ( ) . entrySet ( ) ) ePartnership . appendElement ( " attribute " ) . setAttribute ( " name " , aAttr . getKey ( ) ) . setAttribute ( " value " , aAttr . getValue ( ) ) ; } if ( MicroWriter . writeToFile ( aDoc , new File ( sFilename ) ) . isFailure ( ) ) throw new OpenAS2Exception ( " Failed to write to file  " + sFilename ) ;
public static int [ ] sort ( double [ ] array ) { int [ ] index = new int [ array . length ] ; array = ( double [ ] ) array . clone ( ) ; for ( int i = 0 ; i < index . length ; i + + ) { index [ i ] = i ; if ( Double . isNaN ( array [ i ] ) ) { array [ i ] = Double . MAX_VALUE ; } } quickSort ( array , index , 0 , array . length - 1 ) ; return index ; }
public void byteMessageOnlyValid ( ) throws Exception { new Expectations ( ) { { config . getString ( MorphlineTranslator . ENCODING_MSG ) ; result = " UTF-16 " ; config . getString ( MorphlineTranslator . MORPHLINE ) ; result = getResourcePath ( MORPHLINE_FILE ) ; config . getString ( MorphlineTranslator . MORPHLINE_ID ) ; result = " encoding-message " ; config . getStringList ( MorphlineTranslator . FIELD_NAMES ) ; result = Lists . newArrayList ( " int " , " str " , " float " ) ; config . getStringList ( MorphlineTranslator . FIELD_TYPES ) ; result = Lists . newArrayList ( " int " , " string " , " float " ) ; } } ; byteMorphline . configure ( config ) ; String message = " \ u16b7 " ; Iterable < Row > result = byteMorphline . translate ( null , message . getBytes ( " UTF-16 " ) ) ; Row row = result . iterator ( ) . next ( ) ; Assert . assertNotNull ( " Row is null " , result ) ; Assert . assertEquals ( " Invalid number of fields " , 3 , row . length ( ) ) ; Assert . assertEquals ( " Invalid field value " , 123 , row . get ( 0 ) ) ; Assert . assertEquals ( " Invalid field value " , message , row . get ( 1 ) ) ; Assert . assertEquals ( " Invalid field value " , 234 F , row . get ( 2 ) ) ; }
public void testIntOverflow ( ) { try { int b = tu . decodeInt ( oversizeBytes ) ;
public SASLMechsOperation saslMechs ( OperationCallback cb ) { return new SASLMechsOperationImpl ( cb ) ; }
Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public void addLibrary ( String libraryClassname , File file ) { try {
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public void next ( ) { Log . d ( TAG , " StreamingService.next() " ) ; MPD mpd = app . oMPDAsyncHelper . oMPD ; try { mpd . next ( ) ; } catch ( MPDServerException e ) { } stopStreaming ( ) ; beginStreaming ( ) ; }
protected static Term [ ] termArray ( final Term . . . t ) { return t ; }
public void testDeletes ( ) throws Exception { truncate ( ) ; RandomOutput zkOutput = new ZooKeeperOutput ( ) ; zkOutput . configure ( config ) ; Row row1 = new RowWithSchema ( schema , " hello " , 100 , 1000L , true , 1.0f , - 1.0 ) ; Row row2 = new RowWithSchema ( schema , " world " , - 100 , - 1000L , false , - 1.0f , 1.0 ) ; List < Row > upsertPlan = Lists . newArrayList ( PlannerUtils . setMutationType ( row1 , MutationType . UPSERT ) , PlannerUtils . setMutationType ( row2 , MutationType . UPSERT ) ) ; zkOutput . applyRandomMutations ( upsertPlan ) ; Row delete = new RowWithSchema ( keySchema , " hello " , 100 , 1000L ) ; List < Row > deletePlan = Lists . newArrayList ( PlannerUtils . setMutationType ( delete , MutationType . DELETE ) ) ; zkOutput . applyRandomMutations ( deletePlan ) ; Row filter1 = new RowWithSchema ( keySchema , " hello " , 100 , 1000L ) ; Row filter2 = new RowWithSchema ( keySchema , " world " , - 100 , - 1000L ) ; List < Row > filters = Lists . newArrayList ( filter1 , filter2 ) ; List < Row > rows = Lists . newArrayList ( zkOutput . getExistingForFilters ( filters ) ) ; assertEquals ( rows . size ( ) , 1 ) ; assertEquals ( rows . get ( 0 ) , row2 ) ; }
void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; Set < String > listSaslMechanisms ( ) ; }
public Attribute classAttribute ( ) { return this . instanceInformation . classAttribute ( ) ; }
public void mouseClicked ( java . awt . event . MouseEvent evt ) { jLabel7MouseClicked ( evt ) ; }
C createConcurrentConfig ( ) ; boolean supportsComments ( ) ; default boolean supportsType ( Class < ? > type ) { return InMemoryFormat . DEFAULT_PREDICATE . test ( type ) ; } default boolean isInMemory ( ) { return false ; } default void initEmptyFile ( Path f ) throws IOException { initEmptyFile ( ( ) - > Files . newBufferedWriter ( f ) ) ; } default void initEmptyFile ( File f ) throws IOException { initEmptyFile ( f . toPath ( ) ) ; } default void initEmptyFile ( WriterSupplier ws ) throws IOException { } }
< T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public static void usePre35Fonts ( ) { globalFont = new Font ( " Dialog " , Font . PLAIN , 10 ) ; numericLabelFont = new Font ( " DialogInput " , Font . BOLD , 12 ) ; }
private void add ( Node node ) { if ( root = = null ) { root = node ; } else { addToSubtree ( root , node ) ; } size + + ; }
public void recusriveExponentiationTest ( ) { List < Integer > baseList = Arrays . asList ( 1 , 2 , 4 , 6 , 8 , 17 , 24 ) ; List < Integer > exponentList = Arrays . asList ( 1000 , 27 , 14 , 11 , 10 , 7 , 5 ) ; List < Integer > expectedResultList = Arrays . asList ( 1 , 134217728 , 268435456 , 362797056 , 1073741824 , 410338673 , 7962624 ) ; for ( int i = 0 ; i < expectedResultList . size ( ) ; i + + ) assertEquals ( expectedResultList . get ( i ) , Exponentiation . recursiveExponentiation ( baseList . get ( i ) , exponentList . get ( i ) ) ) ;
public void testTranslateWithRepartition ( ) { int numPartitions = 10 ; Config stepConfig = ConfigFactory . empty ( ) . withValue ( StreamingStep . INPUT_TYPE , ConfigValueFactory . fromMap ( new HashMap < String , Object > ( ) ) . withValue ( " type " , ConfigValueFactory . fromAnyRef ( " com.cloudera.labs.envelope.run.TestStreamingStep$PrepartitionedStreamInput " ) ) . withValue ( " repartition " , ConfigValueFactory . fromMap ( new HashMap < String , Object > ( ) ) . withValue ( " partitions " , ConfigValueFactory . fromAnyRef ( Integer . toString ( numPartitions ) ) ) ) . withValue ( " translator " , ConfigValueFactory . fromMap ( new HashMap < String , Object > ( ) ) . withValue ( " type " , ConfigValueFactory . fromAnyRef ( " com.cloudera.labs.envelope.translate.DummyTranslator " ) ) ) ) ; StreamingStep ss = new StreamingStep ( " TestRepartition " ) ; ss . configure ( stepConfig ) ; Config inputConfig = ConfigFactory . empty ( ) . withValue ( " batch " , ConfigValueFactory . fromMap ( new HashMap < String , Object > ( ) ) . withValue ( " size " , ConfigValueFactory . fromAnyRef ( " 1000 " ) ) . withValue ( " partitions " , ConfigValueFactory . fromAnyRef ( Integer . toString ( 2 * numPartitions ) ) ) ) ; PrepartitionedStreamInput tsi = new PrepartitionedStreamInput ( ) ; tsi . configure ( inputConfig ) ; JavaRDD < String > rdd = tsi . generateRDD ( ) ; assertEquals ( " Stream input was pre-partitioned with wrong number of partitions " , 2 * numPartitions , rdd . getNumPartitions ( ) ) ; Dataset < Row > translated = ss . translate ( rdd ) ; assertEquals ( numPartitions , translated . rdd ( ) . getNumPartitions ( ) ) ; }
SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; }
Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public void update ( long time ) { if ( ! concept . beliefs . isEmpty ( ) ) { List < Task > bbT = concept . getBeliefs ( ) ; List < Sentence > bb = new ArrayList < Sentence > ( ) ; for ( Task ts : bbT ) { bb . add ( ts . sentence ) ; } beliefChart . update ( time , bb ) ; subtitle . setText ( " truth:  " + bb . get ( 0 ) . truth . toString ( ) ) ; beliefTime . setVisible ( beliefTime . update ( time , bb ) ) ; } else { subtitle . setText ( " " ) ; if ( ! concept . questions . isEmpty ( ) ) subtitle . setText ( " ?(question) " ) ; beliefTime . setVisible ( false ) ; } if ( ! concept . questions . isEmpty ( ) ) questionChart . update ( unmodifiableList ( concept . questions ) ) ; if ( ! concept . desires . isEmpty ( ) ) { String s = subtitle . getText ( ) ; subtitle . setText ( s + ( s . equals ( " " ) ? " " : "   " ) + " desire:  " + concept . desires . get ( 0 ) . sentence . truth . toString ( ) ) ; ArrayList < Sentence > desir = new ArrayList ( ) ; for ( Task ts : concept . desires ) { desir . add ( ts . sentence ) ; } desireChart . update ( time , unmodifiableList ( desir ) ) ; } updateUI ( ) ; }
public void disconnect ( ) throws MPDServerException { mpdConnection . sendCommand ( false , MPD_CMD_CLOSE ) ; mpdConnection . disconnect ( ) ; mpdIdleConnection . sendCommand ( false , MPD_CMD_CLOSE ) ; mpdIdleConnection . disconnect ( ) ; }
public DispositionOptions setMICAlg ( @Nullable final ECryptoAlgorithmSign . . . aMICAlgs ) { m_aMICAlgs . clear ( ) ; if ( aMICAlgs ! = null ) for ( final ECryptoAlgorithmSign eMICAlg : aMICAlgs ) if ( eMICAlg ! = null ) m_aMICAlgs . add ( eMICAlg ) ; return this ; }
public OperationFuture < Boolean > replace ( String key , int exp , Object o ) { return asyncStore ( StoreType . replace , key , exp , o , transcoder ) ; }
protected String convertToString ( Object value ) { if ( value = = null ) { return I18N . NOT_SET ;
public int compareTo ( Item o ) { if ( o instanceof Music ) { Music om = ( Music ) o ; int compare ; if ( songId ! = om . songId ) { return songId < om . songId ? - 1 : 1 ; } compare = compare ( album , om . album ) ; if ( 0 ! = compare ) { return compare ; } if ( MPD . sortAlbumsByYear ( ) & & date ! = om . date ) { return date < om . date ? - 1 : 1 ; } if ( MPD . sortByTrackNumber ( ) ) { if ( disc ! = om . disc ) { return disc < om . disc ? - 1 : 1 ; } if ( track ! = om . track ) { return track < om . track ? - 1 : 1 ; } if ( time ! = om . time ) { return time < om . time ? - 1 : 1 ; } } compare = compare ( getTitle ( ) , om . getTitle ( ) ) ; if ( 0 ! = compare ) { return compare ; } compare = compare ( name , om . name ) ; if ( 0 ! = compare ) { return compare ; } return compare ( fullpath , om . fullpath ) ; } return super . compareTo ( o ) ; }
protected Task inlineConjunction ( Task t , final Conjunction c ) { ArrayDeque < Term > inlined = new ArrayDeque ( ) ; boolean modified = false ; if ( c . operator ( ) = = Symbols . NativeOperator . SEQUENCE ) { Term prev = null ; for ( Term e : c . term ) { if ( ! isPlanTerm ( e ) ) { if ( graph . isPlannable ( e ) ) { TreeSet < ParticlePlan > plans = graph . particlePlan ( e , inlineSearchDepth , inlineParticles ) ; if ( plans . size ( ) > 0 ) { ParticlePlan pp = plans . first ( ) ; List < Term > seq = pp . sequence ; desire = TruthFunctions . union ( desire , pp . truth ) ; inlined . addAll ( seq ) ; modified = true ; } else { end ( ) ; } } else { end ( ) ; } } else { inlined . add ( e ) ; } prev = e ; } } if ( inlined . size ( ) > 0 ) { while ( inlined . peekLast ( ) instanceof Interval ) { inlined . removeLast ( ) ; modified = true ; } } if ( inlined . isEmpty ( ) ) end ( ) ; if ( modified ) { Conjunction nc = c . cloneReplacingTerms ( inlined . toArray ( new Term [ inlined . size ( ) ] ) ) ; t = t . clone ( t . sentence . clone ( nc ) ) ; } return t ; }
private static boolean runTests ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " Array= " ) ; unsorted = new Integer [ ARRAY_SIZE ] ; for ( int i = 0 ; i < unsorted . length ; i + + ) { Integer j = RANDOM . nextInt ( unsorted . length * 10 ) ; boolean found = true ; while ( found ) { found = false ; for ( int k = 0 ; k < i ; k + + ) { int l = unsorted [ k ] ; if ( j = = l ) { found = true ; j = RANDOM . nextInt ( unsorted . length * 10 ) ; break ; } } } unsorted [ i ] = j ; builder . append ( j ) . append ( ',' ) ; } builder . append ( '\n' ) ; string = builder . toString ( ) ; System . out . println ( string ) ; boolean passed = true ; passed = testHeap ( ) ; if ( ! passed ) { System . err . println ( " Heap failed. " ) ; return false ; } passed = testBST ( ) ; if ( ! passed ) { System . err . println ( " BST failed. " ) ; return false ; } passed = testGraph ( ) ; if ( ! passed ) { System . err . println ( " Graph failed. " ) ; return false ; } passed = testHashMap ( ) ; if ( ! passed ) { System . err . println ( " Hash Map failed. " ) ; return false ; } passed = testLinkedList ( ) ; if ( ! passed ) { System . err . println ( " Linked List failed. " ) ; return false ; } passed = testMatrix ( ) ; if ( ! passed ) { System . err . println ( " Matrix failed. " ) ; return false ; } passed = testPatriciaTrie ( ) ; if ( ! passed ) { System . err . println ( " Patricia Trie Failed failed. " ) ; return false ; } passed = testQueue ( ) ; if ( ! passed ) { System . err . println ( " Queue failed. " ) ; return false ; } passed = testRadixTree ( ) ; if ( ! passed ) { System . err . println ( " Radix Tree failed. " ) ; return false ; } passed = testSegmentTree ( ) ; if ( ! passed ) { System . err . println ( " Segment Tree failed. " ) ; return false ; } passed = testSkipList ( ) ; if ( ! passed ) { System . err . println ( " Skip List failed. " ) ; return false ; } passed = testSplayTree ( ) ; if ( ! passed ) { System . err . println ( " Splay Tree failed. " ) ; return false ; } passed = testStack ( ) ; if ( ! passed ) { System . err . println ( " Stack failed. " ) ; return false ; } passed = testSuffixTree ( ) ; if ( ! passed ) { System . err . println ( " Suffix Tree failed. " ) ; return false ; } passed = testSuffixTrie ( ) ; if ( ! passed ) { System . err . println ( " Suffix Trie failed. " ) ; return false ; } passed = testTreap ( ) ; if ( ! passed ) { System . err . println ( " Treap failed. " ) ; return false ; } passed = testTrie ( ) ; if ( ! passed ) { System . err . println ( " Trie failed. " ) ; return false ; } passed = testTrieMap ( ) ; if ( ! passed ) { System . err . println ( " Trie Map failed. " ) ; return false ; } return true ; }
private void writeString ( String str ) throws IOException { StringBuilder sb = new StringBuilder ( ) ; sb . append ( '"' ) ; for ( int i = 0 ; i < str . length ( ) ; i + + ) { char c = str . charAt ( i ) ; addEscaped ( c , sb ) ; } sb . append ( '"' ) ; write ( sb . toString ( ) ) ; }
List < DataRecorder > getDataRecorders ( ) ; long getHits ( ) ; long getFirstHitStamp ( ) ; long getLastHitStamp ( ) ; long getCommits ( ) ; double getFirst ( ) ; double getLast ( ) ; double getMin ( ) ; double getMax ( ) ; double getSum ( ) ; Object getField ( String name ) ; DataSet collectData ( ) ; DataSet drainData ( ) ; void restore ( DataSet dataSet ) ; void track ( Tracker tracker , long now ) ; void update ( Tracker tracker , long now ) ; void clear ( ) ; }
public void parseAndLoadData ( File f ) throws Exception { XMLInputFactory factory = XMLInputFactory . newInstance ( ) ; XMLStreamReader parser = factory . createXMLStreamReader ( new FileInputStream ( f ) ) ; int depth = 0 ; for ( ; ; ) { int event = parser . next ( ) ;
protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory m ) { int numArgs = args . length ; if ( args [ args . length - 1 ] . equals ( Term . SELF ) ) numArgs - - ; if ( numArgs < 1 ) { throw new RuntimeException ( " Requires at least 1 arguments " ) ; } if ( numArgs < 2 & & ! ( this instanceof Javascript ) ) { throw new RuntimeException ( " Requires at least 2 arguments " ) ; } Term lastTerm = args [ numArgs - 1 ] ; boolean variable = lastTerm instanceof Variable ; if ( ! variable & & ! ( this instanceof Javascript ) ) { throw new RuntimeException ( " output can not be specified " ) ; } int numParam = numArgs - 1 ; if ( numParam = = 0 ) { numParam = 1 ; } Term [ ] x = new Term [ numParam ] ; System . arraycopy ( args , 0 , x , 0 , numParam ) ; Term y ; y = function ( m , x ) ; if ( y = = null ) { return null ; } if ( numArgs = = 1 & & this instanceof Javascript ) { return null ; } Variable var = new Variable ( " $1 " ) ; operation = ( Operation ) operation . setComponent ( 0 , ( ( CompoundTerm ) operation . getSubject ( ) ) . setComponent ( numArgs - 1 , y , m ) , m ) ; ImageExt ing = ( ImageExt ) ImageExt . make ( ( Product ) operation . getSubject ( ) , operation . getPredicate ( ) , ( short ) ( numArgs - 1 ) ) ; Inheritance inh = Inheritance . make ( y , ing ) ; Term actual = inh ; float confidence = 0.99f ; if ( variable ) { return Lists . newArrayList (
public static HashMap readKeywordMap ( String dir ) { if ( keywordMap = = null ) { keywordMap = new HashMap ( ) ; } if ( keywordMap . isEmpty ( ) ) { System . out . println ( " INFO in LanguageFormatter.readKeywordMap(): filling keywordMap " ) ; String fname = null ; String line ; HashMap newLine ; ArrayList languageKeyArray = new ArrayList ( ) ; String key ; int i ; int count ; BufferedReader br ; try { File dirFile = new File ( dir ) ; File file = new File ( dirFile , " language.txt " ) ; fname = file . getCanonicalPath ( ) ; br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( fname ) , " UTF-8 " ) ) ; } catch ( IOException ioe ) { System . out . println ( " Error in LanguageFormatter.readKeywordMap(): Error opening file  " + fname ) ; return keywordMap ; } try { br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( fname ) , " UTF-8 " ) ) ; do { line = br . readLine ( ) ; if ( line ! = null ) { if ( line . startsWith ( " en| " ) ) { i = 0 ; while ( line . indexOf ( '|' , i ) > 0 ) { languageKeyArray . add ( line . substring ( i , line . indexOf ( '|' , i ) ) ) ; i = line . indexOf ( '|' , i ) + 1 ; } languageKeyArray . add ( line . substring ( i , i + 2 ) ) ; } else if ( line . startsWith ( " ; " ) ) { } else if ( line . length ( ) = = 0 ) { } else if ( line . indexOf ( '|' ) > - 1 ) { newLine = new HashMap ( ) ; key = line . substring ( 0 , line . indexOf ( '|' ) ) ; i = 0 ; count = 0 ; while ( line . indexOf ( '|' , i ) > 0 ) { newLine . put ( languageKeyArray . get ( count ) , line . substring ( i , line . indexOf ( '|' , i ) ) ) ; i = line . indexOf ( '|' , i ) + 1 ; count + + ; } newLine . put ( languageKeyArray . get ( count ) , line . substring ( i , line . length ( ) ) ) ; keywordMap . put ( key . intern ( ) , newLine ) ; } else { System . out . println ( " INFO in LanguageFormatter.keywordMap(): Unrecognized line in language.txt:  " + line ) ; } } } while ( line ! = null ) ; } catch ( IOException ioe ) { try { br . close ( ) ; } catch ( IOException e ) { System . out . println ( " Error in LanguageFormatter.keywordMap(): Error closing file  " + fname ) ; } return ( keywordMap ) ; } try { br . close ( ) ; } catch ( IOException e ) { System . out . println ( " Error  in LanguageFormatter.readKeywordMap(): Error closing file  " + fname ) ; } } return ( keywordMap ) ; }
public static void main ( String [ ] args ) { NAR n = new NAR ( ) ; new TextInput ( n , " <0 --> num>. %1.00;0.90% {0 : 1} " ) ; new TextInput ( n , " <<$1 --> num> ==> <(*,$1) --> num>>. %1.00;0.90% {0 : 2} " ) ; new TextInput ( n , " <(*,(*,(*,0))) --> num>?  {0 : 3} " ) ; n . run ( 220 ) ; Window w = new Window ( " GraphPanel " , new JGraphXGraphPanel ( n ) ) { @Override protected void close ( ) { } } ; w . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; w . setSize ( 1200 , 900 ) ; w . setVisible ( true ) ; }
public static < T extends Comparable < T > > T [ ] sort ( T [ ] unsorted ) { int length = unsorted . length ; for ( int i = 1 ; i < length ; i + + ) { sort ( i , unsorted ) ; } return unsorted ; }
public void restore ( final DataSet dataSet ) { clearState ( ) ; restoreState ( dataSet ) ;
public void onClick ( DialogInterface dialog , int whichButton ) { EditText nameEdit = ( EditText ) view . findViewById ( R . id . name_edit ) ; EditText urlEdit = ( EditText ) view . findViewById ( R . id . url_edit ) ; String name = null = = nameEdit ? null : nameEdit . getText ( ) . toString ( ) . trim ( ) ; String url = null = = urlEdit ? null : urlEdit . getText ( ) . toString ( ) . trim ( ) ; if ( null ! = name & & name . length ( ) > 0 & & null ! = url & & url . length ( ) > 0 ) { if ( index > = 0 & & index < streams . size ( ) ) { streams . remove ( index ) ; } streams . add ( new Stream ( name , url , false ) ) ; Collections . sort ( streams ) ; items = streams ; saveStreams ( ) ; if ( streamUrlToAdd = = null ) { UpdateList ( ) ; } else { Toast . makeText ( getActivity ( ) , R . string . streamSaved , Toast . LENGTH_SHORT ) . show ( ) ; } } if ( streamUrlToAdd ! = null ) { getActivity ( ) . finish ( ) ;
public void testPackedLong ( ) { assertEquals ( " [1] " , Arrays . toString ( tu . encodeLong ( 1 ) ) ) ; }
private Formula renameVariables ( Map topLevelVars , Map scopedRenames , Map allRenames ) { try { if ( this . listP ( ) ) { if ( this . empty ( ) ) { return this ; } String arg0 = this . car ( ) ; if ( isQuantifier ( arg0 ) ) { Map newScopedRenames = new HashMap ( scopedRenames ) ; String oldVars = this . cadr ( ) ; Formula oldVarsF = new Formula ( ) ; oldVarsF . read ( oldVars ) ; String newVars = " " ; while ( ! ( oldVarsF . empty ( ) ) ) { String oldVar = oldVarsF . car ( ) ; String newVar = newVar ( oldVar ) ; newScopedRenames . put ( oldVar , newVar ) ; allRenames . put ( newVar , oldVar ) ; newVars + = ( "   " + newVar ) ; oldVarsF = oldVarsF . cdrAsFormula ( ) ; } newVars = ( " ( " + newVars . trim ( ) + " ) " ) ; String arg2 = this . caddr ( ) ; Formula arg2F = new Formula ( ) ; arg2F . read ( arg2 ) ; String newArg2 = arg2F . renameVariables ( topLevelVars , newScopedRenames , allRenames ) . theFormula ; String theNewFormula = ( " ( " + arg0 + "   " + newVars + "   " + newArg2 + " ) " ) ; Formula newF = new Formula ( ) ; newF . read ( theNewFormula ) ; return newF ; } Formula arg0F = new Formula ( ) ; arg0F . read ( arg0 ) ; String newArg0 = arg0F . renameVariables ( topLevelVars , scopedRenames , allRenames ) . theFormula ; String newRest = this . cdrAsFormula ( ) . renameVariables ( topLevelVars , scopedRenames , allRenames ) . theFormula ; Formula newRestF = new Formula ( ) ; newRestF . read ( newRest ) ; String theNewFormula = newRestF . cons ( newArg0 ) . theFormula ; Formula newF = new Formula ( ) ; newF . read ( theNewFormula ) ; return newF ; } if ( isVariable ( this . theFormula ) ) { String rnv = ( String ) scopedRenames . get ( this . theFormula ) ; if ( ! ( isNonEmptyString ( rnv ) ) ) { rnv = ( String ) topLevelVars . get ( this . theFormula ) ; if ( ! ( isNonEmptyString ( rnv ) ) ) { rnv = newVar ( this . theFormula ) ; topLevelVars . put ( this . theFormula , rnv ) ; allRenames . put ( rnv , this . theFormula ) ; } } Formula newF = new Formula ( ) ; newF . read ( rnv ) ; return newF ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return this ; }
public Object visit ( SentDelay p , LoanParser arg ) { int delay = p . integer_ . intValue ( ) ; for ( int i = 0 ; i < delay ; i + + ) arg . getMemory ( ) . cycle ( ) ; return null ; }
public void testHiveEnabledConfiguration ( ) { Map < String , Object > sparamMap = new HashMap < > ( ) ; sparamMap . put ( Contexts . SPARK_CONF_PROPERTY_PREFIX + " spark.sql.warehouse.dir " , " target/spark-warehouse " ) ; Contexts . initialize ( ConfigFactory . parseMap ( sparamMap ) , Contexts . ExecutionMode . BATCH ) ; Contexts . getSparkSession ( ) . sql ( " CREATE TABLE testHiveEnabled(d int) " ) ; Contexts . getSparkSession ( ) . sql ( " SELECT count(*) from testHiveEnabled " ) ; Contexts . getSparkSession ( ) . sql ( " DROP TABLE testHiveEnabled " ) ; sparamMap . put ( Contexts . SPARK_SESSION_ENABLE_HIVE_SUPPORT , " true " ) ; Contexts . initialize ( ConfigFactory . parseMap ( sparamMap ) , Contexts . ExecutionMode . BATCH ) ; Contexts . getSparkSession ( ) . sql ( " CREATE TABLE testHiveEnabled(d int) " ) ; Contexts . getSparkSession ( ) . sql ( " SELECT count(*) from testHiveEnabled " ) ; Contexts . getSparkSession ( ) . sql ( " DROP TABLE testHiveEnabled " ) ; }
private static boolean executePrecondition ( final DerivationContext nal , ExecutablePrecondition precon , final Concept concept , final Sentence projectedGoal , final Task task ) { if ( precon . bestop ! = null & & precon . bestop_truthexp > nal . narParameters . DECISION_THRESHOLD ) { final Sentence createdSentence = new Sentence ( precon . bestop , Symbols . JUDGMENT_MARK , precon . bestop_truth , projectedGoal . stamp ) ; final Task t = new Task ( createdSentence , new BudgetValue ( 1.0f , 1.0f , 1.0f , nal . narParameters ) , Task . EnumType . DERIVED ) ; if ( ! task . sentence . stamp . evidenceIsCyclic ( ) ) { if ( ! executeOperation ( nal , t ) ) { concept . memory . emit ( Events . UnexecutableGoal . class , task , concept , nal ) ; return false ; } return true ; } } return false ; }
private String processWordForProlog ( String word ) { String result = new String ( word ) ; int start = 0 ; while ( result . indexOf ( " ' " , start ) > - 1 ) { int i = 0 ; i = result . indexOf ( " ' " , start ) ; if ( i = = 0 ) result = " '' " + result . substring ( i + 1 ) ; else result = result . substring ( 0 , i ) + " \\ ' " + result . substring ( i + 1 ) ; start = i + 2 ; } return result ; }
static FileConfigBuilder < Config > builder ( File file , ConfigFormat < ? > format ) { return builder ( file . toPath ( ) , format ) ; }
long getOpQueueMaxBlockTime ( ) ; ExecutorService getListenerExecutorService ( ) ; boolean isDefaultExecutorService ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; boolean isDaemon ( ) ; boolean useNagleAlgorithm ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; int getReadBufSize ( ) ; HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; MetricType enableMetrics ( ) ; MetricCollector getMetricCollector ( ) ; long getAuthWaitTime ( ) ; }
public int hashCode ( ) { return Objects . hash ( integer , decimal , string , stringList , objList , nestedObjList2 , nestedObjList3 , config , subObject ) ;
protected void refreshListColorCacheHint ( ) { if ( list ! = null ) { if ( app . isLightThemeSelected ( ) ) {
public void testGetObjectType ( ) { Assert . assertEquals ( " object type " , MemcachedClient . class , new MemcachedClientFactoryBean ( ) . getObjectType ( ) ) ; }
public void addInput ( String text ) { text = text . trim ( ) ; final Parser narsese = new Narsese ( this ) ; if ( addMultiLineInput ( text ) ) { return ; } if ( text . startsWith ( " \ ' " ) | | text . startsWith ( " // " ) | | text . trim ( ) . length ( ) < = 0 ) { if ( text . trim ( ) . length ( ) > 0 ) { emit ( org . opennars . io . events . OutputHandler . ECHO . class , text ) ; } return ; } try { if ( addCommand ( text ) ) { return ; } } catch ( IOException ex ) { throw new IllegalStateException ( " I/O command failed:  " + text , ex ) ; } Task task = null ; try { task = narsese . parseTask ( text ) ; } catch ( final Parser . InvalidInputException e ) { if ( MiscFlags . SHOW_INPUT_ERRORS ) { emit ( ERR . class , e ) ; } if ( ! MiscFlags . INPUT_ERRORS_CONTINUE ) { throw new IllegalStateException ( " Invalid input:  " + text , e ) ; } return ; } if ( dispatchToSensoryChannel ( task ) ) return ; this . memory . inputTask ( this , task ) ; }
public Node < T > createNewNode ( Node < T > parent , T id ) { return ( new RedBlackNode < T > ( parent , id , BLACK ) ) ; }
protected static Clustering cleanUpKMeans ( Clustering kMeansResult , ArrayList < CFCluster > microclusters ) { int k = kMeansResult . size ( ) ; CFCluster [ ] converted = new CFCluster [ k ] ; for ( CFCluster mc : microclusters ) { double minDistance = Double . MAX_VALUE ; int closestCluster = 0 ; for ( int i = 0 ; i < k ; i + + ) { double distance = distance ( kMeansResult . get ( i ) . getCenter ( ) , mc . getCenter ( ) ) ; if ( distance < minDistance ) { closestCluster = i ; minDistance = distance ; } } if ( converted [ closestCluster ] = = null ) { converted [ closestCluster ] = ( CFCluster ) mc . copy ( ) ; } else { converted [ closestCluster ] . add ( mc ) ; } } int count = 0 ; for ( int i = 0 ; i < converted . length ; i + + ) { if ( converted [ i ] ! = null ) count + + ; } CFCluster [ ] cleaned = new CFCluster [ count ] ; count = 0 ; for ( int i = 0 ; i < converted . length ; i + + ) { if ( converted [ i ] ! = null ) cleaned [ count + + ] = converted [ i ] ; } return new Clustering ( cleaned ) ; }
void initialize ( ) { String [ ] loadedLibraries = engine . getCurrentLibraries ( ) ; for ( int i = loadedLibraries . length - 1 ; i > = 0 ; i - - ) libraries . add ( loadedLibraries [ i ] ) ;
public abstract void push ( T value ) ; public abstract T pop ( ) ; public abstract boolean contains ( T value ) ; public abstract int size ( ) ; public static < T > Stack < T > createStack ( StackType type ) { switch ( type ) { case ArrayStack : return new ArrayStack < T > ( ) ; default : return new LinkedStack < T > ( ) ; } } public static class LinkedStack < T > extends Stack < T > { private Node < T > top = null ; private int size = 0 ; public LinkedStack ( ) { top = null ; size = 0 ; } @Override public void push ( T value ) { push ( new Node < T > ( value ) ) ; } private void push ( Node < T > node ) { if ( top = = null ) { top = node ; } else { Node < T > oldTop = top ; top = node ; top . below = oldTop ; oldTop . above = top ; } size + + ; } @Override public T pop ( ) { Node < T > nodeToRemove = top ; top = nodeToRemove . below ; if ( top ! = null ) top . above = null ; T value = null ; if ( nodeToRemove ! = null ) { value = nodeToRemove . value ; size - - ; } return value ; } @Override public boolean contains ( T value ) { if ( top = = null ) return false ; Node < T > node = top ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . below ; } return false ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = top ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . below ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > above = null ; private Node < T > below = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  above= " + ( ( above ! = null ) ? above . value : " NULL " ) + "  below= " + ( ( below ! = null ) ? below . value : " NULL " ) ; } } } public static class ArrayStack < T > extends Stack < T > { private static final int GROW_IN_CHUNK_SIZE = 1000 ; private static final int SHRINK_IN_CHUNK_SIZE = 1000 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int size = 0 ; @Override public void push ( T value ) { if ( size > = array . length ) { T [ ] temp = Arrays . copyOf ( array , size + GROW_IN_CHUNK_SIZE ) ; temp [ size + + ] = value ; array = temp ; } else { array [ size + + ] = value ; } } @Override public T pop ( ) { if ( size < = 0 ) return null ; T t = array [ size - 1 ] ; array [ - - size ] = null ; if ( array . length - size > = SHRINK_IN_CHUNK_SIZE ) { T [ ] temp = Arrays . copyOf ( array , size ) ; array = temp ; } return t ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = size - 1 ; i > = 0 ; i - - ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } }
int size ( ) ; default boolean isEmpty ( ) { return size ( ) = = 0 ; } Map < String , Object > valueMap ( ) ; }
protected void Add ( String item ) { try { MPDApplication app = ( MPDApplication ) getApplication ( ) ;
public NativeOperator operator ( ) { return NativeOperator . SET_EXT_OPENER ; }
private static boolean testSuffixTree ( ) { if ( debug > 1 ) System . out . println ( " Suffix Tree. " ) ; String bookkeeper = " bookkeeper " ; SuffixTree < String > tree = new SuffixTree < String > ( bookkeeper ) ; if ( debug > 1 ) System . out . println ( tree . toString ( ) ) ; if ( debug > 1 ) System . out . println ( tree . getSuffixes ( ) ) ; boolean exists = tree . doesSubStringExist ( bookkeeper ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + bookkeeper + "  doesn't exists. " ) ; handleError ( tree ) ; return false ; } String failed = " booker " ; exists = tree . doesSubStringExist ( failed ) ; if ( exists ) { System . err . println ( " YIKES!!  " + failed + "  exists. " ) ; handleError ( tree ) ; return false ; } String pass = " kkee " ; exists = tree . doesSubStringExist ( pass ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + pass + "  doesn't exists. " ) ; handleError ( tree ) ; return false ; } if ( debug > 1 ) System . out . println ( ) ; return true ; }
public double sumOfValues ( ) { double sum = 0.0 ; for ( double element : this . doubleArray ) { sum + = element ; } return sum ; }
Set < InstantiatedComponent > getComponents ( Config config , boolean configure ) throws Exception ; }
public CommandResult execute ( final IAliasedCertificateFactory certFx , final Object [ ] params ) throws AS2Exception { if ( params . length ! = 2 ) { return new CommandResult ( ECommandResultType . TYPE_INVALID_PARAM_COUNT , getUsage ( ) ) ; } try {
public abstract Delegate setDelegate ( Delegate value ) ; public abstract void unregisterAllServices ( ) ; public abstract void unregisterService ( ServiceInfo info ) ; }
public ConnectionProfile cursorToObject ( Cursor cursor ) { final ConnectionProfile profile = new ConnectionProfile ( ) ; profile . setId ( cursor . getLong ( columnIds . get ( COL_ID ) ) ) ; profile . setName ( cursor . getString ( columnIds . get ( COL_NAME ) ) ) ; profile . setHostname ( cursor . getString ( columnIds . get ( COL_HOSTNAME ) ) ) ; profile . setPort ( cursor . getInt ( columnIds . get ( COL_PORT ) ) ) ; profile . setPassword ( cursor . getString ( columnIds . get ( COL_PASSWORD ) ) ) ; profile . setStreamingHostname ( cursor . getString ( columnIds . get ( COL_STREAMING_HOSTNAME ) ) ) ; profile . setStreamingPort ( cursor . getInt ( columnIds . get ( COL_STREAMING_PORT ) ) ) ; profile . setStreamingSuffix ( cursor . getString ( columnIds . get ( COL_STREAMING_SUFFIX ) ) ) ; profile . setMusicPath ( cursor . getString ( columnIds . get ( COL_MUSIC_PATH ) ) ) ; profile . setCoverFilename ( cursor . getString ( columnIds . get ( COL_COVER_FILENAME ) ) ) ; profile . setUseDatabaseCache ( cursor . getInt ( columnIds . get ( COL_USE_DATABASE_CACHE ) ) > 0 ? true : false ) ; return profile ; }
int getBy ( ) ; long getDefault ( ) ; int getExpiration ( ) ; }
public static IMessageMDN createMDN ( @Nonnull final IAS2Session aSession , @Nonnull final AS2Message aMsg , @Nonnull final DispositionType aDisposition , @Nonnull final String sText ) throws Exception { final AS2MessageMDN aMdn = new AS2MessageMDN ( aMsg ) ; aMdn . setHeader ( CAS2Header . HEADER_AS2_VERSION , CAS2Header . DEFAULT_AS2_VERSION ) ; aMdn . setHeader ( CAS2Header . HEADER_DATE , DateUtil . getFormattedDateNow ( CAS2Header . DEFAULT_DATE_FORMAT ) ) ; aMdn . setHeader ( CAS2Header . HEADER_SERVER , CAS2Info . NAME_VERSION ) ; aMdn . setHeader ( CAS2Header . HEADER_MIME_VERSION , CAS2Header . DEFAULT_MIME_VERSION ) ; aMdn . setHeader ( CAS2Header . HEADER_AS2_FROM , aMsg . getPartnership ( ) . getReceiverID ( CPartnershipIDs . PID_AS2 ) ) ; aMdn . setHeader ( CAS2Header . HEADER_AS2_TO , aMsg . getPartnership ( ) . getSenderID ( CPartnershipIDs . PID_AS2 ) ) ; aMdn . getPartnership ( ) . setSenderID ( CPartnershipIDs . PID_AS2 , aMdn . getHeader ( CAS2Header . HEADER_AS2_FROM ) ) ; aMdn . getPartnership ( ) . setReceiverID ( CPartnershipIDs . PID_AS2 , aMdn . getHeader ( CAS2Header . HEADER_AS2_TO ) ) ; aSession . getPartnershipFactory ( ) . updatePartnership ( aMdn , true ) ; aMdn . setHeader ( CAS2Header . HEADER_FROM , aMsg . getPartnership ( ) . getReceiverID ( CPartnershipIDs . PID_EMAIL ) ) ; final String sSubject = aMdn . getPartnership ( ) . getAttribute ( CPartnershipIDs . PA_MDN_SUBJECT ) ; if ( sSubject ! = null ) { aMdn . setHeader ( CAS2Header . HEADER_SUBJECT , AbstractParameterParser . parse ( sSubject , new MessageParameters ( aMsg ) ) ) ; } else { aMdn . setHeader ( CAS2Header . HEADER_SUBJECT , " Your Requested MDN Response " ) ; } aMdn . setText ( AbstractParameterParser . parse ( sText , new MessageParameters ( aMsg ) ) ) ; aMdn . setAttribute ( AS2MessageMDN . MDNA_REPORTING_UA , CAS2Info . NAME_VERSION + " @ " + aMsg . getAttribute ( CNetAttribute . MA_DESTINATION_IP ) + " : " + aMsg . getAttribute ( CNetAttribute . MA_DESTINATION_PORT ) ) ; aMdn . setAttribute ( AS2MessageMDN . MDNA_ORIG_RECIPIENT , " rfc822;  " + aMsg . getHeader ( CAS2Header . HEADER_AS2_TO ) ) ; aMdn . setAttribute ( AS2MessageMDN . MDNA_FINAL_RECIPIENT , " rfc822;  " + aMsg . getPartnership ( ) . getReceiverID ( CPartnershipIDs . PID_AS2 ) ) ; aMdn . setAttribute ( AS2MessageMDN . MDNA_ORIG_MESSAGEID , aMsg . getHeader ( CAS2Header . HEADER_MESSAGE_ID ) ) ; aMdn . setAttribute ( AS2MessageMDN . MDNA_DISPOSITION , aDisposition . getAsString ( ) ) ; final DispositionOptions aDispOptions = new DispositionOptions ( aMsg . getHeader ( CAS2Header . HEADER_DISPOSITION_NOTIFICATION_OPTIONS ) ) ; String sMIC = null ; if ( aDispOptions . getMICAlg ( ) ! = null ) { sMIC = getCryptoHelper ( ) . calculateMIC ( aMsg . getData ( ) , aDispOptions . getMICAlg ( ) , aMsg . getHistory ( ) . getItemCount ( ) > 1 ) ; } aMdn . setAttribute ( AS2MessageMDN . MDNA_MIC , sMIC ) ; createMDNData ( aSession , aMdn , aDispOptions . getMICAlg ( ) , aDispOptions . getProtocol ( ) ) ; aMdn . updateMessageID ( ) ; aMsg . setMDN ( aMdn ) ; return aMdn ; }
static FileConfigBuilder builder ( File file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getName ( ) ) ; } return builder ( file , format ) ; }
public StormStream createStream ( ) { return piBolt . createStream ( this . getName ( ) ) ; }
public C remove ( C value ) { if ( value = = null | | root = = null ) return null ; final Node node = search ( root , value , 0 ) ; if ( node ! = null ) { if ( node . isWord ) { node . isWord = false ; remove ( node ) ; size - - ; return value ; } } return null ; }
public String nextExecutionReportFIX ( ) { int execRptQty = new Random ( ) . nextInt ( 3000 ) ; leavesqty - = execRptQty ; if ( leavesqty < 0 ) leavesqty = 0 ; StringBuilder message = new StringBuilder ( ) ; message . append ( constructKVP ( " 35 " , " 8 " ) ) ; message . append ( constructKVP ( " 37 " , orderid ) ) ; message . append ( constructKVP ( " 11 " , clordid ) ) ; message . append ( constructKVP ( " 17 " , UUID . randomUUID ( ) ) ) ; message . append ( constructKVP ( " 20 " , 0 ) ) ; message . append ( constructKVP ( " 150 " , 0 ) ) ; message . append ( constructKVP ( " 39 " , leavesqty = = 0 ? 2 : 1 ) ) ; message . append ( constructKVP ( " 55 " , symbol ) ) ; message . append ( constructKVP ( " 54 " , 1 ) ) ; message . append ( constructKVP ( " 151 " , leavesqty ) ) ; message . append ( constructKVP ( " 14 " , orderqty - leavesqty ) ) ; message . append ( constructKVP ( " 6 " , new Random ( ) . nextFloat ( ) ) ) ; message . append ( constructKVP ( " 60 " , System . currentTimeMillis ( ) ) ) ; message . append ( constructKVP ( " 10 " , " 000 " ) ) ; return message . toString ( ) ; }
public long hash ( final String k ) { long rv = 0 ; int len = k . length ( ) ; switch ( this ) { case NATIVE_HASH : rv = k . hashCode ( ) ; break ; case CRC32_HASH : CRC32 crc32 = new CRC32 ( ) ; crc32 . update ( KeyUtil . getKeyBytes ( k ) ) ; rv = ( crc32 . getValue ( ) > > 16 ) & 0x7fff ; break ; case FNV1_64_HASH : rv = FNV_64_INIT ; for ( int i = 0 ; i < len ; i + + ) { rv * = FNV_64_PRIME ; rv ^ = k . charAt ( i ) ; } break ; case FNV1A_64_HASH : rv = FNV_64_INIT ; for ( int i = 0 ; i < len ; i + + ) { rv ^ = k . charAt ( i ) ; rv * = FNV_64_PRIME ; } break ; case FNV1_32_HASH : rv = FNV_32_INIT ; for ( int i = 0 ; i < len ; i + + ) { rv * = FNV_32_PRIME ; rv ^ = k . charAt ( i ) ; } break ; case FNV1A_32_HASH : rv = FNV_32_INIT ; for ( int i = 0 ; i < len ; i + + ) { rv ^ = k . charAt ( i ) ; rv * = FNV_32_PRIME ; } break ; case KETAMA_HASH : byte [ ] bKey = computeMd5 ( k ) ; rv = ( ( long ) ( bKey [ 3 ] & 0xFF ) < < 24 ) | ( ( long ) ( bKey [ 2 ] & 0xFF ) < < 16 ) | ( ( long ) ( bKey [ 1 ] & 0xFF ) < < 8 ) | ( bKey [ 0 ] & 0xFF ) ; break ; default : assert false ; } return rv & 0xffffffffL ; }
private void printDisjointness ( ) { System . out . println ( " INFO in printDisjointness():  Printing disjoint. " ) ; System . out . println ( ) ; Iterator it = disjoint . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { String term = ( String ) it . next ( ) ; System . out . print ( term + "  is disjoint with  " ) ; System . out . println ( ( Set ) disjoint . get ( term ) ) ; } System . out . println ( ) ; }
private void update ( Object o ) { visible = true ; if ( o instanceof Sentence ) { Sentence kb = ( Sentence ) o ;
protected void getAlbumDetails ( List < Album > albums , boolean findYear ) throws MPDServerException { for ( Album a : albums ) { Artist artist = a . getArtist ( ) ; mpdConnection . queueCommand ( getAlbumDetailsCommand ( artist . getName ( ) , a . getName ( ) , artist . isAlbumArtist ( ) ) ) ; } List < String [ ] > response = mpdConnection . sendCommandQueueSeparated ( ) ; if ( response . size ( ) ! = albums . size ( ) ) { return ; } for ( int i = 0 ; i < response . size ( ) ; i + + ) { String [ ] list = response . get ( i ) ;
KeyStore loadKeyStore ( @Nonnull final IKeyStoreType aKeyStoreType , @Nonnull @WillNotClose InputStream aIS , @Nonnull char [ ] aPassword ) throws Exception ; boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isCompressed ( @Nonnull String sContentType ) throws AS2Exception ; @Nonnull MIC calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm , @Nonnull EContentTransferEncoding eCTE ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt , @Nonnull AS2ResourceHelper aResHelper ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs , @Nonnull EContentTransferEncoding eCTE ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify , @Nullable Consumer < X509Certificate > aEffectiveCertificateConsumer , @Nonnull AS2ResourceHelper aResHelper ) throws Exception ; }
public void readCsvWithAvroSchema ( ) throws Exception { StringBuilder avroLiteral = new StringBuilder ( ) . append ( " {  \" type \"  :  \" record \" ,  \" name \"  :  \" example \" ,  \" fields \"  : [ " ) . append ( " {  \" name \"  :  \" A_Long \" ,  \" type \"  :  \" long \"  }, " ) . append ( " {  \" name \"  :  \" An_Int \" ,  \" type \"  :  \" int \"  }, " ) . append ( " {  \" name \"  :  \" A_String \" ,  \" type \"  :  \" string \"  }, " ) . append ( " {  \" name \"  :  \" Another_String \" ,  \" type \"  :  \" string \"  } " ) . append ( " ] } " ) ; Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( FileSystemInput . FORMAT_CONFIG , " csv " ) ; paramMap . put ( FileSystemInput . PATH_CONFIG , FileSystemInput . class . getResource ( CSV_DATA ) . getPath ( ) ) ; paramMap . put ( FileSystemInput . CSV_HEADER_CONFIG , " true " ) ; paramMap . put ( FileSystemInput . AVRO_LITERAL_CONFIG , avroLiteral . toString ( ) ) ; config = ConfigFactory . parseMap ( paramMap ) ; FileSystemInput csvInput = new FileSystemInput ( ) ; assertNoValidationFailures ( csvInput , config ) ; csvInput . configure ( config ) ; Dataset < Row > dataFrame = csvInput . read ( ) ; assertEquals ( 3 , dataFrame . count ( ) ) ; Row first = dataFrame . first ( ) ; assertEquals ( " four " , first . getString ( 3 ) ) ; assertEquals ( " Another_String " , first . schema ( ) . fields ( ) [ 3 ] . name ( ) ) ; assertEquals ( 1L , first . get ( 0 ) ) ; assertEquals ( DataTypes . LongType , first . schema ( ) . fields ( ) [ 0 ] . dataType ( ) ) ; }
public void drawParticles ( ) { } public void drawGround ( ) { time + + ; noStroke ( ) ; for ( int i = 0 ; i < cells . w ; i + + ) { for ( int j = 0 ; j < cells . h ; j + + ) { Cell c = cells . readCells [ i ] [ j ] ; float x = i * rendersize ; float y = j * rendersize ; pushMatrix ( ) ; translate ( x , y ) ; c . draw ( this , j = = 0 | | i = = 0 | | i = = cells . w - 1 | | j = = cells . w - 1 , hnav . MouseToWorldCoordX ( width / 2 ) , hnav . MouseToWorldCoordY ( height / 2 ) , x , y , hnav . zoom ) ; popMatrix ( ) ; } } } class ProcessingJs { ProcessingJs ( ) { addMouseWheelListener ( new MouseWheelListener ( ) { @Override public void mouseWheelMoved ( MouseWheelEvent evt ) { mouseScroll = - evt . getWheelRotation ( ) ; mouseScrolled ( ) ; } } ) ; } } class Hnav { private float savepx = 0 ; private float savepy = 0 ; private int selID = 0 ; private float zoom = 43.0f ; private float difx = 0 ; private float dify = 0 ; private int lastscr = 0 ; private boolean EnableZooming = true ; private float scrollcamspeed = 1.1f ; float MouseToWorldCoordX ( int x ) { return 1 / zoom * ( x - difx - width / 2 ) ; } float MouseToWorldCoordY ( int y ) { return 1 / zoom * ( y - dify - height / 2 ) ; } private boolean md = false ; void mousePressed ( ) { md = true ; if ( mouseButton = = RIGHT ) { savepx = mouseX ; savepy = mouseY ; } drawn = false ; } void mouseReleased ( ) { md = false ; } void mouseDragged ( ) { if ( mouseButton = = RIGHT ) { difx + = ( mouseX - savepx ) ; dify + = ( mouseY - savepy ) ; savepx = mouseX ; savepy = mouseY ; } drawn = false ; } private float camspeed = 1.0f ; private float scrollcammult = 0.92f ; boolean keyToo = true ; void keyPressed ( ) { if ( ( keyToo & & key = = 'w' ) | | keyCode = = UP ) { dify + = ( camspeed ) ; } if ( ( keyToo & & key = = 's' ) | | keyCode = = DOWN ) { dify + = ( - camspeed ) ; } if ( ( keyToo & & key = = 'a' ) | | keyCode = = LEFT ) { difx + = ( camspeed ) ; } if ( ( keyToo & & key = = 'd' ) | | keyCode = = RIGHT ) { difx + = ( - camspeed ) ; } if ( ! EnableZooming ) { return ; } if ( key = = '-' | | key = = '#' ) { float zoomBefore = zoom ; zoom * = scrollcammult ; difx = ( difx ) * ( zoom / zoomBefore ) ; dify = ( dify ) * ( zoom / zoomBefore ) ; } if ( key = = '+' ) { float zoomBefore = zoom ; zoom / = scrollcammult ; difx = ( difx ) * ( zoom / zoomBefore ) ; dify = ( dify ) * ( zoom / zoomBefore ) ; } drawn = false ; } void Init ( ) { difx = - width / 2 ; dify = - height / 2 ; } void mouseScrolled ( ) { if ( ! EnableZooming ) { return ; } float zoomBefore = zoom ; if ( mouseScroll > 0 ) { zoom * = scrollcamspeed ; } else { zoom / = scrollcamspeed ; } difx = ( difx ) * ( zoom / zoomBefore ) ; dify = ( dify ) * ( zoom / zoomBefore ) ; drawn = false ; } void Transform ( ) { translate ( difx + 0.5f * width , dify + 0.5f * height ) ; scale ( zoom , zoom ) ; } } class Hsim { ArrayList obj = new ArrayList ( ) ; void Init ( ) { smooth ( ) ; } void mousePressed ( ) { if ( mouseButton = = LEFT ) { checkSelect ( ) ; float x = hnav . MouseToWorldCoordX ( mouseX ) ; float y = hnav . MouseToWorldCoordY ( mouseY ) ; automataclicked ( x , y ) ; } } boolean dragged = false ; void mouseDragged ( ) { if ( mouseButton = = LEFT ) { dragged = true ; dragElems ( ) ; } mousePressed ( ) ; } void mouseReleased ( ) { dragged = false ; } void dragElems ( ) { } void checkSelect ( ) { } } class Hamlib { void Init ( ) { noStroke ( ) ; hnav . Init ( ) ; hsim . Init ( ) ; } void mousePressed ( ) { hnav . mousePressed ( ) ; hsim . mousePressed ( ) ; } void mouseDragged ( ) { hnav . mouseDragged ( ) ; hsim . mouseDragged ( ) ; } void mouseReleased ( ) { hnav . mouseReleased ( ) ; hsim . mouseReleased ( ) ; } public void mouseMoved ( ) { } void keyPressed ( ) { hnav . keyPressed ( ) ; } void mouseScrolled ( ) { hnav . mouseScrolled ( ) ; } void Camera ( ) { } } static List < PVector > Reconstruct_Taken_Path ( Map < PVector , PVector > parent , PVector start , PVector target ) { List < PVector > path = new ArrayList < > ( ) ; path . add ( target ) ; while ( ! path . get ( path . size ( ) - 1 ) . equals ( start ) ) { path . add ( parent . get ( path . get ( path . size ( ) - 1 ) ) ) ; } Collections . reverse ( path ) ; return path ; } static List < PVector > Shortest_Path ( Grid2DSpace s , GridAgent a , PVector start , PVector target ) { Set < PVector > avoid = new HashSet < > ( ) ; Map < PVector , PVector > parent = new HashMap < > ( ) ; ArrayDeque < PVector > queue = new ArrayDeque < > ( ) ; queue . add ( start ) ; while ( ! queue . isEmpty ( ) ) { PVector active = queue . removeFirst ( ) ; if ( avoid . contains ( active ) ) continue ; avoid . add ( active ) ; if ( active . equals ( target ) ) { return Reconstruct_Taken_Path ( parent , start , target ) ; } for ( int i = 0 ; i < 4 ; i + + ) { PVector x = new PVector ( ) ; switch ( i ) { case 0 : x . set ( active . x + 1 , active . y ) ; break ; case 1 : x . set ( active . x - 1 , active . y ) ; break ; case 2 : x . set ( active . x , active . y + 1 ) ; break ; case 3 : x . set ( active . x , active . y - 1 ) ; break ; } if ( avoid . contains ( x ) | | s . whyNonTraversible ( a , ( int ) active . x , ( int ) active . y , ( int ) x . x , ( int ) x . y ) ! = null ) continue ; parent . put ( x , active ) ; queue . add ( x ) ; } } return null ; } }
public void forceBufferUpdate ( ) { if ( stext ! = null ) stext . invalidateText ( ) ; bufferInvalid = true ; }
public void testInvalidKey3 ( ) throws Exception { try { Object val = client . get ( " Key \ n " ) ;
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . artists ) ; pd = ProgressDialog . show ( ArtistsActivity . this , getResources ( ) . getString ( R . string . loading ) , getResources ( ) . getString ( R . string . loadingArtists ) ) ; SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( this ) ; albumartist = settings . getBoolean ( " albumartist " , false ) ; registerForContextMenu ( getListView ( ) ) ; UpdateList ( ) ; }
public boolean supportsType ( Class < ? > type ) { return type = = Integer . class | | type = = Long . class
public static void main ( String [ ] args ) throws Exception { new ExcessivelyLargeGetTest ( ) . run ( ) ; }
Mutator getType ( ) ; int getBy ( ) ; long getDefault ( ) ; int getExpiration ( ) ; }
private static BudgetValue budgetInference ( float qual , int complexity , Memory memory ) { Item t = memory . currentTaskLink ; if ( t = = null ) { t = memory . currentTask ; } float priority = t . getPriority ( ) ; float durability = t . getDurability ( ) / complexity ; float quality = qual / complexity ; TermLink bLink = memory . currentBeliefLink ; if ( bLink ! = null ) { priority = or ( priority , bLink . getPriority ( ) ) ; durability = and ( durability , bLink . getDurability ( ) ) ; float targetActivation = memory . getConceptActivation ( bLink . getTarget ( ) ) ; bLink . incPriority ( or ( quality , targetActivation ) ) ; bLink . incDurability ( quality ) ; } return new BudgetValue ( priority , durability , quality ) ; }
public static void sendSimpleHTTPResponse ( @Nonnull final IAS2HttpResponseHandler aResponseHandler , @Nonnegative final int nResponseCode ) throws IOException { final InternetHeaders aHeaders = new InternetHeaders ( ) ; final NonBlockingByteArrayOutputStream aData = new NonBlockingByteArrayOutputStream ( ) ; aData . write ( ( Integer . toString ( nResponseCode ) + "   " + getHTTPResponseMessage ( nResponseCode ) + " \ r \ n " ) . getBytes ( CCharset . CHARSET_ISO_8859_1_OBJ ) ) ; aResponseHandler . sendHttpResponse ( nResponseCode , aHeaders , aData ) ; }
void addExceptionListener ( ExceptionListener l ) ; void removeExceptionListener ( ExceptionListener l ) ; void removeAllExceptionListeners ( ) ; }
public void closeLogFile ( ) { } @Override public boolean isLogging ( ) { return false ; } } }
public abstract String getParameter ( @Nonnull String sKey ) throws AS2InvalidParameterException ; public void setParameters ( @Nonnull final String sEncodedParams ) throws AS2InvalidParameterException { final StringTokenizer aParams = new StringTokenizer ( sEncodedParams , " =, " , false ) ; while ( aParams . hasMoreTokens ( ) ) { final String sKey = aParams . nextToken ( ) . trim ( ) ; if ( ! aParams . hasMoreTokens ( ) ) throw new AS2InvalidParameterException ( " Invalid value " , this , sKey , null ) ; final String sValue = aParams . nextToken ( ) ; setParameter ( sKey , sValue ) ; } } public void setParameters ( @Nullable final String sFormat , @Nullable final String sDelimiters , @Nonnull final String sValue ) throws AS2Exception { final ICommonsList < String > aKeys = StringHelper . getExploded ( ',' , sFormat ) ; final StringTokenizer aValueTokens = new StringTokenizer ( sValue , sDelimiters , false ) ; for ( final String sKey : aKeys ) { if ( ! aValueTokens . hasMoreTokens ( ) ) throw new AS2Exception ( " Invalid value: Format= " + sFormat + " , value= " + sValue ) ; if ( sKey . length ( ) > 0 ) setParameter ( sKey , aValueTokens . nextToken ( ) ) ; } } @Nonnull public String format ( @Nullable final String sFormat ) throws AS2InvalidParameterException { if ( LOGGER . isTraceEnabled ( ) ) LOGGER . trace ( " Formatting ' " + sFormat + " ' " ) ; final StringBuilder aSB = new StringBuilder ( ) ; if ( sFormat ! = null ) { int nNextIndex = 0 ; while ( nNextIndex < sFormat . length ( ) ) { int nPrevIndex = nNextIndex ; nNextIndex = sFormat . indexOf ( '$' , nPrevIndex ) ; if ( nNextIndex < 0 ) { aSB . append ( sFormat . substring ( nPrevIndex , sFormat . length ( ) ) ) ; break ; } if ( nNextIndex > nPrevIndex ) { aSB . append ( sFormat . substring ( nPrevIndex , nNextIndex ) ) ; } nPrevIndex = nNextIndex + 1 ; nNextIndex = sFormat . indexOf ( '$' , nPrevIndex ) ; if ( nNextIndex < 0 ) throw new AS2InvalidParameterException ( " Invalid key (missing closing $) " ) ; if ( nNextIndex = = nPrevIndex ) aSB . append ( '$' ) ; else { final String sParameterName = sFormat . substring ( nPrevIndex , nNextIndex ) ; aSB . append ( getParameter ( sParameterName ) ) ; } + + nNextIndex ; } } if ( LOGGER . isTraceEnabled ( ) ) LOGGER . trace ( " Formatted value is now ' " + aSB . toString ( ) + " ' " ) ; return aSB . toString ( ) ; } @Override public String toString ( ) { return new ToStringGenerator ( this ) . getToString ( ) ; } }
String getContentType ( ) ; void setContentType ( @Nullable String sContentType ) ; @Nullable String getContentDisposition ( ) ; void setContentDisposition ( @Nullable String sContentDisposition ) ; @Nullable String getSubject ( ) ; void setSubject ( @Nullable String sSubject ) ; @Nullable MimeBodyPart getData ( ) ; @Deprecated void setData ( @Nullable MimeBodyPart aData , @Nullable DataHistoryItem aHistoryItem ) throws OpenAS2Exception ; @Nonnull DataHistoryItem setData ( @Nonnull MimeBodyPart aData ) throws OpenAS2Exception ; @Nullable IMessageMDN getMDN ( ) ; void setMDN ( @Nullable IMessageMDN aMDN ) ; @Nonnull @Nonempty String getLoggingText ( ) ; @Nonnull @ReturnsMutableObject ( " design " ) @Deprecated DataHistory getHistory ( ) ; String getProtocol ( ) ; boolean isRequestingMDN ( ) ; boolean isRequestingAsynchMDN ( ) ; }
public void libraryLoaded ( LibraryEvent e ) { } public void libraryUnloaded ( LibraryEvent e ) { } public void newQueryResultAvailable ( QueryEvent e ) { } }
private static HoconConfig convert ( Config typesafeConfig ) { HoconConfig config = new HoconConfig ( ) ; put ( typesafeConfig , config ) ; return config ; }
private boolean hasCurrentFlagYes ( ) { return config . hasPath ( CURRENT_FLAG_YES_CONFIG_NAME ) ; }
public com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . MultipleExample build ( ) { com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . MultipleExample result = buildPartial ( ) ; if ( ! result . isInitialized ( ) ) { throw newUninitializedMessageException ( result ) ; } return result ; }
public C next ( ) { if ( iterator = = null ) return null ; java . util . Map . Entry < PatriciaTrie . Node , String > entry = iterator . next ( ) ; lastNode = entry . getKey ( ) ; return ( C ) entry . getValue ( ) ; }
protected void initRelationCaches ( ) { Iterator it = null ; if ( relationCaches . isEmpty ( ) ) { it = getCachedRelationNames ( ) . iterator ( ) ; String relname = null ; while ( it . hasNext ( ) ) { relname = ( String ) it . next ( ) ; relationCaches . add ( new RelationCache ( relname , 1 , 2 ) ) ; if ( ! relname . equals ( " disjoint " ) ) { relationCaches . add ( new RelationCache ( relname , 2 , 1 ) ) ; } } } else { RelationCache cache = null ; it = relationCaches . iterator ( ) ; while ( it . hasNext ( ) ) { cache = ( RelationCache ) it . next ( ) ; cache . clear ( ) ; } } parents = getRelationCache ( " subclass " , 1 , 2 ) ; children = getRelationCache ( " subclass " , 2 , 1 ) ; disjoint = getRelationCache ( " disjoint " , 1 , 2 ) ; return ; }
public OperationFuture < Boolean > delete ( String key ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; DeleteOperation op = opFact . delete ( key , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }
protected void execute ( final Operation op , final Task task ) { Operator oper = op . getOperator ( ) ; op . setTask ( task ) ; oper . call ( op , memory ) ;
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenu . ContextMenuInfo menuInfo ) { super . onCreateContextMenu ( menu , v , menuInfo ) ; android . view . MenuItem otherCoverItem = menu . add ( POPUP_COVER_BLACKLIST , POPUP_COVER_BLACKLIST , 0 , R . string . otherCover ) ; otherCoverItem . setOnMenuItemClickListener ( this ) ; android . view . MenuItem resetCoverItem = menu . add ( POPUP_COVER_SELECTIVE_CLEAN , POPUP_COVER_SELECTIVE_CLEAN , 0 , R . string . resetCover ) ; resetCoverItem . setOnMenuItemClickListener ( this ) ; }
public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; final ArrayAdapter < MPDOutput > arrayAdapter = new ArrayAdapter < > ( getActivity ( ) , android . R . layout . simple_list_item_multiple_choice , outputs ) ; setListAdapter ( arrayAdapter ) ; getListView ( ) . setChoiceMode ( ListView . CHOICE_MODE_MULTIPLE ) ; getListView ( ) . setOnItemClickListener ( this ) ; refreshOutputs ( ) ; }
private void toggleTrackProgress ( final MPDStatus status ) { final long totalTime = status . getTotalTime ( ) ; if ( totalTime = = 0 ) { mTrackTime . setVisibility ( View . INVISIBLE ) ;
private void checkContainsOnlySubtables ( Config table , List < String > path ) { for ( Entry entry : table . entrySet ( ) ) { Object value = entry . getValue ( ) ;
public boolean hasNext ( ) { if ( next ! = null ) { return true ; } if ( l > = 0 & & levelIterator = = null ) { while ( levelEmpty ( l ) ) { if ( - - l = = - 1 ) return false ; } levelIterator = level [ l ] . iterator ( ) ; } if ( levelIterator = = null ) { return false ; } next = levelIterator . next ( ) ; count + + ; if ( levelIterator . hasNext ( ) ) { return true ;
public static float rankBelief ( final Sentence judg ) { assert ( judg . isJudgment ( ) ) ; final float confidence = judg . truth . getConfidence ( ) ; final float originality = 1.0f / ( judg . stamp . evidentialBase . length + 1 ) ; return or ( confidence , originality ) ; }
public void testStrings ( ) throws Exception { String s1 = " This is a simple test string. " ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( 0 , cd . getFlags ( ) ) ; assertTrue ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; }
public boolean onKeyDown ( int keyCode , KeyEvent event ) { if ( keyCode = = KeyEvent . KEYCODE_VOLUME_DOWN | | keyCode = = KeyEvent . KEYCODE_VOLUME_UP ) { event . startTracking ( ) ; return ! app . getApplicationState ( ) . streamingMode ; } return super . onKeyDown ( keyCode , event ) ; }
public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { for ( Iterator < MemcachedNode > i = locator . getSequence ( key ) ; placeIn = = null & & i . hasNext ( ) ; ) { MemcachedNode n = i . next ( ) ; if ( n . isActive ( ) ) { placeIn = n ; } } if ( placeIn = = null ) { placeIn = primary ; this . getLogger ( ) . warn ( " Could not redistribute  " + " to another node, retrying primary node for %s. " , key ) ; } } assert o . isCancelled ( ) | | placeIn ! = null : " No node found for key  " + key ; if ( placeIn ! = null ) {
public void testSimpleCASGets ( ) throws Exception { assertNull ( client . gets ( " test1 " ) ) ; assert client . set ( " test1 " , 5 , " test1value " ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " test1value " , client . gets ( " test1 " ) . getValue ( ) ) ; }
public boolean equals ( final Object that ) { if ( this = = that ) return true ; if ( ! ( that instanceof Stamp ) ) { return false ; } Stamp s = ( Stamp ) that ; return Arrays . equals ( toSet ( ) , s . toSet ( ) ) ; }
public void update ( Effect nextEffect ) { PVector current = new PVector ( x , y ) ; System . out . println ( nextEffect ) ; if ( nextEffect = = null ) { List < PVector > path = Grid2DSpace . Shortest_Path ( space , this , current , target ) ;
boolean supportsComments ( ) ; default boolean supportsType ( Class < ? > type ) { return InMemoryFormat . DEFAULT_PREDICATE . test ( type ) ; } default boolean isInMemory ( ) { return false ; } }
public boolean is_superset_of ( terminal_set other ) throws internal_error { not_null ( other ) ; return other . is_subset_of ( this ) ; }
public View newView ( Context context , Cursor cursor , ViewGroup parent ) { View v = super . newView ( context , cursor , parent ) ; v . setTag ( new ChildViewCache ( v ) ) ; return v ; }
public boolean equals ( Object obj ) { if ( obj instanceof Obj ) { Obj o = ( Obj ) obj ; return ( o . type = = type ) & & ( o . name . equals ( name ) ) ; } return false ; }
private void _sendViaHTTP ( @Nonnull final AS2Message aMsg , @Nonnull final MimeBodyPart aSecuredData , @Nonnull final String sMIC ) throws OpenAS2Exception , IOException , MessagingException { final Partnership aPartnership = aMsg . getPartnership ( ) ; final String sUrl = aPartnership . getAS2URL ( ) ; final boolean bOutput = true ; final boolean bInput = true ; final boolean bUseCaches = false ; final String sRequestMethod = " POST " ; final HttpURLConnection aConn = getConnection ( sUrl , bOutput , bInput , bUseCaches , sRequestMethod , getSession ( ) . getHttpProxy ( ) ) ; try {
public OutputStream dumpOutgoingRequest ( @Nonnull final IBaseMessage aMsg ) { final File aDestinationFile = new File ( m_aDumpDirectory , getStoreFilename ( aMsg ) ) ; s_aLogger . info ( " Dumping outgoing HTTP request to file  " + aDestinationFile . getAbsolutePath ( ) ) ; return StreamHelper . getBuffered ( FileHelper . getOutputStream ( aDestinationFile ) ) ; }
public void onReceive ( Context context , Intent intent ) { if ( ! NetworkHelper . isLocalNetworkConnected ( context ) ) { Log . d ( MPDApplication . TAG , " No local network available. " ) ; return ; } Log . d ( MPDApplication . TAG , " Phonestate received " ) ; final SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( context ) ; boolean pauseOnCall = settings . getBoolean ( " pauseOnPhoneStateChange " , false ) ; boolean playOnCallStop = pauseOnCall & & settings . getBoolean ( " playOnPhoneStateChange " , false ) ; Log . d ( MPDApplication . TAG , " Pause on call  " + pauseOnCall ) ; if ( pauseOnCall ) { Bundle bundle = intent . getExtras ( ) ;
public void refresh ( ) { this . complexity = calcComplexity ( ) ; setName ( makeName ( ) ) ; this . isConstant = ! hasVar ; }
public static boolean invalidStatement ( final Term subject , final Term predicate ) { if ( subject . equals ( predicate ) ) { return true ; } if ( invalidReflexive ( subject , predicate ) ) { return true ; } if ( invalidReflexive ( predicate , subject ) ) { return true ; } if ( ( subject instanceof Statement ) & & ( predicate instanceof Statement ) ) { final Statement s1 = ( Statement ) subject ; final Statement s2 = ( Statement ) predicate ; final Term t11 = s1 . getSubject ( ) ; final Term t12 = s1 . getPredicate ( ) ; final Term t21 = s2 . getSubject ( ) ; final Term t22 = s2 . getPredicate ( ) ; if ( t11 . equals ( t22 ) & & t12 . equals ( t21 ) ) { return true ; } } return false ; }
private void shrink ( int size ) { int shrinkSize = array . length > > 1 ; T [ ] temp = ( T [ ] ) new Object [ shrinkSize ] ; int adjLast = lastIndex % array . length ; int endIndex = ( lastIndex > array . length ) ? array . length : lastIndex ; if ( adjLast < = firstIndex ) { System . arraycopy ( array , 0 , temp , array . length - firstIndex , adjLast ) ; } System . arraycopy ( array , firstIndex , temp , 0 , endIndex - firstIndex ) ; array = null ; array = temp ; lastIndex = ( lastIndex - firstIndex ) ; firstIndex = 0 ; }
protected ViewGroup . LayoutParams generateDefaultLayoutParams ( ) { return new ViewGroup . LayoutParams ( ViewGroup . LayoutParams . MATCH_PARENT ,
public boolean nameEquals ( Item o ) { return equals ( o ) ; }
Operation removeCurrentWriteOp ( ) ; boolean hasReadOp ( ) ; boolean hasWriteOp ( ) ; void addOp ( Operation op ) ; int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; }
public synchronized void uiDefaultsUpdate ( UIDefaults defaults ) { Enumeration < Object > newKeys = defaults . keys ( ) ; keys . clear ( ) ; keys . addAll ( Collections . list ( newKeys ) ) ; Enumeration < Object > newValues = defaults . elements ( ) ; values . clear ( ) ; values . addAll ( Collections . list ( newValues ) ) ; fireTableDataChanged ( ) ; }
public boolean containsAll ( final Collection < ? > c ) { synchronized ( mLOCK ) { boolean foundAll = true ;
void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public boolean inductionOnSucceedingEvents ( final Task newEvent , NAL nal ) { if ( newEvent = = null | | newEvent . sentence . stamp . getOccurrenceTime ( ) = = Stamp . ETERNAL | | ! isInputOrTriggeredOperation ( newEvent , nal . mem ) ) return false ; if ( stmLast ! = null ) { if ( equalSubTermsInRespectToImageAndProduct ( newEvent . sentence . content , stmLast . sentence . content ) ) { return false ; } nal . setTheNewStamp ( Stamp . make ( newEvent . sentence . stamp , stmLast . sentence . stamp , memory . getTime ( ) ) ) ; nal . setCurrentTask ( newEvent ) ; Sentence currentBelief = stmLast . sentence ; nal . setCurrentBelief ( currentBelief ) ; TemporalRules . temporalInduction ( newEvent . sentence , currentBelief , nal ) ; } shortTermMemory . add ( newEvent ) ; stmLast = newEvent ; return true ; }
@Deprecated protected void forgetPlanSuccess ( ParticlePlan plan , Term goal , Task t ) { for ( Cause c : plan . path ) { c . forgetRelevant ( goal , Executive . relevancyOfSuccessfulPlan ) ;
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }
public void restore ( DockingContent content , DockingPathRecord subpath ) { if ( subpath instanceof PathRecordSplit ) {
public void handle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) throws OpenAS2Exception { s_aLogger . info ( " message submitted " + aMsg . getLoggingText ( ) ) ; if ( ! ( aMsg instanceof AS2Message ) ) throw new OpenAS2Exception ( " Can't send non-AS2 message " ) ; checkRequired ( aMsg ) ; final int nRetries = getRetries ( aOptions ) ; try {
private void updateArea ( int x0 , int y0 , int w , int h ) { g . setBackground ( transparent ) ; g . clearRect ( x0 , y0 , w , h ) ; int xTileStart = ( x0 + xCam ) / 32 ; int yTileStart = ( y0 + yCam ) / 32 ; int xTileEnd = ( x0 + xCam + w ) / 32 ; int yTileEnd = ( y0 + yCam + h ) / 32 ; for ( int x = xTileStart ; x < = xTileEnd ; x + + ) {
public void testOneArrivingOneExistingWhereArrivingSameTimeAsExistingWithDifferentValuesNoCurrentFlag ( ) { p = new BitemporalHistoryPlanner ( ) ; assertNoValidationFailures ( p , configWithoutCurrentFlag ) ; p . configure ( configWithoutCurrentFlag ) ; existing . add ( new RowWithSchema ( existingSchemaWithoutCurrentFlag , " a " , " hello " , 100L , 100L , 253402214400000L , 1L , 253402214400000L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 100L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 2 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; Long systemStart1 = RowUtils . get ( planned . get ( 1 ) , " systemstart " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " systemstart " ) , 1L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " systemend " ) , systemStart1 - 1 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " eventend " ) , 253402214400000L ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " systemend " ) , 253402214400000L ) ; }
public void onComplete ( BulkGetFuture < ? > f ) throws Exception { assertEquals ( items , f . get ( ) . size ( ) ) ; assertTrue ( f . getStatus ( ) . isSuccess ( ) ) ; assertTrue ( f . isDone ( ) ) ; assertFalse ( f . isCancelled ( ) ) ; latch . countDown ( ) ; }
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; setContentView ( R . layout . artists ) ; ListView list = getListView ( ) ; registerForContextMenu ( list ) ; UpdateList ( ) ; }
public IStringMap getAllReceiverIDs ( ) { return m_aReceiverAttrs . getClone ( ) ; }
public void updateStatus ( List < String > response ) { this . updating = false ; if ( response = = null ) { return ; } for ( String line : response ) { String [ ] lines = line . split ( " :  " ) ;
public static void main ( String [ ] arg ) { NAR nar = new DiscretinuousBagNARBuilder ( ) . setConceptBagSize ( 1024 ) . realtime ( ) . build ( ) ; nar . param ( ) . duration . set ( 50 ) ; nar . param ( ) . decisionThreshold . set ( 0.3 ) ; nar . param ( ) . noiseLevel . set ( 0 ) ; nar . param ( ) . conceptForgetDurations . set ( 10 ) ; gameRate = 0.05 ; NARio nario = new NARio ( nar ) ; new NARSwing ( nar ) ; nar . start ( 50 , 300 ) ; }
public static void main ( String args [ ] ) { TestReasoning testReasoning = new TestReasoning ( ) ; if ( args . length = = 1 ) { testReasoning . checkReasoning ( new File ( args [ 0 ] ) ) ;
ManualTracker setValue ( double value ) ; void commit ( ) ; }
public void writeToString ( ) { Config subConfig = TomlFormat . instance ( ) . createConfig ( ) ; subConfig . set ( " string " , " test " ) ; subConfig . set ( " dateTime " , ZonedDateTime . now ( ) ) ; subConfig . set ( " sub " , TomlFormat . instance ( ) . createConfig ( ) ) ; List < Config > tableArray = new ArrayList < > ( ) ; tableArray . add ( subConfig ) ; tableArray . add ( subConfig ) ; tableArray . add ( subConfig ) ; Config config = TomlFormat . instance ( ) . createConfig ( ) ; config . set ( " string " , " \" value \" " ) ; config . set ( " integer " , 2 ) ; config . set ( " long " , 123456789L ) ; config . set ( " double " , 3.1415926535 ) ; config . set ( " bool_array " , Arrays . asList ( true , false , true , false ) ) ; config . set ( " config " , subConfig ) ; config . set ( " table_array " , tableArray ) ; StringWriter stringWriter = new StringWriter ( ) ; TomlWriter writer = new TomlWriter ( ) ; writer . setIndentArrayElementsPredicate ( array - > array . size ( ) > 3 ) ; writer . setWriteTableInlinePredicate ( table - > table . size ( ) < = 2 ) ; writer . write ( config , stringWriter ) ; System . out . println ( " Written: " ) ; System . out . println ( stringWriter ) ; }
public void testBadTRansferEncodingMessageRegular ( ) throws Exception { final IAS2HttpResponseHandler mockedResponseHandler = ( nHttpResponseCode , aHeaders , aData ) - > { } ; final NonBlockingByteArrayInputStream is = new NonBlockingByteArrayInputStream ( m_sBadTransferEncodingMessage . getBytes ( ) ) ; final AS2Message aMsg = new AS2Message ( ) ; aMsg . attrs ( ) . putIn ( ATTR_LARGE_FILE_SUPPORT_ON , false ) ; final IAS2InputStreamProvider mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; HTTPHelper . readHttpRequest ( mockStreamProvider , mockedResponseHandler , aMsg ) ; }
default C parse ( Path file , FileNotFoundAction nefAction ) { return parse ( file , nefAction , StandardCharsets . UTF_8 ) ; }
public String addConstituent ( String filename , boolean buildCachesP , boolean loadVampireP ) { System . out . println ( " ENTER KB.addConstituent( " + filename + " ,  " + buildCachesP + " ,  " + loadVampireP + " ) " ) ; long t1 = System . currentTimeMillis ( ) ; StringBuilder result = new StringBuilder ( ) ; try { File constituent = new File ( filename ) ; String canonicalPath = constituent . getCanonicalPath ( ) ; Iterator it ; Iterator it2 ; KIF file = new KIF ( ) ; String key ; String internedFormula ; ArrayList list ; ArrayList newList ; Formula f ; if ( constituents . contains ( canonicalPath ) ) { return " Error:  " + canonicalPath + "  already loaded. " ; } System . out . println ( " INFO in KB.addConstituent( " + filename + " ,  " + buildCachesP + " ,  " + loadVampireP + " ) " ) ; System . out . println ( "   Adding  " + canonicalPath ) ; try { file . readFile ( canonicalPath ) ; } catch ( Exception ex1 ) { result . append ( ex1 . getMessage ( ) ) ; if ( ex1 instanceof ParseException ) { result . append ( "  at line  " ) . append ( ( ( ParseException ) ex1 ) . getErrorOffset ( ) ) ; } result . append ( "  in file  " ) . append ( canonicalPath ) ; return result . toString ( ) ; } System . out . println ( " INFO in KB.addConstituent( " + filename + " ,  " + buildCachesP + " ,  " + loadVampireP + " ) " ) ; System . out . println ( "   Parsed file  " + canonicalPath + "  of size  " + file . formulas . keySet ( ) . size ( ) ) ; it = file . formulas . keySet ( ) . iterator ( ) ; int count = 0 ; while ( it . hasNext ( ) ) { key = ( String ) it . next ( ) ; if ( ( count + + % 100 ) = = 1 ) { System . out . print ( " . " ) ; } list = ( ArrayList ) formulas . get ( key ) ; if ( list = = null ) { list = new ArrayList ( ) ; formulas . put ( key , list ) ; } newList = ( ArrayList ) file . formulas . get ( key ) ; it2 = newList . iterator ( ) ; while ( it2 . hasNext ( ) ) { f = ( Formula ) it2 . next ( ) ; internedFormula = f . theFormula . intern ( ) ; if ( ! list . contains ( f ) ) { list . add ( f ) ; formulaMap . put ( internedFormula , f ) ; } else { result . append ( " Warning: Duplicate axiom in  " ) ; result . append ( f . sourceFile ) . append ( "  at line  " ) . append ( f . startLine ) . append ( " <BR> " ) ; result . append ( f . theFormula ) . append ( " <P> " ) ; Formula existingFormula = ( Formula ) formulaMap . get ( internedFormula ) ; result . append ( " Warning: Existing formula appears in  " ) ; result . append ( existingFormula . sourceFile ) . append ( "  at line  " ) . append ( existingFormula . startLine ) . append ( " <BR> " ) ; result . append ( " <P> " ) ; } } } System . out . println ( " x " ) ; this . terms . addAll ( file . terms ) ; if ( ! constituents . contains ( canonicalPath ) ) { constituents . add ( canonicalPath ) ; } System . out . println ( " INFO in KB.addConstituent( " + filename + " ,  " + buildCachesP + " ,  " + loadVampireP + " ) " ) ; System . out . println ( "   File  " + canonicalPath + "  loaded in  " + ( ( System . currentTimeMillis ( ) - t1 ) / 1000.0 ) + "  seconds " ) ; if ( buildCachesP & & ! canonicalPath . endsWith ( _cacheFileSuffix ) ) { buildRelationCaches ( ) ; } if ( loadVampireP ) { loadVampire ( ) ; } } catch ( Exception ex ) { result . append ( ex . getMessage ( ) ) ; System . out . println ( ex . getMessage ( ) ) ; ex . printStackTrace ( ) ; } System . out . println ( " EXIT KB.addConstituent( " + filename + " ,  " + buildCachesP + " ,  " + loadVampireP + " ) " ) ; return result . toString ( ) ; }
public void testBagIterator ( final Bag < NullItem , CharSequence > b ) { b . putIn ( new NullItem ( 0.1f ) ) ; b . putIn ( new NullItem ( 0.2f ) ) ; b . putIn ( new NullItem ( 0.3f ) ) ; b . putIn ( new NullItem ( 0.4f ) ) ; b . putIn ( new NullItem ( 0.5f ) ) ; b . putIn ( new NullItem ( 0.6f ) ) ; b . putIn ( new NullItem ( 0.7f ) ) ; b . putIn ( new NullItem ( 0.8f ) ) ; assert ! ( b instanceof LevelBag ) | | ( ( ( LevelBag ) b ) . numEmptyLevels ( ) < L ) ; testIterator ( b ) ; b . clear ( ) ; testIterator ( b ) ; b . putIn ( new NullItem ( 0.6f ) ) ; testIterator ( b ) ;
public java . util . Map < K , V > toMap ( ) { return ( new JavaCompatibleTrieMap < K , V > ( this ) ) ; }
private void writeObject ( Config config , CharacterOutput output ) { if ( config . isEmpty ( ) ) { output . write ( EMPTY_OBJECT ) ; return ; } Iterator < Map . Entry < String , Object > > it = config . asMap ( ) . entrySet ( ) . iterator ( ) ; output . write ( '{' ) ; if ( newlineAfterObjectStart ) { output . write ( newline ) ; } boolean indentElements = indentObjectElementsPredicate . test ( config ) ; if ( indentElements ) { output . write ( newline ) ; increaseIndentLevel ( ) ; } while ( true ) { final Map . Entry < String , Object > entry = it . next ( ) ; final String key = entry . getKey ( ) ; final Object value = entry . getValue ( ) ; if ( indentElements ) { writeIndent ( output ) ; } writeString ( key , output ) ; output . write ( ENTRY_SEPARATOR ) ; writeValue ( value , output ) ; if ( it . hasNext ( ) ) { output . write ( ',' ) ; if ( indentElements ) { output . write ( newline ) ; } } else { if ( indentElements ) { output . write ( newline ) ; } break ; } } if ( indentElements ) { decreaseIndentLevel ( ) ; writeIndent ( output ) ; } output . write ( '}' ) ; }
public Object visit ( EquivalenceAfter p , LoanParser arg ) { Stm subj = wrapTerm ( p . getSubject ( ) . accept ( this , arg ) ) ; Stm pred = wrapTerm ( p . getPredicate ( ) . accept ( this , arg ) ) ; return new StmEqvPred ( subj , pred ) ; }
protected boolean emptyLevel ( int n ) { return itemTable . get ( n ) . isEmpty ( ) ; }
public void testBrokenList2 ( ) throws Exception { String s = "     " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;
public String getDefaultName ( ) { return " importbystream " ; }
public void trace ( Object message , Throwable exception ) { log ( Level . TRACE , message , exception ) ; }
public String toString ( ) { return " Cmd: tap dump Flags: dump,ack " ; }
public void create ( NAR nar ) { int w = 50 ; int h = 50 ; int water_threshold = 30 ; Hauto cells = new Hauto ( w , h , nar ) ; cells . forEach ( 0 , 0 , w , h , new CellFunction ( ) { @Override public void update ( Cell c ) { float smoothness = 20 f ; c . material = Material . GrassFloor ; double n = SimplexNoise . noise ( c . state . x / smoothness , c . state . y / smoothness ) ; if ( ( n * 64 ) > water_threshold ) { c . material = Material . Water ; } c . setHeight ( ( int ) ( Math . random ( ) * 24 + 1 ) ) ; } } ) ; Maze . buildMaze ( cells , 3 , 3 , 23 , 23 ) ; space = new Grid2DSpace ( cells , nar ) ; space . newWindow ( 1000 , 800 , true ) ; cells . forEach ( 16 , 16 , 18 , 18 , new Hauto . SetMaterial ( Material . DirtFloor ) ) ; GridAgent a = new GridAgent ( 17 , 17 , nar ) { @Override public void update ( Effect nextEffect ) { if ( ! target . equals ( lasttarget ) | | target . equals ( lasttarget ) & & ( " pick " . equals ( opname ) | | " activate " . equals ( opname ) | | " deactivate " . equals ( opname ) ) ) { getfeedback = true ; } lasttarget = target ; PVector current = new PVector ( x , y ) ; if ( nextEffect = = null ) { List < PVector > path = Grid2DSpace . Shortest_Path ( space , this , current , target ) ; actions . clear ( ) ; if ( path ! = null ) { if ( inventorybag ! = null ) { inventorybag . x = ( int ) current . x ; inventorybag . y = ( int ) current . y ; inventorybag . cx = ( int ) current . x ; inventorybag . cy = ( int ) current . y ; } if ( inventorybag = = null | | ! ( inventorybag instanceof Key ) ) { keyn = - 1 ; } if ( path . size ( ) < = 1 ) { if ( getfeedback & & ! " " . equals ( goal ) & & current . equals ( target ) ) { getfeedback = false ; GridObject obi = null ; if ( ! " " . equals ( opname ) ) { for ( GridObject gridi : space . objects ) { if ( gridi instanceof LocalGridObject & & ( ( LocalGridObject ) gridi ) . doorname . equals ( goal ) & & ( ( LocalGridObject ) gridi ) . x = = ( int ) current . x & & ( ( LocalGridObject ) gridi ) . y = = ( int ) current . y ) { obi = gridi ; break ; } } } if ( obi ! = null | | cells . readCells [ ( int ) current . x ] [ ( int ) current . y ] . name . equals ( goal ) ) { if ( " pick " . equals ( opname ) ) { if ( inventorybag ! = null & & inventorybag instanceof LocalGridObject ) { LocalGridObject ob = ( LocalGridObject ) inventorybag ; ob . x = ( int ) current . x ; ob . y = ( int ) current . y ; space . objects . add ( ob ) ; } inventorybag = ( LocalGridObject ) obi ; if ( obi ! = null ) { space . objects . remove ( obi ) ; if ( inventorybag . doorname . startsWith ( " key " ) ) { keyn = Integer . parseInt ( inventorybag . doorname . replaceAll ( " key " , " " ) ) ; for ( int i = 0 ; i < cells . h ; i + + ) { for ( int j = 0 ; j < cells . w ; j + + ) { if ( Hauto . doornumber ( cells . readCells [ i ] [ j ] ) = = keyn ) { cells . readCells [ i ] [ j ] . is_solid = false ; cells . writeCells [ i ] [ j ] . is_solid = false ; } } } } } nar . addInput ( " < " + goal + "  --> hold>. :|: " ) ; } else if ( " deactivate " . equals ( opname ) ) { for ( int i = 0 ; i < cells . h ; i + + ) { for ( int j = 0 ; j < cells . w ; j + + ) { if ( cells . readCells [ i ] [ j ] . name . equals ( goal ) ) { if ( cells . readCells [ i ] [ j ] . logic = = Logic . SWITCH ) { cells . readCells [ i ] [ j ] . logic = Logic . OFFSWITCH ; cells . writeCells [ i ] [ j ] . logic = Logic . OFFSWITCH ; cells . readCells [ i ] [ j ] . charge = 0.0f ; cells . writeCells [ i ] [ j ] . charge = 0.0f ; nar . addInput ( " < " + goal + "  --> off>. :|: " ) ; } } } } } else if ( " activate " . equals ( opname ) ) { for ( int i = 0 ; i < cells . h ; i + + ) { for ( int j = 0 ; j < cells . w ; j + + ) { if ( cells . readCells [ i ] [ j ] . name . equals ( goal ) ) { if ( cells . readCells [ i ] [ j ] . logic = = Logic . OFFSWITCH ) { cells . readCells [ i ] [ j ] . logic = Logic . SWITCH ; cells . writeCells [ i ] [ j ] . logic = Logic . SWITCH ; cells . readCells [ i ] [ j ] . charge = 1.0f ; cells . writeCells [ i ] [ j ] . charge = 1.0f ; nar . addInput ( " < " + goal + "  --> on>. :|: " ) ; } } } } } if ( " go-to " . equals ( opname ) ) { nar . addInput ( " < " + goal + "  --> at>. :|: " ) ; nar . start ( 150 ) ; } } } opname = " " ; } else { nar . stop ( ) ; nar . step ( 1 ) ; int numSteps = Math . min ( 10 , path . size ( ) ) ; float cx = x ; float cy = y ; for ( int i = 1 ; i < numSteps ; i + + ) { PVector next = path . get ( i ) ; int dx = ( int ) ( next . x - cx ) ; int dy = ( int ) ( next . y - cy ) ; if ( ( dx = = 0 ) & & ( dy = = 1 ) ) { turn ( UP ) ; forward ( 1 ) ; } if ( ( dx = = 1 ) & & ( dy = = 0 ) ) { turn ( RIGHT ) ; forward ( 1 ) ; } if ( ( dx = = - 1 ) & & ( dy = = 0 ) ) { turn ( LEFT ) ; forward ( 1 ) ; } if ( ( dx = = 0 ) & & ( dy = = - 1 ) ) { turn ( DOWN ) ; forward ( 1 ) ; } cx = next . x ; cy = next . y ; } } } } } } ; Goto wu = new Goto ( this , " ^go-to " ) ; nar . memory . addOperator ( wu ) ; Pick wa = new Pick ( this , " ^pick " ) ; nar . memory . addOperator ( wa ) ; Activate waa = new Activate ( this , " ^activate " ) ; nar . memory . addOperator ( waa ) ; Deactivate waaa = new Deactivate ( this , " ^deactivate " ) ; nar . memory . addOperator ( waaa ) ; Say waaaa = new Say ( this , " ^say " ) ; nar . memory . addOperator ( waaaa ) ; space . add ( a ) ;
public int compare ( XYZPoint o1 , XYZPoint o2 ) { if ( o1 . y < o2 . y ) return - 1 ; if ( o1 . y > o2 . y ) return 1 ; return 0 ; }
static void dedConjunctionByQuestion ( final Sentence sentence , final Sentence belief , final NAL nal ) { if ( sentence = = null | | belief = = null | | ! sentence . isJudgment ( ) | | ! belief . isJudgment ( ) ) { return ; } Memory m = nal . mem ( ) ; Collection < Task > qq = m . conceptQuestions ( Conjunction . class ) ; if ( qq . isEmpty ( ) ) return ; final Term term1 = sentence . content ; final boolean term1ContainVar = term1 . containVar ( ) ; final boolean term1Conjunction = term1 instanceof Conjunction ; if ( ( term1Conjunction ) & & ( term1ContainVar ) ) return ; final Term term2 = belief . content ; final boolean term2ContainVar = term2 . containVar ( ) ; final boolean term2Conjunction = term2 instanceof Conjunction ; if ( ( term2Conjunction ) & & ( term2ContainVar ) ) return ; for ( final Task question : qq ) {
public static void InternalOperations ( Memory memory , Sentence belief , NAL nal , Term beliefTerm , Term taskTerm ) { if ( Parameters . INTERNAL_EXPERIENCE_FULL & & Memory . randomNumber . nextDouble ( ) < Parameters . INTERNAL_EXPERIENCE_PROBABILITY ) { String [ ] ops = new String [ ] { " ^remind " , " ^doubt " , " ^consider " , " ^evaluate " , " hestitate " } ; Operator op = memory . getOperator ( ops [ Memory . randomNumber . nextInt ( ops . length ) ] ) ; Product prod = new Product ( new Term [ ] { belief . content } ) ; if ( op ! = null & & prod ! = null ) { Term new_term = Inheritance . make ( prod , op ) ; Sentence sentence = new Sentence ( new_term , Symbols . GOAL_MARK , new TruthValue ( 1 , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) , new Stamp ( memory ) ) ; float quality = BudgetFunctions . truthToQuality ( sentence . truth ) ; BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_GOAL_PRIORITY * Parameters . INTERNAL_EXPERIENCE_PRIORITY_MUL , Parameters . DEFAULT_GOAL_DURABILITY * Parameters . INTERNAL_EXPERIENCE_QUALITY_MUL , quality ) ; Task newTask = new Task ( sentence , budget ) ; nal . derivedTask ( newTask , false , false , null , null ) ; } } if ( Parameters . INTERNAL_EXPERIENCE_FULL & & beliefTerm instanceof Implication & & Memory . randomNumber . nextDouble ( ) < = Parameters . INTERNAL_EXPERIENCE_PROBABILITY ) { Implication imp = ( Implication ) beliefTerm ;
public void enqueue ( int value ) { enqueue ( new Node ( value ) ) ; }
private ListIterator < ClauseInfo > superListIterator ( int index ) { return super . listIterator ( index ) ; }
MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs , @Nonnull EContentTransferEncoding eCTE ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
< T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }
public void testBracketedOperatorAsTerm2 ( ) throws InvalidTermException { String s = " (u) b1 (b2) b3 a " ; DefaultOperatorManager om = new DefaultOperatorManager ( ) ; om . opNew ( " u " , " fx " , 200 ) ; om . opNew ( " b1 " , " yfx " , 400 ) ; om . opNew ( " b2 " , " yfx " , 500 ) ; om . opNew ( " b3 " , " yfx " , 300 ) ; Parser p = new Parser ( om , s ) ; Struct result = new Struct ( " b1 " , new Struct ( " u " ) , new Struct ( " b3 " , new Struct ( " b2 " ) , new Struct ( " a " ) ) ) ; assertEquals ( result , p . nextTerm ( false ) ) ; }
public static CharSequence yarn ( final int maxLen , final CharSequence . . . components ) { int totalLen = 0 ; int total = 0 ; CharSequence lastNonNull = null ; for ( final CharSequence s : components ) { if ( s ! = null ) { totalLen + = s . length ( ) ; total + + ; lastNonNull = s ; } } if ( total = = 0 ) { return null ; } if ( total = = 1 ) { return lastNonNull ; } if ( ( totalLen < = maxLen ) | | ( maxLen = = - 1 ) ) { TextBuilder sb = new TextBuilder ( totalLen ) ;
private boolean isNetworkConnected ( ) { ConnectivityManager conMgr = ( ConnectivityManager ) getSystemService ( Context . CONNECTIVITY_SERVICE ) ; if ( conMgr . getActiveNetworkInfo ( ) = = null ) return false ; return ( conMgr . getActiveNetworkInfo ( ) . isAvailable ( ) & & conMgr . getActiveNetworkInfo ( ) . isConnected ( ) ) ; }
public void run ( Map < String , Dataset < Row > > dependencies ) { throw new RuntimeException ( message ) ; }
public void testQuerySetDescending ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setDescending ( true ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }
public Meter reset ( ) { lastValue = currentDelta = 0 ; return super . reset ( ) ; }
public Tuple2 < Row , Row > call ( Row t ) throws Exception { String key = UUID . randomUUID ( ) . toString ( ) ; return new Tuple2 < Row , Row > ( RowFactory . create ( key ) , t ) ; }
public boolean onError ( MediaPlayer mp , int what , int extra ) { Log . d ( TAG , " StreamingService.onError() " ) ; final int MAX_ERROR = 4 ; if ( errorIterator > 0 ) { Log . d ( TAG , " Error occurred while streaming, this is try # " + errorIterator + " , will attempt up to  " + MAX_ERROR + "  times. " ) ; } if ( errorIterator > MAX_ERROR ) { die ( ) ; } preparingStreaming = false ; stopStreaming ( ) ; if ( isPlaying ) { beginStreaming ( ) ; } errorIterator + = 1 ; return true ; }
public void output ( final Class c , Object o ) { if ( ( ! showErrors ) & & ( c = = ERR . class ) ) { return ; } if ( o instanceof Sentence ) { Sentence s = ( Sentence ) o ; if ( s . isQuestion ( ) & & ! showQuestions ) return ; if ( s . isJudgment ( ) & & ! showStatements ) return ; } if ( o instanceof Exception ) { o = ( o . toString ( ) + "  @  " + Arrays . asList ( ( ( Exception ) o ) . getStackTrace ( ) ) ) ; } nextOutput . add ( c . getSimpleName ( ) + " :  " ) ; nextOutput . add ( o ) ; nextOutput . add ( '\n' ) ; SwingUtilities . invokeLater ( nextOutputRunnable ) ;
public void testAddWithTranscoder ( ) throws Exception { Transcoder < String > t = new TestTranscoder ( ) ; assertNull ( client . get ( " test1 " , t ) ) ; assertTrue ( client . set ( " test1 " , 5 , " test1value " , t ) . get ( ) ) ; assertEquals ( " test1value " , client . get ( " test1 " , t ) ) ; assertFalse ( client . add ( " test1 " , 5 , " ignoredvalue " , t ) . get ( ) ) ; assertEquals ( " test1value " , client . get ( " test1 " , t ) ) ; }
public Map < String , T > getSome ( long to , TimeUnit unit ) throws InterruptedException , ExecutionException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( to , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { timeout = true ; LoggerFactory . getLogger ( getClass ( ) ) . warn ( new CheckedOperationTimeoutException ( " Operation timed out:  " , timedoutOps ) . getMessage ( ) ) ; } return ret ;
public boolean contains ( T value ) { if ( value = = null ) return false ; KdNode node = getNode ( this , value ) ; return ( node ! = null ) ; }
private void writeObject ( @Nonnull final ObjectOutputStream aOOS ) throws IOException { final NonBlockingByteArrayOutputStream aBAOS = new NonBlockingByteArrayOutputStream ( ) ; try { if ( m_aData ! = null ) { aBAOS . write ( 1 ) ; m_aData . writeTo ( aBAOS ) ; } else { aBAOS . write ( 0 ) ; } } catch ( final MessagingException ex ) { throw new IOException ( " Messaging exception:  " + ex . getMessage ( ) ) ; } aOOS . write ( aBAOS . toByteArray ( ) ) ; aBAOS . close ( ) ; aOOS . writeObject ( m_aMDN ) ; aOOS . writeObject ( m_aHistory ) ; }
public void onTabSelected ( Tab tab , FragmentTransaction ft ) ; public void onTabUnselected ( Tab tab , FragmentTransaction ft ) ; public void onTabReselected ( Tab tab , FragmentTransaction ft ) ; } public static class LayoutParams extends MarginLayoutParams { @ViewDebug.ExportedProperty ( mapping = { @ViewDebug.IntToString ( from = - 1 , to = " NONE " ) , @ViewDebug.IntToString ( from = Gravity . NO_GRAVITY , to = " NONE " ) , @ViewDebug.IntToString ( from = Gravity . TOP , to = " TOP " ) , @ViewDebug.IntToString ( from = Gravity . BOTTOM , to = " BOTTOM " ) , @ViewDebug.IntToString ( from = Gravity . LEFT , to = " LEFT " ) , @ViewDebug.IntToString ( from = Gravity . RIGHT , to = " RIGHT " ) , @ViewDebug.IntToString ( from = Gravity . CENTER_VERTICAL , to = " CENTER_VERTICAL " ) , @ViewDebug.IntToString ( from = Gravity . FILL_VERTICAL , to = " FILL_VERTICAL " ) , @ViewDebug.IntToString ( from = Gravity . CENTER_HORIZONTAL , to = " CENTER_HORIZONTAL " ) , @ViewDebug.IntToString ( from = Gravity . FILL_HORIZONTAL , to = " FILL_HORIZONTAL " ) , @ViewDebug.IntToString ( from = Gravity . CENTER , to = " CENTER " ) , @ViewDebug.IntToString ( from = Gravity . FILL , to = " FILL " ) } ) public int gravity = - 1 ; public LayoutParams ( Context c , AttributeSet attrs ) { super ( c , attrs ) ; } public LayoutParams ( int width , int height ) { super ( width , height ) ; this . gravity = Gravity . CENTER_VERTICAL | Gravity . LEFT ; } public LayoutParams ( int width , int height , int gravity ) { super ( width , height ) ; this . gravity = gravity ; } public LayoutParams ( int gravity ) { this ( WRAP_CONTENT , FILL_PARENT , gravity ) ; } public LayoutParams ( LayoutParams source ) { super ( source ) ; this . gravity = source . gravity ; } public LayoutParams ( ViewGroup . LayoutParams source ) { super ( source ) ; } } }
public static void createMDNData ( @Nonnull final IAS2Session aSession , @Nonnull final IMessageMDN aMdn , final boolean bSignMDN , final boolean bIncludeCertificateInSignedContent , @Nullable final ECryptoAlgorithmSign eMICAlg ) throws Exception { ValueEnforcer . notNull ( aSession , " AS2Session " ) ; ValueEnforcer . notNull ( aMdn , " MDN " ) ; if ( bSignMDN ) ValueEnforcer . notNull ( eMICAlg , " MICAlg " ) ; final MimeMultipart aReportParts = new MimeMultipart ( ) ; final MimeBodyPart aTextPart = new MimeBodyPart ( ) ; final String sText = aMdn . getText ( ) + " \ r \ n " ; aTextPart . setContent ( sText , CMimeType . TEXT_PLAIN . getAsString ( ) ) ; aTextPart . setHeader ( CAS2Header . HEADER_CONTENT_TYPE , CMimeType . TEXT_PLAIN . getAsString ( ) ) ; aReportParts . addBodyPart ( aTextPart ) ; final MimeBodyPart aReportPart = new MimeBodyPart ( ) ; { final InternetHeaders aReportValues = new InternetHeaders ( ) ; aReportValues . setHeader ( HEADER_REPORTING_UA , aMdn . getAttribute ( AS2MessageMDN . MDNA_REPORTING_UA ) ) ; aReportValues . setHeader ( HEADER_ORIGINAL_RECIPIENT , aMdn . getAttribute ( AS2MessageMDN . MDNA_ORIG_RECIPIENT ) ) ; aReportValues . setHeader ( HEADER_FINAL_RECIPIENT , aMdn . getAttribute ( AS2MessageMDN . MDNA_FINAL_RECIPIENT ) ) ; aReportValues . setHeader ( HEADER_ORIGINAL_MESSAGE_ID , aMdn . getAttribute ( AS2MessageMDN . MDNA_ORIG_MESSAGEID ) ) ; aReportValues . setHeader ( HEADER_DISPOSITION , aMdn . getAttribute ( AS2MessageMDN . MDNA_DISPOSITION ) ) ; aReportValues . setHeader ( HEADER_RECEIVED_CONTENT_MIC , aMdn . getAttribute ( AS2MessageMDN . MDNA_MIC ) ) ; final Enumeration < ? > aReportEn = aReportValues . getAllHeaderLines ( ) ; final StringBuilder aReportData = new StringBuilder ( ) ; while ( aReportEn . hasMoreElements ( ) ) aReportData . append ( ( String ) aReportEn . nextElement ( ) ) . append ( " \ r \ n " ) ; aReportData . append ( " \ r \ n " ) ; aReportPart . setContent ( aReportData . toString ( ) , " message/disposition-notification " ) ; } aReportPart . setHeader ( CAS2Header . HEADER_CONTENT_TYPE , " message/disposition-notification " ) ; aReportParts . addBodyPart ( aReportPart ) ; final MimeBodyPart aReport = new MimeBodyPart ( ) ; aReportParts . setSubType ( " report; report-type=disposition-notification " ) ; aReport . setContent ( aReportParts ) ; aReport . setHeader ( CAS2Header . HEADER_CONTENT_TYPE , aReportParts . getContentType ( ) ) ; if ( bSignMDN ) { final ICertificateFactory aCertFactory = aSession . getCertificateFactory ( ) ; try { final X509Certificate aSenderCert = aCertFactory . getCertificate ( aMdn , ECertificatePartnershipType . SENDER ) ; final PrivateKey aSenderKey = aCertFactory . getPrivateKey ( aMdn , aSenderCert ) ; final MimeBodyPart aSignedReport = getCryptoHelper ( ) . sign ( aReport , aSenderCert , aSenderKey , eMICAlg , bIncludeCertificateInSignedContent ) ; aMdn . setData ( aSignedReport ) ; } catch ( final CertificateNotFoundException ex ) { ex . terminate ( ) ; aMdn . setData ( aReport ) ; } catch ( final KeyNotFoundException ex ) { ex . terminate ( ) ; aMdn . setData ( aReport ) ; } } else { aMdn . setData ( aReport ) ; } final MimeBodyPart aData = aMdn . getData ( ) ; aMdn . setHeader ( CAS2Header . HEADER_CONTENT_TYPE , aData . getContentType ( ) ) ;
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; app = ( MPDApplication ) getApplication ( ) ; setContentView ( R . layout . browse ) ; list = ( ListView ) findViewById ( R . id . list ) ; list . setOnItemClickListener ( this ) ; loadingView = findViewById ( R . id . loadingLayout ) ; loadingTextView = ( TextView ) findViewById ( R . id . loadingText ) ; noResultView = findViewById ( R . id . noResultLayout ) ; loadingView . setVisibility ( View . VISIBLE ) ; loadingTextView . setText ( R . string . loading ) ; final Intent queryIntent = getIntent ( ) ; final String queryAction = queryIntent . getAction ( ) ; if ( Intent . ACTION_SEARCH . equals ( queryAction ) ) { searchKeywords = queryIntent . getStringExtra ( SearchManager . QUERY ) . trim ( ) ; } else { return ; } setTitle ( getTitle ( ) + "  :  " + searchKeywords ) ; registerForContextMenu ( list ) ; updateList ( ) ; getSupportActionBar ( ) . setDisplayHomeAsUpEnabled ( true ) ; }
public static int poisson ( double lambda , Random r ) { if ( lambda < 100.0 ) { double product = 1.0 ; double sum = 1.0 ; double threshold = r . nextDouble ( ) * Math . exp ( lambda ) ; int i = 1 ; int max = Math . max ( 100 , 10 * ( int ) Math . ceil ( lambda ) ) ; while ( ( i < max ) & & ( sum < = threshold ) ) { product * = ( lambda / i ) ; sum + = product ; i + + ; } return i - 1 ; } double x = lambda + Math . sqrt ( lambda ) * r . nextGaussian ( ) ; if ( x < 0.0 ) { return 0 ; } return ( int ) Math . floor ( x ) ; }
public String toString ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( " [ " + this . getClass ( ) . getSimpleName ( ) + " @ " + System . identityHashCode ( this ) + "   " ) ; buf . append ( " \ n \ tname: ' " ) ; buf . append ( this . getName ( ) ) ; buf . append ( " ' type: ' " ) ; buf . append ( this . getType ( ) ) ; buf . append ( " ' info: ' " ) ; buf . append ( this . getInfo ( ) ) ; buf . append ( " '] " ) ; return buf . toString ( ) ; }
public void testAvailableServers ( ) { client . asyncGet ( " x " ) ; assertEquals ( Collections . emptyList ( ) , client . getAvailableServers ( ) ) ; }
< T extends IProcessorModule > ICommonsList < T > getAllModulesOfClass ( @Nonnull Class < T > aClass ) ; @Nonnull @ReturnsMutableCopy ICommonsList < IProcessorActiveModule > getAllActiveModules ( ) ; void startActiveModules ( ) ; void stopActiveModules ( ) ; }
public void testNoLengthMessageStream ( ) throws Exception { IAS2HttpResponseHandler mockedResponseHandler = mock ( IAS2HttpResponseHandler . class ) ; InputStream is = new ByteArrayInputStream ( sNoLengthMessage . getBytes ( ) ) ; is = new ByteArrayInputStream ( sNoLengthMessage . getBytes ( ) ) ; AS2Message aMsg = new AS2Message ( ) ; aMsg . attrs ( ) . putIn ( ATTR_LARGE_FILE_SUPPORT_ON , true ) ; AS2InputStreamProviderSocket mockStreamProvider = mock ( AS2InputStreamProviderSocket . class ) ; when ( mockStreamProvider . getInputStream ( ) ) . thenReturn ( is ) ; when ( mockStreamProvider . getNonUpwardClosingInputStream ( ) ) . thenReturn ( is ) ; HTTPHelper . readHttpRequest ( mockStreamProvider , mockedResponseHandler , aMsg ) ; }
public void onOutput ( OutputEvent e ) { assertEquals ( " " , dataToRead [ count ] + " " , e . getMsg ( ) ) ; count + + ; }
protected void asyncUpdate ( ) { } public void updateFromItems ( ) { if ( items ! = null ) { Collections . sort ( items , String . CASE_INSENSITIVE_ORDER ) ; ListViewButtonAdapter < String > listAdapter = new ListViewButtonAdapter < String > ( this , android . R . layout . simple_list_item_1 , items ) ; setListAdapter ( listAdapter ) ; } } @Override public void asyncExecSucceeded ( int jobID ) { if ( iJobID = = jobID ) { updateFromItems ( ) ; try { pd . dismiss ( ) ; } catch ( Exception e ) { } } } }
Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public void test_reverse_2_1 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch(reverse(a, []), error(type_error(ValidType, Culprit), type_error(Goal, ArgNo, ValidType, Culprit)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " reverse_guard " , new Struct ( " a " ) , new Struct ( ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 1 ) ; Struct validType = ( Struct ) info . getTerm ( " ValidType " ) ; assertTrue ( validType . isEqual ( new Struct ( " list " ) ) ) ; Struct culprit = ( Struct ) info . getTerm ( " Culprit " ) ; assertTrue ( culprit . isEqual ( new Struct ( " a " ) ) ) ; }
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - 4 ] ; System . arraycopy ( pl , 4 , data , 0 , pl . length - 4 ) ; Callback cb = ( Callback ) getCallback ( ) ; cb . gotData ( key , flags , data ) ; cb . receivedStatus ( STATUS_OK ) ; }
public void testGraphOneLoopMany ( ) { Set < Step > steps = Sets . newHashSet ( ) ; Map < String , Object > loopStepConfigMap = Maps . newHashMap ( ) ; loopStepConfigMap . put ( LoopStep . MODE_PROPERTY , LoopStep . MODE_PARALLEL ) ; loopStepConfigMap . put ( LoopStep . SOURCE_PROPERTY , LoopStep . SOURCE_RANGE ) ; loopStepConfigMap . put ( LoopStep . RANGE_START_PROPERTY , 5 ) ; loopStepConfigMap . put ( LoopStep . RANGE_END_PROPERTY , 7 ) ; Config loopStepConfig = ConfigFactory . parseMap ( loopStepConfigMap ) ; LoopStep loopStep = new LoopStep ( " loop_step " , loopStepConfig ) ; steps . add ( loopStep ) ; Map < String , Object > step1ConfigMap = Maps . newHashMap ( ) ; step1ConfigMap . put ( " dependencies " , Lists . newArrayList ( " loop_step " ) ) ; Config step1Config = ConfigFactory . parseMap ( step1ConfigMap ) ; Step step1 = new BatchStep ( " step1 " , step1Config ) ; steps . add ( step1 ) ; Set < Step > unrolled = loopStep . unrollLoop ( steps ) ; assertEquals ( unrolled . size ( ) , 4 ) ; assertEquals ( StepUtils . getStepForName ( " loop_step " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_5 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_6 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_7 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; }
public void enableOutput ( int id ) throws MPDServerException { String [ ] args = new String [ 1 ] ; args [ 0 ] = Integer . toString ( id ) ; mpdConnection . sendCommand ( MPD_CMD_OUTPUTENABLE , args ) ; }
public String toString ( ) { final StringBuffer buff = new StringBuffer ( ) ; buff . append ( " [index=' " ) . append ( this . mIndex ) . append ( " ' " ) ; buff . append ( " , prev= " ) ; if ( this . mPrevNode = = null ) { buff . append ( " null " ) ; } else { buff . append ( " ' " ) . append ( this . mPrevNode ) . append ( " ' " ) ; } buff . append ( " , next= " ) ; if ( this . mNextNode = = null ) { buff . append ( " null " ) ; } else { buff . append ( " ' " ) . append ( this . mNextNode ) . append ( " ' " ) ; } buff . append ( " ] " ) ; return buff . toString ( ) ; }
public JPanel newPanel ( ) { JPanel p = new JPanel ( new BorderLayout ( ) ) ; p . add ( this , BorderLayout . CENTER ) ; init ( ) ; return p ; }
abstract public Bag < Task < Term > , Sentence < Term > > newNovelTaskBag ( Param p ) ; abstract public Attention newAttention ( Param p , ConceptBuilder c ) ; abstract public ConceptBuilder getConceptBuilder ( ) ; public NAR build ( ) { Param p = newParam ( ) ; Operator [ ] operators = DefaultOperators . get ( ) ; Memory m = new Memory ( p , newAttention ( p , getConceptBuilder ( ) ) , newNovelTaskBag ( p ) , operators ) ; for ( Operator o : ExampleOperators . get ( ) ) { m . addOperator ( o ) ; } return new NAR ( m , new Perception ( ) ) ; } }
public void invalidFormat ( ) throws Exception { config = ConfigFactory . parseString ( FileSystemInput . FORMAT_CONFIG + " : WILLGOBOOM " ) . withFallback ( config ) ; FileSystemInput fileSystemInput = new FileSystemInput ( ) ; assertValidationFailures ( fileSystemInput , config ) ; }
public void debug ( String message , Object . . . args ) { if ( isDebugEnabled ( ) ) { debug ( String . format ( message , args ) , getThrowable ( args ) ) ;
public static void main ( String [ ] arg ) { new PlanDecisionTest ( ) ; }
public ServletRegistrationBean < AS2ReceiveServlet > servletRegistrationBeanAS2 ( ) { final ServletRegistrationBean < AS2ReceiveServlet > bean = new ServletRegistrationBean < > ( new AS2ReceiveServlet ( ) , " /as2 " ) ; final Map < String , String > aInitParams = new HashMap < > ( ) ; aInitParams . put ( AbstractAS2ReceiveXServletHandler . SERVLET_INIT_PARAM_AS2_SERVLET_CONFIG_FILENAME , " config/config.xml " ) ; bean . setInitParameters ( aInitParams ) ; return bean ; }
public Data copy ( ) { Set < O > listCopy = new TreeSet < O > ( ) ; listCopy . addAll ( list ) ; return new IntervalData < O > ( listCopy ) ; }
public void run ( ) { TestChamber . active = true ; TestChamber . curious = true ; s . nar . addInput ( " <I --> [curious]>. " ) ; / * for ( GridObject g : s . objects ) {
public void add ( URL url ) throws MPDServerException , MPDClientException { List < String > urlContent ; try { urlContent = ( List < String > ) url . openConnection ( ) . getContent ( ) ; } catch ( UnsupportedMimeTypeException e ) { urlContent = new LinkedList < String > ( ) ; urlContent . add ( url . toString ( ) ) ; } catch ( IOException e ) { throw new MPDClientException ( " Unable to fetch  " + url . toString ( ) , e ) ; } if ( urlContent . size ( ) > 0 ) { String [ ] args = new String [ 1 ] ;
public static < T extends Comparable < T > > boolean testQueue ( IQueue < T > queue , String name , T [ ] data , T _invalid ) { for ( int i = 0 ; i < data . length ; i + + ) { T item = data [ i ] ; boolean added = queue . offer ( item ) ; if ( ! queue . validate ( ) | | ( queue . size ( ) ! = i + 1 ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( data , queue ) ; return false ; } if ( ! added | | ! queue . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists but has been added. " ) ; Utils . handleError ( data , queue ) ; return false ; } } boolean contains = queue . contains ( _invalid ) ; boolean removed = queue . remove ( _invalid ) ; if ( contains | | removed ) { System . err . println ( name + "  invalidity check. contains= " + contains + "  removed= " + removed ) ; Utils . handleError ( _invalid , queue ) ; return false ; } int size = queue . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { T item = queue . poll ( ) ; T correct = data [ i ] ; if ( item . compareTo ( correct ) ! = 0 ) { System . err . println ( name + "  YIKES!!  " + item + "  does not match FIFO item. " ) ; Utils . handleError ( data , queue ) ; return false ; } if ( ! queue . validate ( ) | | ( queue . size ( ) ! = data . length - ( i + 1 ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( data , queue ) ; return false ; } if ( queue . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists but it has been remove. " ) ; Utils . handleError ( data , queue ) ; return false ; } } int quarter = data . length / 4 ; int half = data . length / 2 ; int changeOver = half - quarter ; for ( int i = 0 ; i < half ; i + + ) { T item = data [ i ] ; boolean added = queue . offer ( item ) ; if ( ! queue . validate ( ) | | ( queue . size ( ) ! = i + 1 ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( data , queue ) ; return false ; } if ( ! added | | ! queue . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists but has been added. " ) ; Utils . handleError ( data , queue ) ; return false ; } } for ( int i = 0 ; i < quarter ; i + + ) { T item = queue . poll ( ) ; T correct = data [ i ] ; if ( item . compareTo ( correct ) ! = 0 ) { System . err . println ( name + "  YIKES!!  " + item + "  does not match FIFO item. " ) ; Utils . handleError ( data , queue ) ; return false ; } if ( ! queue . validate ( ) | | ( queue . size ( ) ! = ( half - ( i + 1 ) ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( data , queue ) ; return false ; } if ( queue . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists but it has been remove. " ) ; Utils . handleError ( data , queue ) ; return false ; } } for ( int i = 0 ; i < quarter ; i + + ) { T item = data [ i ] ; boolean added = queue . offer ( item ) ; if ( ! queue . validate ( ) | | ( queue . size ( ) ! = ( ( half - quarter ) + ( i + 1 ) ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( data , queue ) ; return false ; } if ( ! added | | ! queue . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists but has been added. " ) ; Utils . handleError ( data , queue ) ; return false ; } } for ( int i = half ; i < data . length ; i + + ) { T item = data [ i ] ; boolean added = queue . offer ( item ) ; if ( ! queue . validate ( ) | | ( queue . size ( ) ! = ( i + 1 ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( data , queue ) ; return false ; } if ( ! added | | ! queue . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  doesn't exists but has been added. " ) ; Utils . handleError ( data , queue ) ; return false ; } } for ( int i = 0 ; i < data . length ; i + + ) { T item = queue . poll ( ) ; int idx = i ; if ( idx < changeOver ) { idx = quarter + i ; } else if ( idx > = changeOver & & idx < half ) { idx = i - changeOver ; } T correct = data [ idx ] ; if ( ( item . compareTo ( correct ) ! = 0 ) ) { System . err . println ( name + "  YIKES!!  " + item + "  does not match FIFO item. " ) ; Utils . handleError ( data , queue ) ; return false ; } if ( ! queue . validate ( ) | | ( queue . size ( ) ! = ( data . length - ( i + 1 ) ) ) ) { System . err . println ( name + "  YIKES!!  " + item + "  caused a size mismatch. " ) ; Utils . handleError ( data , queue ) ; return false ; } if ( queue . contains ( item ) ) { System . err . println ( name + "  YIKES!!  " + item + "  still exists but it has been remove. " ) ; Utils . handleError ( data , queue ) ; return false ; } } if ( ( queue . size ( ) ! = 0 ) ) { System . err . println ( name + "  YIKES!! a size mismatch. " ) ; Utils . handleError ( data , queue ) ; return false ; } return true ; }
private static void decomposeCompound ( CompoundTerm compound , Term component , Term term1 , int index , boolean compoundTask , int order , Memory memory ) { if ( ( compound instanceof Statement ) | | ( compound instanceof ImageExt ) | | ( compound instanceof ImageInt ) ) { return ; } Term term2 = reduceComponents ( compound , component , memory ) ; if ( term2 = = null ) { return ; } Task task = memory . getCurrentTask ( ) ; Sentence sentence = task . sentence ; Sentence belief = memory . getCurrentBelief ( ) ; Statement oldContent = ( Statement ) task . getContent ( ) ; TruthValue v1 , v2 ; if ( compoundTask ) { v1 = sentence . truth ; v2 = belief . truth ; } else { v1 = belief . truth ; v2 = sentence . truth ; } TruthValue truth = null ; Term content ; if ( index = = 0 ) { content = Statement . make ( oldContent , term1 , term2 , order , memory ) ; if ( content = = null ) { return ; } if ( oldContent instanceof Inheritance ) { if ( compound instanceof IntersectionExt ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof IntersectionInt ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetInt ) & & ( component instanceof SetInt ) ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetExt ) & & ( component instanceof SetExt ) ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } else if ( compound instanceof DifferenceExt ) { if ( compound . term [ 0 ] . equals ( component ) ) { truth = TruthFunctions . reduceDisjunction ( v2 , v1 ) ; } else { truth = TruthFunctions . reduceConjunctionNeg ( v1 , v2 ) ; } } } else if ( oldContent instanceof Implication ) { if ( compound instanceof Conjunction ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof Disjunction ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } } } else { content = Statement . make ( oldContent , term2 , term1 , order , memory ) ; if ( content = = null ) { return ; } if ( oldContent instanceof Inheritance ) { if ( compound instanceof IntersectionInt ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof IntersectionExt ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetExt ) & & ( component instanceof SetExt ) ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( ( compound instanceof SetInt ) & & ( component instanceof SetInt ) ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } else if ( compound instanceof DifferenceInt ) { if ( compound . term [ 1 ] . equals ( component ) ) { truth = TruthFunctions . reduceDisjunction ( v2 , v1 ) ; } else { truth = TruthFunctions . reduceConjunctionNeg ( v1 , v2 ) ; } } } else if ( oldContent instanceof Implication ) { if ( compound instanceof Disjunction ) { truth = TruthFunctions . reduceConjunction ( v1 , v2 ) ; } else if ( compound instanceof Conjunction ) { truth = TruthFunctions . reduceDisjunction ( v1 , v2 ) ; } } } if ( truth ! = null ) { BudgetValue budget = BudgetFunctions . compoundForward ( truth , content , memory ) ;
public MPDCommand listAlbumsCommand ( String artist , boolean useAlbumArtist ) { if ( useAlbumArtist ) { return new MPDCommand ( MPDCommand . MPD_CMD_LIST_TAG , MPDCommand . MPD_TAG_ALBUM ,
public void singlePremiseTask ( final Term newContent , final TruthValue newTruth , final BudgetValue newBudget ) { singlePremiseTask ( newContent , currentTask . getSentence ( ) . getPunctuation ( ) , newTruth , newBudget ) ; }
private boolean addCommand ( final String text ) { if ( text . startsWith ( " ** " ) ) { this . reset ( ) ;
public void playlistChanged ( final MPDStatus mpdStatus , final int oldPlaylistVersion ) { super . playlistChanged ( mpdStatus , oldPlaylistVersion ) ; try { refresh ( ) ;
public void testStringEnums ( ) { Map < String , Object > configMap = new HashMap < > ( ) ; configMap . put ( " fields " , Lists . newArrayList ( " name " , " nickname " ) ) ; configMap . put ( " fieldtype " , " string " ) ; configMap . put ( " values " , Lists . newArrayList ( " Ian " , " Jeremy " , " Webster " ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; EnumRowRule rule = new EnumRowRule ( ) ; assertNoValidationFailures ( rule , config ) ; rule . configure ( " namecheck " , config ) ; Row row1 = new RowWithSchema ( SCHEMA , " Ian " , " Ian " , 34 , new BigDecimal ( " 0.00 " ) ) ; assertTrue ( " Row should pass rule " , rule . check ( row1 ) ) ; Row row2 = new RowWithSchema ( SCHEMA , " Webster " , " Websta " , 110 , new BigDecimal ( " 450.10 " ) ) ; assertFalse ( " Row should not pass rule " , rule . check ( row2 ) ) ; }
public void processBody ( Body argBody , Long argTag ) { if ( argTag = = CHASSIS_TAG ) { m_chassis = argBody ;
public void testUndecodeableSerialized ( ) throws Exception { CachedData cd = new CachedData ( SerializingTranscoder . SERIALIZED , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( tc . decode ( cd ) ) ; }
public char [ ] read ( int n ) { n = Math . min ( n , chars . length - index + deque . size ( ) ) ; final int offset ; final char [ ] array = new char [ n ] ; if ( deque . isEmpty ( ) ) { offset = 0 ; } else { offset = Math . min ( deque . size ( ) , n ) ; for ( int i = 0 ; i < offset ; i + + ) { int next = deque . removeFirst ( ) ; if ( next = = EOS ) { return Arrays . copyOf ( array , i ) ; } array [ i ] = ( char ) next ; } } System . arraycopy ( chars , index , array , offset , n - offset ) ; index + = n ; return array ; }
public static boolean unify ( Random rnd , final char type , final Term [ ] t ) { return unify ( rnd , type , t [ 0 ] , t [ 1 ] , t ) ; }
public void mouseClicked ( java . awt . event . MouseEvent evt ) { jLabel10MouseClicked ( evt ) ; }
private boolean hasHandledStreamingMessage ( final int what ) { boolean result = true ; final MPDStatus mpdStatus = getMPDStatus ( ) ; switch ( what ) { case StreamingService . BUFFERING_BEGIN : mNotificationHandler . setMediaPlayerBuffering ( true ) ; mRemoteControlClientHandler . setMediaPlayerBuffering ( true ) ; mStreamingServiceWoundDown = false ; break ; case StreamingService . REQUEST_NOTIFICATION_STOP : if ( mStreamingOwnsNotification & & ! sApp . isNotificationPersistent ( ) ) { haltSelf ( ) ; } else { tryToGetAudioFocus ( ) ; stateChanged ( getMPDStatus ( ) , null ) ; } break ; case StreamingService . SERVICE_WOUND_DOWN : mNotificationHandler . setMediaPlayerWoundDown ( ) ; mStreamingServiceWoundDown = true ; break ; case StreamingService . BUFFERING_END : case StreamingService . BUFFERING_ERROR : case StreamingService . STREAMING_STOP : mRemoteControlClientHandler . setMediaPlayerBuffering ( false ) ; mNotificationHandler . setMediaPlayerBuffering ( false ) ; stateChanged ( getMPDStatus ( ) , MPDStatus . MPD_STATE_UNKNOWN ) ; break ; default : result = false ; break ; } return result ; }
public void getSchemaInvalidDataType ( ) throws Exception { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( MorphlineDeriver . STEP_NAME_CONFIG , " dep1 " ) ; paramMap . put ( MorphlineDeriver . MORPHLINE , getResourcePath ( MORPHLINE_FILE ) ) ; paramMap . put ( MorphlineDeriver . MORPHLINE_ID , " id " ) ; paramMap . put ( MorphlineDeriver . FIELD_NAMES , Lists . newArrayList ( " bar " ) ) ; paramMap . put ( MorphlineDeriver . FIELD_TYPES , Lists . newArrayList ( " boom " ) ) ; final Config config = ConfigFactory . parseMap ( paramMap ) ; MorphlineDeriver deriver = new MorphlineDeriver ( ) ; assertNoValidationFailures ( deriver , config ) ; deriver . configure ( config ) ; }
protected ArrayList < Task > execute ( Term [ ] args , Memory memory ) { Term term = args [ 0 ] ; Concept concept = memory . conceptualize ( term ) ; concept . discountConfidence ( true ) ; return null ; }
public List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { lastAction = 1 ; memory . allowExecution = false ; return null ; }
public boolean add ( Sentence s , CompoundTerm ct , Item c ) { if ( ct instanceof Statement ) { Statement st = ( Statement ) ct ; Term subject = st . getSubject ( ) ; Term predicate = st . getPredicate ( ) ; addVertex ( subject ) ; addVertex ( predicate ) ; addEdge ( subject , predicate , s ) ; return true ; } return false ;
public BlockingQueue < Operation > createWriteOperationQueue ( ) { return new LinkedBlockingQueue < Operation > ( ) ; }
protected void print ( final Class c , final Object o ) { float priority = 1f ; if ( c ! = OUT . class ) { String n = c . getSimpleName ( ) ; n = n . substring ( 0 , Math . min ( 6 , n . length ( ) ) ) ; switch ( n . length ( ) ) { case 0 : break ; case 1 : n = "       " + n ; break ; case 2 : n = "      " + n ; break ; case 3 : n = "     " + n ; break ; case 4 : n = "    " + n ; break ; case 5 : n = "   " + n ; break ; } print ( LogPanel . getChannelColor ( c ) , n ) ; } else { if ( o instanceof Task ) { Task t = ( Task ) o ; priority = t . budget . getPriority ( ) ; printColorBlock ( LogPanel . getPriorityColor ( priority ) , "    " ) ; Sentence s = t . sentence ; if ( s ! = null ) { TruthValue tv = s . truth ; if ( tv ! = null ) { printColorBlock ( LogPanel . getFrequencyColor ( tv . getFrequency ( ) ) , "    " ) ; printColorBlock ( LogPanel . getConfidenceColor ( tv . getConfidence ( ) ) , "    " ) ; } else { printColorBlock ( LogPanel . getStatementColor ( s . punctuation , priority ) , "      " ) ; } } } } float tc = 0.75f + 0.25f * priority ; Color textColor = new Color ( tc , tc , tc ) ; print ( textColor , ' ' + LogPanel . getText ( o , showStamp , nar ) + '\n' ) ; }
protected Void doInBackground ( Void . . . voids ) { return null ; }
protected boolean isActive ( final Task t ) { return t . getPriority ( ) > = priorityThreshold ; }
public static Operation make ( Operator oper , final Term [ ] arg , boolean addSelf , final Memory memory ) { addSelf = false ; if ( oper = = null ) { return null ; } Term productArg [ ] ; if ( addSelf ) { productArg = new Term [ arg . length + 1 ] ; System . arraycopy ( arg , 0 , productArg , 0 , arg . length ) ; productArg [ arg . length ] = memory . self ; } else { productArg = arg ; } CharSequence name = makeName ( oper . name ( ) , arg ) ; Term t = memory . conceptTerm ( name ) ; if ( t ! = null ) { return ( Operation ) t ; } return new Operation ( name , termArray ( Product . make ( productArg , memory ) , oper )
public static SetExt make ( final Collection < Term > l ) { return make ( l . toArray ( new Term [ l . size ( ) ] ) ) ; }
public void onLostAudioFocus ( boolean canDuck ) { Log . d ( TAG , " Lost audio focus. " ) ; mAudioFocus = canDuck ? AudioFocusHelper . NO_FOCUS_CAN_DUCK : AudioFocusHelper . NO_FOCUS_NO_DUCK ;
public static MPDOutput build ( final Collection < String > response ) { String name = null ; int id = - 1 ; Boolean enabled = null ; for ( final String [ ] pair : Tools . splitResponse ( response ) ) { switch ( pair [ KEY ] ) { case CMD_ENABLED : enabled = Boolean . valueOf ( " 1 " . equals ( pair [ VALUE ] ) ) ; break ; case CMD_ID : id = Integer . parseInt ( pair [ VALUE ] ) ; break ; case CMD_NAME : name = pair [ VALUE ] ; break ; default : Log . warning ( TAG , " Non-standard line appeared in output response. Key:  " + pair [ KEY ] + "  value:  " + pair [ VALUE ] ) ; break ; } } if ( name = = null | | id = = - 1 | | enabled = = null ) { throw new InvalidResponseException ( " Failed to parse output information. " ) ; } return new MPDOutput ( name , id , enabled . booleanValue ( ) ) ; }
public void testCarryForwardWhenNull ( ) { p = new BitemporalHistoryPlanner ( ) ; config = config . withValue ( BitemporalHistoryPlanner . CARRY_FORWARD_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( true ) ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , 1L , 253402214400000L , CURRENT_FLAG_DEFAULT_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , null , 200L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 3 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 2 ) ) , MutationType . INSERT ) ; Long systemStart1 = ( Long ) RowUtils . get ( planned . get ( 1 ) , " systemstart " ) ; Long systemStart2 = ( Long ) RowUtils . get ( planned . get ( 2 ) , " systemstart " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " systemstart " ) , 1L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " systemend " ) , systemStart1 - 1 ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " eventstart " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " eventend " ) , 199L ) ; assertTrue ( systemStart1 > = preplanSystemTime ) ; assertTrue ( systemStart1 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " systemend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " value " ) , " hello " ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " eventstart " ) , 200L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " eventend " ) , 253402214400000L ) ; assertTrue ( systemStart2 > = preplanSystemTime ) ; assertTrue ( systemStart2 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " systemend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 2 ) , " currentflag " ) , CURRENT_FLAG_DEFAULT_YES ) ; }
protected void ensureLevelExists ( int level ) { if ( itemTable [ level ] = = null ) itemTable [ level ] = new LinkedList ( ) ;
public boolean remove ( T value ) { Node < T > node = this . getNode ( value ) ; if ( node = = null ) return false ; int index = node . indexOf ( value ) ; node . removeKey ( value ) ; if ( node . numberOfChildren ( ) = = 0 ) { if ( node . parent ! = null & & node . numberOfKeys ( ) < minKeySize ) { this . combined ( node ) ; } else if ( node . parent = = null & & node . numberOfKeys ( ) = = 0 ) { root = null ; } } else { Node < T > lesser = node . getChild ( index ) ; Node < T > greatest = this . getGreatestNode ( lesser ) ; T replaceValue = this . removeGreatestValue ( greatest ) ; node . addKey ( replaceValue ) ; if ( greatest . parent ! = null & & greatest . numberOfKeys ( ) < minKeySize ) { this . combined ( greatest ) ; } if ( greatest . numberOfChildren ( ) > maxChildrenSize ) { this . split ( greatest ) ; } } size - - ; return true ; }
public final int compareTo ( final AbstractTerm that ) { return ( that instanceof Variable ) ? ( ( Comparable ) name ( ) ) . compareTo ( that . name ( ) ) : - 1 ; }
public Variable clone ( ) { return new Variable ( getName ( ) ) ; }
public void onUpdate ( Context context , AppWidgetManager appWidgetManager , int [ ] appWidgetIds ) { Log . v ( TAG , " Enter onUpdate " ) ; final Resources res = context . getResources ( ) ; final RemoteViews views = new RemoteViews ( context . getPackageName ( ) , R . layout . widget_simple ) ; views . setViewVisibility ( R . id . title , View . GONE ) ; views . setTextViewText ( R . id . artist , res . getText ( R . string . widget_initial_text ) ) ; linkButtons ( context , views , false ) ; pushUpdate ( context , appWidgetIds , views ) ; Intent updateIntent = new Intent ( StreamingService . CMD_REMOTE ) ; updateIntent . putExtra ( StreamingService . CMD_COMMAND , StreamingService . CMD_UPDATE_WIDGET ) ; updateIntent . putExtra ( AppWidgetManager . EXTRA_APPWIDGET_IDS , appWidgetIds ) ; updateIntent . addFlags ( Intent . FLAG_RECEIVER_REGISTERED_ONLY ) ; context . sendBroadcast ( updateIntent ) ; }
public Integer [ ] sort ( Integer [ ] input ) { return CountingSort . sort ( input ) ; }
public double score ( NAR n ) { Parameters . DEBUG = false ; double s ; try { s = NALTestScore . score ( n , maxCycles ) ; } catch ( Throwable e ) { if ( Parameters . DEBUG ) e . printStackTrace ( ) ; return 0 ; } return s ;
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " ( " ) ; builder . append ( upperLeft . toString ( ) ) . append ( " ,  " ) ; builder . append ( " height " ) . append ( "  =  " ) . append ( height ) . append ( " ,  " ) ; builder . append ( " width " ) . append ( "  =  " ) . append ( width ) ; builder . append ( " ) " ) ; return builder . toString ( ) ; }
public void pushLibraryFragment ( final Fragment fragment , final String label ) { final String title ; if ( fragment instanceof BrowseFragment ) { title = ( ( BrowseFragment ) fragment ) . getTitle ( ) ; } else { title = fragment . toString ( ) ; } setTitle ( title ) ; final FragmentTransaction ft = getSupportFragmentManager ( ) . beginTransaction ( ) ; ft . setTransition ( FragmentTransaction . TRANSIT_FRAGMENT_OPEN ) ; ft . replace ( R . id . root_frame , fragment ) ; ft . addToBackStack ( label ) ; ft . setBreadCrumbTitle ( title ) ; ft . commit ( ) ; }
SpanTracker start ( ) ; void stop ( ) ; boolean isTracking ( ) ; long getStartTime ( ) ; }
protected void loadArtwork ( CoverAsyncHelper coverHelper , AlbumInfo albumInfo ) { coverHelper . downloadCover ( albumInfo ) ; }
private void reconnect ( ) { final boolean isMonitorAlive = isStatusMonitorAlive ( ) ; if ( isMonitorAlive ) { stopStatusMonitor ( ) ; try { mStatusMonitor . join ( 2L * DateUtils . SECOND_IN_MILLIS ) ; } catch ( final InterruptedException ignored ) { } } connect ( ) ; if ( isMonitorAlive ) { startStatusMonitor ( ) ;
VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , AuthHandlerBridge cb ) ; SASLStepOperation saslStep ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }
public DispositionOptions setMICAlg ( @Nullable final ECryptoAlgorithm eMICAlg ) { if ( eMICAlg ! = null & & eMICAlg . getCryptAlgorithmMode ( ) ! = ECryptoAlgorithmMode . DIGEST ) throw new IllegalArgumentException ( " Only digesting algorithms can be used here.  " + eMICAlg + "  is invalid! " ) ; return setMICAlg ( eMICAlg = = null ? null : eMICAlg . getID ( ) ) ; }
public void testArrayQueue ( ) { TestData data = Utils . generateTestData ( 100 ) ; String aName = " Queue [array] " ; Queue . ArrayQueue < Integer > aQueue = new Queue . ArrayQueue < Integer > ( ) ; Collection < Integer > aCollection = aQueue . toCollection ( ) ; assertTrue ( QueueTest . testQueue ( aQueue , aName , data . unsorted , data . invalid ) ) ; assertTrue ( JavaCollectionTest . testCollection ( aCollection , Integer . class , aName , data . unsorted , data . sorted , data . invalid ) ) ;
public Map < String , T > get ( ) throws InterruptedException , ExecutionException { try { return get ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ;
void rotateZ ( double d ) { Matrix3D matrix3d = new Matrix3D ( ) ; double d1 = Math . cos ( d ) ; double d2 = Math . sin ( d ) ; matrix3d . set ( 0 , 0 , d1 ) ; matrix3d . set ( 0 , 1 , - d2 ) ; matrix3d . set ( 1 , 0 , d2 ) ; matrix3d . set ( 1 , 1 , d1 ) ; postMultiply ( matrix3d ) ; }
protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { Term term = args [ 0 ] ; Concept concept = memory . conceptualize ( Consider . budgetMentalConcept ( operation ) , term ) ; concept . fire ( ) ; return null ; }
public void walk ( final int steps , final boolean immediate ) { if ( immediate ) { running = true ; paused = false ; tick ( ) ; } walk ( steps ) ; if ( immediate ) { running = false ;
private static void transformSubjectPI ( CompoundTerm subject , Term predicate , Memory memory ) { TruthValue truth = memory . currentTask . getSentence ( ) . truth ; BudgetValue budget ; Inheritance inheritance ; Term newSubj , newPred ; if ( subject instanceof Product ) { Product product = ( Product ) subject ;
public static Term make ( TreeSet < Term > set , Memory memory ) { if ( set . size ( ) = = 1 ) { return set . first ( ) ; } Term [ ] argument = set . toArray ( new Term [ set . size ( ) ] ) ; String name = makeCompoundName ( NativeOperator . INTERSECTION_INT , argument ) ; Term t = memory . term ( name ) ; return ( t ! = null ) ? t : new IntersectionInt ( name , argument ) ; }
public void clearComments ( ) { synchronized ( rootMonitor ) { config . clearComments ( ) ;
public void forget ( Concept x ) { BudgetFunctions . forget ( x . budget , memory . param . conceptForgetDurations . getCycles ( ) , Parameters . BAG_THRESHOLD ) ; }
public List < Artist > getArtists ( ) throws MPDServerException { return getArtists ( MPD . useAlbumArtist ) ; }
public StatsKeyMatcher not ( ) { return NoneMatcher . INSTANCE ; }
public boolean nextInput ( ) { if ( timer > 0 ) { timer - - ; return true ; } if ( inExp = = null ) { return false ; } String line = null ; while ( timer = = 0 ) { try { line = inExp . readLine ( ) ; if ( line = = null ) { inExp . close ( ) ; inExp = null ; return false ; } } catch ( IOException ex ) { reasoner . output ( " i/o error:  " + ex . getMessage ( ) ) ; } line = line . trim ( ) ; parse ( line ) ; } return true ; }
public boolean proceedWithTemporalInduction ( final Sentence newEvent , final Sentence stmLast , Task controllerTask , NAL nal , boolean SucceedingEventsInduction ) { if ( SucceedingEventsInduction & & ! controllerTask . isParticipatingInTemporalInductionOnSucceedingEvents ( ) ) { return false ; } if ( newEvent . isEternal ( ) | | ! isInputOrTriggeredOperation ( controllerTask , nal . memory ) ) { return false ; } if ( equalSubTermsInRespectToImageAndProduct ( newEvent . term , stmLast . term ) ) { return false ; } if ( newEvent . punctuation ! = Symbols . JUDGMENT_MARK | | stmLast . punctuation ! = Symbols . JUDGMENT_MARK ) return false ; nal . setTheNewStamp ( newEvent . stamp , stmLast . stamp , time ( ) ) ; nal . setCurrentTask ( controllerTask ) ; Sentence previousBelief = stmLast ; nal . setCurrentBelief ( previousBelief ) ; Sentence currentBelief = newEvent ; TemporalRules . temporalInduction ( currentBelief , previousBelief , nal ) ; return false ; }
public void specialCase ( ) { List < String > split = StringUtils . split ( " .a...a. " , '.' ) ; System . out . println ( " StringUtils:   " + split ) ; String [ ] jsplit = " .a...a. " . split ( " \\ . " ) ; System . out . println ( " String#split:  " + Arrays . toString ( jsplit ) ) ; AbstractConfig config = new SimpleConfig ( type - > true ) ; config . setValue ( " .a...a. " , " value " ) ; assert config . containsValue ( " .a...a. " ) ; assert config . < String > getValue ( " .a...a. " ) . equals ( " value " ) ; Map < String , Object > map = config . valueMap ( ) ; assert map . get ( " " ) instanceof Config ; Config c1 = ( Config ) map . get ( " " ) ; Config c2 = c1 . < Config > getValue ( " a " ) ; Config c3 = c2 . < Config > getValue ( " " ) ; Config c4 = c3 . < Config > getValue ( " " ) ; Config c5 = c4 . < Config > getValue ( " a " ) ; String value = c5 . < String > getValue ( " " ) ; assert value . equals ( " value " ) ; }
int getTimeoutExceptionThreshold ( ) ; MetricType enableMetrics ( ) ; MetricCollector getMetricCollector ( ) ; long getAuthWaitTime ( ) ; }
void setHeader ( String key , String value ) ; String getHeader ( String key ) ; String getHeader ( String key , String delimiter ) ; void setHeaders ( InternetHeaders headers ) ; InternetHeaders getHeaders ( ) ; void setHistory ( DataHistory history ) ; DataHistory getHistory ( ) ; void setMessage ( IMessage message ) ; IMessage getMessage ( ) ; void setMessageID ( String messageID ) ; String getMessageID ( ) ; void setPartnership ( Partnership partnership ) ; Partnership getPartnership ( ) ; void setText ( String text ) ; String getText ( ) ; void addHeader ( String key , String value ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; }
private static void asymmetricAsymmetric ( final Sentence taskSentence , final Sentence belief , int figure , final NAL nal ) { Statement taskStatement = ( Statement ) taskSentence . content ; Statement beliefStatement = ( Statement ) belief . content ; Term t1 , t2 ; Term [ ] u = new Term [ ] { taskStatement , beliefStatement } ; switch ( figure ) { case 11 :
public void toDataTypeDecimal ( ) { Schema logicalType = LogicalTypes . decimal ( 4 , 2 ) . addToSchema ( SchemaBuilder . builder ( ) . bytesType ( ) ) ; assertEquals ( " Invalid DataType " , DataTypes . createDecimalType ( 4 , 2 ) , AvroUtils . dataTypeFor ( logicalType ) ) ; }
public final static Term get ( final CharSequence name ) { Term x = atoms . get ( name ) ; if ( x ! = null & & ! x . toString ( ) . endsWith ( " ] " ) ) { return x ; } String namestr = name . toString ( ) ; int [ ] term_indices = null ; String before_indices_str = null ; if ( namestr . endsWith ( " ] " ) & & namestr . contains ( " [ " ) ) { String indices_str = namestr . split ( " \\ [ " ) [ 1 ] . split ( " \\ ] " ) [ 0 ] ; before_indices_str = namestr . split ( " \\ [ " ) [ 0 ] ; String [ ] inds = indices_str . split ( " , " ) ; if ( inds . length = = 2 ) { indices_str = " 1,1, " + indices_str ; inds = indices_str . split ( " , " ) ; } term_indices = new int [ inds . length ] ; for ( int i = 0 ; i < inds . length ; i + + ) { try { term_indices [ i ] = Integer . valueOf ( inds [ i ] ) ; } catch ( NumberFormatException ex ) { term_indices = null ; break ; } } } CharSequence name2 = name ; if ( term_indices ! = null ) { name2 = before_indices_str + " [i,j,k,l] " ; } x = new Term ( name2 ) ; x . term_indices = term_indices ; x . index_variable = before_indices_str ; atoms . put ( name2 , x ) ; return x ; }
@Override public int vertexColor ( V vertex ) { return ProcessingGraphPanel . this . vertexColor ( vertex ) ; }
public void testAbolish ( ) throws PrologException { Prolog engine = new Prolog ( ) ; String theory = " test(A, B) :- A is 1+2, B is 2+3. " ; engine . setTheory ( new Theory ( theory ) ) ; TheoryManager manager = engine . getTheoryManager ( ) ; Struct testTerm = new Struct ( " test " , new Struct ( " a " ) , new Struct ( " b " ) ) ; List < ClauseInfo > testClauses = manager . find ( testTerm ) ; assertEquals ( 1 , testClauses . size ( ) ) ; manager . abolish ( new Struct ( " / " , new Struct ( " test " ) , new Int ( 2 ) ) ) ; testClauses = manager . find ( testTerm ) ; assertEquals ( 0 , testClauses . size ( ) ) ; }
public JsonConfig parseJsonObject ( ) { JsonConfig config = new JsonConfig ( ) ; parseJsonObject ( config ) ; return config ; }
public void finish ( ) { if ( mFinished ) { return ; } mFinished = true ; mContextView . sendAccessibilityEvent ( AccessibilityEvent . TYPE_WINDOW_STATE_CHANGED ) ; mCallback . onDestroyActionMode ( this ) ; }
public void handleLine ( String line ) { getLogger ( ) . debug ( " Result:  %s " , line ) ; Long found = null ; if ( ! line . equals ( " NOT_FOUND " ) ) { found = new Long ( line ) ; } if ( cb ! = null ) { cb . mutatorResult ( found ) ; } transitionState ( State . COMPLETE ) ; }
public void containsValue ( ) throws Exception { MapConfig config = new SimpleConfig ( new SimpleConfig . SupportEverythingStrategy ( ) ) ; config . setString ( " a.b.c " , " value " ) ; assert config . containsValue ( " a " ) ; assert ! config . containsValue ( " b " ) ; assert config . containsValue ( " a.b " ) ; assert ! config . containsValue ( " c " ) ; assert config . containsValue ( " a.b.c " ) ; config . setInt ( " int " , 12 ) ; assert config . containsValue ( " int " ) ; }
public static boolean isJsonObject ( final String s ) { if ( s = = null | | s . isEmpty ( ) ) { return false ; } if ( s . startsWith ( " { " ) | | s . startsWith ( " [ " ) | | " true " . equals ( s ) | | " false " . equals ( s ) | | " null " . equals ( s ) | | decimalMatcher . reset ( s ) . matches ( ) ) { return true ; } return false ; }
public String toString ( ) { if ( arguments . length = = 0 ) { return rawType . toString ( ) ; } return rawType + " < " + String . join ( " ,  " , Arrays . stream ( arguments ) . map ( t - > t . toString ( ) )
public void handle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) throws AS2Exception { if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " Immediately resending message " + aMsg . getLoggingText ( ) ) ; String sResendAction = aOptions = = null ? null : ( String ) aOptions . get ( IProcessorResenderModule . OPTION_RESEND_ACTION ) ; if ( sResendAction = = null ) { LOGGER . warn ( " The resending action is missing - default to message sending! " ) ; sResendAction = IProcessorSenderModule . DO_SEND ; } final String sRetries = aOptions = = null ? null : ( String ) aOptions . get ( IProcessorResenderModule . OPTION_RETRIES ) ; int nRetries ; if ( sRetries ! = null ) nRetries = Integer . parseInt ( sRetries ) ; else { nRetries = IProcessorResenderModule . DEFAULT_RETRIES ; if ( LOGGER . isWarnEnabled ( ) ) LOGGER . warn ( " The resending retry count is missing - default to  " + nRetries + " ! " ) ; } nRetries - - ; if ( aOptions ! = null ) aOptions . put ( IProcessorResenderModule . OPTION_RETRIES , Integer . toString ( nRetries ) ) ; getSession ( ) . getMessageProcessor ( ) . handle ( sResendAction , aMsg , aOptions ) ; }
public void testQuery1 ( ) throws Narsese . InvalidInputException { testQueryAnswered ( 0 , 8 ) ; testQueryAnswered ( 8 , 0 ) ; }
public String toString ( ) { return " Cmd:  " + type + "  Key:  " + key + "  Flags:  " + flags + "  Exp:  " + exp + "  Data Length:  " + data . length ;
public static void main ( String [ ] args ) throws IOException , InstantiationException , InvocationTargetException , NoSuchMethodException , ParserConfigurationException , SAXException , IllegalAccessException , ParseException , ClassNotFoundException { NarParameters params = new NarParameters ( ) ; loadFrom ( " ../opennars/src/main/config/defaultConfig.xml " , null , params ) ; }
public static void main ( String [ ] args ) { FileWriter fw = null ; try { long t1 = System . currentTimeMillis ( ) ;
Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public int compare ( IntervalData < ? > arg0 , IntervalData < ? > arg1 ) { if ( arg0 . start < arg1 . start ) return - 1 ; if ( arg1 . start < arg0 . start ) return 1 ; return 0 ; }
public static < T extends Comparable < T > > void print ( BinarySearchTree < T > tree ) { System . out . println ( getString ( tree . root , " " , true ) ) ; }
public void writeBoolean ( boolean b , CharacterOutput output ) { if ( b ) { output . write ( TRUE_CHARS ) ;
private void reopenMenu ( boolean toggleMenuMode ) { if ( wActionBar ! = null & & wActionBar . isOverflowReserved ( ) ) { if ( ! wActionBar . isOverflowMenuShowing ( ) | | ! toggleMenuMode ) {
public void paint ( Graphics g ) { int w = getWidth ( ) ; int h = getHeight ( ) ; g . clearRect ( 0 , 0 , w , h ) ; float p = ( value . floatValue ( ) - min ) / ( max - min ) ; if ( barColor = = null ) { g . setColor ( Color . getHSBColor ( ( 1f - ( float ) p ) / 3.0f , 0.1f , 0.8f + 0.15f * ( 1f - ( float ) p ) ) ) ; } else { g . setColor ( barColor ) ; } int wp = ( int ) ( ( ( float ) w ) * p ) ; g . setColor ( barColor ) ; g . fillRect ( 0 , 0 , wp , h ) ; super . paint ( g ) ; }
public static CanonicalPath from ( Path fullFilePath ) { try {
public Param newParam ( ) { Param p = new Param ( ) ; p . noiseLevel . set ( 100 ) ; p . cycleMemory . set ( 1 ) ; p . cycleInputTasks . set ( 1 ) ; p . decisionThreshold . set ( 0.30 ) ; p . conceptCyclesToForget . set ( 10 ) ; p . taskCyclesToForget . set ( 20 ) ; p . beliefCyclesToForget . set ( 50 ) ; p . newTaskCyclesToForget . set ( 10 ) ; p . conceptBeliefsMax . set ( 7 ) ; p . conceptQuestionsMax . set ( 5 ) ; p . duration . set ( 5 ) ; p . contrapositionPriority . set ( 30 ) ; p . termLinkMaxReasoned . set ( 3 ) ; p . termLinkMaxMatched . set ( 10 ) ; p . termLinkRecordLength . set ( 10 ) ; p . experimentalNarsPlus . set ( false ) ; p . internalExperience . set ( false ) ; p . abbreviationMinComplexity . set ( 20 ) ; p . abbreviationMinQuality . set ( 0.9f ) ; return p ; }
Rule QueryVariable ( ) { return sequence ( " ? " , optional ( Identifier ( ) ) ) ; }
static Properties getProperties ( ) throws IOException { Properties props = new Properties ( ) ; InputStream is ; File f = new File ( " src/main/resources/samoa-storm-cluster.properties " ) ; is = new FileInputStream ( f ) ; try { props . load ( is ) ; } catch ( IOException e1 ) { System . out . println ( " Fail to load property file " ) ; return null ; } finally { is . close ( ) ; } return props ; }
boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isCompressed ( @Nonnull String sContentType ) throws AS2Exception ; @Nonnull MIC calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm , @Nonnull EContentTransferEncoding eCTE ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt , @Nonnull AS2ResourceHelper aResHelper ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs , @Nonnull EContentTransferEncoding eCTE ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify , @Nullable Consumer < X509Certificate > aEffectiveCertificateConsumer , @Nonnull AS2ResourceHelper aResHelper ) throws Exception ; }
protected void asyncUpdate ( ) { } @Override public void asyncExecSucceeded ( int jobID ) { if ( iJobID = = jobID ) { if ( items ! = null ) { ListViewButtonAdapter < String > listAdapter = new ListViewButtonAdapter < String > ( this , android . R . layout . simple_list_item_1 , items ) ; setListAdapter ( listAdapter ) ; } pd . dismiss ( ) ; } } }
public boolean expandActionView ( ) { return mNativeItem . expandActionView ( ) ; }
private static < V > boolean validate ( ArrayNode parent , KeyValueNode < V > child ) { if ( parent = = null | | parent . height = = 0 ) return true ; int parentPosition = getPosition ( parent . height - 1 , parent . key ) ; int childPosition = getPosition ( parent . height - 1 , child . key ) ; return ( childPosition = = parentPosition ) ; }
public static void run ( final MPD mpd , final String userCommand , final long l , final boolean internalMPD ) { new Thread ( new Runnable ( ) {
protected void setupNodes ( HashAlgorithm alg , int n ) { super . setupNodes ( n ) ; for ( int i = 0 ; i < nodeMocks . length ; i + + ) { nodeMocks [ i ] . expects ( atLeastOnce ( ) ) . method ( " getSocketAddress " ) . will ( returnValue ( InetSocketAddress . createUnresolved ( " 127.0.0.1 " , 10000 + i ) ) ) ; } locator = new KetamaNodeLocator ( Arrays . asList ( nodes ) , alg ) ; }
public IntersectionExt clone ( ) { return new IntersectionExt ( name ( ) , cloneTerms ( ) , isConstant ( ) , complexity ) ; }
protected abstract String getFilename ( IMessage aMsg , String sFileParam ) throws AS2InvalidParameterException ; @Nonnull @OverrideOnDemand protected File getFile ( @Nonnull final IMessage aMsg , @Nullable final String sFileParam ) throws IOException , AS2Exception { final String sFilename = getFilename ( aMsg , sFileParam ) ; final File aFile = new File ( sFilename ) ; AS2IOHelper . getFileOperationManager ( ) . createDirRecursiveIfNotExisting ( aFile . getParentFile ( ) ) ; return AS2IOHelper . getUniqueFile ( aFile . getParentFile ( ) , FilenameHelper . getAsSecureValidFilename ( aFile . getName ( ) ) ) ; } private static void _writeStreamToFile ( @Nonnull @WillClose final InputStream aIS , @Nonnull final File aDestination ) throws IOException { final FileOutputStream aOS = new FileOutputStream ( aDestination ) ; if ( StreamHelper . copyInputStreamToOutputStreamAndCloseOS ( aIS , aOS ) . isFailure ( ) ) throw new IOException ( " Failed to write content to  " + aDestination . getAbsolutePath ( ) ) ; } protected void store ( @Nonnull final File aMsgFile , @Nonnull @WillClose final InputStream aIS ) throws IOException { final String sTempDirname = getTempDir ( ) ; if ( sTempDirname ! = null ) { final File aTempDir = AS2IOHelper . getDirectoryFile ( sTempDirname ) ; final File aTempFile = AS2IOHelper . getUniqueFile ( aTempDir , aMsgFile . getName ( ) ) ; _writeStreamToFile ( aIS , aTempFile ) ; AS2IOHelper . moveFile ( aTempFile , aMsgFile , true , true ) ; } else { _writeStreamToFile ( aIS , aMsgFile ) ; } } @Override public boolean equals ( final Object o ) { return super . equals ( o ) ; } @Override public int hashCode ( ) { return super . hashCode ( ) ; } }
public boolean onQueryTextSubmit ( String query ) { InputMethodManager imm = ( InputMethodManager ) activity . getSystemService ( Context . INPUT_METHOD_SERVICE ) ; imm . hideSoftInputFromWindow ( searchView . getWindowToken ( ) , 0 ) ; list . requestFocus ( ) ; return true ; }
public void startAnim ( ) { if ( f ! = null ) f . getGraphanim ( ) . startAnim ( ) ;
public void testConceptInstancing ( ) throws Narsese . InvalidInputException { final NAR n = new NAR ( ) ; final String statement1 = " <a --> b>. " ; final Term a = np . parseTerm ( " a " ) ; assertTrue ( a ! = null ) ; final Term a1 = np . parseTerm ( " a " ) ; assertTrue ( a . equals ( a1 ) ) ; n . addInput ( statement1 ) ; n . cycles ( 4 ) ; n . addInput ( "  <a  --> b>.   " ) ; n . cycles ( 1 ) ; n . addInput ( "  <a--> b>.   " ) ; n . cycles ( 1 ) ; final String statement2 = " <a --> c>. " ; n . addInput ( statement2 ) ; n . cycles ( 4 ) ; final Term a2 = np . parseTerm ( " a " ) ; assertTrue ( a2 ! = null ) ; final Concept ca = n . memory . concept ( a2 ) ; assertTrue ( ca ! = null ) ; assertEquals ( true , n . memory . concepts . iterator ( ) . hasNext ( ) ) ;
private String senseKeyPOS ( String senseKey ) { if ( senseKey = = null | | senseKey = = " " ) return " " ; int underscore2 = senseKey . lastIndexOf ( " _ " ) ; if ( underscore2 < 0 ) return " " ; int underscore1 = senseKey . lastIndexOf ( " _ " , underscore2 - 1 ) ; if ( underscore1 < 0 ) return " " ; return senseKey . substring ( underscore1 + 1 , underscore2 ) ; }
public String [ ] getCoverUrl ( String artist , String album , String path , String filename ) throws Exception { String key = " 7fb78a81b20bee7cb6e8fad4cbcb3694 " ; Album albumObj = Album . getInfo ( artist , album , key ) ; return new String [ ] { albumObj . getImageURL ( ImageSize . MEGA ) } ; }
public void gotData ( String key , long cas ) { } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status:   " + status ) ; } } ; testData = new byte [ 64 ] ; new Random ( ) . nextBytes ( testData ) ; } protected abstract OperationFactory getOperationFactory ( ) ; public void testDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , genericCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertCallback ( op2 ) ; } public void testCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , storeCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getData ( ) ) ; assertStoreCallback ( op2 ) ; } public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } public void testMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } public void testStoreOperationAddCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . add , TEST_KEY , flags , exp , testData , storeCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . add , op2 . getStoreType ( ) ) ; assertStoreCallback ( op2 ) ; } public void testStoreOperationSetCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . set , TEST_KEY , flags , exp , testData , storeCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . set , op2 . getStoreType ( ) ) ; assertStoreCallback ( op2 ) ; } public void testConcatenationOperationAppendCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . append , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . append , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testConcatenationOperationPrependCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . prepend , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . prepend , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testSingleGetOperationCloning ( ) { GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( TEST_KEY , callback ) ; GetOperation op2 = cloneOne ( GetOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; } public void testSingleGetsOperationCloning ( ) { GetsOperation . Callback callback = ( GetsOperation . Callback ) mock ( GetsOperation . Callback . class ) . proxy ( ) ; GetsOperation op = ofact . gets ( TEST_KEY , callback ) ; GetsOperation op2 = cloneOne ( GetsOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; } public void testMultipleGetOperationCloning ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Collection < Operation > ops = ofact . clone ( op ) ; assertEquals ( 3 , ops . size ( ) ) ; Collection < String > mutableKeys = new ArrayList < String > ( keys ) ; int i = 3 ; for ( Operation o : ops ) { assertEquals ( i , mutableKeys . size ( ) ) ; GetOperation go = ( GetOperation ) o ; mutableKeys . removeAll ( go . getKeys ( ) ) ; assertEquals ( - - i , mutableKeys . size ( ) ) ; } } public void testMultipleGetOperationFanout ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; Mock m = mock ( GetOperation . Callback . class ) ; OperationStatus st = new OperationStatus ( true , " blah " ) ; m . expects ( once ( ) ) . method ( " complete " ) ; m . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; GetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Iterator < String > ki = keys . iterator ( ) ; int i = 0 ; for ( Operation o : ofact . clone ( op ) ) { GetOperation . Callback cb = ( GetOperation . Callback ) o . getCallback ( ) ; cb . gotData ( ki . next ( ) , + + i , new byte [ 3 ] ) ; cb . receivedStatus ( st ) ; cb . complete ( ) ; } } protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; } protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; } protected void assertStoreCallback ( Operation op ) { assertSame ( storeCallback , op . getCallback ( ) ) ; } private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( testData , bytes ) ) ; } @SuppressWarnings ( " unchecked " ) private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; } protected < T > T cloneOne ( Class < T > c , KeyedOperation t ) { return assertOne ( c , ofact . clone ( t ) ) ; } }
public void playlistChanged ( MPDPlaylistChangedEvent event ) { } @Override public void randomChanged ( MPDRandomChangedEvent event ) { } @Override public void repeatChanged ( MPDRepeatChangedEvent event ) { } @Override public void stateChanged ( MPDStateChangedEvent event ) { Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = oldStatus ) return ; if ( state = = MPDStatus . MPD_STATE_PLAYING ) { isPaused = false ; resumeStreaming ( ) ; isPlaying = true ; } else { oldStatus = state ; isPlaying = false ; stopStreaming ( ) ; } } } } @Override public void updateStateChanged ( MPDUpdateStateChangedEvent event ) { } @Override public void volumeChanged ( MPDVolumeChangedEvent event ) { } @Override public void onPrepared ( MediaPlayer mp ) { buffering = false ; isPlaying = true ; oldStatus = " " ; showNotification ( ) ; mediaPlayer . start ( ) ; } @Override public void onCompletion ( MediaPlayer mp ) { Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = MPDStatus . MPD_STATE_PLAYING ) { resumeStreaming ( ) ; } else { oldStatus = state ; die ( ) ; } } } } @Override public void onBufferingUpdate ( MediaPlayer mp , int percent ) { } @Override public boolean onError ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public boolean onInfo ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public void connectionFailed ( String message ) { Toast . makeText ( this , " Connection Failed ! " , Toast . LENGTH_SHORT ) . show ( ) ; } @Override public void connectionSucceeded ( String message ) { } }
public static Inheritance make ( Term subject , Term predicate , Memory memory ) { if ( invalidStatement ( subject , predicate ) ) { return null ; } String name = makeStatementName ( subject , Symbols . INHERITANCE_RELATION , predicate ) ; Term t = memory . nameToListedTerm ( name ) ; if ( t ! = null ) { return ( Inheritance ) t ; } ArrayList < Term > argument = argumentsToList ( subject , predicate ) ; return new Inheritance ( argument ) ; }
protected Node < T > removeValue ( T value ) { Node < T > nodeToRemoved = this . getNode ( value ) ; if ( nodeToRemoved ! = null ) { Node < T > replacementNode = this . getReplacementNode ( nodeToRemoved ) ; AVLNode < T > nodeToRefactor = null ; if ( replacementNode ! = null ) nodeToRefactor = ( AVLNode < T > ) replacementNode . parent ; if ( nodeToRefactor ! = null & & nodeToRefactor . equals ( nodeToRemoved ) ) nodeToRefactor = ( AVLNode < T > ) replacementNode ; if ( nodeToRefactor = = null ) nodeToRefactor = ( AVLNode < T > ) nodeToRemoved . parent ; replaceNodeWithNode ( nodeToRemoved , replacementNode ) ; if ( nodeToRefactor ! = null ) { while ( nodeToRefactor ! = null ) { if ( nodeToRefactor . lesser ! = null ) ( ( AVLNode < T > ) nodeToRefactor . lesser ) . updateHeight ( false ) ; if ( nodeToRefactor . greater ! = null ) ( ( AVLNode < T > ) nodeToRefactor . greater ) . updateHeight ( false ) ; ( ( AVLNode < T > ) nodeToRefactor ) . updateHeight ( false ) ; balanceAfterDelete ( nodeToRefactor ) ; nodeToRefactor = ( AVLNode < T > ) nodeToRefactor . parent ; } } } return nodeToRemoved ; }
public AS2ClientResponse sendSynchronous ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2ClientRequest aRequest ) { ValueEnforcer . notNull ( aSettings , " ClientSettings " ) ; ValueEnforcer . notNull ( aRequest , " ClientRequest " ) ; final AS2ClientResponse aResponse = createResponse ( ) ; IMessage aMsg = null ; final StopWatch aSW = StopWatch . createdStarted ( ) ; try { final Partnership aPartnership = buildPartnership ( aSettings ) ; aMsg = createMessage ( aPartnership , aRequest ) ; aResponse . setOriginalMessageID ( aMsg . getMessageID ( ) ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " MessageID to send:  " + aMsg . getMessageID ( ) ) ; final boolean bHasRetries = aSettings . getRetryCount ( ) > 0 ; final AS2Session aSession = createSession ( ) ; initCertificateFactory ( aSettings , aSession ) ; initPartnershipFactory ( aSession ) ; initMessageProcessor ( aSession ) ; if ( bHasRetries ) { final IProcessorResenderModule aResender = new ImmediateResenderModule ( ) ; aResender . initDynamicComponent ( aSession , null ) ; aSession . getMessageProcessor ( ) . addModule ( aResender ) ; } aSession . getMessageProcessor ( ) . startActiveModules ( ) ; try { beforeSend ( aSettings , aSession , aMsg ) ; final ICommonsMap < String , Object > aHandleOptions = new CommonsHashMap < > ( ) ; if ( bHasRetries ) aHandleOptions . put ( IProcessorResenderModule . OPTION_RETRIES , Integer . toString ( aSettings . getRetryCount ( ) ) ) ; aPartnership . setContentTransferEncodingSend ( aRequest . getContentTransferEncoding ( ) ) ; aPartnership . setContentTransferEncodingReceive ( aRequest . getContentTransferEncoding ( ) ) ; final AS2SenderModule aSender = m_aAS2SenderModuleFactory . get ( ) ; aSender . initDynamicComponent ( aSession , null ) ; aSender . attrs ( ) . putIn ( AbstractHttpSenderModule . ATTR_CONNECT_TIMEOUT , aSettings . getConnectTimeoutMS ( ) ) ; aSender . attrs ( ) . putIn ( AbstractHttpSenderModule . ATTR_READ_TIMEOUT , aSettings . getReadTimeoutMS ( ) ) ; aMsg . headers ( ) . setAllHeaders ( aSettings . customHeaders ( ) ) ; aSession . getMessageProcessor ( ) . addModule ( aSender ) ; aSender . handle ( IProcessorSenderModule . DO_SEND , aMsg , aHandleOptions ) ; } finally { aSession . getMessageProcessor ( ) . stopActiveModules ( ) ; } } catch ( final Exception ex ) { LOGGER . error ( " Error sending AS2 message " , ex ) ; aResponse . setException ( ex ) ; } finally { if ( aMsg ! = null & & aMsg . getMDN ( ) ! = null ) { aResponse . setMDN ( aMsg . getMDN ( ) ) ; } } if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Response retrieved:  " + aResponse . getAsString ( ) ) ; aResponse . setExecutionDuration ( aSW . stopAndGetDuration ( ) ) ; return aResponse ; }
public String getPartnershipName ( ) { return m_sPartnershipName ; }
public void step ( TestbedSettings settings ) { boolean advanceRay = settings . pause = = false | | settings . singleStep ; super . step ( settings ) ; addTextLine ( " Press 1-6 to drop stuff, m to change the mode " ) ; addTextLine ( " Polygon 1 is filtered " ) ; addTextLine ( " Mode =  " + m_mode ) ; float L = 11.0f ; point1 . set ( 0.0f , 10.0f ) ; d . set ( L * MathUtils . cos ( m_angle ) , L * MathUtils . sin ( m_angle ) ) ; point2 . set ( point1 ) ; point2 . addLocal ( d ) ; if ( m_mode = = Mode . e_closest ) { ccallback . init ( ) ; getWorld ( ) . raycast ( ccallback , point1 , point2 ) ; if ( ccallback . m_hit ) { getDebugDraw ( ) . drawPoint ( ccallback . m_point , 5.0f , new Color3f ( 0.4f , 0.9f , 0.4f ) ) ; getDebugDraw ( ) . drawSegment ( point1 , ccallback . m_point , new Color3f ( 0.8f , 0.8f , 0.8f ) ) ; pooledHead . set ( ccallback . m_normal ) ; pooledHead . mulLocal ( .5f ) . addLocal ( ccallback . m_point ) ; getDebugDraw ( ) . drawSegment ( ccallback . m_point , pooledHead , new Color3f ( 0.9f , 0.9f , 0.4f ) ) ; } else { getDebugDraw ( ) . drawSegment ( point1 , point2 , new Color3f ( 0.8f , 0.8f , 0.8f ) ) ; } } else if ( m_mode = = Mode . e_any ) { acallback . init ( ) ; getWorld ( ) . raycast ( acallback , point1 , point2 ) ; if ( acallback . m_hit ) { getDebugDraw ( ) . drawPoint ( acallback . m_point , 5.0f , new Color3f ( 0.4f , 0.9f , 0.4f ) ) ; getDebugDraw ( ) . drawSegment ( point1 , acallback . m_point , new Color3f ( 0.8f , 0.8f , 0.8f ) ) ; pooledHead . set ( acallback . m_normal ) ; pooledHead . mulLocal ( .5f ) . addLocal ( acallback . m_point ) ; getDebugDraw ( ) . drawSegment ( acallback . m_point , pooledHead , new Color3f ( 0.9f , 0.9f , 0.4f ) ) ; } else { getDebugDraw ( ) . drawSegment ( point1 , point2 , new Color3f ( 0.8f , 0.8f , 0.8f ) ) ; } } else if ( m_mode = = Mode . e_multiple ) { mcallback . init ( ) ; getWorld ( ) . raycast ( mcallback , point1 , point2 ) ; getDebugDraw ( ) . drawSegment ( point1 , point2 , new Color3f ( 0.8f , 0.8f , 0.8f ) ) ; for ( int i = 0 ; i < mcallback . m_count ; + + i ) { Vec2 p = mcallback . m_points [ i ] ; Vec2 n = mcallback . m_normals [ i ] ; getDebugDraw ( ) . drawPoint ( p , 5.0f , new Color3f ( 0.4f , 0.9f , 0.4f ) ) ; getDebugDraw ( ) . drawSegment ( point1 , p , new Color3f ( 0.8f , 0.8f , 0.8f ) ) ; pooledHead . set ( n ) ; pooledHead . mulLocal ( .5f ) . addLocal ( p ) ; getDebugDraw ( ) . drawSegment ( p , pooledHead , new Color3f ( 0.9f , 0.9f , 0.4f ) ) ; } } if ( advanceRay ) { m_angle + = 0.25f * MathUtils . PI / 180.0f ;
protected void heapUp ( int idx ) { int nodeIndex = idx ; T value = this . array [ nodeIndex ] ; if ( value = = null ) return ; while ( nodeIndex > = 0 ) { int parentIndex = getParentIndex ( nodeIndex ) ;
public void testBadOperation ( ) throws Exception { client . addOp ( " x " , new OperationImpl ( new OperationCallback ( ) { public void complete ( ) {
public CountDownLatch broadcastOperation ( BroadcastOpFactory of ) { return broadcastOperation ( of , locator . getAll ( ) ) ; }
public CommandResult execute ( final IPartnershipFactoryWithPartners partFx , final Object [ ] params ) throws OpenAS2Exception { if ( params . length < 1 ) { return new CommandResult ( ECommandResultType . TYPE_INVALID_PARAM_COUNT , getUsage ( ) ) ; } final IMicroDocument doc = new MicroDocument ( ) ; final IMicroElement root = doc . appendElement ( " partner " ) ; for ( int i = 0 ; i < params . length ; i + + ) { final String param = ( String ) params [ i ] ; final int pos = param . indexOf ( '=' ) ; if ( i = = 0 ) { root . setAttribute ( " name " , param ) ; } else if ( pos = = 0 ) { return new CommandResult ( ECommandResultType . TYPE_ERROR , " incoming parameter missing name " ) ; } else if ( pos > 0 ) { root . setAttribute ( param . substring ( 0 , pos ) , param . substring ( pos + 1 ) ) ; } else return new CommandResult ( ECommandResultType . TYPE_ERROR , " incoming parameter missing value " ) ; } final Partner aNewPartner = ( ( XMLPartnershipFactory ) partFx ) . loadPartner ( root ) ; partFx . addPartner ( aNewPartner ) ; return new CommandResult ( ECommandResultType . TYPE_OK ) ; }
public Builder clearIncluded ( ) { included_ = getDefaultInstance ( ) . getIncluded ( ) ; onChanged ( ) ; return this ; }
public final AS2ClientSettings setKeyStore ( @Nonnull final IKeyStoreType aKeyStoreType , @Nonnull final File aFile , @Nonnull final String sPassword ) { ValueEnforcer . notNull ( aKeyStoreType , " KeyStoreType " ) ; ValueEnforcer . notNull ( aFile , " File " ) ; ValueEnforcer . notNull ( sPassword , " Password " ) ; m_aKeyStoreType = aKeyStoreType ; m_aKeyStoreFile = aFile ; m_aKeyStoreBytes = null ; m_sKeyStorePassword = sPassword ; return this ; }
Bucket getBucketConfiguration ( String bucketname ) throws ConfigurationException ; void subscribe ( String bucketName , Reconfigurable rec ) throws ConfigurationException ; void unsubscribe ( String vbucketName , Reconfigurable rec ) ; void shutdown ( ) ; String getAnonymousAuthBucket ( ) ; }
public void associateWithTask ( DNSTask task , DNSState state ) { _state . associateWithTask ( task , state ) ; }
void Draw1DLine ( float [ ] input , int RenderSize ) { for ( int i = 0 ; i < input . length ; i + + ) {
public void clear ( ) { for ( int i = 0 ; i < array . length ; i + + ) { array [ i ] . clear ( ) ; } size = 0 ; }
public void remove ( int value ) { Node nodeToRemove = root ; while ( true ) { if ( nodeToRemove = = null ) {
public NAR init ( NAR n ) { for ( Operator o : DefaultOperators . get ( ) ) n . memory . addOperator ( o ) ; for ( Operator o : ExampleOperators . get ( ) ) n . memory . addOperator ( o ) ; n . addPlugin ( new DefaultTextPerception ( ) ) ; if ( pluginPlanner ! = null ) { n . addPlugin ( pluginPlanner ) ; } if ( Parameters . INTERNAL_EXPERIENCE_FULL ) { FullInternalExperience nal9 = new FullInternalExperience ( ) ; n . addPlugin ( nal9 ) ; } else if ( Parameters . INTERNAL_EXPERIENCE ) { MinimalInternalExperience nal9 = new MinimalInternalExperience ( ) ; n . addPlugin ( nal9 ) ; } if ( Parameters . INTERNAL_EXPERIENCE_FULL ) { Abbreviation nal9abr = new Abbreviation ( ) ; n . addPlugin ( nal9abr ) ; } if ( Parameters . INTERNAL_EXPERIENCE_FULL ) { Counting nal9cnt = new Counting ( ) ; n . addPlugin ( nal9cnt ) ; } return n ; }
private void convertConfig ( UnmodifiableConfig input , ConcurrentCommentedConfig into ) { if ( input instanceof UnmodifiableCommentedConfig ) { into . bulkCommentedUpdate ( view - > {
public void run ( ) { s . cells . click ( " " , " go-to " , " " ) ; s . nar . start ( 100 ) ; }
@Override public void event ( Class event , Object [ ] arguments ) { long t = n . getTime ( ) ; if ( t % 100 ! = 0 ) return ; for ( int i = 0 ; i < v . input . data . length ; i + + ) v . input . data [ i ] = 0.5 * ( 1.0 + Math . sin ( ( t + i ) / 20 f ) ) ; v . update ( ) ; }
private int refresh ( int playlistVersion ) throws MPDServerException { MPDStatus status = this . mpd . getStatus ( ) ; List < String > response = this . mpd . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_CHANGES , Integer . toString ( playlistVersion ) ) ; List < Music > playlist = Music . getMusicFromList ( response ) ; this . list . clear ( ) ; this . list . addAll ( playlist ) ; return status . getPlaylistVersion ( ) ; }
public boolean isEnabled ( final int position ) { final boolean isEnabled ; if ( mDataBinder = = null ) { isEnabled = super . isEnabled ( position ) ; } else { isEnabled = mDataBinder . isEnabled ( position , mItems , getItem ( position ) ) ; } return isEnabled ; }
public String mainText ( ) { return music . mainText ( ) ; }
public void event ( Class event , Object . . . arguments ) { if ( app ! = null ) app . updateGraph ( ) ;
public void testGetStatsCacheDump ( ) throws Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } client . set ( " dumpinitializer " , 0 , " hi " ) ; Map < SocketAddress , Map < String , String > > stats = client . getStats ( " cachedump 1 10000 " ) ; System . out . println ( " Stats cachedump:   " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; String val = oneStat . get ( " dumpinitializer " ) ; assertTrue ( val + " doesn't match " , val . matches ( " \\ [2 b;  \\ d+ s \\ ] " ) ) ; }
public void insertTermLink ( TermLink termLink ) { termLinks . putIn ( termLink ) ; }
@Override public void actionPerformed ( ActionEvent e ) { layoutMode = layoutSelect . getSelectedItem ( ) . toString ( ) ; update ( ) ; app . drawn = false ; }
public CommentedFileConfig wrapRead ( CommentedFileConfig config ) { return new ConvertedCommentedFileConfig ( config , this : : convert , v - > v , config . configFormat ( ) : : supportsType ) ;
public List < Artist > getArtists ( boolean useAlbumArtist ) throws MPDServerException { List < String > artistNames = useAlbumArtist ? listAlbumArtists ( ) : listArtists ( true ) ; List < Artist > artists = new ArrayList < > ( ) ; if ( null ! = artistNames & & ! artistNames . isEmpty ( ) ) { for ( String artist : artistNames ) { artists . add ( new Artist ( artist , MPD . showArtistAlbumCount ( ) ? getAlbumCount ( artist , useAlbumArtist ) : 0 ) ) ; } } Collections . sort ( artists ) ; return artists ; }
public void reset ( ) { event . emit ( ResetStart . class ) ; concepts . clear ( ) ; novelTasks . clear ( ) ; newTasks . clear ( ) ; timing = param . getTiming ( ) ; cycle = 0 ; timeRealStart = timeRealNow = System . currentTimeMillis ( ) ; timePreviousCycle = time ( ) ; cyclesQueued = 0 ; working = true ; emotion . set ( 0.5f , 0.5f ) ; event . emit ( ResetEnd . class ) ;
public void randomChanged ( final boolean random ) { } @Override public void repeatChanged ( final boolean repeating ) { } @Override public void stateChanged ( final MPDStatus mpdStatus , final int oldState ) { } @Override public void trackChanged ( final MPDStatus mpdStatus , final int oldTrack ) { } @Override public void volumeChanged ( final MPDStatus mpdStatus , final int oldVolume ) { } }
public static boolean tooMuchTemporalStatements ( Term t ) { String s = t . toString ( ) ; int a = s . length ( ) - s . replace ( " =/> " , " " ) . length ( ) ; int b = s . length ( ) - s . replace ( " =|> " , " " ) . length ( ) ; int c = s . length ( ) - s . replace ( " = \\ > " , " " ) . length ( ) ; int d = s . length ( ) - s . replace ( " </> " , " " ) . length ( ) ; int e = s . length ( ) - s . replace ( " <|> " , " " ) . length ( ) ; return ( a + b + c + d + e ) / 3 > 1 ; }
public String getAS2VersionID ( ) { return m_sAS2VersionID ; }
public void run ( ) { try {
public void boot ( ) { System . out . println ( incipit ) ; become ( " goalRequest " ) ; }
public Term conceptTerm ( final CharSequence name ) { final Concept concept = concepts . get ( name ) ; if ( concept ! = null ) { return concept . term ; } return null ; }
public String toString ( ) { if ( this . truth = = null ) { if ( calculated ) { return " No connection to input evidence " ; } else { return " Node not connected to input " ; } } return this . term . toString ( ) + " . :|:  " + this . truth . toString ( ) ; }
public abstract String [ ] getHostAddresses ( ) ; @Deprecated public abstract InetAddress getAddress ( ) ; @Deprecated public abstract InetAddress getInetAddress ( ) ; @Deprecated public abstract Inet4Address getInet4Address ( ) ; @Deprecated public abstract Inet6Address getInet6Address ( ) ; public abstract InetAddress [ ] getInetAddresses ( ) ; public abstract Inet4Address [ ] getInet4Addresses ( ) ; public abstract Inet6Address [ ] getInet6Addresses ( ) ; public abstract int getPort ( ) ; public abstract int getPriority ( ) ; public abstract int getWeight ( ) ; public abstract byte [ ] getTextBytes ( ) ; @Deprecated public abstract String getTextString ( ) ; @Deprecated public abstract String getURL ( ) ; public abstract String [ ] getURLs ( ) ; @Deprecated public abstract String getURL ( String protocol ) ; public abstract String [ ] getURLs ( String protocol ) ; public abstract byte [ ] getPropertyBytes ( final String name ) ; public abstract String getPropertyString ( final String name ) ; public abstract Enumeration < String > getPropertyNames ( ) ; public abstract String getNiceTextString ( ) ; public abstract void setText ( final byte [ ] text ) throws IllegalStateException ; public abstract void setText ( final Map < String , ? > props ) throws IllegalStateException ; public abstract boolean isPersistent ( ) ; public abstract String getDomain ( ) ; public abstract String getProtocol ( ) ; public abstract String getApplication ( ) ; public abstract String getSubtype ( ) ; public abstract Map < Fields , String > getQualifiedNameMap ( ) ; @Override public ServiceInfo clone ( ) { try { return ( ServiceInfo ) super . clone ( ) ; } catch ( CloneNotSupportedException exception ) { return null ; } } }
public boolean isForceCoverRefresh ( ) { return mForceCoverRefresh ; }
public void handle ( final AbstractNetModule owner , @Nonnull final Socket aSocket ) { final String sClientInfo = getClientInfo ( aSocket ) ; s_aLogger . info ( " Incoming connection  " + sClientInfo ) ; final AS2Message aMsg = createMessage ( aSocket ) ; byte [ ] aMsgData = null ; final IAS2HttpResponseHandler aResponseHandler = new AS2HttpResponseHandlerSocket ( aSocket ) ; final StopWatch aSW = StopWatch . createdStarted ( ) ; try { aMsgData = HTTPHelper . readHttpRequest ( new AS2InputStreamProviderSocket ( aSocket ) , aResponseHandler , aMsg ) ; } catch ( final Exception ex ) { final NetException ne = new NetException ( aSocket . getInetAddress ( ) , aSocket . getPort ( ) , ex ) ; ne . terminate ( ) ; } aSW . stop ( ) ; if ( aMsgData ! = null ) {
public List < String > listAlbumArtists ( final Genre genre , final boolean sortInsensitive ) throws IOException , MPDException { final List < String > response = mConnection . sendCommand ( MPDCommand . MPD_CMD_LIST_TAG , MPDCommand . MPD_TAG_ALBUM_ARTIST , MPDCommand . MPD_TAG_GENRE , genre . getName ( ) ) ; return parseResponse ( response , MPDCommand . MPD_TAG_ALBUM_ARTIST , sortInsensitive ) ; }
void libraryStateChanged ( boolean updating , boolean dbChanged ) ; void playlistChanged ( MPDStatus mpdStatus , int oldPlaylistVersion ) ; void randomChanged ( boolean random ) ; void repeatChanged ( boolean repeating ) ; void stateChanged ( MPDStatus mpdStatus , int oldState ) ; void trackChanged ( MPDStatus mpdStatus , int oldTrack ) ; void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) ; }
public void render ( Graphics og , float alpha ) { if ( ! visible ) return ; int xPixel = ( int ) ( xOld + ( x - xOld ) * alpha ) - xPicO ; int yPixel = ( int ) ( yOld + ( y - yOld ) * alpha ) - yPicO ; og . drawImage ( sheet [ xPic ] [ yPic ] , xPixel + ( xFlipPic ? wPic : 0 ) , yPixel + ( yFlipPic ? hPic : 0 ) , xFlipPic ? - wPic : wPic , yFlipPic ? - hPic : hPic , null ) ; }
private static String timeToString ( long seconds ) { if ( seconds < 0 ) { seconds = 0 ; } long hours = seconds / 3600 ; seconds - = 3600 * hours ; long minutes = seconds / 60 ; seconds - = minutes * 60 ; if ( hours = = 0 ) { return String . format ( " %02d:%02d " , minutes , seconds ) ;
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { System . out . println ( " Executed:  " + this ) ; for ( Term t : args ) { System . out . println ( "  ---  " + t ) ; chamb . gotoObj ( t . toString ( ) , " pick " ) ; } return null ; }
long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public void event ( Class event , Object [ ] args ) { if ( event = = Events . InduceSucceedingEvent . class ) { Task newEvent = ( Task ) args [ 0 ] ; eventbuffer . add ( newEvent ) ; if ( eventbuffer . size ( ) > cur_maxlen ) { eventbuffer . remove ( 0 ) ; } NAL nal = ( NAL ) args [ 1 ] ; perceive ( ) ; } if ( event = = Events . ConceptForget . class ) { Concept forgot = ( Concept ) args [ 0 ] ; handleConjunctionSequence ( forgot . term , false ) ; } if ( event = = Events . ConceptNew . class ) { Concept newC = ( Concept ) args [ 0 ] ;
public static void main ( String [ ] args ) throws InterruptedException , IOException { int port = 9090 ; NARServer s = new NARServer ( port , 8887 ) ; System . out . println ( " NARS Web Server ready on port:  " + port ) ;
public void addOperation ( CASOperation op ) { ops . add ( op ) ; Iterator < String > is = op . getKeys ( ) . iterator ( ) ; String k = is . next ( ) ; int keylen = KeyUtil . getKeyBytes ( k ) . length ; byteCount + = MIN_RECV_PACKET + StoreOperationImpl . EXTRA_LEN + keylen + op . getData ( ) . length ;
public void draw ( boolean text ) { update ( ) ; if ( ! visible ) return ; float r = ( radius + boost * boostScale ) * nodeSize / 2f ; if ( r > 0 ) { g . setPaint ( color ) ;
MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bAllowCertificateInBodyPart ) throws Exception ; }
void configure ( Config config ) ; Iterator < Row > translate ( K key , V value ) throws Exception ; StructType getSchema ( ) ; }
public List < String > listAlbumArtists ( Genre genre ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; List < String > response = mpdConnection . sendCommand ( MPDCommand . MPD_CMD_LIST_TAG , MPDCommand . MPD_TAG_ALBUM_ARTIST , MPDCommand . MPD_TAG_GENRE , genre . getName ( ) ) ; ArrayList < String > result = new ArrayList < String > ( ) ; for ( String s : response ) { String name = s . substring ( " albumartist:  " . length ( ) ) ; if ( name . length ( ) > 0 ) result . add ( name ) ; } Collections . sort ( result ) ; return result ; }
public String calculateMIC ( @Nonnull final MimeBodyPart aPart , @Nonnull final ECryptoAlgorithmSign eDigestAlgorithm , final boolean bIncludeHeaders ) throws GeneralSecurityException , MessagingException , IOException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( eDigestAlgorithm , " DigestAlgorithm " ) ; final ASN1ObjectIdentifier aMICAlg = eDigestAlgorithm . getOID ( ) ; final MessageDigest aMessageDigest = MessageDigest . getInstance ( aMICAlg . getId ( ) , BouncyCastleProvider . PROVIDER_NAME ) ; final NonBlockingByteArrayOutputStream aBAOS = new NonBlockingByteArrayOutputStream ( ) ; if ( bIncludeHeaders ) { aPart . writeTo ( aBAOS ) ; } else { StreamUtils . copyInputStreamToOutputStream ( aPart . getInputStream ( ) , aBAOS ) ; } final byte [ ] aData = aBAOS . toByteArray ( ) ; aBAOS . close ( ) ; final NonBlockingByteArrayInputStream aIS = _trimCRLFPrefix ( aData ) ; final DigestInputStream aDigIS = new DigestInputStream ( aIS , aMessageDigest ) ; final byte [ ] aBuf = new byte [ 4096 ] ; while ( aDigIS . read ( aBuf ) > = 0 ) { } aDigIS . close ( ) ; final byte [ ] aMIC = aDigIS . getMessageDigest ( ) . digest ( ) ; final String sMICString = Base64 . encodeBytes ( aMIC ) ; return sMICString + " ,  " + eDigestAlgorithm . getID ( ) ; }
public void initDynamicComponent ( final ISession aSession , final IStringMap aOptions ) throws OpenAS2Exception { super . initDynamicComponent ( aSession , aOptions ) ; getParameterRequired ( PARAM_RESEND_DIRECTORY ) ; getParameterRequired ( PARAM_ERROR_DIRECTORY ) ; }
public boolean add ( T value ) ; public boolean remove ( T value ) ; public boolean contains ( T value ) ; public int size ( ) ; public boolean validate ( ) ; public java . util . List < T > asList ( ) ; public java . util . Collection < T > toCollection ( ) ; }
public void setupResend ( ) { Operation op = getCurrentWriteOp ( ) ; if ( op ! = null ) { op . getBuffer ( ) . reset ( ) ; } while ( hasReadOp ( ) ) { op = removeCurrentReadOp ( ) ; getLogger ( ) . warn ( " Discarding partially completed op: %s " , op ) ; op . cancel ( ) ; } getWbuf ( ) . clear ( ) ; getRbuf ( ) . clear ( ) ; toWrite = 0 ; }
protected void OnArtistsLoaded ( ) { ListViewButtonAdapter < String > artistsAdapter = new ListViewButtonAdapter < String > ( ArtistsActivity . this , android . R . layout . simple_list_item_1 , items ) ; PlusListener AddListener = new PlusListener ( ) { @Override public void OnAdd ( CharSequence sSelected , int iPosition ) { try { MPDApplication app = ( MPDApplication ) getApplication ( ) ; ArrayList < Music > songs = new ArrayList < Music > ( app . oMPDAsyncHelper . oMPD . find ( MPD . MPD_FIND_ARTIST , sSelected . toString ( ) ) ) ; app . oMPDAsyncHelper . oMPD . getPlaylist ( ) . add ( songs ) ; MainMenuActivity . notifyUser ( String . format ( getResources ( ) . getString ( R . string . artistAdded ) , sSelected ) , ArtistsActivity . this ) ; } catch ( MPDServerException e ) { e . printStackTrace ( ) ; } } } ; artistsAdapter . SetPlusListener ( AddListener ) ; setListAdapter ( artistsAdapter ) ; pd . dismiss ( ) ; }
public static StatsKeyMatcher attrNamePrefix ( final String prefix ) { return new PrefixMatcher ( MatchTarget . ATTR_NAME , prefix ) ; }
public String reject ( NAL nal , Task task , boolean revised , boolean single , Task parent , Sentence otherBelief ) { if ( ! task . sentence . isGoal ( ) ) { if ( task . sentence . isEternal ( ) ) return " Not Goal " ; } return null ; }
private static void runStreaming ( final Set < Step > steps ) throws Exception { final Set < Step > independentNonStreamingSteps = StepUtils . getIndependentNonStreamingSteps ( steps ) ; runBatch ( independentNonStreamingSteps ) ; Set < StreamingStep > streamingSteps = StepUtils . getStreamingSteps ( steps ) ; for ( final StreamingStep streamingStep : streamingSteps ) { LOG . debug ( " Setting up streaming step:  " + streamingStep . getName ( ) ) ; JavaDStream stream = streamingStep . getStream ( ) ; stream . foreachRDD ( new VoidFunction < JavaRDD < ? > > ( ) { @Override public void call ( JavaRDD < ? > raw ) throws Exception { StepUtils . resetRepeatingSteps ( steps ) ; runBatch ( independentNonStreamingSteps ) ; streamingStep . setData ( streamingStep . translate ( raw ) ) ; streamingStep . setSubmitted ( true ) ; Set < Step > dependentSteps = StepUtils . getAllDependentSteps ( streamingStep , steps ) ; Set < Step > batchSteps = Sets . newHashSet ( dependentSteps ) ; batchSteps . add ( streamingStep ) ; batchSteps . addAll ( streamingStep . loadNewBatchSteps ( ) ) ; batchSteps . addAll ( independentNonStreamingSteps ) ; runBatch ( batchSteps ) ; StepUtils . resetSteps ( dependentSteps ) ; streamingStep . recordProgress ( raw ) ; } } ) ; LOG . debug ( " Finished setting up streaming step:  " + streamingStep . getName ( ) ) ; } JavaStreamingContext jsc = Contexts . getJavaStreamingContext ( ) ; jsc . start ( ) ; LOG . debug ( " Streaming context started " ) ; jsc . awaitTermination ( ) ; LOG . debug ( " Streaming context terminated " ) ; }
public boolean add ( T value ) { return queue . offer ( value ) ; }
public boolean equals ( Object obj ) { if ( obj = = null ) return false ; if ( ! ( obj instanceof Step ) ) return false ; return this . getName ( ) . equals ( ( ( Step ) obj ) . getName ( ) ) ; }
public void onChange ( float v ) { app . nodeSize = ( float ) v ; app . drawn = false ; }
public int hashCode ( ) { if ( hash = = 0 ) { if ( length ( ) > 0 ) hash = ( 31 + left . hashCode ( ) ) * 31 + right . hashCode ( ) ; else hash = 1 ; } return hash ; }
protected void decodePayload ( byte [ ] pl ) { final int flags = decodeInt ( pl , 0 ) ; final byte [ ] data = new byte [ pl . length - EXTRA_HDR_LEN ] ; System . arraycopy ( pl , EXTRA_HDR_LEN , data , 0 , pl . length - EXTRA_HDR_LEN ) ; GetOperation . Callback gcb = ( GetOperation . Callback ) getCallback ( ) ; gcb . gotData ( key , flags , data ) ; getCallback ( ) . receivedStatus ( STATUS_OK ) ; }
public void startReaper ( ) { DNSTaskStarter . Factory . getInstance ( ) . getStarter ( this . getDns ( ) ) . startReaper ( ) ; }
public String toString ( ) { final StringWriter out = new StringWriter ( this . length ( ) ) ; try { this . write ( out ) ; out . close ( ) ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } return out . toString ( ) ; }
public boolean add ( T value ) { return tree . add ( value ) ; }
public String getTextEscaped ( ) { return StringHelper . replaceAll ( m_sText , " $ " , " $$ " ) ; }
protected void toString ( StringBuilder aLog ) { super . toString ( aLog ) ; aLog . append ( "  text: ' " + ( ( _text . length > 20 ) ? new String ( _text , 0 , 17 ) + " ... " : new String ( _text ) ) + " ' " ) ; }
public static Term make ( Term [ ] argument , final Memory memory ) { final String name = makeCompoundName ( NativeOperator . PRODUCT , argument ) ; final Term t = memory . conceptTerm ( name ) ; return ( t ! = null ) ? t : new Product ( name , argument ) ; }
public boolean handleMessage ( final Message message ) { boolean result = true ; switch ( message . what ) { case DELAYED_PLAY : mMediaPlayer . prepareAsync ( ) ; break ; case DELAYED_SERVICE_STOP : Log . d ( TAG , " Stopping self by handler delay. " ) ; stopSelf ( ) ; break ; default : result = false ; break ; } return result ; }
public int compare ( final Object lhs , final Object rhs ) { return DEFAULT_COLLATOR . compare ( ( String ) lhs , ( String ) rhs ) ; }
final public static Term make ( final Term [ ] argList , final int temporalOrder , final boolean spatial ) { if ( Debug . DETAILED ) { Terms . verifyNonNull ( argList ) ; } if ( argList = = null | | argList . length = = 0 ) { return null ; } if ( argList . length = = 1 ) { return argList [ 0 ] ; } if ( temporalOrder = = TemporalRules . ORDER_FORWARD ) { final Term [ ] newArgList = spatial ? argList : simplifyIntervals ( flatten ( argList , temporalOrder , spatial ) ) ;
public static void main ( String [ ] args ) { FileConfig config = FileConfig . of ( " config.toml " ) ; System . out . println ( " Config:  " + config ) ; config . set ( " key " , " value " ) ; config . set ( " number " , 123456 ) ; config . set ( " floatingPoint " , 3.1415926535 ) ; Config subConfig = Config . inMemory ( ) ; subConfig . set ( " subKey " , " value " ) ; config . set ( " subConfig " , subConfig ) ; config . set ( " subConfig.subKey " , " newValue " ) ; config . set ( Arrays . asList ( " subConfig " , " 127.0.0.1 " ) , " test " ) ; System . out . println ( " Config:  " + config ) ; config . save ( ) ; config . load ( ) ; config . close ( ) ; }
protected final Void doInBackground ( final MPDStatus . . . params ) { final int songPos = params [ 0 ] . getSongPos ( ) ; mCurrentSong = mApp . oMPDAsyncHelper . oMPD . getPlaylist ( ) . getByIndex ( songPos ) ; if ( mCurrentSong ! = null ) { if ( mCurrentSong . isStream ( ) ) { if ( mCurrentSong . hasTitle ( ) ) { mAlbum = mCurrentSong . getName ( ) ; mTitle = mCurrentSong . getTitle ( ) ; } else { mTitle = mCurrentSong . getName ( ) ; } mArtist = mCurrentSong . getArtist ( ) ; mAlbumInfo = new AlbumInfo ( mArtist , mAlbum ) ; } else { mAlbum = mCurrentSong . getAlbum ( ) ; mDate = Long . toString ( mCurrentSong . getDate ( ) ) ; if ( mDate . isEmpty ( ) | | mDate . charAt ( 0 ) = = '-' ) { mDate = " " ; } else { mDate = "  -  " + mDate ; } mTitle = mCurrentSong . getTitle ( ) ; setArtist ( ) ; mAlbumInfo = new AlbumInfo ( mCurrentSong ) ; } mHasCoverChanged = hasCoverChanged ( ) ; if ( DEBUG ) { Log . i ( TAG , " mAlbum:  " + mAlbum + "  mArtist:  " + mArtist + "  mDate:  " + mDate + "  mAlbumInfo:  " + mAlbumInfo + "  mHasTrackChanged:  " + mHasCoverChanged + "  mCurrentSong:  " + mCurrentSong + "  mForceCoverUpdate:  " + mForceCoverUpdate ) ; } } mLastAlbum = mAlbum ; mLastArtist = mArtist ; return null ; }
public static Term toTerm ( final Sentence s , final Memory mem ) { String opName ; switch ( s . punctuation ) { case Symbols . JUDGMENT_MARK : opName = " ^believe " ; if ( ! AllowWantBelieve ) { return null ; } break ; case Symbols . GOAL_MARK : opName = " ^want " ; if ( ! AllowWantBelieve ) { return null ; } break ; case Symbols . QUESTION_MARK : opName = " ^wonder " ; break ; case Symbols . QUEST_MARK : opName = " ^evaluate " ; break ; default : return null ; } Term opTerm = mem . getOperator ( opName ) ; Term [ ] arg = new Term [ s . truth = = null ? 1 : 2 ] ; arg [ 0 ] = s . getTerm ( ) ; if ( s . truth ! = null ) { arg [ 1 ] = s . truth . toWordTerm ( ) ; } Term operation = Inheritance . make ( new Product ( arg ) , opTerm ) ; if ( operation = = null ) { throw new RuntimeException ( " Unable to create Inheritance:  " + opTerm + " ,  " + Arrays . toString ( arg ) ) ; } return operation ; }
public static final long divisionUsingMultiplication ( int a , int b ) { int absA = Math . abs ( a ) ; int absB = Math . abs ( b ) ; int temp = absB ; int counter = 0 ; while ( temp < = absA ) { temp = temp < < 1 ; counter + + ; } absA - = absB < < ( counter - 1 ) ; long result = ( long ) Math . pow ( 2 , counter - 1 ) ; if ( absB < = absA ) result + = divisionUsingMultiplication ( absA , absB ) ; return ( a > 0 & & b > 0 | | a < 0 & & b < 0 ) ? result : - result ; }
public static boolean isInputOrOperation ( final Task newEvent ) { return newEvent . isInput ( ) | | ( newEvent . sentence . term instanceof Operation ) ; }
public static String getFilenameFromMessageID ( @Nonnull final String sMessageID ) { final String s = sMessageID . replace ( " < " , " " ) . replace ( " > " , " " ) ; return FilenameHelper . getAsSecureValidASCIIFilename ( s ) ; }
private boolean isNonfatalACK ( final String message ) { final boolean isNonfatalACK ; final int errorCode = MPDException . getAckErrorCode ( message ) ; if ( mCommand . isErrorNonfatal ( errorCode ) ) { isNonfatalACK = true ; if ( DEBUG ) { Log . debug ( TAG , " Non-fatal ACK emitted, exception suppressed:  " + message ) ; } } else { isNonfatalACK = false ; } return isNonfatalACK ; }
R visit ( StringLiteral p , A arg ) ; R visit ( URIRef p , A arg ) ; R visit ( Variable p , A arg ) ; R visit ( Term p , A arg ) ; }
public Performance printCSV ( boolean finalComma ) { System . out . print ( name + " ,  " + getCycleTimeMS ( ) + " ,  " ) ; System . out . print ( ( ( double ) totalMemory ) / ( ( double ) repeats ) / 1024.0 ) ; if ( finalComma ) System . out . print ( " , " ) ; return this ; }
private void saveRelation ( final String subject , final String object , final String predicate ) { if ( ( subject = = null ) | | ( object = = null ) ) { return ; } if ( predicate . equals ( " parentOf " ) ) { append ( " < " + getClassName ( subject ) + "  -->  " + getClassName ( object ) + " >. \ n " ) ;
private void freeCoverDrawable ( Drawable oldDrawable ) { if ( coverArt = = null ) return ; final Drawable coverDrawable = oldDrawable = = null ? coverArt . getDrawable ( ) : oldDrawable ; if ( coverDrawable = = null | | ! ( coverDrawable instanceof CoverBitmapDrawable ) ) return ; if ( oldDrawable = = null ) { int noCoverDrawable ; if ( bigCoverNotFound ) { noCoverDrawable = lightTheme ? R . drawable . no_cover_art_light_big : R . drawable . no_cover_art_big ; } else { noCoverDrawable = lightTheme ? R . drawable . no_cover_art_light : R . drawable . no_cover_art ; } coverArt . setImageResource ( noCoverDrawable ) ; } coverDrawable . setCallback ( null ) ; final Bitmap coverBitmap = ( ( BitmapDrawable ) coverDrawable ) . getBitmap ( ) ; if ( coverBitmap ! = null ) coverBitmap . recycle ( ) ;
public void sumIndexOutOfRangeTest ( ) { final IntervalSumArray sum = new IntervalSumArray ( 100 ) ; boolean thrown = false ; try { sum . sum ( 101 ) ; } catch ( IndexOutOfBoundsException e ) { thrown = true ; } assertTrue ( thrown ) ; }
public void run ( ) { s . cells . click ( " GrassFloor " , " " , " " ) ; }
protected void rotateRight ( Node < T > node ) { Node < T > parent = node . parent ; Node < T > lesser = node . lesser ; Node < T > greater = lesser . greater ; lesser . greater = node ; node . parent = lesser ; node . lesser = greater ; if ( greater ! = null ) greater . parent = node ; if ( parent ! = null ) { if ( node . equals ( parent . lesser ) ) {
int lookForSelectablePosition ( int position , boolean lookDown ) { return position ; }
protected void prepareBuffer ( String key , long cas , byte [ ] val , Object . . . extraHeaders ) { int extraLen = 0 ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { extraLen + = 4 ; } else if ( o instanceof byte [ ] ) { extraLen + = ( ( byte [ ] ) o ) . length ; } else if ( o instanceof Long ) { extraLen + = 8 ; } else { assert false : " Unhandled extra header type:   " + o . getClass ( ) ; } } final byte [ ] keyBytes = KeyUtil . getKeyBytes ( key ) ; int bufSize = MIN_RECV_PACKET + keyBytes . length + val . length ; ByteBuffer bb = ByteBuffer . allocate ( bufSize + extraLen ) ; assert bb . order ( ) = = ByteOrder . BIG_ENDIAN ; bb . put ( REQ_MAGIC ) ; bb . put ( ( byte ) cmd ) ; bb . putShort ( ( short ) keyBytes . length ) ; bb . put ( ( byte ) extraLen ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( vbucket ) ; bb . putInt ( keyBytes . length + val . length + extraLen ) ; bb . putInt ( opaque ) ; bb . putLong ( cas ) ; for ( Object o : extraHeaders ) { if ( o instanceof Integer ) { bb . putInt ( ( Integer ) o ) ; } else if ( o instanceof byte [ ] ) { bb . put ( ( byte [ ] ) o ) ; } else if ( o instanceof Long ) { bb . putLong ( ( Long ) o ) ; } else { assert false : " Unhandled extra header type:   " + o . getClass ( ) ; } } bb . put ( keyBytes ) ; bb . put ( val ) ; bb . flip ( ) ; setBuffer ( bb ) ; }
public String toString ( ) { return super . toString ( ) + "   " + getTargetTask ( ) . getSentence ( ) . stamp ; }
public void directProcess ( final Task task ) { char type = task . sentence . punctuation ; switch ( type ) { case Symbols . JUDGMENT_MARK : memory . logic . JUDGMENT_PROCESS . commit ( ) ; processJudgment ( task ) ; break ; case Symbols . GOAL_MARK : memory . logic . GOAL_PROCESS . commit ( ) ; processGoal ( task ) ; break ; case Symbols . QUESTION_MARK : case Symbols . QUEST_MARK : memory . logic . QUESTION_PROCESS . commit ( ) ; processQuestion ( task ) ; break ; default : return ; } if ( task . aboveThreshold ( ) ) { memory . logic . LINK_TO_TASK . commit ( ) ; linkToTask ( task ) ; } if ( entityObserver . isActive ( ) ) { entityObserver . refresh ( displayContent ( ) ) ; } if ( memory . param . internalExperience . get ( ) ) { memory . rememberAction ( task ) ;
public static ServiceInfo create ( final String type , final String name , final String subtype , final int port , final int weight , final int priority , final boolean persistent , final byte [ ] text ) { return new ServiceInfoImpl ( type , name , subtype , port , weight , priority , persistent , text ) ; }
public void testLineParser ( ) throws Exception { String input = " This is a multiline string \ r \ nhere is line two \ r \ n " ; ByteBuffer b = ByteBuffer . wrap ( input . getBytes ( ) ) ; SimpleOp op = new SimpleOp ( OperationReadType . LINE ) ; op . linesToRead = 2 ; op . readFromBuffer ( b ) ; assertEquals ( " This is a multiline string " , op . getLines ( ) . get ( 0 ) ) ; assertEquals ( " here is line two " , op . getLines ( ) . get ( 1 ) ) ; op . setBytesToRead ( 2 ) ; op . readFromBuffer ( ByteBuffer . wrap ( " xy " . getBytes ( ) ) ) ; byte [ ] expected = { 'x' , 'y' } ; assertTrue ( " Expected  " + Arrays . toString ( expected ) + "  but got  " + Arrays . toString ( op . getCurentBytes ( ) ) ,
public void playlistChanged ( MPDStatus mpdStatus , int oldPlaylistVersion ) { if ( isDetached ( ) ) return ; new updateTrackInfoAsync ( ) . execute ( ( MPDStatus [ ] ) null ) ; }
public int size ( ) { long stamp = lock . tryOptimisticRead ( ) ; int size = values . size ( ) ; if ( ! lock . validate ( stamp ) ) { checkStateForNormalOp ( ) ; stamp = lock . readLock ( ) ; try { size = values . size ( ) ; } finally { lock . unlockRead ( stamp ) ; } } return size ; }
boolean canHandle ( @Nonnull String sAction , @Nonnull IMessage aMsg , @Nullable Map < String , Object > aOptions ) ; void handle ( @Nonnull String sAction , @Nonnull IMessage aMsg , @Nullable Map < String , Object > aOptions ) throws AS2Exception ; }
public void init ( ) { if ( builder = = null ) { builder = new TopologyBuilder ( ) ; logger . debug ( " Sucessfully instantiating TopologyBuilder " ) ; builder . initTopology ( evaluationNameOption . getValue ( ) ) ; logger . debug ( " Sucessfully initializing SAMOA topology with name {} " , evaluationNameOption . getValue ( ) ) ; } preqSource = new PrequentialSourceProcessor ( ) ; preqSource . setStreamSource ( ( InstanceStream ) this . streamTrainOption . getValue ( ) ) ; preqSource . setMaxNumInstances ( instanceLimitOption . getValue ( ) ) ; preqSource . setSourceDelay ( sourceDelayOption . getValue ( ) ) ; builder . addEntranceProcessor ( preqSource ) ; logger . debug ( " Sucessfully instantiating PrequentialSourceProcessor " ) ; sourcePiOutputStream = builder . createStream ( preqSource ) ; classifier = ( Learner ) this . learnerOption . getValue ( ) ; classifier . init ( builder , preqSource . getDataset ( ) , 1 ) ; builder . connectInputShuffleStream ( sourcePiOutputStream , classifier . getInputProcessor ( ) ) ; logger . debug ( " Sucessfully instantiating Classifier " ) ; evaluatorPiInputStream = classifier . getResultStream ( ) ; PerformanceEvaluator evaluatorOptionValue = ( PerformanceEvaluator ) this . evaluatorOption . getValue ( ) ; if ( ! PrequentialEvaluation . isLearnerAndEvaluatorCompatible ( classifier , evaluatorOptionValue ) ) { evaluatorOptionValue = getDefaultPerformanceEvaluatorForLearner ( classifier ) ; } evaluator = new EvaluatorProcessor . Builder ( evaluatorOptionValue ) . samplingFrequency ( sampleFrequencyOption . getValue ( ) ) . dumpFile ( dumpFileOption . getFile ( ) ) . build ( ) ; builder . addProcessor ( evaluator ) ; builder . connectInputShuffleStream ( evaluatorPiInputStream , evaluator ) ; logger . debug ( " Sucessfully instantiating EvaluatorProcessor " ) ; prequentialTopology = builder . build ( ) ; logger . debug ( " Sucessfully building the topology " ) ; }
public T set ( int index , T value ) { final Node < T > n = this . getNodeByIndex ( index ) ; if ( n = = null ) return null ; n . value = value ; return n . value ; }
public int positionOf ( final E o ) { final int y = o . budget . getPriorityShort ( ) ; final int s = size ( ) ; if ( s > 0 ) {
public void pause ( ) throws MPDServerException { mpdConnection . sendCommand ( MPD_CMD_PAUSE ) ; }
public boolean matches ( Invocation arg0 ) { return ( cnt + + < n ) ; }
private void next ( ) { Log . d ( TAG , " StreamingService.next() " ) ; MPD mpd = app . oMPDAsyncHelper . oMPD ; try { mpd . next ( ) ; } catch ( MPDServerException e ) { } stopStreaming ( ) ; beginStreaming ( ) ; }
public MimeBodyPart verify ( @Nonnull final MimeBodyPart aPart , @Nullable final X509Certificate aX509Cert , final boolean bUseCertificateInBodyPart , final boolean bForceVerify ) throws GeneralSecurityException , IOException , MessagingException , CMSException , OperatorCreationException { if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " BCCryptoHelper.verify; X509 subject= " + aX509Cert . getSubjectX500Principal ( ) . getName ( ) + " ; useCertificateInBodyPart= " + bUseCertificateInBodyPart + " ; forceVerify= " + bForceVerify ) ; if ( ! bForceVerify & & ! isSigned ( aPart ) ) throw new GeneralSecurityException ( " Content-Type indicates data isn't signed:  " + aPart . getContentType ( ) ) ; final MimeMultipart aMainPart = ( MimeMultipart ) aPart . getContent ( ) ; final SMIMESignedParser aSignedParser = new SMIMESignedParser ( new JcaDigestCalculatorProviderBuilder ( ) . setProvider ( BouncyCastleProvider . PROVIDER_NAME ) . build ( ) , aMainPart , EContentTransferEncoding . AS2_DEFAULT . getID ( ) ) ; X509Certificate aRealX509Cert = aX509Cert ; if ( bUseCertificateInBodyPart ) { final Collection < ? > aContainedCerts = aSignedParser . getCertificates ( ) . getMatches ( null ) ; if ( ! aContainedCerts . isEmpty ( ) ) { if ( aContainedCerts . size ( ) > 1 ) s_aLogger . warn ( " Signed part contains  " + aContainedCerts . size ( ) + "  certificates - using the first one! " ) ; final X509CertificateHolder aCertHolder = ( ( X509CertificateHolder ) CollectionHelper . getFirstElement ( aContainedCerts ) ) ; final X509Certificate aCert = new JcaX509CertificateConverter ( ) . setProvider ( BouncyCastleProvider . PROVIDER_NAME ) . getCertificate ( aCertHolder ) ; if ( aX509Cert ! = null & & ! aX509Cert . equals ( aCert ) ) s_aLogger . warn ( " Certificate mismatch! Provided certificate \ n " + aX509Cert + "  differs from certficate contained in message \ n " + aCert ) ; aRealX509Cert = aCert ; } } if ( aRealX509Cert = = null ) throw new GeneralSecurityException ( " No certificate provided " + ( bUseCertificateInBodyPart ? "  and none found in the message " : " " ) + " ! " ) ; if ( s_aLogger . isDebugEnabled ( ) ) if ( aRealX509Cert = = aX509Cert ) s_aLogger . debug ( " Verifying signature using the provided certificate (partnership) " ) ; else s_aLogger . debug ( " Verifying signature using the certificate contained in the MIME body part " ) ; final SignerInformationVerifier aSIV = new JcaSimpleSignerInfoVerifierBuilder ( ) . setProvider ( BouncyCastleProvider . PROVIDER_NAME ) . build ( aRealX509Cert . getPublicKey ( ) ) ; for ( final Object aSigner : aSignedParser . getSignerInfos ( ) . getSigners ( ) ) { final SignerInformation aSignerInfo = ( SignerInformation ) aSigner ; if ( ! aSignerInfo . verify ( aSIV ) ) throw new SignatureException ( " Verification failed " ) ; } return aSignedParser . getContent ( ) ; }
public AbstractBag < Task > newNovelTaskBag ( Param p ) { return new ContinuousBag < Task > ( Parameters . TASK_BUFFER_SIZE , Parameters . NEW_TASK_FORGETTING_CYCLE , randomRemoval ) ; }
void processUpdateInfo ( MusicParcelable music ) { Log . d ( TAG , " parcelable= " + music + "  mCurrentMusic= " + mCurrentMusic ) ; if ( mCurrentMusic ! = null & & ( mCurrentMusic ) . equals ( music ) ) { return ; } mCurrentMusic = music ; updatePlayingInfo ( RemoteControlClient . PLAYSTATE_PLAYING ) ; }
void save ( OutputStream out , char [ ] password ) throws OpenAS2Exception ; }
public Map . Entry < K , V > lastEntry ( ) { return exportEntry ( getLastEntry ( ) ) ; }
public int compareTo ( Item o ) { return getName ( ) . compareToIgnoreCase ( o . getName ( ) ) ; }
public List < String [ ] > listAlbumArtists ( final List < Album > albums ) throws MPDServerException { final List < String [ ] > albumArtists ; if ( isCached ( ) ) { albumArtists = new ArrayList < > ( albums . size ( ) ) ; for ( final Album album : albums ) { final Artist artist = album . getArtist ( ) ; final Set < String > albumArtist ; final String artistName = getArtistName ( artist ) ; albumArtist = mCache . getAlbumArtists ( album . getName ( ) , artistName ) ; albumArtists . add ( albumArtist . toArray ( new String [ albumArtist . size ( ) ] ) ) ; } } else { albumArtists = super . listAlbumArtists ( albums ) ; } return albumArtists ; }
public void mouseWheel ( MouseEvent event ) { mouseScroll = - event . getCount ( ) ; hamlib . mouseScrolled ( ) ; }
void endSplitting ( ) { this . isSplitting = false ; logger . trace ( " wasted instance: {} " , this . thrownAwayInstance ) ; this . thrownAwayInstance = 0 ; }
protected final boolean isQuoteHeaderValues ( ) { return m_aReceiver . isQuoteHeaderValues ( ) ; }
public void readTwoChunkBuffer ( ) throws Exception { try ( final InputStream empty = new NonBlockingByteArrayInputStream ( " 2 \ r \ n12 \ r \ n1 \ na \ r \ n0 \ r \ n " . getBytes ( ) ) ; final ChunkedInputStream cIS = new ChunkedInputStream ( empty ) )
public void addResult ( Instance inst , double [ ] classVotes ) { double weight = inst . weight ( ) ; int trueClass = ( int ) inst . classValue ( ) ; if ( weight > 0.0 ) { if ( TotalweightObserved = = 0 ) {
public void testStaticPivot ( ) throws Exception { List < Row > sourceList = Lists . newArrayList ( RowFactory . create ( " A " , " hello " , " 1 " ) , RowFactory . create ( " A " , " world " , " 2 " ) , RowFactory . create ( " B " , " hello " , " 3 " ) , RowFactory . create ( " C " , " world " , " 4 " ) , RowFactory . create ( " D " , " dummy " , " 5 " ) ) ; StructType schema = RowUtils . structTypeFor ( Lists . newArrayList ( " entity_id " , " key " , " value " ) , Lists . newArrayList ( " string " , " string " , " string " ) ) ; Dataset < Row > source = Contexts . getSparkSession ( ) . createDataFrame ( sourceList , schema ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " source " , source ) ; Config config = ConfigFactory . empty ( ) . withValue ( PivotDeriver . STEP_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " source " ) ) . withValue ( PivotDeriver . ENTITY_KEY_FIELD_NAMES_CONFIG , ConfigValueFactory . fromAnyRef ( Lists . newArrayList ( " entity_id " ) ) ) . withValue ( PivotDeriver . PIVOT_KEY_FIELD_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " key " ) ) . withValue ( PivotDeriver . PIVOT_VALUE_FIELD_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " value " ) ) . withValue ( PivotDeriver . PIVOT_KEYS_SOURCE_CONFIG , ConfigValueFactory . fromAnyRef ( PivotDeriver . PIVOT_KEYS_SOURCE_STATIC ) ) . withValue ( PivotDeriver . PIVOT_KEYS_LIST_CONFIG , ConfigValueFactory . fromAnyRef ( Lists . newArrayList ( " hello " , " world " ) ) ) ; PivotDeriver d = new PivotDeriver ( ) ; assertNoValidationFailures ( d , config ) ; d . configure ( config ) ; List < Row > results = d . derive ( dependencies ) . collectAsList ( ) ; assertEquals ( results . size ( ) , 4 ) ; assertTrue ( results . contains ( RowFactory . create ( " A " , " 1 " , " 2 " ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " B " , " 3 " , null ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " C " , null , " 4 " ) ) ) ; assertTrue ( results . contains ( RowFactory . create ( " D " , null , null ) ) ) ; }
public void testBrokenHost2 ( ) throws Exception { String s = " www.google.com:80 www.yahoo.com " ; try { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( s ) ;
public void subtractTest ( ) { assertEquals ( 0 , Modular . subtract ( - 22 , 3 , 5 ) ) ; assertEquals ( Long . MAX_VALUE - 1 , Modular . subtract ( Long . MAX_VALUE - 2 , Long . MAX_VALUE - 1 , Long . MAX_VALUE ) ) ; assertEquals ( Long . MAX_VALUE - 1 , Modular . subtract ( 1 - Long . MAX_VALUE , 2 , Long . MAX_VALUE ) ) ; assertEquals ( 0 , Modular . subtract ( - 1000 , - 10000000 , 10 ) ) ; try { Modular . subtract ( 1 , 1 , 0 ) ;
public void testReadChunkLenCrap ( ) throws Exception { final NonBlockingByteArrayInputStream aIS = new NonBlockingByteArrayInputStream ( " xyz \ u0000 \ u00ff " . getBytes ( StandardCharsets . ISO_8859_1 ) ) ; final int res = HTTPHelper . readChunkLen ( aIS ) ; assertEquals ( 0 , res ) ; }
public String readUTF ( int len ) { StringBuilder buffer = new StringBuilder ( len ) ; for ( int index = 0 ; index < len ; index + + ) { int ch = this . read ( ) ; switch ( ch > > 4 ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : break ; case 12 : case 13 : ch = ( ( ch & 0x1F ) < < 6 ) | ( this . read ( ) & 0x3F ) ; index + + ; break ; case 14 : ch = ( ( ch & 0x0f ) < < 12 ) | ( ( this . read ( ) & 0x3F ) < < 6 ) | ( this . read ( ) & 0x3F ) ; index + + ; index + + ; break ; default : ch = ( ( ch & 0x3F ) < < 4 ) | ( this . read ( ) & 0x0f ) ; index + + ; break ; } buffer . append ( ( char ) ch ) ; } return buffer . toString ( ) ; }
public X509Certificate getCertificate ( @Nonnull final IBaseMessage aMsg , @Nonnull final ECertificatePartnershipType ePartnershipType ) throws AS2Exception { debugLog ( ( ) - > " getCertificate ( " + aMsg . getMessageID ( ) + " ,  " + ePartnershipType + " ) " ) ; final String sAlias = getAlias ( aMsg . partnership ( ) , ePartnershipType ) ; final X509Certificate ret = internalGetCertificate ( sAlias , ePartnershipType ) ; debugLog ( ( ) - > " getCertificate ->  " + _debug ( ret ) ) ; return ret ; }
public void evaluate ( String input ) { new TextInput ( reasoner , input ) ; reasoner . tick ( ) ; reasoner . run ( 0 ) ; }
public static final String toBinaryUsingDivideAndDouble ( int integer ) { StringBuilder builder = new StringBuilder ( ) ; double temp = 0d ; while ( integer > 0 ) { temp = integer / 2d ; integer = ( int ) temp ; builder . append ( ( temp > integer ) ? 1 : 0 ) ; } return builder . reverse ( ) . toString ( ) ; }
public void validate ( ) throws DispositionException { if ( m_sStatus = = null ) throw new DispositionException ( this , null ) ; if ( ! m_sStatus . equalsIgnoreCase ( STATUS_PROCESSED ) ) throw new DispositionException ( this , null ) ; if ( m_sStatusModifier ! = null ) if ( m_sStatusModifier . equalsIgnoreCase ( STATUS_MODIFIER_ERROR ) | | m_sStatusModifier . equalsIgnoreCase ( STATUS_MODIFIER_WARNING ) )
public void testToRowValueFloat ( ) { DataType field = DataTypes . FloatType ; Float value = Float . valueOf ( " 123 " ) ; assertEquals ( " Invalid Float " , value , RowUtils . toRowValue ( value , field ) ) ; assertEquals ( " Invalid Number " , value , RowUtils . toRowValue ( 123L , field ) ) ; assertEquals ( " Invalid String " , value , RowUtils . toRowValue ( " 123 " , field ) ) ; try { RowUtils . toRowValue ( " foo " , field ) ; fail ( " Expected a RuntimeException for invalid type " ) ; } catch ( RuntimeException e ) { assertThat ( e . getMessage ( ) , JUnitMatchers . containsString ( " Invalid or unrecognized input format " ) ) ; } try { RowUtils . toRowValue ( ByteBuffer . allocate ( 1 ) , field ) ;
public Dimension preferredLayoutSize ( Container parent ) { Dimension dim = new Dimension ( ) ; Insets insets = getInsets ( ) ; dim . width = insets . left + insets . right ; dim . height = insets . top + insets . bottom ; Dimension centerPref = center . getPreferredSize ( ) ; dim . width + = centerPref . width ; dim . height + = centerPref . height ; Dimension rightPref = right . getPreferredSize ( ) ; dim . width + = rightPref . width ; Dimension bottomPref = bottom . getPreferredSize ( ) ; dim . height + = bottomPref . height ; return dim ; }
void save ( ) ; void load ( ) ; @Override void close ( ) ; @Override default FileConfig checked ( ) { return new CheckedFileConfig ( this ) ; } < R > R bulkUpdate ( Function < ? super Config , R > action ) ; default void bulkUpdate ( Consumer < ? super Config > action ) { bulkUpdate ( config - > { action . accept ( config ) ; return null ; } ) ; } static FileConfig of ( File file ) { return of ( file . toPath ( ) ) ; } static FileConfig of ( File file , ConfigFormat < ? extends Config > format ) { return of ( file . toPath ( ) , format ) ; } static FileConfig of ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return of ( file , format ) ; } static FileConfig of ( Path file , ConfigFormat < ? extends Config > format ) { return builder ( file , format ) . build ( ) ; } static FileConfig of ( String filePath ) { return of ( Paths . get ( filePath ) ) ; } static FileConfig of ( String filePath , ConfigFormat < ? > format ) { return of ( Paths . get ( filePath ) , format ) ; } @Deprecated static FileConfig ofConcurrent ( File file ) { return ofConcurrent ( file . toPath ( ) ) ; } @Deprecated static FileConfig ofConcurrent ( File file , ConfigFormat < ? > format ) { return ofConcurrent ( file . toPath ( ) , format ) ; } @Deprecated static FileConfig ofConcurrent ( Path file ) { return builder ( file ) . concurrent ( ) . build ( ) ; } @Deprecated static FileConfig ofConcurrent ( Path file , ConfigFormat < ? > format ) { return builder ( file , format ) . concurrent ( ) . build ( ) ; } @Deprecated static FileConfig ofConcurrent ( String filePath ) { return ofConcurrent ( Paths . get ( filePath ) ) ; } @Deprecated static FileConfig ofConcurrent ( String filePath , ConfigFormat < ? > format ) { return ofConcurrent ( Paths . get ( filePath ) , format ) ; } static FileConfigBuilder builder ( File file ) { return builder ( file . toPath ( ) ) ; } static FileConfigBuilder builder ( File file , ConfigFormat < ? > format ) { return builder ( file . toPath ( ) , format ) ; } static FileConfigBuilder builder ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return builder ( file , format ) ; } static FileConfigBuilder builder ( Path file , ConfigFormat < ? > format ) { return new FileConfigBuilder ( file , format ) ; } static FileConfigBuilder builder ( String filePath ) { return builder ( Paths . get ( filePath ) ) ; } static FileConfigBuilder builder ( String filePath , ConfigFormat < ? > format ) { return builder ( Paths . get ( filePath ) , format ) ; } }
protected void cycle ( ) { updatePriorities ( ) ; if ( tasks . size ( ) = = 0 ) return ; if ( tasks . size ( ) > 1 ) { System . out . println ( " Tasks @  " + memory . getTime ( ) ) ; for ( TaskConcept tcc : tasks ) System . out . println ( "    " + tcc . toString ( ) ) ; } else { System . out . println ( " Task @  " + memory . getTime ( ) + " :  " + tasks . get ( 0 ) ) ; } TaskConcept topConcept = tasks . getFirst ( ) ; Task top = topConcept . t ; Term term = top . getContent ( ) ; if ( term instanceof Operation ) { execute ( ( Operation ) term , top ) ;
X509Certificate getCertificate ( String alias ) throws OpenAS2Exception ; Map < String , Certificate > getCertificates ( ) throws OpenAS2Exception ; void addCertificate ( String alias , X509Certificate cert , boolean overwrite ) throws OpenAS2Exception ; void addPrivateKey ( String alias , Key key , String password ) throws OpenAS2Exception ; void clearCertificates ( ) throws OpenAS2Exception ; void removeCertificate ( X509Certificate cert ) throws OpenAS2Exception ; void removeCertificate ( String alias ) throws OpenAS2Exception ; }
public void run ( ) { while ( run ) { boolean allNull = true ; dirsIter : for ( Iterator < WatchedDir > it = watchedDirs . values ( ) . iterator ( ) ; it . hasNext ( ) & & run ; ) { WatchedDir watchedDir = it . next ( ) ; WatchKey key = watchedDir . watchService . poll ( ) ; if ( key = = null ) { continue ; } allNull = false ; for ( WatchEvent < ? > event : key . pollEvents ( ) ) { if ( ! run ) { break dirsIter ; } if ( event . kind ( ) ! = StandardWatchEventKinds . ENTRY_MODIFY | | event . count ( ) > 1 ) { continue ; } Path childPath = ( ( WatchEvent < Path > ) event ) . context ( ) ; Path filePath = watchedDir . dir . resolve ( childPath ) ; WatchedFile watchedFile = watchedFiles . get ( filePath ) ; if ( watchedFile ! = null ) { try { watchedFile . changeHandler . run ( ) ; } catch ( Exception e ) { exceptionHandler . accept ( e ) ; } } } key . reset ( ) ; } if ( allNull ) { LockSupport . parkNanos ( SLEEP_TIME_NANOS ) ; } } for ( WatchedDir watchedDir : watchedDirs . values ( ) ) { try { watchedDir . watchService . close ( ) ; } catch ( IOException e ) { exceptionHandler . accept ( e ) ; } } watchedDirs . clear ( ) ; watchedFiles . clear ( ) ; }
public final AS2ClientSettings setHttpIncomingDumper ( @Nullable final IHTTPIncomingDumper aHttpIncomingDumper ) { m_aHttpIncomingDumper = aHttpIncomingDumper ; return this ; }
public boolean containQueryVar ( ) { return ( content . name ( ) . indexOf ( Symbols . VAR_QUERY ) > = 0 ) ; }
public void stickerChanged ( final MPDStatus mpdStatus ) { mHelperHandler . obtainMessage ( MPDAsyncHelper . EVENT_STICKER_CHANGED , Tools . toObjectArray ( mpdStatus ) )
public boolean preUpdate ( AbstractGraphVis g ) { if ( h = = null ) h = new HyperassociativeMap ( g . getGraph ( ) , 2 ) ; else h . setGraph ( g . getGraph ( ) ) ; h . align ( ) ; return true ; }
final void stateChanged ( final MPDStatus mpdStatus ) { mCurrentMPDState = mpdStatus . getState ( ) ; updateSeekTime ( mpdStatus . getElapsedTime ( ) ) ; getRemoteState ( mCurrentMPDState ) ; }
public void start ( ) { mTerminated = false ; mStarted = true ; sortNodes ( ) ; int numSortedNodes = mSortedNodes . size ( ) ; for ( int i = 0 ; i < numSortedNodes ; + + i ) { Node node = mSortedNodes . get ( i ) ; ArrayList < AnimatorListener > oldListeners = node . animation . getListeners ( ) ; if ( oldListeners ! = null & & oldListeners . size ( ) > 0 ) { final ArrayList < AnimatorListener > clonedListeners = new ArrayList < AnimatorListener > ( oldListeners ) ; for ( AnimatorListener listener : clonedListeners ) { if ( listener instanceof DependencyListener | | listener instanceof AnimatorSetListener ) { node . animation . removeListener ( listener ) ; } } } } final ArrayList < Node > nodesToStart = new ArrayList < Node > ( ) ; for ( int i = 0 ; i < numSortedNodes ; + + i ) { Node node = mSortedNodes . get ( i ) ; if ( mSetListener = = null ) { mSetListener = new AnimatorSetListener ( this ) ; } if ( node . dependencies = = null | | node . dependencies . size ( ) = = 0 ) { nodesToStart . add ( node ) ; } else { int numDependencies = node . dependencies . size ( ) ; for ( int j = 0 ; j < numDependencies ; + + j ) { Dependency dependency = node . dependencies . get ( j ) ; dependency . node . animation . addListener ( new DependencyListener ( this , node , dependency . rule ) ) ; } node . tmpDependencies = ( ArrayList < Dependency > ) node . dependencies . clone ( ) ; } node . animation . addListener ( mSetListener ) ; } if ( mStartDelay < = 0 ) { for ( Node node : nodesToStart ) { node . animation . start ( ) ; mPlayingSet . add ( node . animation ) ; } } else { mDelayAnim = ValueAnimator . ofFloat ( 0f , 1f ) ; mDelayAnim . setDuration ( mStartDelay ) ; mDelayAnim . addListener ( new AnimatorListenerAdapter ( ) { boolean canceled = false ; public void onAnimationCancel ( Animator anim ) { canceled = true ; } public void onAnimationEnd ( Animator anim ) { if ( ! canceled ) { int numNodes = nodesToStart . size ( ) ; for ( int i = 0 ; i < numNodes ; + + i ) { Node node = nodesToStart . get ( i ) ; node . animation . start ( ) ; mPlayingSet . add ( node . animation ) ; } } } } ) ; mDelayAnim . start ( ) ; } if ( mListeners ! = null ) { ArrayList < AnimatorListener > tmpListeners = ( ArrayList < AnimatorListener > ) mListeners . clone ( ) ; int numListeners = tmpListeners . size ( ) ; for ( int i = 0 ; i < numListeners ; + + i ) { tmpListeners . get ( i ) . onAnimationStart ( this ) ; } } if ( mNodes . size ( ) = = 0 & & mStartDelay = = 0 ) {
public String nounRootForm ( String mixedCase , String input ) { String result = null ; if ( ( exceptionNounHash . containsKey ( mixedCase ) ) | | ( exceptionNounHash . containsKey ( input ) ) ) { if ( exceptionNounHash . containsKey ( mixedCase ) ) { result = ( String ) exceptionNounHash . get ( mixedCase ) ; } else { result = ( String ) exceptionNounHash . get ( input ) ; } } else { if ( WordNetUtilities . substTest ( input , " s$ " , " " , nounSynsetHash ) ) { result = WordNetUtilities . subst ( input , " s$ " , " " ) ; } else { if ( WordNetUtilities . substTest ( input , " ses$ " , " s " , nounSynsetHash ) ) { result = WordNetUtilities . subst ( input , " ses$ " , " s " ) ; } else { if ( WordNetUtilities . substTest ( input , " xes$ " , " x " , nounSynsetHash ) ) { result = WordNetUtilities . subst ( input , " xes$ " , " x " ) ; } else { if ( WordNetUtilities . substTest ( input , " zes$ " , " z " , nounSynsetHash ) ) { result = WordNetUtilities . subst ( input , " zes$ " , " z " ) ; } else { if ( WordNetUtilities . substTest ( input , " ches$ " , " ch " , nounSynsetHash ) ) { result = WordNetUtilities . subst ( input , " ches$ " , " ch " ) ; } else { if ( WordNetUtilities . substTest ( input , " shes$ " , " sh " , nounSynsetHash ) ) { result = WordNetUtilities . subst ( input , " shes$ " , " sh " ) ; } else { if ( nounSynsetHash . containsKey ( mixedCase ) ) { result = mixedCase ; } else { if ( nounSynsetHash . containsKey ( input ) ) { result = input ; } } } } } } } } } return result ; }
public void onRefreshMinimized ( ) { } public abstract boolean showHeaderView ( ) ; public abstract boolean hideHeaderView ( ) ; public void onConfigurationChanged ( Activity activity , Configuration newConfig ) { } }
public void adjustHappy ( float newValue , float weight ) { happy + = newValue * weight ; happy / = 1.0f + weight ;
public void connectionTimeout ( final NHttpConnection conn ) { getLogger ( ) . error ( " Connection timed out:  " + conn ) ; }
protected boolean hasChildren ( ) { return ( segments ! = null ) ; }
protected void onCreate ( Bundle savedInstanceState ) { if ( ! Tools . isTabletMode ( this ) ) { setTheme ( android . R . style . Theme_Black_NoTitleBar ) ; } super . onCreate ( savedInstanceState ) ; }
public void testKnownPaths ( ) { Validation v = new IfPathHasValueValidation ( " hello " , 2 , Validations . single ( ) . allowedValues ( " world " , 1 , 2 , 3 ) ) ; assertEquals ( Sets . newHashSet ( " hello " , " world " ) , v . getKnownPaths ( ) ) ; }
public ContentHandler createContentHandler ( String mimetype ) { Class < ? extends ContentHandler > handlerClass = map . get ( mimetype ) ; ContentHandler handler = null ; if ( handlerClass ! = null ) { try { handler = handlerClass . newInstance ( ) ; } catch ( InstantiationException e ) { e . printStackTrace ( ) ; } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } } if ( handler = = null ) { handler = new NullContentHandler ( ) ; } return handler ; }
public void chainAdd ( final Term t ) { if ( t = = null ) throw new RuntimeException ( " Chain must contain non-null items " ) ; if ( derivationChain . size ( ) + 1 > Parameters . MAXIMUM_DERIVATION_CHAIN_LENGTH ) { derivationChain . remove ( 0 ) ; } derivationChain . add ( t ) ; name = null ; }
public AS2ClientSettings setEncryptAndSign ( @Nullable final ECryptoAlgorithm eCryptAlgo , @Nullable final ECryptoAlgorithm eSignAlgo ) { if ( eCryptAlgo ! = null & & eCryptAlgo . getCryptAlgorithmMode ( ) ! = ECryptoAlgorithmMode . CRYPT ) throw new IllegalArgumentException ( " The provided crypt algorithm is not possible for crypting. " ) ; if ( eSignAlgo ! = null & & eSignAlgo . getCryptAlgorithmMode ( ) ! = ECryptoAlgorithmMode . DIGEST ) throw new IllegalArgumentException ( " The provided sign algorithm is not possible for digesting. " ) ; m_eCryptAlgo = eCryptAlgo ; m_eSignAlgo = eSignAlgo ; return this ; }
private static boolean testPatriciaTrie ( ) { { if ( debug ) System . out . println ( " Patricia Trie. " ) ; PatriciaTrie < String > trie = new PatriciaTrie < String > ( ) ; for ( int i : unsorted ) { String string = String . valueOf ( i ) ; trie . add ( string ) ; boolean exists = trie . contains ( string ) ; if ( ! exists ) { System . err . println ( " YIKES!!  " + string + "  doesn't exist. " ) ; handleError ( trie ) ; return false ; } } if ( debug ) System . out . println ( trie . toString ( ) ) ; for ( int i : unsorted ) { String string = String . valueOf ( i ) ; trie . remove ( string ) ; boolean exists = trie . contains ( string ) ; if ( exists ) { System . err . println ( " YIKES!!  " + string + "  still exists. " ) ; handleError ( trie ) ; return false ; } } if ( debug ) System . out . println ( ) ; } return true ; }
public void undoAction ( ) { try { undoManager . undo ( ) ;
public static byte [ ] computeMd5 ( String k ) { MessageDigest md5 ; try { md5 = ( MessageDigest ) MD5_DIGEST . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( " clone of MD5 not supported " , e ) ; } md5 . update ( KeyUtil . getKeyBytes ( k ) ) ; return md5 . digest ( ) ; }
public boolean isHigherOrderStatement ( ) { return ( this instanceof Equivalence ) | | ( this instanceof Implication ) ; }
public String getKeyStorePassword ( ) { return m_sKeyStorePassword ; }
long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public void step ( ) { point1 = body . getWorldPoint ( point ) ; Body hit = null ; float minDist = distance * 1.1f ; float totalDist = 0 ; float dArc = arc / resolution ; for ( int r = 0 ; r < resolution ; r + + ) { float da = ( - arc / 2f ) + dArc * r ; d . set ( distance * MathUtils . cos ( da + angle + body . getAngle ( ) ) , distance * MathUtils . sin ( da + angle + body . getAngle ( ) ) ) ; point2 . set ( point1 ) ; point2 . addLocal ( d ) ; ccallback . init ( ) ; getWorld ( ) . raycast ( ccallback , point1 , point2 ) ; if ( ccallback . m_hit ) { float d = ccallback . m_point . sub ( point1 ) . length ( ) / distance ; laserHitColor . x = Math . min ( 1.0f , laserUnhitColor . x + 0.75f * ( 1.0f - d ) ) ; draw ( ) . drawPoint ( ccallback . m_point , 5.0f , sparkColor ) ; draw ( ) . drawSegment ( point1 , ccallback . m_point , laserHitColor ) ; pooledHead . set ( ccallback . m_normal ) ; pooledHead . mulLocal ( .5f ) . addLocal ( ccallback . m_point ) ; draw ( ) . drawSegment ( ccallback . m_point , pooledHead , normalColor ) ; totalDist + = d ; if ( d < minDist ) { hit = ccallback . body ; minDist = d ; } } else { draw ( ) . drawSegment ( point1 , point2 , laserUnhitColor ) ; totalDist + = 1 ; } } if ( hit ! = null ) {
public synchronized boolean peek ( Term t , Prolog engine ) { return search ( t , engine , false ) ; }
public FileConfig build ( ) { FileConfig fileConfig ; if ( sync ) { fileConfig = new WriteSyncFileConfig < > ( getConfig ( ) , file , charset , writer , writingMode , parser , parsingMode , nefAction ) ; } else { fileConfig = new WriteAsyncFileConfig < > ( getConfig ( ) , file , charset , writer , writingMode , parser , parsingMode , nefAction ) ; } if ( autoreload ) { if ( ! file . exists ( ) ) { try { nefAction . run ( file ) ; } catch ( IOException e ) { throw new WritingException ( " An exception occured while executing the  " + " FileNotFoundAction for file  " + file , e ) ; } } fileConfig = new AutoreloadFileConfig < > ( fileConfig ) ; } if ( autosave ) { fileConfig = new AutosaveFileConfig < > ( fileConfig ) ; } return fileConfig ; }
ReplicaGetsOperation replicaGets ( String key , int index , ReplicaGetsOperation . Callback callback ) ; GetlOperation getl ( String key , int exp , GetlOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; StatsOperation keyStats ( String key , StatsOperation . Callback cb ) ; MutatorOperation mutate ( Mutator m , String key , long by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; TouchOperation touch ( String key , int expiration , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , StoreOperation . Callback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
public void fire ( ) { final TaskLink currentTaskLink = taskLinks . takeOut ( ) ; if ( currentTaskLink = = null ) { return ; } new NAL . FireConcept ( memory , this , currentTaskLink ) . call ( ) ; taskLinks . putBack ( currentTaskLink , memory ) ; }
public CouchbaseConnection createCouchDBConnection ( List < InetSocketAddress > addrs ) throws IOException { return new CouchbaseConnection ( this , addrs , getInitialObservers ( ) ) ; }
public void setEncryptAndSign ( @Nullable final ECryptoAlgorithm eCryptAlgo , @Nullable final ECryptoAlgorithm eSignAlgo ) { if ( eCryptAlgo ! = null & & eCryptAlgo . getCryptAlgorithmMode ( ) ! = ECryptoAlgorithmMode . CRYPT ) throw new IllegalArgumentException ( " The provided crypt algorithm is not possible for crypting. " ) ; if ( eSignAlgo ! = null & & eSignAlgo . getCryptAlgorithmMode ( ) ! = ECryptoAlgorithmMode . DIGEST ) throw new IllegalArgumentException ( " The provided sign algorithm is not possible for digesting. " ) ; m_eCryptAlgo = eCryptAlgo ; m_eSignAlgo = eSignAlgo ; }
public com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . OtherExample buildPartial ( ) { com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . OtherExample result = new com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . OtherExample ( this ) ; result . other_ = other_ ; onBuilt ( ) ; return result ; }
public void RemoveBucket ( ) { compressBucketsRow ( 1 ) ; }
DeleteOperation delete ( String key , OperationCallback operationCallback ) ; FlushOperation flush ( int delay , OperationCallback operationCallback ) ; GetOperation get ( String key , GetOperation . Callback callback ) ; GetlOperation getl ( String key , int exp , GetlOperation . Callback callback ) ; GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; KeyedOperation touch ( String key , int expiration , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }
public DataFrame derive ( Map < String , DataFrame > dependencies ) throws Exception { String intoDependency = config . getString ( NEST_INTO_CONFIG_NAME ) ; if ( ! dependencies . containsKey ( intoDependency ) ) { throw new RuntimeException ( " Nest deriver points to non-existent nest-into dependency " ) ; } DataFrame into = dependencies . get ( intoDependency ) ; String fromDependency = config . getString ( NEST_FROM_CONFIG_NAME ) ; if ( ! dependencies . containsKey ( fromDependency ) ) { throw new RuntimeException ( " Nest deriver points to non-existent nest-from dependency " ) ; } DataFrame from = dependencies . get ( fromDependency ) ; List < String > keyFieldNames = config . getStringList ( KEY_FIELD_NAMES_CONFIG_NAME ) ; String nestedFieldName = config . getString ( NESTED_FIELD_NAME_CONFIG_NAME ) ; ExtractFieldsFunction extractFieldsFunction = new ExtractFieldsFunction ( keyFieldNames ) ; JavaPairRDD < List < Object > , Row > keyedIntoRDD = into . javaRDD ( ) . keyBy ( extractFieldsFunction ) ; JavaPairRDD < List < Object > , Row > keyedFromRDD = from . javaRDD ( ) . keyBy ( extractFieldsFunction ) ; NestFunction nestFunction = new NestFunction ( ) ; JavaRDD < Row > nestedRDD = keyedIntoRDD . cogroup ( keyedFromRDD ) . values ( ) . map ( nestFunction ) ; StructType nestedSchema = into . schema ( ) . add ( nestedFieldName , DataTypes . createArrayType ( from . schema ( ) ) ) ; DataFrame nested = into . sqlContext ( ) . createDataFrame ( nestedRDD , nestedSchema ) ; return nested ; }
public Object [ ] toArray ( ) { synchronized ( mLOCK ) { this . cleanPhantomReferences ( ) ;
public static boolean InternalExperienceFromTaskInternal ( Memory memory , Task task , boolean full ) { if ( ! enabled ) { return false ; } { if ( task . sentence . punctuation = = Symbols . QUESTION_MARK | | task . sentence . punctuation = = Symbols . QUEST_MARK ) { if ( task . budget . summary ( ) < MINIMUM_BUDGET_SUMMARY_TO_CREATE_WONDER_EVALUATE ) { return false ; } } else if ( task . budget . summary ( ) < MINIMUM_BUDGET_SUMMARY_TO_CREATE ) { return false ; } } Term content = task . getTerm ( ) ; if ( content instanceof Operation ) { return true ; } Sentence sentence = task . sentence ; TruthValue truth = new TruthValue ( 1.0f , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) ; Stamp stamp = task . sentence . stamp . clone ( ) ; stamp . setOccurrenceTime ( memory . time ( ) ) ; Term ret = toTerm ( sentence , memory ) ; if ( ret = = null ) { return true ; } Sentence j = new Sentence ( ret , Symbols . JUDGMENT_MARK , truth , stamp ) ; BudgetValue newbudget = new BudgetValue ( Parameters . DEFAULT_JUDGMENT_CONFIDENCE * INTERNAL_EXPERIENCE_PRIORITY_MUL , Parameters . DEFAULT_JUDGMENT_PRIORITY * INTERNAL_EXPERIENCE_DURABILITY_MUL , BudgetFunctions . truthToQuality ( truth ) ) ; if ( ! OLD_BELIEVE_WANT_EVALUATE_WONDER_STRATEGY ) { newbudget . setPriority ( task . getPriority ( ) * INTERNAL_EXPERIENCE_PRIORITY_MUL ) ; newbudget . setDurability ( task . getDurability ( ) * INTERNAL_EXPERIENCE_DURABILITY_MUL ) ; } Task newTask = new Task ( j , ( BudgetValue ) newbudget , full ) ; memory . addNewTask ( newTask , " Remembered Action (Internal Experience) " ) ; return false ; }
protected void loadCommand ( final IMicroElement eCommand , @Nullable final MultiCommand aParent ) throws OpenAS2Exception { final IAS2Session aSession = getSession ( ) ; final String sBaseDirectory = aSession instanceof AS2ServerXMLSession ? ( ( AS2ServerXMLSession ) aSession ) . getBaseDirectory ( ) : null ; final ICommand aCommand = AS2XMLHelper . createComponent ( eCommand , ICommand . class , aSession , sBaseDirectory ) ; if ( aParent ! = null ) aParent . getCommands ( ) . add ( aCommand ) ;
public CharSequence makeName ( ) { return makeImageName ( operator ( ) , term , relationIndex ) ; }
long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }
public void inc ( float additional ) { this . balance . addAndGet ( additional ) ; }
private static void checkClass ( Field field , Object value , Class < ? > expectedClass ) { checkNotNull ( field , value ) ; Class < ? > valueClass = value . getClass ( ) ; if ( valueClass ! = expectedClass ) { throw new InvalidValueException ( " Invalid type %s for field %s, expected %s " , valueClass ,
< T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }
private < T > OperationFuture < Boolean > asyncCat ( ConcatenationType catType , long cas , String key , T value , Transcoder < T > tc ) { CachedData co = tc . encode ( value ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout ) ; Operation op = opFact . cat ( catType , cas , key , co . getData ( ) , new OperationCallback ( ) { public void receivedStatus ( OperationStatus val ) { rv . set ( val . isSuccess ( ) , val ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }
public long getInterval ( ) { return attrs ( ) . getAsLong ( ATTR_POLLING_INTERVAL , 0 L ) ; }
public void crop ( ) { final MPDStatus mpdStatus = mMPD . getStatus ( ) ; if ( mpdStatus . isState ( MPDStatus . STATE_PLAYING ) | | mpdStatus . isState ( MPDStatus . STATE_PAUSED ) ) {
public static Inheritance make ( final Term subject , final Term predicate ) { if ( invalidStatement ( subject , predicate ) ) { return null ; } boolean subjectProduct = subject instanceof Product ; boolean predicateOperator = predicate instanceof Operator ; CharSequence name ; if ( subjectProduct & & predicateOperator ) {
@Override public void actionPerformed ( ActionEvent e ) { rover . rotate ( 4.0f ) ; }
public void createWorkerProcessingItems ( ) { for ( IProcessingItem pi : this . processingItems ) { if ( pi instanceof ParallelProcessingItem ) {
public void renameVariables ( ) { if ( containVar ( ) ) { int existingComponents = term . length ; renameVariables ( new HashMap < Variable , Variable > ( ) ) ; } setConstant ( true ) ; setName ( makeName ( ) ) ; }
public abstract String getName ( ) ; public boolean isUnknown ( ) { final String name = getName ( ) ; return name = = null | | name . isEmpty ( ) ; } public String mainText ( ) { String mainText = getName ( ) ; if ( mainText = = null | | mainText . isEmpty ( ) ) { final String unknownKey = " UnknownMetadata " ; final String key = unknownKey + getClass ( ) . getSimpleName ( ) ; ResourceBundle labels ; try { labels = ResourceBundle . getBundle ( unknownKey ) ; } catch ( final MissingResourceException ignored ) { labels = ResourceBundle . getBundle ( unknownKey , Locale . ENGLISH ) ; } if ( labels . containsKey ( key ) ) { mainText = ( String ) labels . getObject ( key ) ; } } return mainText ; } public String sortText ( ) { String name = getName ( ) ; if ( name ! = null ) { name = name . toLowerCase ( Locale . getDefault ( ) ) ; } return name ; } @Override public String toString ( ) { return mainText ( ) ; } }
protected Node createNewNode ( Node parent , Character character , boolean isWord ) { return ( new Node ( parent , character , isWord ) ) ; }
public EChange removePartner ( @Nullable final String sPartnerName ) { return m_aMap . removeObject ( sPartnerName ) ; }
public void initializeSteps ( ) { Map < String , Object > step1ConfigMap = Maps . newHashMap ( ) ; step1ConfigMap . put ( Step . DEPENDENCIES_CONFIG , Lists . newArrayList ( ) ) ; step1ConfigMap . put ( DataStep . CACHE_ENABLED_PROPERTY , false ) ; step1ConfigMap . put ( DataStep . CACHE_STORAGE_LEVEL_PROPERTY , " MEMORY_ONLY " ) ; Config step1Config = ConfigFactory . parseMap ( step1ConfigMap ) ; step1 = new BatchStep ( " step1 " ) ; step1 . configure ( step1Config ) ; steps . add ( step1 ) ; Map < String , Object > step3ConfigMap = Maps . newHashMap ( ) ; step3ConfigMap . put ( Step . DEPENDENCIES_CONFIG , Lists . newArrayList ( " step2 " ) ) ; Config step3Config = ConfigFactory . parseMap ( step3ConfigMap ) ; step3 = new BatchStep ( " step3 " ) ; step3 . configure ( step3Config ) ; steps . add ( step3 ) ; Map < String , Object > step4ConfigMap = Maps . newHashMap ( ) ; step4ConfigMap . put ( Step . DEPENDENCIES_CONFIG , Lists . newArrayList ( " step3 " ) ) ; Config step4Config = ConfigFactory . parseMap ( step4ConfigMap ) ; step4 = new BatchStep ( " step4 " ) ; step4 . configure ( step4Config ) ; steps . add ( step4 ) ; Map < String , Object > step5ConfigMap = Maps . newHashMap ( ) ; step5ConfigMap . put ( Step . DEPENDENCIES_CONFIG , Lists . newArrayList ( " step2 " ) ) ; Config step5Config = ConfigFactory . parseMap ( step5ConfigMap ) ; step5 = new BatchStep ( " step5 " ) ; step5 . configure ( step5Config ) ; steps . add ( step5 ) ; Map < String , Object > step6ConfigMap = Maps . newHashMap ( ) ; step6ConfigMap . put ( Step . DEPENDENCIES_CONFIG , Lists . newArrayList ( " step5 " ) ) ; Config step6Config = ConfigFactory . parseMap ( step6ConfigMap ) ; step6 = new BatchStep ( " step6 " ) ; step6 . configure ( step6Config ) ; steps . add ( step6 ) ; Map < String , Object > step7ConfigMap = Maps . newHashMap ( ) ; step7ConfigMap . put ( Step . DEPENDENCIES_CONFIG , Lists . newArrayList ( " step2 " ) ) ; Config step7Config = ConfigFactory . parseMap ( step7ConfigMap ) ; step7 = new BatchStep ( " step7 " ) ; step7 . configure ( step7Config ) ; steps . add ( step7 ) ; Map < String , Object > step8ConfigMap = Maps . newHashMap ( ) ; step8ConfigMap . put ( Step . DEPENDENCIES_CONFIG , Lists . newArrayList ( " step7 " ) ) ; Config step8Config = ConfigFactory . parseMap ( step8ConfigMap ) ; step8 = new BatchStep ( " step8 " ) ; step8 . configure ( step8Config ) ; steps . add ( step8 ) ; }
public void test_java_array_set_3_1 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " java_object('java.lang.String[]', [1], s), java_catch(java_array_set(s, -1, a), [('java.lang.IllegalArgumentException'(Cause, Message, StackTrace), true)], true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Term cause = info . getTerm ( " Cause " ) ; assertFalse ( cause instanceof Var ) ; Term message = info . getTerm ( " Message " ) ; assertFalse ( message instanceof Var ) ; Term stackTrace = info . getTerm ( " StackTrace " ) ; assertTrue ( stackTrace . isList ( ) ) ; }
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { if ( args . length < 2 ) { return null ; } if ( ( ( args . length - 2 ) % 2 ) ! = 0 ) { return null ; } if ( ! ( args [ 0 ] instanceof Term ) ) { return null ; } if ( ! ( args [ 1 ] instanceof Term ) ) { return null ; } if ( ! context . prologInterpreters . containsKey ( args [ 1 ] ) ) { return null ; } Prolog prologInterpreter = context . prologInterpreters . get ( args [ 1 ] ) ; Term queryTerm = ( Term ) args [ 0 ] ; String query = getStringOfTerm ( queryTerm ) ; VariableInfo [ ] variableInfos = translateNarsArgumentsToQueryVariableInfos ( args ) ; prologParseAndExecuteAndDereferenceInput ( prologInterpreter , query , variableInfos ) ; memory . emit ( Prolog . class , query + "  | TODO " ) ; Term [ ] resultTerms = getResultVariablesFromPrologVariables ( variableInfos , memory ) ; int i ; Term [ ] resultInnerProductTerms = new Term [ 2 + resultTerms . length * 2 ] ; resultInnerProductTerms [ 0 ] = args [ 0 ] ; resultInnerProductTerms [ 1 ] = args [ 1 ] ; for ( i = 0 ; i < resultTerms . length ; i + + ) { resultInnerProductTerms [ 2 + i * 2 + 0 ] = args [ 2 + i * 2 ] ; resultInnerProductTerms [ 2 + i * 2 + 1 ] = resultTerms [ i ] ; } Inheritance operatorInheritance = Operation . make ( new Product ( resultInnerProductTerms ) , this ) ; Inheritance resultInheritance = Inheritance . make ( operatorInheritance , new Term ( " prolog_evaluation " ) ) ; memory . emit ( Task . class , resultInheritance ) ; ArrayList < Task > results = new ArrayList < > ( 1 ) ; results . add ( memory . newTask ( resultInheritance , Symbols . JUDGMENT_MARK , 1f , 0.99f , Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY , Tense . Eternal ) ) ; return results ; }
public < T > T set ( List < String > path , Object value ) { T result = super . set ( path , value ) ; save ( ) ; return result ; }
public boolean remove ( T value ) ; public boolean contains ( T value ) ; public int size ( ) ; public boolean validate ( ) ; public java . util . Collection < T > toCollection ( ) ; }
public static void main ( String args [ ] ) { NAR nar = new CommandLineNARBuilder ( args ) . build ( ) ; NARSwing swing = new NARSwing ( nar ) ; LogPanel outputLog = new SwingLogPanel ( swing . narControls ) ; Window outputWindow = new Window ( " Log " , outputLog ) ; outputWindow . setLocation ( swing . narControls . getLocation ( ) . x + swing . narControls . getWidth ( ) , swing . narControls . getLocation ( ) . y ) ; outputWindow . setSize ( 800 , 400 ) ; outputWindow . setVisible ( true ) ; InputPanel inputPanel = new InputPanel ( nar ) ; Window inputWindow = new Window ( " Text Input " , inputPanel ) ; inputWindow . setLocation ( outputWindow . getLocation ( ) . x , outputWindow . getLocation ( ) . y + outputWindow . getHeight ( ) ) ; inputWindow . setSize ( 800 , 200 ) ; inputWindow . setVisible ( true ) ; NARFacePanel f = new NARFacePanel ( nar ) ; Window w = new Window ( " Face " , f ) ; w . setSize ( 250 , 400 ) ; w . setVisible ( true ) ; if ( args . length > 0 & & CommandLineNARBuilder . isReallyFile ( args [ 0 ] ) ) { try { nar . addInput ( new TextInput ( new File ( args [ 0 ] ) ) ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } if ( args . length > 1 ) swing . nar . start ( 0 ) ;
public static void main ( String [ ] args ) { NAR nar = new DefaultNARBuilder ( ) . build ( ) ; new NARPhysics < Rover > ( nar , new Rover ( nar ) ) { } ; nar . param ( ) . duration . set ( 10 ) ; nar . start ( 50 , 10 ) ;
public void initialize ( ) { ByteBuffer bb = ByteBuffer . allocate ( byteCount ) ; for ( CASOperation so : ops ) { Iterator < String > is = so . getKeys ( ) . iterator ( ) ; String k = is . next ( ) ; byte [ ] keyBytes = KeyUtil . getKeyBytes ( k ) ; assert ! is . hasNext ( ) ; int myOpaque = generateOpaque ( ) ; callbacks . put ( myOpaque , so . getCallback ( ) ) ; byte [ ] data = so . getData ( ) ; bb . put ( REQ_MAGIC ) ; bb . put ( ( byte ) cmdMap ( so . getStoreType ( ) ) ) ; bb . putShort ( ( short ) keyBytes . length ) ; bb . put ( ( byte ) StoreOperationImpl . EXTRA_LEN ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( ( ( VBucketAware ) so ) . getVBucket ( k ) ) ; bb . putInt ( keyBytes . length + data . length + StoreOperationImpl . EXTRA_LEN ) ; bb . putInt ( myOpaque ) ; bb . putLong ( so . getCasValue ( ) ) ; bb . putInt ( so . getFlags ( ) ) ; bb . putInt ( so . getExpiration ( ) ) ; bb . put ( keyBytes ) ; bb . put ( data ) ; } bb . put ( REQ_MAGIC ) ; bb . put ( ( byte ) NoopOperationImpl . CMD ) ; bb . putShort ( ( short ) 0 ) ; bb . put ( ( byte ) 0 ) ; bb . put ( ( byte ) 0 ) ; bb . putShort ( ( short ) 0 ) ; bb . putInt ( 0 ) ; bb . putInt ( terminalOpaque ) ; bb . putLong ( 0 ) ; bb . flip ( ) ; setBuffer ( bb ) ; }
boolean isTimedOut ( ) ; boolean isTimedOut ( long ttlMillis ) ; boolean isTimedOutUnsent ( ) ; long getWriteCompleteTimestamp ( ) ; byte [ ] getErrorMsg ( ) ; }
private static boolean testJavaRedBlackTree ( ) { { long count = 0 ; long addTime = 0 L ; long removeTime = 0 L ; long beforeAddTime = 0 L ; long afterAddTime = 0 L ; long beforeRemoveTime = 0 L ; long afterRemoveTime = 0 L ; long memory = 0 L ; long beforeMemory = 0 L ; long afterMemory = 0 L ; if ( debug > 1 ) System . out . println ( " Java's Red-Black Tree " ) ; testNames [ testIndex ] = " Java's RedBlack Tree " ; count + + ; if ( debugMemory ) beforeMemory = DataStructures . getMemoryUse ( ) ; if ( debugTime ) beforeAddTime = System . currentTimeMillis ( ) ; java . util . TreeSet < Integer > tree = new java . util . TreeSet < Integer > ( ) ; for ( int i = 0 ; i < unsorted . length ; i + + ) { int item = unsorted [ i ] ; tree . add ( item ) ; } if ( debugTime ) { afterAddTime = System . currentTimeMillis ( ) ; addTime + = afterAddTime - beforeAddTime ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree add time =  " + addTime / count + "  ms " ) ; } if ( debugMemory ) { afterMemory = DataStructures . getMemoryUse ( ) ; memory + = afterMemory - beforeMemory ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree memory use =  " + ( memory / count ) + "  bytes " ) ; } boolean contains = tree . contains ( INVALID ) ; boolean removed = tree . remove ( INVALID ) ; if ( contains | | removed ) { System . err . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; return false ; } else System . out . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; if ( debug > 1 ) System . out . println ( tree . toString ( ) ) ; long lookupTime = 0 L ; long beforeLookupTime = 0 L ; long afterLookupTime = 0 L ; if ( debugTime ) beforeLookupTime = System . currentTimeMillis ( ) ; for ( int item : unsorted ) { tree . contains ( item ) ; } if ( debugTime ) { afterLookupTime = System . currentTimeMillis ( ) ; lookupTime + = afterLookupTime - beforeLookupTime ; if ( debug > 0 ) System . out . println ( " Java's Red-Black lookup time =  " + lookupTime / count + "  ms " ) ; } if ( debugTime ) beforeRemoveTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < unsorted . length ; i + + ) { int item = unsorted [ i ] ; tree . remove ( item ) ; } if ( debugTime ) { afterRemoveTime = System . currentTimeMillis ( ) ; removeTime + = afterRemoveTime - beforeRemoveTime ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree remove time =  " + removeTime / count + "  ms " ) ; } contains = tree . contains ( INVALID ) ; removed = tree . remove ( INVALID ) ; if ( contains | | removed ) { System . err . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; return false ; } else System . out . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; count + + ; if ( debugMemory ) beforeMemory = DataStructures . getMemoryUse ( ) ; if ( debugTime ) beforeAddTime = System . currentTimeMillis ( ) ; for ( int i = unsorted . length - 1 ; i > = 0 ; i - - ) { int item = unsorted [ i ] ; tree . add ( item ) ; } if ( debugTime ) { afterAddTime = System . currentTimeMillis ( ) ; addTime + = afterAddTime - beforeAddTime ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree add time =  " + addTime / count + "  ms " ) ; } if ( debugMemory ) { afterMemory = DataStructures . getMemoryUse ( ) ; memory + = afterMemory - beforeMemory ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree memory use =  " + ( memory / count ) + "  bytes " ) ; } contains = tree . contains ( INVALID ) ; removed = tree . remove ( INVALID ) ; if ( contains | | removed ) { System . err . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; return false ; } else System . out . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; if ( debug > 1 ) System . out . println ( tree . toString ( ) ) ; lookupTime = 0 L ; beforeLookupTime = 0 L ; afterLookupTime = 0 L ; if ( debugTime ) beforeLookupTime = System . currentTimeMillis ( ) ; for ( int item : unsorted ) { tree . contains ( item ) ; } if ( debugTime ) { afterLookupTime = System . currentTimeMillis ( ) ; lookupTime + = afterLookupTime - beforeLookupTime ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree lookup time =  " + lookupTime / count + "  ms " ) ; } if ( debugTime ) beforeRemoveTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < unsorted . length ; i + + ) { int item = unsorted [ i ] ; tree . remove ( item ) ; } if ( debugTime ) { afterRemoveTime = System . currentTimeMillis ( ) ; removeTime + = afterRemoveTime - beforeRemoveTime ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree remove time =  " + removeTime / count + "  ms " ) ; } contains = tree . contains ( INVALID ) ; removed = tree . remove ( INVALID ) ; if ( contains | | removed ) { System . err . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; return false ; } else System . out . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; long addSortedTime = 0 L ; long removeSortedTime = 0 L ; long beforeAddSortedTime = 0 L ; long afterAddSortedTime = 0 L ; long beforeRemoveSortedTime = 0 L ; long afterRemoveSortedTime = 0 L ; if ( debugMemory ) beforeMemory = DataStructures . getMemoryUse ( ) ; if ( debugTime ) beforeAddSortedTime = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < sorted . length ; i + + ) { int item = sorted [ i ] ; tree . add ( item ) ; } if ( debugTime ) { afterAddSortedTime = System . currentTimeMillis ( ) ; addSortedTime + = afterAddSortedTime - beforeAddSortedTime ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree add time =  " + addSortedTime + "  ms " ) ; } if ( debugMemory ) { afterMemory = DataStructures . getMemoryUse ( ) ; memory + = afterMemory - beforeMemory ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree memory use =  " + ( memory / ( count + 1 ) ) + "  bytes " ) ; } contains = tree . contains ( INVALID ) ; removed = tree . remove ( INVALID ) ; if ( contains | | removed ) { System . err . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; return false ; } else System . out . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; if ( debug > 1 ) System . out . println ( tree . toString ( ) ) ; lookupTime = 0 L ; beforeLookupTime = 0 L ; afterLookupTime = 0 L ; if ( debugTime ) beforeLookupTime = System . currentTimeMillis ( ) ; for ( int item : sorted ) { tree . contains ( item ) ; } if ( debugTime ) { afterLookupTime = System . currentTimeMillis ( ) ; lookupTime + = afterLookupTime - beforeLookupTime ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree lookup time =  " + lookupTime / ( count + 1 ) + "  ms " ) ; } if ( debugTime ) beforeRemoveSortedTime = System . currentTimeMillis ( ) ; for ( int i = sorted . length - 1 ; i > = 0 ; i - - ) { int item = sorted [ i ] ; tree . remove ( item ) ; } if ( debugTime ) { afterRemoveSortedTime = System . currentTimeMillis ( ) ; removeSortedTime + = afterRemoveSortedTime - beforeRemoveSortedTime ; if ( debug > 0 ) System . out . println ( " Java's Red-Black Tree remove time =  " + removeSortedTime + "  ms " ) ; } contains = tree . contains ( INVALID ) ; removed = tree . remove ( INVALID ) ; if ( contains | | removed ) { System . err . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; return false ; } else System . out . println ( " Java's Red-Black Tree invalidity check. contains= " + contains + "  removed= " + removed ) ; testIndex + + ; if ( testResults [ testIndex ] = = null ) testResults [ testIndex ] = new long [ 6 ] ; testResults [ testIndex ] [ 0 ] + = addTime / count ; testResults [ testIndex ] [ 1 ] + = removeTime / count ; testResults [ testIndex ] [ 2 ] + = addSortedTime ; testResults [ testIndex ] [ 3 ] + = removeSortedTime ; testResults [ testIndex ] [ 4 ] + = lookupTime / ( count + 1 ) ; testResults [ testIndex ] [ 5 ] + = memory / ( count + 1 ) ; if ( debug > 1 ) System . out . println ( ) ; } return true ; }
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( final CallbackHandler cbh ) throws OperationException ; }
public Implication clone ( ) { return new Implication ( name ( ) , cloneTerms ( ) , isConstant ( ) , containVar ( ) , getComplexity ( ) , getTemporalOrder ( ) ) ; }
public IntersectionExt clone ( ) { return new IntersectionExt ( cloneTerms ( ) , getTemporalOrder ( ) , isConstant ( ) , containsVar ( ) , getComplexity ( ) , hashCode ( ) ) ; }
public void outputReady ( NHttpClientConnection conn , ContentEncoder encoder ) { this . handler . outputReady ( conn , encoder ) ; }
public void test_print_1_1 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch(print(X), error(instantiation_error, instantiation_error(Goal, ArgNo)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " print " , new Var ( " X " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 1 ) ; }
public void testBuildAuthHeaderUTF8 ( ) throws UnsupportedEncodingException { String result = ConfigurationProviderHTTP . buildAuthHeader ( " blahblah " , " bla@@h " ) ; System . err . println ( " Authorization header for matt:this@here is  " + result ) ; assertEquals ( " Basic YmxhaGJsYWg6YmxhQEBo " , result ) ; }
public void run ( ) { s_aLogger . info ( " ConnectionThread: run " ) ; final Socket s = m_aSocket ; m_aOwner . createHandler ( ) . handle ( m_aOwner , s ) ; try {
void update ( Tracker tracker , long now ) ; void clear ( ) ; void setEventManager ( EventManager e ) ; }
public void applyBulkMutations ( List < Tuple2 < MutationType , Dataset < Row > > > planned ) throws Exception { for ( Tuple2 < MutationType , Dataset < Row > > plan : planned ) { MutationType mutationType = plan . _1 ( ) ;
protected void plan ( Task task , Term target , double searchDistance , char punctuation ) { if ( ! implication . containsVertex ( target ) ) return ; ParticlePlan plan = planParticle ( target , searchDistance , particles ) ; if ( plan = = null ) return ; Sentence [ ] path = plan . path ; List < Term > seq = plan . sequence ; if ( seq . size ( ) < 1 ) return ; Sentence currentEdge = path [ path . length - 1 ] ; Stamp stamp = Stamp . make ( task . sentence . stamp , currentEdge . stamp , memory . getTime ( ) ) ; if ( seq . get ( seq . size ( ) - 1 ) . equals ( target ) ) { seq . remove ( seq . size ( ) - 1 ) ; } Term subj = seq . size ( ) > 1 ? ( Conjunction ) Conjunction . make ( seq . toArray ( new Term [ seq . size ( ) ] ) , TemporalRules . ORDER_FORWARD , memory ) : seq . get ( 0 ) ; double planDistance = Math . min ( plan . distance , searchDistance ) ; float confidence = ( float ) plan . activation ; TruthValue val = new TruthValue ( 1.0f , confidence ) ; Term imp = Implication . make ( subj , target , TemporalRules . ORDER_FORWARD , memory ) ; if ( imp = = null ) { throw new RuntimeException ( " Invalid implication:  " + subj + "  = \\ >  " + target ) ; } BudgetValue bud = BudgetFunctions . forward ( val , memory ) ; bud . andPriority ( confidence ) ; Task t = new Task ( new Sentence ( imp , punctuation , val , stamp ) , bud ) ; System . out . println ( "   -> Plan:  " + t ) ; memory . inputTask ( t ) ;
public void collectData ( final StatsSession session , final DataSet dataSet ) { dataSet . setField ( Field . PRODUCT , product . get ( ) ) ; dataSet . setField ( Field . SUM_OF_SQUARES , sumOfSquares . get ( ) ) ; dataSet . setField ( Field . SUM_OF_INVERSES , sumOfInverses . get ( ) ) ; dataSet . setField ( Field . ARITHMETIC_MEAN , getArithmeticMean ( session ) ) ; dataSet . setField ( Field . GEOMETRIC_MEAN , getGeometricMean ( session ) ) ; dataSet . setField ( Field . HARMONIC_MEAN , getHarmonicMean ( session ) ) ; dataSet . setField ( Field . QUADRATIC_MEAN , getQuadraticMean ( session ) ) ; dataSet . setField ( Field . STANDARD_DEVIATION , getStandardDeviation ( session ) ) ;
public static final String reverseWordsUsingStringTokenizerWithAdditionalStorage ( String string ) { String output = new String ( ) ; StringTokenizer st = new StringTokenizer ( string ) ; while ( st . hasMoreTokens ( ) ) { output = ( st . nextToken ( ) ) + ' ' + output ; } return output ; }
abstract public boolean allow ( CompoundTerm st ) ; public void remove ( final Sentence s ) { if ( ! containsEdge ( s ) ) return ; Term from = getEdgeSource ( s ) ; Term to = getEdgeTarget ( s ) ; boolean r = removeEdge ( s ) ; if ( inDegreeOf ( from ) + outDegreeOf ( from ) = = 0 ) removeVertex ( from ) ; if ( inDegreeOf ( to ) + outDegreeOf ( to ) = = 0 ) removeVertex ( to ) ; if ( r ) event . emit ( GraphChange . class , null , s ) ; } public synchronized void add ( final Sentence s ) { if ( containsEdge ( s ) ) return ; if ( ! allow ( s ) ) return ; if ( s . content instanceof CompoundTerm ) { CompoundTerm cs = ( CompoundTerm ) s . content ; if ( cs instanceof Statement ) { Statement st = ( Statement ) cs ; if ( allow ( st ) ) { if ( add ( s , st ) ) event . emit ( GraphChange . class , st , null ) ; } } } } public boolean add ( Sentence s , CompoundTerm ct ) { if ( ct instanceof Statement ) { Statement st = ( Statement ) ct ; Term subject = st . getSubject ( ) ; Term predicate = st . getPredicate ( ) ; addVertex ( subject ) ; addVertex ( predicate ) ; addEdge ( subject , predicate , s ) ; return true ; } return false ; } }
private void generateExpressLanes ( ) { int numberOfLanes = determineNumberOfExpressLanes ( ) ; if ( numberOfLanes = = 0 ) return ; int numberOfNodes = size / 2 ; if ( numberOfNodes = = 0 ) return ; if ( lanes = = null ) lanes = new ArrayList < List < ExpressNode < T > > > ( numberOfLanes ) ; if ( numberOfLanes = = lanes . size ( ) & & numberOfNodes = = lanes . get ( 0 ) . size ( ) ) return ; int width = 0 ; List < ExpressNode < T > > expressLane = null ; Node < T > node = null ; List < ExpressNode < T > > previousLane = null ; int prevIndex = 0 ; ExpressNode < T > expressNode = null ; boolean reuse = false ; for ( int i = 0 ; i < numberOfLanes ; i + + ) {
void handle ( @Nonnull String sAction , @Nonnull IMessage aMsg , @Nullable Map < String , Object > aOptions ) throws AS2Exception ; void addModule ( @Nonnull IProcessorModule aModule ) ; @Nonnull EChange removeModule ( @Nullable IProcessorModule aModule ) ; @Nonnegative int getModuleCount ( ) ; @Nonnull @ReturnsMutableCopy ICommonsList < IProcessorModule > getAllModules ( ) ; @Nullable < T extends IProcessorModule > T getModuleOfClass ( @Nonnull Class < T > aClass ) ; @Nonnull @ReturnsMutableCopy < T extends IProcessorModule > ICommonsList < T > getAllModulesOfClass ( @Nonnull Class < T > aClass ) ; @Nonnull @ReturnsMutableCopy ICommonsList < IProcessorActiveModule > getAllActiveModules ( ) ; void startActiveModules ( ) ; void stopActiveModules ( ) ; }
public static CharSequence yarn ( final int maxLen , final CharSequence . . . components ) { int totalLen = 0 ; int total = 0 ; CharSequence lastNonNull = null ; for ( final CharSequence s : components ) { if ( s ! = null ) { totalLen + = s . length ( ) ; total + + ; lastNonNull = s ; } } if ( total = = 0 ) { return null ; } if ( total = = 1 ) { return lastNonNull . toString ( ) ; } if ( ( totalLen < = maxLen ) | | ( maxLen = = - 1 ) ) { / *
public void storePartnership ( ) throws OpenAS2Exception { final String sFilename = getFilename ( ) ; { long nIndex = 0 ; File aBackupFile ; do { aBackupFile = new File ( sFilename + '.' + StringHelper . getLeadingZero ( nIndex , 7 ) ) ; nIndex + + ; } while ( aBackupFile . exists ( ) ) ; s_aLogger . info ( " backing up  " + sFilename + "  to  " + aBackupFile . getName ( ) ) ; final File fr = new File ( sFilename ) ; FileOperations . renameFile ( fr , aBackupFile ) ; } final IMicroDocument aDoc = new MicroDocument ( ) ; final IMicroElement ePartnerships = aDoc . appendElement ( " partnerships " ) ; for ( final IStringMap aAttrs : getAllPartners ( ) ) { final IMicroElement ePartner = ePartnerships . appendElement ( " partner " ) ; for ( final Map . Entry < String , String > aAttr : aAttrs ) ePartner . setAttribute ( aAttr . getKey ( ) , aAttr . getValue ( ) ) ; } for ( final Partnership partnership : getAllPartnerships ( ) ) { final IMicroElement ePartnership = ePartnerships . appendElement ( " partnership " ) ; ePartnership . setAttribute ( PARTNER_NAME , partnership . getName ( ) ) ; final IMicroElement eSender = ePartnership . appendElement ( " sender " ) ; eSender . setAttribute ( PARTNER_NAME , partnership . getSenderID ( PARTNER_NAME ) ) ; final IMicroElement eReceiver = ePartnership . appendElement ( " receiver " ) ; eReceiver . setAttribute ( PARTNER_NAME , partnership . getReceiverID ( PARTNER_NAME ) ) ; for ( final Map . Entry < String , String > aAttr : partnership . getAllAttributes ( ) ) ePartnership . appendElement ( " attribute " ) . setAttribute ( PARTNER_NAME , aAttr . getKey ( ) ) . setAttribute ( " value " , aAttr . getValue ( ) ) ; } if ( MicroWriter . writeToFile ( aDoc , new File ( sFilename ) ) . isFailure ( ) ) throw new OpenAS2Exception ( " Failed to write to file  " + sFilename ) ;
public boolean equals ( final StatsKeyMatcher other ) { LengthMatcher lengthMatcher = ( LengthMatcher ) other ; return target = = lengthMatcher . target & & length = = lengthMatcher . length ;
private String check ( String url ) { HttpURLConnection connection = null ; try { URL u = new URL ( url ) ; connection = ( HttpURLConnection ) u . openConnection ( ) ; InputStream in = new BufferedInputStream ( connection . getInputStream ( ) , 8192 ) ; byte buffer [ ] = new byte [ 8192 ] ; int read = in . read ( buffer ) ; if ( read < buffer . length ) { buffer [ read ] = '\0' ; } return parse ( new String ( buffer ) , handlers ) ; } catch ( final IOException e ) { Log . e ( TAG , " Failed to check and parse an incoming playlist. " , e ) ; } finally { if ( null ! = connection ) { connection . disconnect ( ) ; } } return null ; }
public boolean containsKey ( Object key ) { return get ( key ) ! = null ; }
public static IHTTPIncomingDumper getHTTPIncomingDumper ( ) { return s_aHTTPIncomingDumper ; }
void identity ( ) { for ( int i = 0 ; i < size ( ) ; i + + ) {
public T poll ( ) { int size = lastIndex - firstIndex ; if ( size < 0 ) return null ; T t = array [ firstIndex % array . length ] ; array [ firstIndex % array . length ] = null ; firstIndex + + ; size = lastIndex - firstIndex ; if ( size < = 0 ) { lastIndex = 0 ; firstIndex = 0 ; } shrink ( size ) ; return t ; }
public T pop ( ) { Node < T > nodeToRemove = top ; top = nodeToRemove . below ; if ( top ! = null ) top . above = null ; T value = null ; if ( nodeToRemove ! = null ) { value = nodeToRemove . value ; size - - ; } return value ; }
public ICommonsList < IProcessorActiveModule > getAllActiveModules ( ) { return m_aModules . getAllInstanceOf ( IProcessorActiveModule . class ) ; }
public void connectionSucceeded ( String message ) ; } public interface ConnectionInfoListener { void onConnectionConfigChange ( ConnectionInfo connectionInfo ) ; } public interface NetworkMonitorListener { void onNetworkConnect ( ) ; } }
public < C extends Collection < V > , V > C deserializeToCollection ( Object configValue , Class < C > collectionClass , Class < V > valueClass ) { return super . deserializeToCollection ( configValue , collectionClass , valueClass ) ; }
public void testCompressedString ( ) throws Exception { String s1 = " This is a test simple string that will be compressed. " ; tc . setCompressionThreshold ( 8 ) ; CachedData cd = tc . encode ( s1 ) ; assertEquals ( SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertFalse ( Arrays . equals ( s1 . getBytes ( ) , cd . getData ( ) ) ) ; assertEquals ( s1 , tc . decode ( cd ) ) ; }
public void testCustomNullStringHash ( ) { Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " dep1 " , testDataFrame ( ) ) ; Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( HashDeriver . NULL_STRING_CONFIG , " " ) ; Config config = ConfigFactory . parseMap ( configMap ) ; HashDeriver d = new HashDeriver ( ) ; assertNoValidationFailures ( d , config ) ; d . configure ( config ) ; Dataset < Row > derived = d . derive ( dependencies ) ; assertEquals ( 1 , derived . count ( ) ) ; assertEquals ( testDataFrame ( ) . schema ( ) . size ( ) + 1 , derived . schema ( ) . size ( ) ) ; assertTrue ( Lists . newArrayList ( derived . schema ( ) . fieldNames ( ) ) . contains ( HashDeriver . DEFAULT_HASH_FIELD_NAME ) ) ; assertEquals ( " 862ff0dc2acce97b6f8bd6c369df2668 " ,
public ListIterator < T > listIterator ( int index ) { synchronized ( mLOCK ) { this . cleanPhantomReferences ( ) ;
public static boolean include ( String filename ) { return filename . startsWith ( " nal5.19 " ) ; }
public float NeighborsValue2 ( String op , int i , int j , Cell [ ] [ ] readCells , String Condition , float data ) { return Op ( op , Op ( op , Op ( op , Neighbor_Value ( readCells [ i + 1 ] [ j ] , Condition , data ) , Neighbor_Value ( readCells [ i - 1 ] [ j ] , Condition , data ) ) , Neighbor_Value ( readCells [ i ] [ j + 1 ] , Condition , data ) ) , Neighbor_Value ( readCells [ i ] [ j - 1 ] , Condition , data ) ) ; }
public void validSchema ( ) { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( ComponentFactory . TYPE_CONFIG_NAME , " flat " ) ; paramMap . put ( FlatSchema . FIELD_NAMES_CONFIG , Lists . newArrayList ( " decimalField " , " stringField " , " floatField " , " doubleField " , " byteField " , " shortField " , " integerField " , " longField " , " booleanField " , " binaryField " , " dateField " , " timestampField " , " decimalField2 " ) ) ; paramMap . put ( FlatSchema . FIELD_TYPES_CONFIG , Lists . newArrayList ( " decimal(10,0) " , " string " , " float " , " double " , " byte " , " short " , " integer " , " long " , " boolean " , " binary " , " date " , " timestamp " , "  decimal ( 38 , 38 ) " ) ) ; config = ConfigFactory . parseMap ( paramMap ) ; FlatSchema flatSchema = new FlatSchema ( ) ; assertNoValidationFailures ( flatSchema , config ) ; flatSchema . configure ( config ) ; StructType schema = flatSchema . getSchema ( ) ; assertEquals ( schema . fields ( ) . length , 13 ) ; assertEquals ( schema . fields ( ) [ 0 ] . name ( ) , " decimalField " ) ; assertEquals ( schema . fields ( ) [ 1 ] . name ( ) , " stringField " ) ; assertEquals ( schema . fields ( ) [ 2 ] . name ( ) , " floatField " ) ; assertEquals ( schema . fields ( ) [ 3 ] . name ( ) , " doubleField " ) ; assertEquals ( schema . fields ( ) [ 4 ] . name ( ) , " byteField " ) ; assertEquals ( schema . fields ( ) [ 5 ] . name ( ) , " shortField " ) ; assertEquals ( schema . fields ( ) [ 6 ] . name ( ) , " integerField " ) ; assertEquals ( schema . fields ( ) [ 7 ] . name ( ) , " longField " ) ; assertEquals ( schema . fields ( ) [ 8 ] . name ( ) , " booleanField " ) ; assertEquals ( schema . fields ( ) [ 9 ] . name ( ) , " binaryField " ) ; assertEquals ( schema . fields ( ) [ 10 ] . name ( ) , " dateField " ) ; assertEquals ( schema . fields ( ) [ 11 ] . name ( ) , " timestampField " ) ; assertEquals ( schema . fields ( ) [ 12 ] . name ( ) , " decimalField2 " ) ; assertEquals ( schema . fields ( ) [ 0 ] . dataType ( ) , new DecimalType ( 10 , 0 ) ) ; assertEquals ( schema . fields ( ) [ 1 ] . dataType ( ) , DataTypes . StringType ) ; assertEquals ( schema . fields ( ) [ 2 ] . dataType ( ) , DataTypes . FloatType ) ; assertEquals ( schema . fields ( ) [ 3 ] . dataType ( ) , DataTypes . DoubleType ) ; assertEquals ( schema . fields ( ) [ 4 ] . dataType ( ) , DataTypes . ByteType ) ; assertEquals ( schema . fields ( ) [ 5 ] . dataType ( ) , DataTypes . ShortType ) ; assertEquals ( schema . fields ( ) [ 6 ] . dataType ( ) , DataTypes . IntegerType ) ; assertEquals ( schema . fields ( ) [ 7 ] . dataType ( ) , DataTypes . LongType ) ; assertEquals ( schema . fields ( ) [ 8 ] . dataType ( ) , DataTypes . BooleanType ) ; assertEquals ( schema . fields ( ) [ 9 ] . dataType ( ) , DataTypes . BinaryType ) ; assertEquals ( schema . fields ( ) [ 10 ] . dataType ( ) , DataTypes . DateType ) ; assertEquals ( schema . fields ( ) [ 11 ] . dataType ( ) , DataTypes . TimestampType ) ; assertEquals ( schema . fields ( ) [ 12 ] . dataType ( ) , new DecimalType ( 38 , 38 ) ) ; }
abstract public float getMass ( ) ; abstract public boolean putIn ( final E newItem , boolean insertIntoNameTable ) ; public boolean putIn ( final E newItem ) { return putIn ( newItem , true ) ; } abstract public int size ( ) ; abstract public E takeOut ( boolean removeFromNameTable ) ; abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } public E takeOut ( ) { return takeOut ( true ) ; } protected float forgetCycles ( ) { return forgettingRate . getCycles ( ) ; } public void forget ( final E x ) { float forgetCycles = forgetCycles ( ) ; if ( forgetCycles > 0 ) { final float size = size ( ) ; float emptyBagFactor = size > 0 ? ( 1 + ( getCapacity ( ) - size ) / size ) : 1 ; forgetCycles * = emptyBagFactor ; BudgetFunctions . forget ( x . budget , forgetCycles , RELATIVE_THRESHOLD ) ; } } public final boolean putBack ( final E oldItem , final boolean insertIntoNameTable ) { forget ( oldItem ) ; return putIn ( oldItem , insertIntoNameTable ) ; } public final boolean putBack ( final E oldItem ) { return putBack ( oldItem , true ) ; } public E processNext ( boolean forget ) { final E x = takeOut ( false ) ; if ( x ! = null ) { if ( forget ) { forget ( x ) ; } boolean r = putIn ( x , false ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else { return null ; } } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; @Override public abstract Iterator < E > iterator ( ) ; abstract public E removeKey ( CharSequence key ) ; }
public void onReceive ( Context context , Intent intent ) { String action = intent . getAction ( ) ; if ( action . equals ( AudioManager . ACTION_AUDIO_BECOMING_NOISY ) ) { Intent i = new Intent ( context , StreamingService . class ) ;
public float next ( final long time , final NAR nar ) { if ( concept = = null ) { concept = nar . memory . concept ( conceptTerm ) ; if ( concept = = null ) { return 0 ; } } switch ( mode ) { case Priority : return concept . getPriority ( ) ; case Duration : return concept . getDurability ( ) ; } return 0f ; }
public boolean react ( NAR nar , String input , TextReaction lastHandler ) { if ( ! nar . isWorking ( ) ) { if ( input . equals ( Symbols . STOP_COMMAND ) ) { nar . output ( Output . IN . class , input ) ; nar . setWorking ( false ) ; return true ; } } return false ; }
public void playlistChanged ( MPDPlaylistChangedEvent event ) { try { MPDApplication app = ( MPDApplication ) getApplication ( ) ;
protected final long getResendDelayMS ( ) throws InvalidParameterException { if ( ! containsAttribute ( ATTR_RESEND_DELAY_SECONDS ) ) return DEFAULT_RESEND_DELAY_MS ; return getAttributeAsIntRequired ( ATTR_RESEND_DELAY_SECONDS ) * CGlobal . MILLISECONDS_PER_SECOND ; }
public static void assertConfig ( Config config , String key ) { if ( ! config . hasPath ( key ) ) { throw new RuntimeException ( " Missing required property [ " + key + " ] " ) ;
public boolean expandPane ( float mSlideOffset ) { if ( ! isPaneVisible ( ) ) { showPane ( ) ; } return expandPane ( mSlideableView , 0 , mSlideOffset ) ; }
public void translateInvalidPayload ( ) throws Exception { String descPath = TestProtobufTranslator . class . getResource ( SINGLE_EXAMPLE ) . getPath ( ) ; Map < String , Object > configMap = new HashMap < > ( ) ; configMap . put ( ProtobufTranslator . SCHEMA_CONFIG + " . " + SchemaFactory . TYPE_CONFIG_NAME , " protobuf " ) ; configMap . put ( ProtobufTranslator . SCHEMA_CONFIG + " . " + ProtobufSchema . DESCRIPTOR_FILEPATH_CONFIG , descPath ) ; Config config = ConfigFactory . parseMap ( configMap ) ; ProtobufTranslator translator = new ProtobufTranslator ( ) ; assertNoValidationFailures ( translator , config ) ; translator . configure ( config ) ; byte [ ] key = " foo " . getBytes ( ) ; byte [ ] payload = new byte [ ] { } ; Row raw = TestingMessageFactory . get ( key , DataTypes . BinaryType , payload , DataTypes . BinaryType ) ; translator . translate ( raw ) ; }
CharsWrapper readUntil ( char [ ] stop ) ; CharsWrapper readCharsUntil ( char [ ] stop ) ; int peek ( ) ; int peek ( int n ) ; char peekChar ( ) ; char peekChar ( int n ) ; void skipPeeks ( ) ; void pushBack ( char c ) ; }
protected void see ( boolean [ ] hit ) { int totalHit = 0 ; for ( boolean x : hit ) if ( x ) totalHit + + ; float th = totalHit / ( ( float ) hit . length ) ; String sp = Texts . n1 ( th / 3f ) ; sight . set ( " < " + sp + "  --> sight>. :|: " ) ;
public void handleMessage ( Message msg ) { stopSelf ( ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > aNode = this . head ; if ( aNode ! = null ) builder . append ( " Nodes= " ) ; while ( aNode ! = null ) { builder . append ( aNode . index ) . append ( " = " ) . append ( aNode . value ) ; aNode = aNode . nextNode ; if ( aNode ! = null ) builder . append ( " ,  " ) ; else builder . append ( " \ n " ) ; } for ( int i = 0 ; i < lanes . size ( ) ; i + + ) { builder . append ( " Lane= " ) . append ( i ) . append ( " \ n " ) ; List < ExpressNode < T > > lane = lanes . get ( i ) ; for ( int j = 0 ; j < lane . size ( ) ; j + + ) { ExpressNode < T > node = lane . get ( j ) ; builder . append ( node ) ; } builder . append ( " \ n " ) ; } return builder . toString ( ) ; }
public static boolean isNegatedQuery ( String query , String formula ) { boolean result = false ; formula = formula . trim ( ) ; if ( formula . substring ( 0 , 4 ) . compareTo ( " (not " ) ! = 0 ) return false ; formula = formula . substring ( 5 , formula . length ( ) - 1 ) ; Formula f = new Formula ( ) ; f . read ( formula ) ; result = f . equals ( query ) ; return result ; }
private static void transformSubjectPI ( CompoundTerm subject , Term predicate , DerivationContext nal ) { TruthValue truth = nal . getCurrentTask ( ) . sentence . truth ; BudgetValue budget ; Inheritance inheritance ; Term newSubj , newPred ; if ( subject instanceof Product ) { Product product = ( Product ) subject ;
public void addOutput ( PrintStream p ) { addOutput ( new LogOutput ( ) { @Override public void traceAppend ( Class channel , String s ) {
public boolean keyUp ( Event e , int key ) { switch ( key ) { case Event . LEFT : leftArrow = true ; prevKey = - 1 ; break ; case Event . RIGHT : rightArrow = true ; prevKey = - 1 ; break ; case '{' : spin + + ; break ; case '}' : spin - - ; break ; case '\t' : toggleNoise ( ) ; break ; default : if ( key ! = prevKey ) { setFlex ( key ) ; leftArrow = false ; rightArrow = false ; } prevKey = key ; break ; } return true ; }
public void onClick ( DialogInterface dialog , int whichButton ) { savePlaylist ( playlistToSave ) ; }
public void testDebugBuffer ( ) throws Exception { String input = " this is a test _ " ; ByteBuffer bb = ByteBuffer . wrap ( input . getBytes ( ) ) ; String s = MemcachedConnection . dbgBuffer ( bb , input . length ( ) ) ; assertEquals ( " this is a test  \\ x5f " , s ) ; }
protected String executeGetRequest ( String request ) { HttpGet httpGet = null ; prepareRequest ( ) ; request = removeDiscReference ( request ) ; request = request . replace ( "   " , " %20 " ) ; if ( DEBUG ) Log . d ( getName ( ) , " Http request :  " + request ) ; httpGet = new HttpGet ( request ) ; return executeRequest ( httpGet ) ; }
public V get ( K key ) { PatriciaTrie . Node < K > node = trie . getNode ( key ) ; if ( node instanceof RadixNode ) { RadixNode < K , V > radixNode = ( RadixNode < K , V > ) node ; return radixNode . value ; } return null ; }
public void end ( ) { if ( ! sAnimations . get ( ) . contains ( this ) & & ! sPendingAnimations . get ( ) . contains ( this ) ) { mStartedDelay = false ; startAnimation ( ) ; } else if ( ! mInitialized ) { initAnimation ( ) ; } if ( mRepeatCount > 0 & & ( mRepeatCount & 0x01 ) = = 1 ) { animateValue ( 0f ) ; } else { animateValue ( 1f ) ; } endAnimation ( ) ; }
public NodeLocator createLocator ( List < MemcachedNode > nodes ) { return new KetamaNodeLocator ( nodes , getHashAlg ( ) ) ; }
public < T > Future < CASValue < T > > asyncGetAndLock ( final String key , int exp , final Transcoder < T > tc ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < CASValue < T > > rv = new OperationFuture < CASValue < T > > ( latch , operationTimeout ) ; Operation op = opFact . getl ( key , exp , new GetlOperation . Callback ( ) { private CASValue < T > val = null ; public void receivedStatus ( OperationStatus status ) { rv . set ( val ) ; } public void gotData ( String k , int flags , long cas , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; assert cas > 0 : " CAS was less than zero:   " + cas ; val = new CASValue < T > ( cas , tc . decode ( new CachedData ( flags , data , tc . getMaxSize ( ) ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; rv . setOperation ( op ) ; addOp ( key , op ) ; return rv ; }
public void init ( String path , String ext ) { this . setupConfig ( ) ; this . filePaths = new ArrayList < String > ( ) ; Path hdfsPath = new Path ( path ) ; FileSystem fs ; try { fs = FileSystem . get ( config ) ; FileStatus fileStat = fs . getFileStatus ( hdfsPath ) ; if ( fileStat . isDirectory ( ) ) { FileStatus [ ] filesInDir = fs . globStatus ( new Path ( path . toString ( ) , " *. " + ext ) ) ; for ( int i = 0 ; i < filesInDir . length ; i + + ) { if ( filesInDir [ i ] . isFile ( ) ) { System . out . println ( " ADD FILE: " + filesInDir [ i ] . getPath ( ) . toString ( ) ) ; filePaths . add ( filesInDir [ i ] . getPath ( ) . toString ( ) ) ; } } } else { this . filePaths . add ( path ) ; } } catch ( IOException ioe ) { throw new RuntimeException ( " Failed getting list of files at: " + path , ioe ) ; } this . currentIndex = - 1 ; }
public void onChange ( float v ) { NARGraphDisplay . this . nodeSize = v ;
public void onMessage ( WebSocket conn , String message ) { NARConnection n = socketSession . get ( conn ) ; if ( n ! = null ) { n . read ( message ) ;
public NAR init ( NAR n ) { n . addPlugin ( new RuntimeNARSettings ( ) ) ; n . addPlugin ( new Emotions ( ) ) ; n . addPlugin ( new Anticipate ( ) ) ; boolean full_internal_experience = false ; if ( ! full_internal_experience ) { n . addPlugin ( new InternalExperience ( ) ) ; } else { n . addPlugin ( new FullInternalExperience ( ) ) ; n . addPlugin ( new Abbreviation ( ) ) ; n . addPlugin ( new Counting ( ) ) ; } return n ; }
public boolean asyncDecode ( CachedData d ) { return d . getFlags ( ) = = 1 ; }
private static String translateLinePartToNarsese ( NaturalLanguagePerception . LinePart linePart ) { if ( linePart . type = = NaturalLanguagePerception . LinePart . EnumType . SIGN ) { return " ' " + linePart . content + " '. " ;
private static void detachmentWithVar ( Sentence originalMainSentence , Sentence subSentence , int index , Memory memory ) { Sentence mainSentence = ( Sentence ) originalMainSentence . clone ( ) ; Statement statement = ( Statement ) mainSentence . getContent ( ) ; Term component = statement . componentAt ( index ) ; Term content = subSentence . getContent ( ) ; if ( ( ( component instanceof Inheritance ) | | ( component instanceof Negation ) ) & & ( memory . currentBelief ! = null ) ) { if ( component . isConstant ( ) ) {
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { } } ; BlockingQueue < Operation > oQueue = new LinkedBlockingQueue < Operation > ( ) ; BlockingQueue < Operation > rQueue = new LinkedBlockingQueue < Operation > ( ) ; BlockingQueue < Operation > wQueue = new LinkedBlockingQueue < Operation > ( ) ; OperationQueueFactory opQueueFactory = new DirectFactory ( oQueue ) ; OperationQueueFactory rQueueFactory = new DirectFactory ( rQueue ) ; OperationQueueFactory wQueueFactory = new DirectFactory ( wQueue ) ; AuthDescriptor anAuthDescriptor = new AuthDescriptor ( new String [ ] { " PLAIN " } , new PlainCallbackHandler ( " username " , " password " ) ) ; ConnectionFactory f = b . setDaemon ( true ) . setShouldOptimize ( false ) . setFailureMode ( FailureMode . Redistribute ) . setHashAlg ( HashAlgorithm . KETAMA_HASH ) . setInitialObservers ( Collections . singleton ( testObserver ) ) . setOpFact ( new BinaryOperationFactory ( ) ) . setOpTimeout ( 4225 ) . setOpQueueFactory ( opQueueFactory ) . setReadOpQueueFactory ( rQueueFactory ) . setWriteOpQueueFactory ( wQueueFactory ) . setReadBufferSize ( 19 ) . setTranscoder ( new WhalinTranscoder ( ) ) . setUseNagleAlgorithm ( true ) . setLocatorType ( Locator . CONSISTENT ) . setOpQueueMaxBlockTime ( 19 ) . setAuthDescriptor ( anAuthDescriptor ) . build ( ) ; assertEquals ( 4225 , f . getOperationTimeout ( ) ) ; assertEquals ( 19 , f . getReadBufSize ( ) ) ; assertSame ( HashAlgorithm . KETAMA_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof WhalinTranscoder ) ; assertSame ( FailureMode . Redistribute , f . getFailureMode ( ) ) ; assertEquals ( 1 , f . getInitialObservers ( ) . size ( ) ) ; assertSame ( testObserver , f . getInitialObservers ( ) . iterator ( ) . next ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof BinaryOperationFactory ) ; assertSame ( oQueue , f . createOperationQueue ( ) ) ; assertSame ( rQueue , f . createReadOperationQueue ( ) ) ; assertSame ( wQueue , f . createWriteOperationQueue ( ) ) ; assertTrue ( f . isDaemon ( ) ) ; assertFalse ( f . shouldOptimize ( ) ) ; assertTrue ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , 19 ) ; assertSame ( anAuthDescriptor , f . getAuthDescriptor ( ) ) ; MemcachedNode n = new MockMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) ) ; assertTrue ( f . createLocator ( Collections . singletonList ( n ) ) instanceof KetamaNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) , sc , 1 ) instanceof BinaryMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } } public void testProtocolSetterBinary ( ) { assertTrue ( b . setProtocol ( Protocol . BINARY ) . build ( ) . getOperationFactory ( ) instanceof BinaryOperationFactory ) ; } public void testProtocolSetterText ( ) { assertTrue ( b . setProtocol ( Protocol . TEXT ) . build ( ) . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue < Operation > queue ; public DirectFactory ( BlockingQueue < Operation > q ) { super ( ) ; queue = q ; } public BlockingQueue < Operation > create ( ) { return queue ; } } }
private String whyNonTraversible ( GridAgent agent , int x , int y , int tx , int ty ) { int dx = Math . abs ( tx - x ) ; int dy = Math . abs ( ty - y ) ; if ( ! ( ( dx < = 1 ) & & ( dy < = 1 ) ) ) return " Too far " ; if ( ( tx < 0 ) | | ( ty < 0 ) | | ( tx > = WIDTH ) | | ( ty > = HEIGHT ) ) return " Out of bounds " ; Cell from = cells . at ( x , y ) ; Cell to = cells . at ( tx , ty ) ; if ( to . isSolid ( ) ) return " Too solid " ; final float maxTraversableHeight = 16 ; float dHeight = to . height - from . height ; if ( dHeight > maxTraversableHeight ) return " Too high " ; return null ; }
public static void transformNegation ( Term content , Memory memory ) { Task task = memory . getCurrentTask ( ) ; Sentence sentence = task . getSentence ( ) ; TruthValue truth = sentence . truth ; if ( sentence . isJudgment ( ) ) { truth = TruthFunctions . negation ( truth ) ; } BudgetValue budget ; if ( sentence . isQuestion ( ) ) { budget = BudgetFunctions . compoundBackward ( content , memory ) ; } else { budget = BudgetFunctions . compoundForward ( truth , content , memory ) ; } memory . singlePremiseTask ( content , truth , budget ) ; }
public static Term make ( Term term1 , Term term2 , Memory memory ) { TreeSet set ; if ( term1 instanceof ConjunctionParallel ) { set = new TreeSet ( ( ( CompoundTerm ) term1 ) . cloneComponents ( ) ) ; if ( term2 instanceof ConjunctionParallel ) set . addAll ( ( ( CompoundTerm ) term2 ) . cloneComponents ( ) ) ; else set . add ( ( Term ) term2 . clone ( ) ) ; } else if ( term2 instanceof ConjunctionParallel ) { set = new TreeSet ( ( ( CompoundTerm ) term2 ) . cloneComponents ( ) ) ; set . add ( ( Term ) term1 . clone ( ) ) ; } else { set = new TreeSet ( ) ; set . add ( term1 ) ; set . add ( term2 ) ; } return make ( set , memory ) ; }
public void nextOutput ( ArrayList < String > lines ) { if ( ! lines . isEmpty ( ) ) { String text = " " ;
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; final Map < MemcachedNode , Collection < String > > chunks = new HashMap < MemcachedNode , Collection < String > > ( ) ; final NodeLocator locator = conn . getLocator ( ) ; for ( String key : keys ) { final MemcachedNode primaryNode = locator . getPrimary ( key ) ; MemcachedNode node = null ; if ( primaryNode . isActive ( ) ) { node = primaryNode ; } else { for ( Iterator < MemcachedNode > i = locator . getSequence ( key ) ; node = = null & & i . hasNext ( ) ; ) { MemcachedNode n = i . next ( ) ; if ( n . isActive ( ) ) { node = n ; } } if ( node = = null ) { node = primaryNode ; } } assert node ! = null : " Didn't find a node for  " + key ; Collection < String > ks = chunks . get ( node ) ; if ( ks = = null ) { ks = new ArrayList < String > ( ) ; chunks . put ( node , ks ) ; } ks . add ( key ) ; } final CountDownLatch latch = new CountDownLatch ( chunks . size ( ) ) ; final Collection < Operation > ops = new ArrayList < Operation > ( ) ; GetOperation . Callback cb = new GetOperation . Callback ( ) { @SuppressWarnings ( " synthetic-access " ) public void receivedStatus ( String line ) { if ( ! line . equals ( " END " ) ) { getLogger ( ) . warn ( " Expected ``END'', was ``%s'' " , line ) ; } } public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , transcoder . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; for ( Map . Entry < MemcachedNode , Collection < String > > me : chunks . entrySet ( ) ) { ops . add ( addOp ( me . getKey ( ) , opFact . get ( me . getValue ( ) , cb ) ) ) ; } return new BulkGetFuture ( m , ops , latch ) ; }
private int calcItemHeight ( int position , int childHeight ) { int divHeight = getDividerHeight ( ) ; boolean isSliding = mAnimate & & mFirstExpPos ! = mSecondExpPos ; int maxNonSrcBlankHeight = mFloatViewHeight - mItemHeightCollapsed ; int slideHeight = ( int ) ( mSlideFrac * maxNonSrcBlankHeight ) ; int height ; if ( position = = mSrcPos ) { if ( mSrcPos = = mFirstExpPos ) { if ( isSliding ) { height = slideHeight + mItemHeightCollapsed ; } else { height = mFloatViewHeight ; } } else if ( mSrcPos = = mSecondExpPos ) { height = mFloatViewHeight - slideHeight ; } else { height = mItemHeightCollapsed ; } } else if ( position = = mFirstExpPos ) { if ( isSliding ) { height = childHeight + slideHeight ; } else { height = childHeight + maxNonSrcBlankHeight ; } } else if ( position = = mSecondExpPos ) { height = childHeight + maxNonSrcBlankHeight - slideHeight ; } else { height = childHeight ; } return height ; }
public void addCoverRequest ( CoverInfo coverInfo ) { if ( DEBUG ) { d ( CoverManager . class . getSimpleName ( ) , " Looking for cover with artist= " + coverInfo . getArtist ( ) + " , album= " + coverInfo . getAlbum ( ) ) ; } this . requests . add ( coverInfo ) ; }
public boolean requestFocus ( int direction , Rect previouslyFocusedRect ) { if ( mClearingFocus ) return false ; if ( ! isFocusable ( ) ) return false ; if ( ! isIconified ( ) ) { boolean result = mQueryTextView . requestFocus ( direction , previouslyFocusedRect ) ;
public abstract T get ( int index ) ; public abstract int size ( ) ; public static < T > List < T > createList ( ListType type ) { switch ( type ) { case ArrayList : return new ArrayList < T > ( ) ; default : return new LinkedList < T > ( ) ; } } public static class LinkedList < T > extends List < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; @Override public void add ( T value ) { add ( new Node < T > ( value ) ) ; } private void add ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > prev = tail ; prev . nextNode = node ; node . previousNode = prev ; tail = node ; } size + + ; } @Override public boolean remove ( T value ) { Node < T > node = head ; while ( node ! = null & & ( ! node . value . equals ( value ) ) ) { node = node . nextNode ; } if ( node = = null ) return false ; if ( node . equals ( tail ) ) tail = node . previousNode ; Node < T > prev = node . previousNode ; Node < T > next = node . nextNode ; if ( prev ! = null & & next ! = null ) { prev . nextNode = next ; next . previousNode = prev ; } else if ( prev ! = null & & next = = null ) { prev . nextNode = null ; } else if ( prev = = null & & next ! = null ) { next . previousNode = null ; head = next ; } else { head = null ; } size - - ; return true ; } @Override public boolean contains ( T value ) { Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . nextNode ; } return false ; } @Override public T get ( int index ) { T result = null ; Node < T > node = head ; int i = 0 ; while ( node ! = null & & i < index ) { node = node . nextNode ; i + + ; } if ( node ! = null ) result = node . value ; return result ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . nextNode ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > previousNode = null ; private Node < T > nextNode = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( previousNode ! = null ) ? previousNode . value : " NULL " ) + "  next= " + ( ( nextNode ! = null ) ? nextNode . value : " NULL " ) ; } } } public static class ArrayList < T > extends List < T > { private static final int GROW_IN_CHUNK_SIZE = 50 ; private static final int SHRINK_IN_CHUNK_SIZE = 50 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int size = 0 ; @Override public void add ( T value ) { if ( size > = array . length ) { T [ ] temp = Arrays . copyOf ( array , size + GROW_IN_CHUNK_SIZE ) ; temp [ size + + ] = value ; array = temp ; } else { array [ size + + ] = value ; } } @Override public boolean remove ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) { for ( int j = i + 1 ; j < size ; j + + ) { array [ j - 1 ] = array [ j ] ; } array [ - - size ] = null ; if ( array . length - size > = SHRINK_IN_CHUNK_SIZE ) { T [ ] temp = Arrays . copyOf ( array , size ) ; array = temp ; } return true ; } } return false ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public T get ( int index ) { if ( index > = size ) return null ; return array [ index ] ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i + + ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } }
public String makeName ( ) { return makeImageName ( Operator . IMAGE_INT , components , relationIndex ) ; }
public JPanel buildButtonPanel ( ) { loadButton = new JButton ( " Load " ) ; saveButton = new JButton ( " Save " ) ; nameField = new JTextField ( " test.lvl " , 10 ) ; loadButton . addActionListener ( this ) ; saveButton . addActionListener ( this ) ; JPanel panel = new JPanel ( ) ; panel . add ( nameField ) ; panel . add ( loadButton ) ; panel . add ( saveButton ) ; return panel ; }
public static double errorFunction ( double x ) { double y , z ; final double T [ ] = { 9.60497373987051638749E0 , 9.00260197203842689217E1 , 2.23200534594684319226E3 , 7.00332514112805075473E3 , 5.55923013010394962768E4 } ; final double U [ ] = { 3.35617141647503099647E1 , 5.21357949780152679795E2 , 4.59432382970980127987E3 , 2.26290000613890934246E4 , 4.92673942608635921086E4 } ; if ( Math . abs ( x ) > 1.0 ) return ( 1.0 - errorFunctionComplemented ( x ) ) ; z = x * x ; y = x * polevl ( z , T , 4 ) / p1evl ( z , U , 5 ) ; return y ; }
public void ambiguousDependencies ( ) throws Exception { thrown . expect ( RuntimeException . class ) ; thrown . expectMessage ( " multiple dependencies have been listed " ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; List < String > inListLiteral = Arrays . asList ( new String [ ] { " 1 " , " 2 " , " 3 " } ) ; dependencies . put ( " df1 " , null ) ; dependencies . put ( " df2 " , null ) ; Config config = ConfigFactory . empty ( ) . withValue ( InListDeriver . INLIST_VALUES_CONFIG , ConfigValueFactory . fromIterable ( inListLiteral ) ) ; Deriver deriver = new InListDeriver ( ) ; deriver . configure ( config ) ; deriver . derive ( dependencies ) ; }
public boolean add ( List < String > path , Object value ) { boolean result = super . add ( path , value ) ; autoSave ( ) ; return result ; }
@Override public void run ( ) { s . cells . click ( " NOT " ) ; } } ) ;
public synchronized List < String [ ] > sendCommandQueueSeparated ( ) throws MPDServerException { return separatedQueueResults ( sendCommandQueue ( true ) ) ; }
public void readFrom ( File file ) throws IOException { try ( Reader fileReader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , StandardCharsets . UTF_8 ) ) ) { this . asMap ( ) . clear ( ) ;
void processCloseNotificationRequest ( ) { relaxResources ( ) ; if ( mRemoteControlClient ! = null ) { mRemoteControlClient . setPlaybackState ( RemoteControlClient . PLAYSTATE_STOPPED ) ; } stopSelf ( ) ; }
public Rope subSequence ( final int start , final int end ) { if ( start = = 0 & & end = = this . length ( ) ) { return this ; } return this . rope . subSequence ( this . length ( ) - end , this . length ( ) - start ) . reverse ( ) ; }
public boolean injectNextEvent ( ) { if ( entranceProcessor . hasNext ( ) ) { ContentEvent nextEvent = this . entranceProcessor . nextEvent ( ) ;
public boolean isWifi ( ) { ConnectivityManager conMan = ( ConnectivityManager ) app . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; State wifi = conMan . getNetworkInfo ( 1 ) . getState ( ) ; if ( wifi = = NetworkInfo . State . CONNECTED | | wifi = = NetworkInfo . State . CONNECTING ) { return true ;
protected boolean insert ( AABB b ) { if ( ! aabb . intersectsBox ( b ) ) return false ; if ( aabbs . contains ( b ) ) return true ; if ( isLeaf ( ) ) subdivide ( b ) ; boolean inserted = insertIntoChildren ( b ) ; if ( ! inserted ) {
@Override public void run ( ) { s . cells . click ( " onswitch " , " " ) ; } } ) ;
public static < T extends Comparable < T > > T [ ] sort ( T [ ] unsorted ) { createHeap ( unsorted ) ; sortHeap ( unsorted ) ; return unsorted ; }
private void jButton7ActionPerformed ( java . awt . event . ActionEvent evt ) { jButton7 . setText ( " X " ) ; }
public FileConfigBuilder < C > charset ( Charset charset ) { this . charset = charset ; return this ; }
public Stream < E > onClose ( Runnable closeHandler ) { return new UnwrappedStream < E > ( wrapped . onClose ( closeHandler ) ) ; }
long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public void reparse ( @Nonnull final AS2Message aMsg , final IAS2HttpConnection aConn ) throws OpenAS2Exception { final IMessageMDN aMDN = new AS2MessageMDN ( aMsg ) ; aMDN . headers ( ) . addAllHeaders ( aConn . getHeaderFields ( ) ) ; NonBlockingByteArrayOutputStream aMDNStream = null ; try { final InputStream aIS = aConn . getInputStream ( ) ; aMDNStream = new NonBlockingByteArrayOutputStream ( ) ; final long nContentLength = StringParser . parseLong ( aMDN . getHeader ( CHttpHeader . CONTENT_LENGTH ) , - 1 ) ; if ( nContentLength > = 0 ) StreamHelper . copyInputStreamToOutputStreamWithLimit ( aIS , aMDNStream , nContentLength ) ; else StreamHelper . copyInputStreamToOutputStream ( aIS , aMDNStream ) ; } catch ( final IOException ex ) { LOGGER . error ( " Error reparsing " , ex ) ; } finally { StreamHelper . close ( aMDNStream ) ; } final IHTTPIncomingDumper aIncomingDumper = HTTPHelper . getHTTPIncomingDumper ( ) ; if ( aIncomingDumper ! = null ) aIncomingDumper . dumpIncomingRequest ( aMDN . headers ( ) . getAllHeaderLines ( ) , aMDNStream ! = null ? aMDNStream . toByteArray ( ) : ArrayHelper . EMPTY_BYTE_ARRAY , aMDN ) ; MimeBodyPart aPart = null ; if ( aMDNStream ! = null ) try { aPart = new MimeBodyPart ( AS2HttpHelper . getAsInternetHeaders ( aMDN . headers ( ) ) , aMDNStream . toByteArray ( ) ) ; } catch ( final MessagingException ex ) { LOGGER . error ( " Error creating MimeBodyPart " , ex ) ; } aMsg . getMDN ( ) . setData ( aPart ) ; aMDN . partnership ( ) . setSenderAS2ID ( aMDN . getHeader ( CHttpHeader . AS2_FROM ) ) ; aMDN . partnership ( ) . setReceiverAS2ID ( aMDN . getHeader ( CHttpHeader . AS2_TO ) ) ; }
private void initializeNotification ( final MPDStatus mpdStatus ) { Log . d ( TAG , " initializeNotification() " ) ; if ( mNotificationHandler = = null ) { mNotificationHandler = new NotificationHandler ( this ) ; mAlbumCoverHandler = new AlbumCoverHandler ( this ) ; mAudioManager = ( AudioManager ) getSystemService ( AUDIO_SERVICE ) ; mRemoteControlClientHandler = new RemoteControlClientHandler ( this ) ; } else { mNotificationHandler . start ( ) ; mRemoteControlClientHandler . start ( ) ; } mAlbumCoverHandler . addCallback ( mNotificationHandler ) ; mAlbumCoverHandler . addCallback ( mRemoteControlClientHandler ) ; mMessageHandler . sendMessageToClients ( NotificationHandler . IS_ACTIVE , true ) ; }
protected void onCreate ( Bundle arg0 ) { if ( ! MPDApplication . isHoneycombOrBetter ( ) ) { setTheme ( android . R . style . Theme_Black_NoTitleBar ) ; } super . onCreate ( arg0 ) ; setContentView ( R . layout . artists_activity ) ; }
public void testAsyncIncrementNonExistent ( ) throws Exception { String k = " async-incr-non-existent " ; OperationFuture < Long > f = client . asyncIncr ( k , 1 ) ; assertEquals ( StatusCode . ERR_NOT_FOUND , f . getStatus ( ) . getStatusCode ( ) ) ; assertEquals ( - 1 , ( long ) f . get ( ) ) ; }
public void addOperation ( final String key , final Operation o ) { MemcachedNode placeIn = null ; MemcachedNode primary = locator . getPrimary ( key ) ; if ( primary . isActive ( ) | | failureMode = = FailureMode . Retry ) { placeIn = primary ; } else if ( failureMode = = FailureMode . Cancel ) { o . cancel ( ) ; } else { for ( Iterator < MemcachedNode > i = locator . getSequence ( key ) ; placeIn = = null & & i . hasNext ( ) ; ) { MemcachedNode n = i . next ( ) ; if ( n . isActive ( ) ) { placeIn = n ; } } if ( placeIn = = null ) { placeIn = primary ; this . getLogger ( ) . warn ( " Could not redistribute  " + " to another node, retrying primary node for %s. " , key ) ; } } assert o . isCancelled ( ) | | placeIn ! = null : " No node found for key  " + key ; if ( placeIn ! = null ) {
public static void eliminateVariableOfConditionAbductive ( final int figure , final Sentence sentence , final Sentence belief , final NAL nal ) { Statement T1 = ( Statement ) sentence . content ; Statement T2 = ( Statement ) belief . content ; Term S1 = T2 . getSubject ( ) ; Term S2 = T1 . getSubject ( ) ; Term P1 = T2 . getPredicate ( ) ; Term P2 = T1 . getPredicate ( ) ; HashMap < Term , Term > res1 = new HashMap < > ( ) ; HashMap < Term , Term > res2 = new HashMap < > ( ) ; HashMap < Term , Term > res3 = new HashMap < > ( ) ; HashMap < Term , Term > res4 = new HashMap < > ( ) ; if ( figure = = 21 ) { res1 . clear ( ) ; res2 . clear ( ) ; Variables . findSubstitute ( Symbols . VAR_INDEPENDENT , P1 , S2 , res1 , res2 ) ; T1 = ( Statement ) T1 . applySubstitute ( res2 ) ; T2 = ( Statement ) T2 . applySubstitute ( res1 ) ; S1 = T2 . getSubject ( ) ; S2 = T1 . getSubject ( ) ; P1 = T2 . getPredicate ( ) ; P2 = T1 . getPredicate ( ) ; if ( S1 instanceof Conjunction ) { for ( final Term s1 : ( ( CompoundTerm ) S1 ) . term ) { res3 . clear ( ) ; res4 . clear ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , P2 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) S1 ) . term ) { if ( ! ( s2 instanceof CompoundTerm ) | | s2 . hasVarIndep ( ) ) { continue ; } s2 = ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ! s2 . equals ( s1 ) & & ( sentence . truth ! = null ) & & ( belief . truth ! = null ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , nal ) ; nal . doublePremiseTask ( s2 , truth , budget , false ) ; } } } } } if ( P2 instanceof Conjunction ) { for ( final Term s1 : ( ( CompoundTerm ) P2 ) . term ) { res3 . clear ( ) ; res4 . clear ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , S1 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) P2 ) . term ) { if ( ! ( s2 instanceof CompoundTerm ) | | s2 . hasVarIndep ( ) ) { continue ; } s2 = ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ! s2 . equals ( s1 ) & & ( sentence . truth ! = null ) & & ( belief . truth ! = null ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , nal ) ; nal . doublePremiseTask ( s2 , truth , budget , false ) ; } } } } } } if ( figure = = 12 ) { res1 . clear ( ) ; res2 . clear ( ) ; Variables . findSubstitute ( Symbols . VAR_INDEPENDENT , S1 , P2 , res1 , res2 ) ; T1 = ( Statement ) T1 . applySubstitute ( res2 ) ; T2 = ( Statement ) T2 . applySubstitute ( res1 ) ; S1 = T2 . getSubject ( ) ; S2 = T1 . getSubject ( ) ; P1 = T2 . getPredicate ( ) ; P2 = T1 . getPredicate ( ) ; if ( S2 instanceof Conjunction ) { for ( final Term s1 : ( ( CompoundTerm ) S2 ) . term ) { res3 . clear ( ) ; res4 . clear ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , P1 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) S2 ) . term ) { if ( ! ( s2 instanceof CompoundTerm ) | | s2 . hasVarIndep ( ) ) { continue ; } s2 = ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ! s2 . equals ( s1 ) & & ( sentence . truth ! = null ) & & ( belief . truth ! = null ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , nal ) ; nal . doublePremiseTask ( s2 , truth , budget , false ) ; } } } } } if ( P1 instanceof Conjunction ) { for ( final Term s1 : ( ( CompoundTerm ) P1 ) . term ) { res3 . clear ( ) ; res4 . clear ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , S2 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) P1 ) . term ) { if ( ! ( s2 instanceof CompoundTerm ) | | s2 . hasVarIndep ( ) ) { continue ; } s2 = ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ! s2 . equals ( s1 ) & & ( sentence . truth ! = null ) & & ( belief . truth ! = null ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , nal ) ; nal . doublePremiseTask ( s2 , truth , budget , false ) ; } } } } } } if ( figure = = 11 ) { res1 . clear ( ) ; res2 . clear ( ) ; Variables . findSubstitute ( Symbols . VAR_INDEPENDENT , S1 , S2 , res1 , res2 ) ; T1 = ( Statement ) T1 . applySubstitute ( res2 ) ; T2 = ( Statement ) T2 . applySubstitute ( res1 ) ; S1 = T2 . getSubject ( ) ; S2 = T1 . getSubject ( ) ; P1 = T2 . getPredicate ( ) ; P2 = T1 . getPredicate ( ) ; if ( P1 instanceof Conjunction ) { for ( final Term s1 : ( ( CompoundTerm ) P1 ) . term ) { res3 . clear ( ) ; res4 . clear ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , P2 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) P1 ) . term ) { if ( ! ( s2 instanceof CompoundTerm ) | | s2 . hasVarIndep ( ) ) { continue ; } s2 = ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( s2 ! = null ) { if ( ( ! s2 . equals ( s1 ) ) & & ( sentence . truth ! = null ) & & ( belief . truth ! = null ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , nal ) ; nal . doublePremiseTask ( s2 , truth , budget , false ) ; } } } } } } if ( P2 instanceof Conjunction ) { for ( final Term s1 : ( ( CompoundTerm ) P2 ) . term ) { res3 . clear ( ) ; res4 . clear ( ) ; if ( Variables . findSubstitute ( Symbols . VAR_DEPENDENT , s1 , P1 , res3 , res4 ) ) { for ( Term s2 : ( ( CompoundTerm ) P2 ) . term ) { if ( ! ( s2 instanceof CompoundTerm ) | | s2 . hasVarIndep ( ) ) { continue ; } s2 = ( ( CompoundTerm ) s2 ) . applySubstitute ( res3 ) ; if ( ( s2 ! = null ) & & ! s2 . equals ( s1 ) & & ( sentence . truth ! = null ) & & ( belief . truth ! = null ) ) { TruthValue truth = abduction ( sentence . truth , belief . truth ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , s2 , nal ) ; nal . doublePremiseTask ( s2 , truth , budget , false ) ; } } } } } } if ( figure = = 22 ) { res1 . clear ( ) ;
public int hashCode ( ) { final Object [ ] objects = { mAlbum , mArtist , mAlbumArtist , mGenre , mName , mTitle } ; int result = 31 * mFullPath . hashCode ( ) ; result = 31 * result + mDisc ; result = 31 * result + ( int ) ( mDate ^ ( mDate > > > 32 ) ) ; result = 31 * result + mSongPos ; result = 31 * result + ( int ) ( mTime ^ ( mTime > > > 32 ) ) ; result = 31 * result + mTotalTracks ; result = 31 * result + mTrack ; return result + Arrays . hashCode ( objects ) ; }
public Stream < E > peek ( Consumer < ? super E > action ) { return new UnwrappedStream < E > ( wrapped . peek ( new UnwrappedAction < E > ( action ) ) ) ; }
public void automataclicked ( float x , float y ) { if ( x < 0 | | y < 0 ) { return ; } float realx = x / rendersize ; float realy = y / rendersize ; if ( realx > = cells . w | | realy > = cells . h ) { return ; } cells . clicked ( ( int ) realx , ( int ) realy , this ) ; }
public T remove ( int index ) { synchronized ( mLOCK ) { this . cleanPhantomReferences ( ) ;
public static boolean findSubstitute ( final char type , final Term term1 , final Term term2 , final HashMap < Term , Term > map1 , final HashMap < Term , Term > map2 ) { return findSubstitute ( type , term1 , term2 , map1 , map2 , 0 ) ; }
private void handleReadsAndWrites ( final SelectionKey sk , final MemcachedNode node ) throws IOException { if ( sk . isValid ( ) & & sk . isReadable ( ) ) { handleReads ( node ) ; } if ( sk . isValid ( ) & & sk . isWritable ( ) ) { handleWrites ( node ) ;
public void testEarlierExistingWithSameValuesPlansNothing ( ) { Planner p = new UpsertPlanner ( new Properties ( ) ) ; List < GenericRecord > existing = Lists . newArrayList ( ) ; GenericRecord exist = createTestRecord ( ) ; exist . put ( " key " , " a " ) ; exist . put ( " timestamp " , 50L ) ; exist . put ( " value " , " world " ) ; existing . add ( exist ) ; List < GenericRecord > arriving = Lists . newArrayList ( ) ; GenericRecord arrived = createTestRecord ( ) ; arrived . put ( " key " , " a " ) ; arrived . put ( " timestamp " , 100L ) ; arrived . put ( " value " , " world " ) ; arriving . add ( arrived ) ; RecordModel rm = new RecordModel ( ) ; rm . setKeyFieldNames ( Lists . newArrayList ( " key " ) ) ; rm . setTimestampFieldName ( " timestamp " ) ; rm . setValueFieldNames ( Lists . newArrayList ( " value " ) ) ; rm . setLastUpdatedFieldName ( " lastupdated " ) ; List < PlannedRecord > planned = p . planMutations ( arriving , existing , rm ) ; assertEquals ( planned . size ( ) , 0 ) ; }
public boolean onInfo ( final MediaPlayer mp , final int what , final int extra ) { boolean result = true ; switch ( what ) { case MediaPlayer . MEDIA_INFO_BUFFERING_START : mServiceHandler . sendEmptyMessage ( BUFFERING_BEGIN ) ; break ; case MediaPlayer . MEDIA_INFO_BUFFERING_END : mServiceHandler . sendEmptyMessage ( BUFFERING_END ) ; break ; default : result = false ; } return result ; }
InputStream getHttpInputStream ( ) throws IOException ; boolean isChunkedEncodingAlreadyProcessed ( ) ; @Nullable String getHttpRequestMethod ( ) ; @Nullable String getHttpRequestUrl ( ) ; @Nonnull String getHttpRequestVersion ( ) ; @Nonnull HttpHeaderMap getHttpHeaderMap ( ) ; }
public boolean hasNext ( ) { return ( index + 1 < = stack . size ) ; }
protected void addProcessingItem ( IProcessingItem procItem ) { addProcessingItem ( procItem , 1 ) ; }
private static void asymmetricSymmetric ( Sentence asym , Sentence sym , int figure , Memory memory ) { Statement asymSt = ( Statement ) asym . cloneContent ( ) ; Statement symSt = ( Statement ) sym . cloneContent ( ) ; Term t1 , t2 ; Term [ ] u = new Term [ ] { asymSt , symSt } ; switch ( figure ) { case 11 :
public Matrix < T > identity ( ) throws Exception { if ( this . rows ! = this . cols ) throw new Exception ( " Matrix should be a square " ) ; final T element = this . get ( 0 , 0 ) ; final T zero ; final T one ; if ( element instanceof BigDecimal ) { zero = ( T ) BigDecimal . ZERO ; one = ( T ) BigDecimal . ONE ; } else if ( element instanceof BigInteger ) { zero = ( T ) BigInteger . ZERO ; one = ( T ) BigInteger . ONE ; } else if ( element instanceof Long ) { zero = ( T ) new Long ( 0 ) ; one = ( T ) new Long ( 1 ) ; } else if ( element instanceof Double ) { zero = ( T ) new Double ( 0 ) ; one = ( T ) new Double ( 1 ) ; } else if ( element instanceof Float ) { zero = ( T ) new Float ( 0 ) ; one = ( T ) new Float ( 1 ) ; } else { zero = ( T ) new Integer ( 0 ) ; one = ( T ) new Integer ( 1 ) ; } final T array [ ] [ ] = ( T [ ] [ ] ) new Number [ this . rows ] [ this . cols ] ; for ( int i = 0 ; i < this . rows ; + + i ) { for ( int j = 0 ; j < this . cols ; + + j ) { array [ i ] [ j ] = zero ; } } final Matrix < T > identityMatrix = new Matrix < T > ( this . rows , this . cols , array ) ; for ( int i = 0 ; i < this . rows ; + + i ) { identityMatrix . set ( i , i , one ) ; } return identityMatrix ; }
final synchronized private int [ ] connect ( ) throws MPDServerException { if ( sock ! = null ) { try { disconnect ( ) ; } catch ( MPDServerException e ) { } } try { sock = new Socket ( ) ;
public void updateData ( ) { for ( Map . Entry < String , TimeSeriesChart > e : charts . entrySet ( ) ) { String f = e . getKey ( ) ;
public static Term make ( Term t1 , Term t2 ) { if ( t1 . equals ( t2 ) ) { return null ; } return make ( new Term [ ] { t1 , t2 } ) ; }
GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( String key , long casId , int flags , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }
List < DataRecorder > getDataRecorders ( ) ; long getHits ( ) ; long getFirstHitStamp ( ) ; long getLastHitStamp ( ) ; long getCommits ( ) ; double getFirst ( ) ; double getLast ( ) ; double getMin ( ) ; double getMax ( ) ; double getSum ( ) ; Object getField ( String name ) ; DataSet collectData ( ) ; DataSet drainData ( ) ; void restore ( DataSet dataSet ) ; void track ( Tracker tracker , long now ) ; void update ( Tracker tracker , long now ) ; void clear ( ) ; void setEventManager ( EventManager e ) ; }
protected static boolean is_id_start ( char c ) { return ( c > = 'a' & & c < = 'z' ) | | ( c > = 'A' & & c < = 'Z' ) | | ( c = = '_' ) ;
public String toString ( ) { return new ToStringGenerator ( this ) . append ( " data " , m_aData ) . append ( " MDN " , m_aMDN )
void copyInputQueue ( ) ; Collection < Operation > destroyInputQueue ( ) ; void setupResend ( ) ; void fillWriteBuffer ( boolean optimizeGets ) ; void transitionWriteItem ( ) ; Operation getCurrentReadOp ( ) ; Operation removeCurrentReadOp ( ) ; Operation getCurrentWriteOp ( ) ; Operation removeCurrentWriteOp ( ) ; boolean hasReadOp ( ) ; boolean hasWriteOp ( ) ; void addOp ( Operation op ) ; int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; }
private String reverse ( String text ) { return new StringBuilder ( text ) . reverse ( ) . toString ( ) ; }
public boolean isGreater ( Term t ) { t = t . getTerm ( ) ; if ( t instanceof Number ) { return value > ( ( Number ) t ) . doubleValue ( ) ;
protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { Term term = args [ 0 ] ; Concept concept = memory . conceptualize ( Consider . budgetMentalConcept ( operation ) , term ) ; concept . discountConfidence ( false ) ; return null ; }
public void testWithParameter ( ) throws Exception { Set < Step > steps = Sets . newHashSet ( ) ; Map < String , Object > loopStepConfigMap = Maps . newHashMap ( ) ; loopStepConfigMap . put ( LoopStep . MODE_PROPERTY , LoopStep . MODE_PARALLEL ) ; loopStepConfigMap . put ( LoopStep . SOURCE_PROPERTY , LoopStep . SOURCE_RANGE ) ; loopStepConfigMap . put ( LoopStep . RANGE_START_PROPERTY , 5 ) ; loopStepConfigMap . put ( LoopStep . RANGE_END_PROPERTY , 7 ) ; loopStepConfigMap . put ( LoopStep . PARAMETER_PROPERTY , " loop_value " ) ; Config loopStepConfig = ConfigFactory . parseMap ( loopStepConfigMap ) ; RefactorStep loopStep = new LoopStep ( " loop_step " , loopStepConfig ) ; steps . add ( loopStep ) ; Map < String , Object > step1ConfigMap = Maps . newHashMap ( ) ; step1ConfigMap . put ( " dependencies " , Lists . newArrayList ( " loop_step " ) ) ; step1ConfigMap . put ( " deriver. " + DeriverFactory . TYPE_CONFIG_NAME , SQLDeriver . class . getName ( ) ) ; step1ConfigMap . put ( " deriver.query.literal " , " SELECT ${loop_value} " ) ; Config step1Config = ConfigFactory . parseMap ( step1ConfigMap ) ; Step step1 = new BatchStep ( " step1 " , step1Config ) ; steps . add ( step1 ) ; Set < Step > unrolled = loopStep . refactor ( steps ) ; assertEquals ( unrolled . size ( ) , 4 ) ; BatchStep step1_5 = ( BatchStep ) StepUtils . getStepForName ( " step1_5 " , unrolled ) . get ( ) ; BatchStep step1_6 = ( BatchStep ) StepUtils . getStepForName ( " step1_6 " , unrolled ) . get ( ) ; BatchStep step1_7 = ( BatchStep ) StepUtils . getStepForName ( " step1_7 " , unrolled ) . get ( ) ; assertNotNull ( StepUtils . getStepForName ( " loop_step " , unrolled ) . get ( ) ) ; assertNotNull ( step1_5 ) ; assertNotNull ( step1_6 ) ; assertNotNull ( step1_7 ) ; step1_5 . submit ( Sets . < Step > newHashSet ( ) ) ; step1_6 . submit ( Sets . < Step > newHashSet ( ) ) ; step1_7 . submit ( Sets . < Step > newHashSet ( ) ) ; assertEquals ( step1_5 . getData ( ) . collectAsList ( ) . get ( 0 ) , RowFactory . create ( 5 ) ) ; assertEquals ( step1_6 . getData ( ) . collectAsList ( ) . get ( 0 ) , RowFactory . create ( 6 ) ) ; assertEquals ( step1_7 . getData ( ) . collectAsList ( ) . get ( 0 ) , RowFactory . create ( 7 ) ) ; }
GetOperation get ( String key , GetOperation . Callback callback ) ; GetOperation get ( Collection < String > value , GetOperation . Callback cb ) ; MutatatorOperation mutate ( MutatatorOperation . Mutator m , String key , int by , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; }
private boolean inserects ( Line line ) { double ulResult = pointRelativeToLine ( ul , line ) ; double urResult = pointRelativeToLine ( ur , line ) ; double llResult = pointRelativeToLine ( ll , line ) ; double lrResult = pointRelativeToLine ( lr , line ) ; if ( ulResult > 0 & & urResult > 0 & & llResult > 0 & & lrResult > 0 ) return false ; if ( ulResult < 0 & & urResult < 0 & & llResult < 0 & & lrResult < 0 ) return false ; if ( line . p1 . x > ur . x & & line . p2 . x > lr . x ) return false ; if ( line . p1 . x < ul . x & & line . p2 . x < ll . x ) return false ; if ( line . p1 . y > ll . y & & line . p2 . y > lr . y ) return false ; if ( line . p1 . y < ul . y & & line . p2 . y < ur . y ) return false ; return true ; }
public boolean advanceState ( DNSTask task ) ; public boolean revertState ( ) ; public boolean cancelState ( ) ; public boolean closeState ( ) ; public boolean recoverState ( ) ; public boolean isProbing ( ) ; public boolean isAnnouncing ( ) ; public boolean isAnnounced ( ) ; public boolean isCanceling ( ) ; public boolean isCanceled ( ) ; public boolean isClosing ( ) ; public boolean isClosed ( ) ; public boolean waitForAnnounced ( long timeout ) ; public boolean waitForCanceled ( long timeout ) ; }
public Iterable < Tuple2 < Row , Tuple2 < Iterable < Row > , Iterable < Row > > > > call ( Iterator < Tuple2 < Row , Iterable < Row > > > arrivingForKeysIterator ) throws Exception { if ( ! arrivingForKeysIterator . hasNext ( ) ) { return Lists . newArrayList ( ) ; } if ( output = = null ) { output = ( RandomOutput ) OutputFactory . create ( outputConfig ) ; } List < Tuple2 < Row , Iterable < Row > > > arrivingForKeys = Lists . newArrayList ( arrivingForKeysIterator ) ; Set < Row > arrivingKeys = extractKeys ( arrivingForKeys ) ; Iterable < Row > existingWithoutKeys = output . getExistingForFilters ( arrivingKeys ) ; Map < Row , Iterable < Row > > existingForKeys = mapExistingToKeys ( existingWithoutKeys ) ; List < Tuple2 < Row , Tuple2 < Iterable < Row > , Iterable < Row > > > > arrivingAndExistingForKeys = attachExistingToArrivingForKeys ( existingForKeys , arrivingForKeys ) ; return arrivingAndExistingForKeys ; }
public void testGetStatsSizes ( ) throws Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } client . set ( " sizeinitializer " , 0 , " hi " ) ; Map < SocketAddress , Map < String , String > > stats = client . getStats ( " sizes " ) ; System . out . println ( " Stats sizes:   " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; String noItemsSmall = oneStat . get ( " 96 " ) ; assertTrue ( Integer . parseInt ( noItemsSmall ) > = 1 ) ; }
INTERSECTION_EXT { @Override public String toString ( ) { return " & " ; } } , INTERSECTION_INT { @Override public String toString ( ) { return " | " ; } } ,
public List < Music > search ( final String type , final String locatorString ) throws MPDServerException { return genericSearch ( MPDCommand . MPD_CMD_SEARCH , type , locatorString ) ; }
public Bucket parseBucket ( String sBucket ) throws ParseException { try { return parseBucketFromJSON ( new JSONObject ( sBucket ) ) ;
public void init ( ) { HelloWorldSourceProcessor sourceProcessor = new HelloWorldSourceProcessor ( instanceLimitOption . getValue ( ) ) ; builder . addEntranceProcessor ( sourceProcessor ) ; Stream stream = builder . createStream ( sourceProcessor ) ; HelloWorldDestinationProcessor destProcessor = new HelloWorldDestinationProcessor ( ) ; builder . addProcessor ( destProcessor , helloWorldParallelismOption . getValue ( ) ) ; builder . connectInputShuffleStream ( stream , destProcessor ) ; helloWorldTopology = builder . build ( ) ; logger . debug ( " Successfully built the topology " ) ; }
public AS2HttpClient getHttpClient ( @Nonnull @Nonempty final String sUrl , @Nonnull final EHttpMethod eRequestMethod , @Nullable final Proxy aProxy ) throws AS2Exception { ValueEnforcer . notEmpty ( sUrl , " URL " ) ; final SSLContext aSSLCtx ; final HostnameVerifier aHV ; if ( isUseSSL ( sUrl ) ) { try { aSSLCtx = createSSLContext ( ) ; } catch ( final GeneralSecurityException ex ) { throw new AS2Exception ( " Error creating SSL Context " , ex ) ; } aHV = createHostnameVerifier ( ) ; } else { aSSLCtx = null ; aHV = null ; } final int nConnectTimeoutMS = getConnectionTimeoutMilliseconds ( ) ; final int nReadTimeoutMS = getReadTimeoutMilliseconds ( ) ; return new AS2HttpClient ( sUrl , nConnectTimeoutMS , nReadTimeoutMS , eRequestMethod , aProxy , aSSLCtx , aHV ) ; }
public SongsFragment init ( final Album al ) { mAlbum = al ; return this ; }
public < R > R bulkUpdate ( Function < ? super Config , R > action ) { R result = CommentedFileConfig . super . bulkUpdate ( action ) ; autoSave ( ) ; return result ; }
public boolean run ( Integer [ ] unsorted , Integer [ ] sorted , String input ) { this . input = input ; List . SinglyLinkedList < Integer > linkedList = new List . SinglyLinkedList < Integer > ( ) ; Collection < Integer > lCollection = linkedList . toCollection ( ) ; if ( ! testJavaCollection ( lCollection , Integer . class , name , unsorted , sorted , input ) ) return false ; return true ; }
Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { TestChamber . executed = true ; System . out . println ( " Executed:  " + this ) ; for ( Term t : args ) { System . out . println ( "  ---  " + t ) ; chamb . operateObj ( t . toString ( ) , " pick " ) ; } return null ; }
private void writeArray ( long [ ] array ) throws IOException { write ( '[' ) ; for ( long element : array ) { write ( String . valueOf ( element ) ) ; write ( " ,  " ) ; } write ( ']' ) ; }
public void connectionStateChanged ( MPDConnectionStateChangedEvent event ) { } @Override public void playlistChanged ( MPDPlaylistChangedEvent event ) { } @Override public void randomChanged ( MPDRandomChangedEvent event ) { } @Override public void repeatChanged ( MPDRepeatChangedEvent event ) { } @Override public void stateChanged ( MPDStateChangedEvent event ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = oldStatus ) return ; if ( state = = MPDStatus . MPD_STATE_PLAYING ) { isPaused = false ; resumeStreaming ( ) ; isPlaying = true ; } else { oldStatus = state ; isPlaying = false ; stopStreaming ( ) ; } } } } @Override public void updateStateChanged ( MPDUpdateStateChangedEvent event ) { } @Override public void volumeChanged ( MPDVolumeChangedEvent event ) { } @Override public void onPrepared ( MediaPlayer mp ) { buffering = false ; isPlaying = true ; oldStatus = " " ; showNotification ( ) ; mediaPlayer . start ( ) ; } @Override public void onCompletion ( MediaPlayer mp ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = MPDStatus . MPD_STATE_PLAYING ) { resumeStreaming ( ) ; } else { oldStatus = state ; die ( ) ; } } } } @Override public void onBufferingUpdate ( MediaPlayer mp , int percent ) { } @Override public boolean onError ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public boolean onInfo ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public void connectionFailed ( String message ) { Toast . makeText ( this , " Connection Failed ! " , Toast . LENGTH_SHORT ) . show ( ) ; } @Override public void connectionSucceeded ( String message ) { } }
View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; HttpFuture < ViewResponseWithDocs > asyncQuery ( View view , Query query ) ; HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; }
public void testPrepend ( ) throws Exception { final String key = " prepend.key " ; assertTrue ( client . set ( key , 5 , " test " ) . get ( ) ) ; OperationFuture < Boolean > op = client . prepend ( 0 , key , " es " ) ; assertTrue ( op . get ( ) ) ; assert op . getStatus ( ) . isSuccess ( ) ; assertEquals ( " estest " , client . get ( key ) ) ; }
private void addPrefix ( Suffix active , int last_char_index ) { int parent_node ; int last_parent_node = - 1 ; while ( true ) { Edge edge = null ; parent_node = active . originNode ; if ( active . isExplicit ( ) ) { edge = Edge . find ( active . originNode , SuffixTree . characters [ last_char_index ] ) ; if ( edge ! = null ) break ; } else { edge = Edge . find ( active . originNode , SuffixTree . characters [ active . firstCharIndex ] ) ; int span = active . lastCharIndex - active . firstCharIndex ; if ( SuffixTree . characters [ edge . firstCharIndex + span + 1 ] = = SuffixTree . characters [ last_char_index ] ) break ; parent_node = edge . split ( active ) ; } edge = new Edge ( last_char_index , SuffixTree . characters . length - 1 , parent_node ) ; edge . insert ( ) ; System . out . printf ( " Created edge to new leaf:  " + edge + " \ n " ) ; AddSuffixLink ( last_parent_node , parent_node ) ; last_parent_node = parent_node ; if ( active . originNode = = 0 ) { System . out . printf ( " Can't follow suffix link, I'm at the root \ n " ) ; active . firstCharIndex + + ; } else { System . out . printf ( " Following suffix link from node  " + active . originNode + "  to node  " + nodes [ active . originNode ] . suffixNode + " . \ n " ) ; active . originNode = nodes [ active . originNode ] . suffixNode ; System . out . printf ( " New prefix :  " + active + " \ n " ) ; } active . canonize ( ) ; } AddSuffixLink ( last_parent_node , parent_node ) ; last_parent_node = parent_node ; active . lastCharIndex + + ; active . canonize ( ) ; } ;
OperationCallback getCallback ( ) ; void cancel ( ) ; OperationState getState ( ) ; ByteBuffer getBuffer ( ) ; void writeComplete ( ) ; OperationReadType getReadType ( ) ; void initialize ( ) ; void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; void handleLine ( String line ) ; }
public Task planTask ( Concept c , Task goal , Term goalTerm , char punctuation ) { Cause currentEdge = path [ path . length - 1 ] ; Stamp stamp = Stamp . make ( goal . sentence . stamp , currentEdge . getStamp ( ) , memory . time ( ) ) ; for ( Term T : sequence ) { stamp . derivationChain . add ( T ) ; } Term subj = sequence . size ( ) > 1 ? Conjunction . make ( sequence . toArray ( new Term [ sequence . size ( ) ] ) , TemporalRules . ORDER_FORWARD ) : sequence . get ( 0 ) ; Term imp = Implication . make ( subj , goalTerm , TemporalRules . ORDER_FORWARD ) ; if ( imp = = null ) { throw new RuntimeException ( " Invalid implication:  " + subj + "  = \\ >  " + goalTerm ) ; } this . goal = goal ; this . solution = new Task ( new Sentence ( imp , punctuation , truth , stamp ) , budget , goal ) { @Override public void end ( boolean success ) { super . end ( success ) ; } @Override public void expect ( boolean eventHappened ) { if ( eventHappened ) { rememberPlanSuccess ( ParticlePlan . this , goalTerm , this ) ; } if ( ! eventHappened ) { forgetPlanSuccess ( ParticlePlan . this , goalTerm , this ) ; } } } ; return solution ; }
boolean isCancelled ( ) ; boolean hasErrored ( ) ; OperationException getException ( ) ; OperationCallback getCallback ( ) ; void cancel ( ) ; OperationState getState ( ) ; ByteBuffer getBuffer ( ) ; void writeComplete ( ) ; void initialize ( ) ; void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; void handleLine ( String line ) ; }
protected synchronized void spy ( final String s ) { if ( spy ) { notifySpy ( new SpyEvent ( this , s ) ) ;
protected boolean insert ( AABB b ) { if ( ! aabb . intersectsBox ( b ) ) return false ; if ( aabbs . contains ( b ) ) return true ; if ( isLeaf ( ) ) subdivide ( b ) ; boolean inserted = false ; if ( isLeaf ( ) ) { aabbs . add ( b ) ; inserted = true ; } else { inserted = insertIntoChildren ( b ) ; } if ( ! inserted ) { aabbs . add ( b ) ; return true ; } return true ; }
public void keyPressed ( char key , int argKeyCode ) { switch ( key ) { case 'c' :
public static int f ( float p ) { if ( p < 0 ) { p = 0 ; } if ( p > 1f ) { p = 1f ; } return ( int ) ( p * ( discretization - 1 ) ) ; }
public ProcessingItem connectInputShuffleStream ( Stream inputStream ) { S4Stream stream = ( S4Stream ) inputStream ; stream . setParalellism ( this . paralellismLevel ) ; stream . addStream ( inputStream . getStreamId ( ) , getKeyFinder ( ) , this , S4Stream . SHUFFLE ) ; return this ; }
public List < Item > getAllResendItems ( ) { return CollectionHelper . newList ( m_aItems ) ; }
public boolean equals ( final Object that ) { if ( that instanceof BudgetValue ) { final BudgetValue t = ( ( BudgetValue ) that ) ; float dPrio = Math . abs ( getPriority ( ) - t . getPriority ( ) ) ; if ( dPrio > = TRUTH_EPSILON ) return false ; float dDura = Math . abs ( getDurability ( ) - t . getDurability ( ) ) ; if ( dDura > = TRUTH_EPSILON ) return false ; float dQual = Math . abs ( getQuality ( ) - t . getQuality ( ) ) ; if ( dQual > = TRUTH_EPSILON ) return false ; return true ; } return false ; }
OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; }
public NAR init ( NAR n ) { Javascript js = new Javascript ( ) ; js . setEnabled ( n , true ) ; for ( Operator o : Operators . get ( n ) ) n . memory . addOperator ( o ) ; n . addPlugin ( new DefaultTextPerception ( ) ) ; n . addPlugin ( new RuntimeNARSettings ( ) ) ; n . addPlugin ( new Emotions ( ) ) ; n . addPlugin ( new Anticipate ( ) ) ; boolean full_interval_experience = false ; if ( ! full_interval_experience ) { n . addPlugin ( new InternalExperience ( ) ) ; } else { n . addPlugin ( new FullInternalExperience ( ) ) ; n . addPlugin ( new Abbreviation ( ) ) ; n . addPlugin ( new Counting ( ) ) ; } return n ; }
private void balanceAfterInsert ( AVLNode < T > node ) { int balanceFactor = node . getBalanceFactor ( ) ; if ( balanceFactor > 1 | | balanceFactor < - 1 ) { AVLNode < T > child = null ;
public void multipleFiles ( ) throws Exception { int nDirs = 10 ; int nFiles = 10 ; FileWatcher watcher = new FileWatcher ( Duration . ZERO , Duration . ZERO , onWatcherException ) ; CountDownLatch latch = new CountDownLatch ( nDirs * nFiles ) ; for ( int i = 0 ; i < nDirs ; i + + ) { Path dir = tmp . resolve ( " sub- " + i ) ; Files . createDirectory ( dir ) ; for ( int j = 0 ; j < nFiles ; j + + ) { Path file = dir . resolve ( " multipleFilesNotifications- " + j ) ; watcher . addWatch ( file , latch : : countDown ) ; } } for ( int i = 0 ; i < nDirs ; i + + ) { for ( int j = 0 ; j < nFiles ; j + + ) { Path dir = tmp . resolve ( " sub- " + i ) ; Path file = dir . resolve ( " multipleFilesNotifications- " + j ) ; Files . createFile ( file ) ; } } assertTrue ( latch . await ( 200 , TimeUnit . MILLISECONDS ) ) ; watcher . stop ( ) ; }
public void addToPlaylist ( final String playlistName , final Album album ) throws IOException , MPDException { if ( mIdleConnection . isCommandAvailable ( MPDCommand . MPD_CMD_SEARCH_ADD_PLAYLIST ) ) { final String [ ] artistPair = getAlbumArtistPair ( album ) ;
private void initStreamTokenizer ( Reader reader ) { BufferedReader br = new BufferedReader ( reader ) ; streamTokenizer = new StreamTokenizer ( br ) ; streamTokenizer . resetSyntax ( ) ; streamTokenizer . whitespaceChars ( 0 , ' ' ) ; streamTokenizer . wordChars ( ' ' + 1 , '\u00FF' ) ; streamTokenizer . whitespaceChars ( ',' , ',' ) ; streamTokenizer . commentChar ( '%' ) ; streamTokenizer . quoteChar ( '"' ) ; streamTokenizer . quoteChar ( '\'' ) ; streamTokenizer . ordinaryChar ( '{' ) ; streamTokenizer . ordinaryChar ( '}' ) ; streamTokenizer . eolIsSignificant ( true ) ; this . instanceInformation = this . getHeader ( ) ; if ( classAttribute < 0 ) { this . instanceInformation . setClassIndex ( this . instanceInformation . numAttributes ( ) - 1 ) ;
private static < T extends Comparable < T > > void sort ( int i , T [ ] unsorted ) { for ( int j = i ; j > 0 ; j - - ) { T jthElement = unsorted [ j ] ;
public boolean run ( Integer [ ] unsorted , Integer [ ] sorted , String input ) { this . input = input ; Queue . LinkedQueue < Integer > arrayQueue = new Queue . LinkedQueue < Integer > ( ) ; Collection < Integer > aCollection = arrayQueue . toCollection ( ) ; if ( ! testJavaCollection ( aCollection , Integer . class , name , unsorted , sorted , input ) ) return false ; return true ; }
protected Node < T > removeValue ( T value ) { RedBlackNode < T > nodeRemoved = ( RedBlackNode < T > ) super . getNode ( value ) ; if ( nodeRemoved = = null ) return null ; if ( nodeRemoved . isLeaf ( ) ) { nodeRemoved . value = null ; if ( nodeRemoved . parent = = null ) { root = null ; } else { nodeRemoved . value = null ; nodeRemoved . color = Color . Black ; nodeRemoved . lesser = null ; nodeRemoved . greater = null ; } } else { RedBlackNode < T > lesser = ( RedBlackNode < T > ) nodeRemoved . lesser ; RedBlackNode < T > greater = ( RedBlackNode < T > ) nodeRemoved . greater ; if ( lesser . value ! = null & & greater . value ! = null ) { RedBlackNode < T > greatestInLesser = ( RedBlackNode < T > ) this . getGreatest ( lesser ) ; if ( greatestInLesser = = null | | greatestInLesser . value = = null ) greatestInLesser = lesser ; replaceValueOnly ( nodeRemoved , greatestInLesser ) ; nodeRemoved = greatestInLesser ; } RedBlackNode < T > child = ( RedBlackNode < T > ) ( ( nodeRemoved . lesser . value ! = null ) ? nodeRemoved . lesser : nodeRemoved . greater ) ; if ( nodeRemoved . color = = Color . Black ) { if ( child . color = = Color . Black ) { nodeRemoved . color = Color . Red ; } boolean result = delete ( nodeRemoved ) ; if ( ! result ) return null ; } replaceWithChild ( nodeRemoved , child ) ; if ( root . equals ( nodeRemoved ) & & nodeRemoved . isLeaf ( ) ) { root = null ; } } size - - ; return nodeRemoved ; }
private Future < Boolean > asyncStore ( StoreType storeType , String key , int exp , Object value ) { return asyncStore ( storeType , key , exp , value , transcoder ) ; }
public void handle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) throws AS2Exception { String sResendAction = aOptions = = null ? null : ( String ) aOptions . get ( IProcessorResenderModule . OPTION_RESEND_ACTION ) ; if ( sResendAction = = null ) { LOGGER . warn ( " The resending action is missing - default to message sending! " ) ; sResendAction = IProcessorSenderModule . DO_SEND ; } final String sRetries = aOptions = = null ? null : ( String ) aOptions . get ( IProcessorResenderModule . OPTION_RETRIES ) ; int nRetries ; if ( sRetries ! = null ) nRetries = Integer . parseInt ( sRetries ) ; else { nRetries = IProcessorResenderModule . DEFAULT_RETRIES ; if ( LOGGER . isWarnEnabled ( ) ) LOGGER . warn ( " The resending retry count is missing - default to  " + nRetries + " ! " ) ; } final ResendItem aItem = new ResendItem ( sResendAction , nRetries , aMsg , getResendDelayMS ( ) ) ; m_aRWLock . writeLocked ( ( ) - > m_aItems . add ( aItem ) ) ; LOGGER . info ( " Message put in resend queue " + aMsg . getLoggingText ( ) ) ; }
public void testHandled ( ) { TestingEventHandler eh = new TestingEventHandler ( ) ; eh . setHandledEventTypes ( Sets . newHashSet ( " hello " ) ) ; EventManager . register ( Collections . < EventHandler > singleton ( eh ) ) ; EventManager . notify ( new Event ( " hello " , " world " ) ) ; assertEquals ( 1 , eh . getHandledEvents ( ) . size ( ) ) ; }
public T get ( int index ) { Node < T > current = top ; for ( int i = 0 ; i < index ; i + + ) { if ( current = = null ) break ; current = current . below ; } return ( current ! = null ) ? current . value : null ; }
public static void resetRepeatingSteps ( Set < Step > allSteps ) { Set < Step > resetSteps = Sets . newHashSet ( ) ; Set < DataStep > repeatingSteps = Repetitions . get ( ) . getAndClearRepeatingSteps ( ) ; LOG . info ( " Resetting {} repeating steps and their dependents " , repeatingSteps . size ( ) ) ; for ( DataStep step : repeatingSteps ) { resetSteps . add ( step ) ; resetSteps . addAll ( getAllDependentSteps ( step , allSteps ) ) ; } resetDataSteps ( resetSteps ) ; }
private HashAlgorithm lookupHashAlgorithm ( String algorithm ) { HashAlgorithm ha = DefaultHashAlgorithm . NATIVE_HASH ; if ( " crc " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . CRC32_HASH ; } else if ( " fnv1_32 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1_32_HASH ; } else if ( " fnv1_64 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1_64_HASH ; } else if ( " fnv1a_32 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1A_32_HASH ; } else if ( " fnv1a_64 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . FNV1A_64_HASH ; } else if ( " md5 " . equalsIgnoreCase ( algorithm ) ) { ha = DefaultHashAlgorithm . KETAMA_HASH ; } else { throw new IllegalArgumentException ( " Unhandled algorithm type:  " + algorithm ) ; } return ha ; }
public synchronized void step ( TestbedSettings settings ) { super . step ( settings ) ; if ( m_count < MAX_NUM ) { BodyDef bd = new BodyDef ( ) ;
KeyStore loadKeyStore ( @Nonnull final IKeyStoreType aKeyStoreType , @Nonnull @WillNotClose InputStream aIS , @Nonnull char [ ] aPassword ) throws Exception ; boolean isEncrypted ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; boolean isCompressed ( @Nonnull String sContentType ) throws OpenAS2Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithmSign eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithmCrypt eAlgorithm , @Nonnull EContentTransferEncoding eCTE ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt , boolean bLargeFileOn ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent , boolean bUseOldRFC3851MicAlgs , @Nonnull EContentTransferEncoding eCTE ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
protected FireConcept next ( ) { Concept currentConcept = concepts . takeNext ( ) ; if ( currentConcept = = null ) return null ; return new FireConcept ( memory , currentConcept , 1 ) {
public static Result addTags ( String artist , String album , String tags , Session session ) { return Caller . getInstance ( ) . call ( " album.addTags " , session , " artist " , artist , " album " , album , " tags " , tags ) ; }
public Partnership getPartnership ( @Nonnull final Partnership aPartnership ) throws OpenAS2Exception { ValueEnforcer . notNull ( aPartnership , " Partnership " ) ; m_aRWLock . readLock ( ) . lock ( ) ; try {
public List < PlannedRecord > planMutations ( List < GenericRecord > arrivingRecords , RecordModel recordModel ) { return planMutations ( arrivingRecords , null , recordModel ) ; }
public Task planTask ( Concept c , Task goal , Term goalTerm , char punctuation ) { Cause currentEdge = path [ path . length - 1 ] ; Stamp stamp = new Stamp ( goal . sentence . stamp , currentEdge . getStamp ( ) , memory . time ( ) ) ; for ( Term T : sequence ) { stamp . chainAdd ( T ) ; } Term subj = sequence . size ( ) > 1 ? Conjunction . make ( sequence . toArray ( new Term [ sequence . size ( ) ] ) , TemporalRules . ORDER_FORWARD ) : sequence . get ( 0 ) ; Term imp = Implication . make ( subj , goalTerm , TemporalRules . ORDER_FORWARD ) ; if ( imp = = null ) { throw new RuntimeException ( " Invalid implication:  " + subj + "  = \\ >  " + goalTerm ) ; } this . goal = goal ; this . solution = new Task ( new Sentence ( imp , punctuation , truth , stamp ) , budget , goal ) ; return solution ; }
public void testFibonacci ( ) { int element = 25 ; int check = 75025 ; long result = FibonacciSequence . fibonacciSequenceUsingLoop ( element ) ; assertTrue ( " Fibonacci Sequence Using Loop error. result= " + result + "  check= " + check , ( result = = check ) ) ; result = FibonacciSequence . fibonacciSequenceUsingRecursion ( element ) ; assertTrue ( " Fibonacci Sequence Using Recursion error. result= " + result + "  check= " + check , ( result = = check ) ) ; result = FibonacciSequence . fibonacciSequenceUsingMatrixMultiplication ( element ) ; assertTrue ( " Fibonacci Sequence Using Matrix error. result= " + result + "  check= " + check , ( result = = check ) ) ; result = FibonacciSequence . fibonacciSequenceUsingBinetsFormula ( element ) ; assertTrue ( " Fibonacci Sequence Using Binet's formula error. result= " + result + "  check= " + check , ( result = = check ) ) ; }
public List < String > waitForChanges ( ) throws MPDServerException { if ( null = = mpdIdleConnection ) { throw new MPDServerException ( ) ; } while ( true ) { List < String > data = mpdIdleConnection . sendAsyncCommand ( " idle " ) ;
public boolean onMenuItemActionCollapse ( android . view . MenuItem menuItem ) { if ( mActionExpandListener ! = null ) { return mActionExpandListener . onMenuItemActionCollapse ( MenuItemWrapper . this ) ; } return false ; }
List < Row > convertFromResults ( Iterable < Result > results ) ; List < Put > convertToPuts ( List < Row > rows ) ; List < Delete > convertToDeletes ( List < Row > rows ) ; }
public void write ( Kryo kryo , Output output , Object object ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; try { ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( object ) ; oos . flush ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } byte [ ] ser = bos . toByteArray ( ) ; output . writeInt ( ser . length ) ; output . writeBytes ( ser ) ; }
public void decisionPlanning ( final DerivationContext nal , final Task t , final Concept concept ) { if ( ! isDesired ( nal , concept ) ) { return ; } boolean plannable = graph . isPlannable ( t . getTerm ( ) ) ; if ( plannable ) { graph . plan ( nal , concept , t , t . getTerm ( ) , planParticles , searchDepth , '!' , maxPlannedTasks ) ;
public int compareTo ( final Term that ) { if ( this = = that ) return 0 ; if ( that instanceof CompoundTerm ) { final CompoundTerm t = ( CompoundTerm ) that ;
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " {MemcachedConnection to " ) ; for ( MemcachedNodeImpl qa : connections ) { sb . append ( "   " ) ; sb . append ( qa . getSocketAddress ( ) ) ; } sb . append ( " } " ) ; return sb . toString ( ) ; }
public void testConvertFromResults ( ) { byte [ ] rowKey = Bytes . add ( Bytes . toBytes ( " GOOG: " ) , Bytes . toBytes ( 1000L ) ) ; byte [ ] cf = Bytes . toBytes ( " cf1 " ) ; byte [ ] clordid = Bytes . toBytes ( " clordid " ) ; byte [ ] orderqty = Bytes . toBytes ( " orderqty " ) ; byte [ ] leavesqty = Bytes . toBytes ( " leavesqty " ) ; byte [ ] cumqty = Bytes . toBytes ( " cumqty " ) ; List < Cell > cells1 = Lists . newArrayList ( ( Cell ) new KeyValue ( rowKey , cf , clordid , 1000L , Bytes . toBytes ( " abcd " ) ) , new KeyValue ( rowKey , cf , orderqty , 1000L , Bytes . toBytes ( 100 ) ) , new KeyValue ( rowKey , cf , leavesqty , 1000L , Bytes . toBytes ( 10 ) ) , new KeyValue ( rowKey , cf , cumqty , 1000L , Bytes . toBytes ( 5 ) ) ) ; Result result1 = Result . create ( cells1 ) ; byte [ ] rowKey2 = Bytes . add ( Bytes . toBytes ( " AAPL: " ) , Bytes . toBytes ( 1004L ) ) ; List < Cell > cells2 = Lists . newArrayList ( ( Cell ) new KeyValue ( rowKey2 , cf , clordid , 1004L , Bytes . toBytes ( " efgh " ) ) , new KeyValue ( rowKey2 , cf , orderqty , 1004L , Bytes . toBytes ( 99 ) ) , new KeyValue ( rowKey2 , cf , leavesqty , 1004L , Bytes . toBytes ( 9 ) ) , new KeyValue ( rowKey2 , cf , cumqty , 1004L , Bytes . toBytes ( 4 ) ) ) ; Result result2 = Result . create ( cells2 ) ; List < Row > rows = serde . convertFromResults ( Lists . newArrayList ( result1 , result2 ) ) ; assertEquals ( " Two Rows should be returned " , 2 , rows . size ( ) ) ; assertEquals ( " Symbol should be GOOG " , " GOOG " , RowUtils . getAs ( String . class , rows . get ( 0 ) , " symbol " ) ) ; assertEquals ( " Transacttime should be 1000L " , 1000L , RowUtils . getAs ( Long . class , rows . get ( 0 ) , " transacttime " ) . longValue ( ) ) ; assertEquals ( " Clordid should be abcd " , " abcd " , RowUtils . getAs ( String . class , rows . get ( 0 ) , " clordid " ) ) ; assertEquals ( " Orderqty should be 100 " , 100 , RowUtils . getAs ( Integer . class , rows . get ( 0 ) , " orderqty " ) . intValue ( ) ) ; assertEquals ( " Leavesqty should be 10 " , 10 , RowUtils . getAs ( Integer . class , rows . get ( 0 ) , " leavesqty " ) . intValue ( ) ) ; assertEquals ( " Cumqty should be 5 " , 5 , RowUtils . getAs ( Integer . class , rows . get ( 0 ) , " cumqty " ) . intValue ( ) ) ; assertEquals ( " Symbol should be AAPL " , " AAPL " , RowUtils . getAs ( String . class , rows . get ( 1 ) , " symbol " ) ) ; assertEquals ( " Transacttime should be 1004L " , 1004L , RowUtils . getAs ( Long . class , rows . get ( 1 ) , " transacttime " ) . longValue ( ) ) ; assertEquals ( " Clordid should be efgh " , " efgh " , RowUtils . getAs ( String . class , rows . get ( 1 ) , " clordid " ) ) ; assertEquals ( " Orderqty should be 99 " , 99 , RowUtils . getAs ( Integer . class , rows . get ( 1 ) , " orderqty " ) . intValue ( ) ) ; assertEquals ( " Leavesqty should be 9 " , 9 , RowUtils . getAs ( Integer . class , rows . get ( 1 ) , " leavesqty " ) . intValue ( ) ) ; assertEquals ( " Cumqty should be 4 " , 4 , RowUtils . getAs ( Integer . class , rows . get ( 1 ) , " cumqty " ) . intValue ( ) ) ; }
public String [ ] getCoverUrl ( AlbumInfo albumInfo ) throws Exception { final String storageState = Environment . getExternalStorageState ( ) ; if ( Environment . MEDIA_MOUNTED_READ_ONLY . equals ( storageState ) | | Environment . MEDIA_MOUNTED . equals ( storageState ) ) { final String url = getAbsolutePathForSong ( albumInfo ) ; if ( new File ( url ) . exists ( ) ) { return new String [ ] { url } ; } } return null ; }
protected void updateGUI ( ) { speedSlider . repaint ( ) ;
public void testWrite ( ) throws IOException { Config subConfig = CommentedConfig . inMemory ( ) ; subConfig . set ( " string " , " test " ) ; subConfig . set ( " enum " , BasicTestEnum . C ) ; subConfig . set ( " sub " , CommentedConfig . inMemory ( ) ) ; List < Config > configList = new ArrayList < > ( ) ; configList . add ( subConfig ) ; configList . add ( subConfig ) ; configList . add ( subConfig ) ; CommentedConfig config = CommentedConfig . inMemory ( ) ; config . set ( " string " , " \" value \" " ) ; config . set ( " integer " , 2 ) ; config . set ( " long " , 123456789L ) ; config . set ( " double " , 3.1415926535 ) ; config . set ( " bool_array " , Arrays . asList ( true , false , true , false ) ) ; config . set ( " config " , subConfig ) ; config . set ( " config_list " , configList ) ; config . setComment ( " string " , "  Comment 1 \ n Comment 2 \ n Comment 3 " ) ; config . set ( " enum " , TestEnum . A ) ; StringWriter sw = new StringWriter ( ) ; HoconWriter writer = new HoconWriter ( ) ; writer . write ( config , sw ) ; System . out . println ( " Written: " ) ; System . out . println ( sw ) ; }
public static Statement makeSym ( Statement statement , Term subj , Term pred , Memory memory ) { if ( statement instanceof Inheritance ) { return Similarity . make ( subj , pred , memory ) ; } if ( statement instanceof Implication ) { return Equivalence . make ( subj , pred , memory ) ; } return null ; }
private static int indexToFigure ( TermLink link1 , TermLink link2 ) { return ( link1 . getIndex ( 0 ) + 1 ) * 10 + ( link2 . getIndex ( 0 ) + 1 ) ; }
public void testAfterLoop ( ) { Set < Step > steps = Sets . newHashSet ( ) ; Map < String , Object > loopStepConfigMap = Maps . newHashMap ( ) ; loopStepConfigMap . put ( LoopStep . MODE_PROPERTY , LoopStep . MODE_PARALLEL ) ; loopStepConfigMap . put ( LoopStep . SOURCE_PROPERTY , LoopStep . SOURCE_RANGE ) ; loopStepConfigMap . put ( LoopStep . RANGE_START_PROPERTY , 5 ) ; loopStepConfigMap . put ( LoopStep . RANGE_END_PROPERTY , 7 ) ; Config loopStepConfig = ConfigFactory . parseMap ( loopStepConfigMap ) ; LoopStep loopStep = new LoopStep ( " loop_step " , loopStepConfig ) ; steps . add ( loopStep ) ; Map < String , Object > step1ConfigMap = Maps . newHashMap ( ) ; step1ConfigMap . put ( " dependencies " , Lists . newArrayList ( " loop_step " ) ) ; Config step1Config = ConfigFactory . parseMap ( step1ConfigMap ) ; Step step1 = new BatchStep ( " step1 " , step1Config ) ; steps . add ( step1 ) ; Map < String , Object > afterLoopConfigMap = Maps . newHashMap ( ) ; afterLoopConfigMap . put ( " dependencies " , Lists . newArrayList ( " step1 " ) ) ; Config afterLoopConfig = ConfigFactory . parseMap ( afterLoopConfigMap ) ; Step afterLoop = new BatchStep ( " after_loop " , afterLoopConfig ) ; steps . add ( afterLoop ) ; Map < String , Object > afterAfterLoopConfigMap = Maps . newHashMap ( ) ; afterAfterLoopConfigMap . put ( " dependencies " , Lists . newArrayList ( " after_loop " ) ) ; Config afterAfterLoopConfig = ConfigFactory . parseMap ( afterAfterLoopConfigMap ) ; Step afterAfterLoop = new BatchStep ( " after_after_loop " , afterAfterLoopConfig ) ; steps . add ( afterAfterLoop ) ; Set < Step > unrolled = loopStep . unrollLoop ( steps ) ; assertEquals ( unrolled . size ( ) , 6 ) ; assertEquals ( StepUtils . getStepForName ( " loop_step " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_5 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_6 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_7 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; assertEquals ( StepUtils . getStepForName ( " after_loop " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " step1_5 " , " step1_6 " , " step1_7 " ) ) ; assertEquals ( StepUtils . getStepForName ( " after_after_loop " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " after_loop " ) ) ; }
public NARGraph add ( NAR n , Filter filter , Graphize graphize ) { graphize . onTime ( this , n . time ( ) ) ; for ( Concept c : n . memory ) { float p = c . getPriority ( ) ; if ( ! filter . includePriority ( p ) ) { continue ; } if ( ! filter . includeConcept ( c ) ) { continue ; } graphize . onConcept ( this , c ) ; } graphize . onFinish ( this ) ; return this ;
private int countChar ( String str , char c ) { int len = 0 ; char [ ] cArray = str . toCharArray ( ) ; for ( int i = 0 ; i < cArray . length ; i + + ) { if ( cArray [ i ] = = c ) len + + ; } return len ; }
public boolean remove ( Object key , Object value ) { return wrapped . remove ( key , value ) ; }
protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory m ) { if ( args . length < 2 ) { throw new RuntimeException ( " Requires at least 2 arguments " ) ; } if ( ! ( args [ args . length - 1 ] instanceof Variable ) ) { throw new RuntimeException ( " Last argument must be a Variable " ) ; } Term [ ] x = new Term [ args . length - 1 ] ; System . arraycopy ( args , 0 , x , 0 , args . length - 1 ) ; Term y ; try { y = function ( m , x ) ; if ( y = = null ) { return null ; } m . output ( SynchronousFunctionOperator . class , Arrays . toString ( x ) + "  |  " + y ) ; } catch ( Exception e ) { throw e ; } Term parameterTerm = x . length = = 1 ? x [ 0 ] : Product . make ( x , m ) ; Inheritance operatorInheritance = Operation . make ( Product . make ( new Term [ ] { parameterTerm , y } , m ) , this , m ) ; Inheritance resultInheritance = Inheritance . make ( operatorInheritance , getRange ( ) , m ) ; m . output ( Task . class , resultInheritance ) ; return Lists . newArrayList ( m . newTask ( resultInheritance , Symbols . JUDGMENT_MARK ,
public static void main ( String [ ] args ) throws SocketException , UnknownHostException , IOException , InterruptedException , InstantiationException , InvocationTargetException , ParserConfigurationException , NoSuchMethodException , SAXException , ClassNotFoundException , IllegalAccessException , ParseException { if ( ( args . length - 5 ) % 5 ! = 0 | | args . length < 5 ) { System . out . println ( " expected arguments: narOrConfigFileOrNull idOrNull nalFileOrNull cyclesToRunOrNull listenPort targetIP1 targetPort1 prioThres1 mustContainTermOrNull1 sendInput1 ... targetIPN targetPortN prioThresN mustContainTermOrNullN sendInputN " ) ; System . out . println ( " Here, OrNull means they can be null too, example: null null 64001 127.0.0.1 64002 0.5 null True " ) ; System . exit ( 0 ) ; } int nar1port = Integer . parseInt ( args [ 4 ] ) ; log ( " creating Reasoner... " ) ; Nar nar = Shell . createNar ( args ) ; log ( " creating NarNode... " ) ; NarNode nar1 = new NarNode ( nar , nar1port ) ; List < TargetNar > redirections = new ArrayList < TargetNar > ( ) ; for ( int i = 5 ; i < args . length ; i + = 5 ) { Term T = args [ i + 3 ] . toLowerCase ( ) . equals ( " null " ) ? null : new Term ( args [ i + 3 ] ) ; redirections . add ( new TargetNar ( args [ i ] , Integer . parseInt ( args [ i + 1 ] ) , Float . parseFloat ( args [ i + 2 ] ) , T , Boolean . parseBoolean ( args [ i + 4 ] ) ) ) ; } for ( TargetNar target : redirections ) { nar1 . addRedirectionTo ( target ) ; } log ( " running Shell... " ) ; new Shell ( nar1 . nar ) . run ( new String [ ] { args [ 0 ] , args [ 1 ] , args [ 2 ] , args [ 3 ] } ) ; }
public void run ( Map < String , Dataset < Row > > dependencies ) { Task task = TaskFactory . create ( config ) ; task . run ( dependencies ) ; this . setSubmitted ( true ) ; }
public void update ( long index , D data ) { if ( length > = 2 ) { if ( index < startIndex + half ) { ( ( NonOverlappingSegment < D > ) segments [ 0 ] ) . update ( index , data ) ; } else if ( index > = startIndex + half ) { ( ( NonOverlappingSegment < D > ) segments [ 1 ] ) . update ( index , data ) ; } } if ( index > = this . startIndex & & index < = this . endIndex & & this . segments = = null ) { this . data . update ( data ) ;
public E takeOut ( ) { int c = size ( ) ; if ( c = = 0 ) return null ; final E selected = takeOutIndex ( nextRemovalIndex ( ) ) ; nameTable . remove ( selected . getKey ( ) ) ; return selected ; }
private static final boolean _sameInfo ( ServiceInfo info , ServiceInfo lastInfo ) { if ( info = = null ) return false ; if ( lastInfo = = null ) return false ; if ( ! info . equals ( lastInfo ) ) return false ; byte [ ] text = info . getTextBytes ( ) ; byte [ ] lastText = lastInfo . getTextBytes ( ) ; if ( text . length ! = lastText . length ) return false ; for ( int i = 0 ; i < text . length ; i + + ) { if ( text [ i ] ! = lastText [ i ] ) return false ; } return true ; }
public void testTimestampFormats ( ) { String kvps = " field3=100.9---field6=---field7=true---field2=2018-09-09 23:49:29.00000---field1=2018-09-19 23:49:29.92284---field4=-1---field5=120---field8=2018-09-19 00:00:00 " ; Config config = ConfigFactory . empty ( ) . withValue ( KVPTranslator . SCHEMA_CONFIG + " . " + ComponentFactory . TYPE_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( " flat " ) ) . withValue ( KVPTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_NAMES_CONFIG , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " field1 " , " field2 " , " field3 " , " field4 " , " field5 " , " field6 " , " field7 " , " field8 " ) ) ) . withValue ( KVPTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_TYPES_CONFIG , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " timestamp " , " timestamp " , " double " , " integer " , " long " , " integer " , " boolean " , " timestamp " ) ) ) . withValue ( KVPTranslator . KVP_DELIMITER_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( " --- " ) ) . withValue ( KVPTranslator . FIELD_DELIMITER_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( " = " ) ) . withValue ( DelimitedTranslator . TIMESTAMP_FORMAT_CONFIG_NAME , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " yyyy-MM-dd HH:mm:ss.SSSSS " , " yyyy-MM-dd HH:mm:ss " ) ) ) ; KVPTranslator t = new KVPTranslator ( ) ; assertNoValidationFailures ( t , config ) ; t . configure ( config ) ; Row raw = TestingMessageFactory . get ( kvps , DataTypes . StringType ) ; Row r = t . translate ( raw ) . iterator ( ) . next ( ) ; assertEquals ( r . length ( ) , 8 ) ; assertEquals ( new LocalDateTime ( r . get ( 0 ) ) . toDateTime ( DateTimeZone . UTC ) . toString ( ) , " 2018-09-19T23:49:29.922Z " ) ; assertEquals ( new LocalDateTime ( r . get ( 1 ) ) . toDateTime ( DateTimeZone . UTC ) . toString ( ) , " 2018-09-09T23:49:29.000Z " ) ; assertEquals ( r . get ( 2 ) , 100.9d ) ; assertEquals ( r . get ( 3 ) , - 1 ) ; assertEquals ( r . get ( 4 ) , 120L ) ; assertEquals ( r . get ( 5 ) , null ) ; assertEquals ( r . get ( 6 ) , true ) ; assertEquals ( new LocalDateTime ( r . get ( 7 ) ) . toDateTime ( DateTimeZone . UTC ) . toString ( ) , " 2018-09-19T00:00:00.000Z " ) ;
public int compareTo ( Item o ) { if ( o instanceof Genre ) { Genre oa = ( Genre ) o ; return sort ( ) . compareToIgnoreCase ( oa . sort ( ) ) ; } return super . compareTo ( o ) ; }
public void gotData ( String k , int flags , byte [ ] data ) { assert k . equals ( key ) : " Incorrect key returned:  " + k ; rvContainer [ 0 ] = new CachedData ( flags , data ) ; } } , key ) ;
MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , boolean bForceDecrypt ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithmSign eAlgorithm , boolean bIncludeCertificateInSignedContent ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bUseCertificateInBodyPart , boolean bForceVerify ) throws Exception ; }
public void fire ( ) { this . lastFired = memory . getTime ( ) ; while ( ! pendingTasks . isEmpty ( ) ) { super . directProcess ( pendingTasks . remove ( ) ) ; } super . fire ( ) ; memory . setCurrentTerm ( term ) ; for ( TaskLink t : taskLinks ) fire ( t ) ;
public void onReceive ( Context context , Intent intent ) { if ( ! NetworkHelper . isLocalNetworkConnected ( context ) ) { Log . d ( MPDApplication . TAG , " No local network available. " ) ; return ; } Log . d ( MPDApplication . TAG , " Phonestate received " ) ; final SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( context ) ; boolean pauseOnCall = settings . getBoolean ( " pauseOnPhoneStateChange " , false ) ; boolean playOnCallStop = pauseOnCall & & settings . getBoolean ( " playOnPhoneStateChange " , false ) ; Log . d ( MPDApplication . TAG , " Pause on call  " + pauseOnCall ) ; if ( pauseOnCall = = false ) { return ; } Bundle bundle = intent . getExtras ( ) ; if ( null = = bundle ) { Log . e ( MPDApplication . TAG , " Bundle was null " ) ; return ; } String state = bundle . getString ( TelephonyManager . EXTRA_STATE ) ; final boolean shouldPause = pauseOnCall & & ( state . equalsIgnoreCase ( TelephonyManager . EXTRA_STATE_RINGING ) | | state . equalsIgnoreCase ( TelephonyManager . EXTRA_STATE_OFFHOOK ) ) ; Log . d ( MPDApplication . TAG , " Should pause  " + shouldPause ) ; final boolean shouldPlay = ( playOnCallStop & & settings . getBoolean ( PAUSED_MARKER , false ) & & state . equalsIgnoreCase ( TelephonyManager . EXTRA_STATE_IDLE ) ) ; Log . d ( MPDApplication . TAG , " Should play  " + shouldPlay ) ; if ( shouldPause = = false & & shouldPlay = = false ) { return ; } final MPDAsyncHelper oMPDAsyncHelper = new MPDAsyncHelper ( ) ; SettingsHelper settingsHelper = new SettingsHelper ( ( ContextWrapper ) context . getApplicationContext ( ) , oMPDAsyncHelper ) ; settingsHelper . updateConnectionSettings ( ) ; oMPDAsyncHelper . execAsync ( new Runnable ( ) { @Override
public static final Manifest createManifest ( ) { Manifest manifest = new Manifest ( ) ; manifest . getMainAttributes ( ) . put ( Attributes . Name . MANIFEST_VERSION , " 1.0 " ) ; manifest . getMainAttributes ( ) . put ( Attributes . Name . IMPLEMENTATION_URL , " http://samoa.yahoo.com " ) ; manifest . getMainAttributes ( ) . put ( Attributes . Name . IMPLEMENTATION_VERSION , " 0.1 " ) ; manifest . getMainAttributes ( ) . put ( Attributes . Name . IMPLEMENTATION_VENDOR , " Yahoo " ) ; manifest . getMainAttributes ( ) . put ( Attributes . Name . IMPLEMENTATION_VENDOR_ID , " SAMOA " ) ; Attributes s4Attributes = new Attributes ( ) ; s4Attributes . putValue ( " S4-App-Class " , " path.to.Class " ) ; Attributes . Name name = new Attributes . Name ( " S4-App-Class " ) ; Attributes . Name S4Version = new Attributes . Name ( " S4-Version " ) ; manifest . getMainAttributes ( ) . put ( name , " samoa.topology.impl.DoTaskApp " ) ; manifest . getMainAttributes ( ) . put ( S4Version , " 0.6.0-incubating " ) ; return manifest ; }
public static Term make ( ArrayList < Term > argument , Memory memory ) { if ( argument . size ( ) ! = 1 ) return null ; Term t = argument . get ( 0 ) ; if ( t instanceof TenseFuture ) return t ; if ( t instanceof TensePast ) return null ; if ( t instanceof TensePresent ) t = ( ( CompoundTerm ) t ) . componentAt ( 0 ) ; String name = makeCompoundName ( Symbols . FUTURE_OPERATOR , argument ) ; t = memory . nameToListedTerm ( name ) ; return ( t ! = null ) ? t : new TenseFuture ( name , argument ) ; }
public Builder mergeFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . OtherExample parsedMessage = null ; try { parsedMessage = PARSER . parsePartialFrom ( input , extensionRegistry ) ; } catch ( com . google . protobuf . InvalidProtocolBufferException e ) { parsedMessage = ( com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . OtherExample ) e . getUnfinishedMessage ( ) ; throw e . unwrapIOException ( ) ; } finally { if ( parsedMessage ! = null ) { mergeFrom ( parsedMessage ) ; } } return this ; }
public void doStop ( ) throws OpenAS2Exception { throw new UnsupportedOperationException ( " Never stop this module! " ) ; }
public void run ( boolean warmup ) { try { n . reset ( ) ; n . addInput ( example ) ; n . finish ( extraCycles ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } if ( ! warmup ) totalCycles + = n . getTime ( ) ;
static Concept makeConcept ( final String name , final float priority ) { final BudgetValue budg = new BudgetValue ( priority , priority , priority ) ; final Concept s = new Concept ( budg , new Term ( name ) , nar . memory ) ; return s ; }
public T get ( int index ) { Node < T > node = this . getNode ( index ) ; if ( node ! = null ) return node . getValue ( ) ;
public T previous ( ) { current = prevNode ; if ( index > 0 ) index - - ; if ( current ! = null ) { prevNode = current . prev ; nextNode = current . next ; return current . value ; } return null ; }
public boolean addEdge ( Object sourceVertex , Object targetVertex , NAREdge e ) { return addEdge ( sourceVertex , targetVertex , e , false ) ; }
boolean isTimeout ( ) ; V getSome ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException ; OperationStatus getStatus ( ) ; Future < V > addListener ( BulkGetCompletionListener listener ) ; Future < V > removeListener ( BulkGetCompletionListener listener ) ; }
public void repeatChanged ( boolean repeating ) { } @Override public void randomChanged ( boolean random ) { } @Override public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } @Override public void onAudioFocusChange ( int focusChange ) { if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS_TRANSIENT ) { mediaPlayer . setVolume ( 0.2f , 0.2f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_GAIN ) { mediaPlayer . setVolume ( 1f , 1f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS ) { stop ( ) ; } } }
public void load ( @Nonnull @WillClose final InputStream aIS , @Nonnull final char [ ] aPassword ) throws OpenAS2Exception { m_aRWLock . writeLock ( ) . lock ( ) ; try {
public Boolean call ( ) throws Exception { assert client . set ( " testparallel " , 5 , " parallelvalue " ) . getStatus ( ) . isSuccess ( ) ; for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " parallelvalue " , client . get ( " testparallel " ) ) ; } return Boolean . TRUE ; } } ) ;
public static void main ( String [ ] args ) { System . out . println ( " Starting tests. " ) ; boolean passed = true ; for ( int i = 0 ; i < NUMBER_OF_TESTS ; i + + ) { passed = runTests ( ) ; if ( ! passed ) break ; } if ( passed ) System . out . println ( " Tests finished. All passed. " ) ;
public void onItemClick ( final AdapterView < ? > parent , final View view , final int position , final long id ) { final ActionItem item = mItems . get ( position ) ; if ( item . mActionString . equals ( MPDControl . ACTION_VOLUME_SET ) ) { final SeekBar seekBar = new SeekBar ( this ) ;
private void addListeners ( ) { model . addTestChangeListener ( new TestbedState . TestChangedListener ( ) { @Override
ConfigWriter createWriter ( ) ; ConfigParser < C > createParser ( ) ; C createConfig ( ) ; C createConcurrentConfig ( ) ; boolean supportsComments ( ) ; @Deprecated default boolean supportsType ( Class < ? > type ) { return InMemoryFormat . DEFAULT_PREDICATE . test ( type ) ; } default boolean accepts ( Object value ) { if ( value instanceof List ) { List l = ( List ) value ; return l . isEmpty ( ) ? true : supportsType ( l . get ( 0 ) . getClass ( ) ) ; } return supportsType ( value . getClass ( ) ) ; } default boolean isInMemory ( ) { return false ; } default void initEmptyFile ( Path f ) throws IOException { initEmptyFile ( ( ) - > Files . newBufferedWriter ( f ) ) ; } default void initEmptyFile ( File f ) throws IOException { initEmptyFile ( f . toPath ( ) ) ; } default void initEmptyFile ( WriterSupplier ws ) throws IOException { } }
public static void main ( String [ ] args ) { int repeats = 4 ; int warmups = 1 ; int extraCycles = 2048 ; NAR n = new DefaultNARBuilder ( ) . build ( ) ; Collection c = NALTest . params ( ) ; while ( true ) { for ( Object o : c ) {
public void subtract ( Number operand ) { this . value - = operand . doubleValue ( ) ; }
public ConfigParser < CommentedConfig > createParser ( ) { return new TestParser ( ) ; }
protected String getFilename ( final IMessage aMsg , final String sFileParam , final String sAction ) throws InvalidParameterException { final IMessageMDN aMdn = aMsg . getMDN ( ) ; final CompositeParameters aCompParams = new CompositeParameters ( false ) . add ( " date " , new DateParameters ( ) ) . add ( " mdn " , new MessageMDNParameters ( aMdn ) ) ; return aCompParams . format ( sFileParam ) ; }
boolean isTimedOut ( ) ; void cancel ( ) ; void timeOut ( ) ; OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }
public Partnership loadPartnership ( @Nonnull final IMicroElement ePartnership , @Nonnull final IPartnerMap aAllPartners ) throws OpenAS2Exception { final IStringMap aPartnershipAttrs = XMLHelper . getAllAttrsWithLowercaseNameWithRequired ( ePartnership , PARTNERSHIP_NAME ) ; final Partnership aPartnership = new Partnership ( aPartnershipAttrs . getAsString ( PARTNERSHIP_NAME ) ) ; loadPartnerIDs ( ePartnership , aAllPartners , aPartnership , true ) ; loadPartnerIDs ( ePartnership , aAllPartners , aPartnership , false ) ; loadPartnershipAttributes ( ePartnership , aPartnership ) ; return aPartnership ; }
String getSubject ( ) ; void setSubject ( @Nullable String sSubject ) ; @Nullable MimeBodyPart getData ( ) ; void setData ( @Nullable MimeBodyPart aData , @Nullable DataHistoryItem aHistoryItem ) throws OpenAS2Exception ; @Nonnull DataHistoryItem setData ( @Nonnull MimeBodyPart aData ) throws OpenAS2Exception ; @Nullable IMessageMDN getMDN ( ) ; void setMDN ( @Nullable IMessageMDN aMDN ) ; @Nonnull @Nonempty String getLoggingText ( ) ; @Nonnull DataHistory getHistory ( ) ; String getProtocol ( ) ; boolean isRequestingMDN ( ) ; boolean isRequestingAsynchMDN ( ) ; @Deprecated String toString ( ) ; }
public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage \ r \ n " . getBytes ( ) ) ) ; } } ) ;
< T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }
Proxy getHttpProxy ( ) ; void setHttpProxy ( @Nullable Proxy aHttpProxy ) ; @Nonnull @Nonempty String getAS2VersionID ( ) ; void setAS2VersionID ( @Nonnull @Nonempty String sAS2Version ) ; }
public static void main ( String [ ] args ) { new Run ( ) ; }
protected static void do_action_table ( PrintWriter out , parse_action_table act_tab , boolean compact_reduces ) throws internal_error { parse_action_row row ; parse_action act ; int red ; long start_time = System . currentTimeMillis ( ) ; short [ ] [ ] action_table = new short [ act_tab . num_states ( ) ] [ ] ; for ( int i = 0 ; i < act_tab . num_states ( ) ; i + + ) { row = act_tab . under_state [ i ] ; if ( compact_reduces ) row . compute_default ( ) ; else row . default_reduce = - 1 ; short [ ] temp_table = new short [ 2 * row . size ( ) ] ; int nentries = 0 ; for ( int j = 0 ; j < row . size ( ) ; j + + ) { act = row . under_term [ j ] ; if ( act . kind ( ) ! = parse_action . ERROR ) { if ( act . kind ( ) = = parse_action . SHIFT ) { temp_table [ nentries + + ] = ( short ) j ; temp_table [ nentries + + ] = ( short ) ( ( ( shift_action ) act ) . shift_to ( ) . index ( ) + 1 ) ; } else if ( act . kind ( ) = = parse_action . REDUCE ) { red = ( ( reduce_action ) act ) . reduce_with ( ) . index ( ) ; if ( red ! = row . default_reduce ) { temp_table [ nentries + + ] = ( short ) j ; temp_table [ nentries + + ] = ( short ) ( - ( red + 1 ) ) ; } } else if ( act . kind ( ) = = parse_action . NONASSOC ) { } else throw new internal_error ( " Unrecognized action code  " + act . kind ( ) + "  found in parse table " ) ; } } action_table [ i ] = new short [ nentries + 2 ] ; System . arraycopy ( temp_table , 0 , action_table [ i ] , 0 , nentries ) ; action_table [ i ] [ nentries + + ] = - 1 ; if ( row . default_reduce ! = - 1 ) action_table [ i ] [ nentries + + ] = ( short ) ( - ( row . default_reduce + 1 ) ) ; else action_table [ i ] [ nentries + + ] = 0 ; } out . println ( ) ; out . println ( "   /** Parse-action table. */ " ) ; out . println ( "   protected static final short[][] _action_table =  " ) ; out . print ( "     unpackFromStrings( " ) ; do_table_as_string ( out , action_table ) ; out . println ( " ); " ) ; out . println ( ) ; out . println ( "   /** Access to parse-action table. */ " ) ; out . println ( "   public short[][] action_table() {return _action_table;} " ) ; action_table_time = System . currentTimeMillis ( ) - start_time ; }
void setCryptoVerifyUseCertificateInBodyPart ( boolean bCryptoVerifyUseCertificateInBodyPart ) ; @Nullable Proxy getHttpProxy ( ) ; void setHttpProxy ( @Nullable Proxy aHttpProxy ) ; }
public boolean onCreateOptionsMenu ( Menu menu ) { super . onCreateOptionsMenu ( menu ) ; getMenuInflater ( ) . inflate ( R . menu . mpd_browsermenu , menu ) ; return true ; }
public static long [ ] toSetArray ( final long [ ] x ) { long [ ] set = x . clone ( ) ; if ( x . length < 2 ) return set ; Arrays . sort ( set ) ; long lastValue = - 1 ; int j = 0 ; for ( int i = 0 ; i < set . length ; i + + ) { long v = set [ i ] ; if ( lastValue ! = v ) j + + ; lastValue = v ; } lastValue = - 1 ; long [ ] sorted = new long [ j ] ; j = 0 ; for ( int i = 0 ; i < set . length ; i + + ) { long v = set [ i ] ; if ( lastValue ! = v ) sorted [ j + + ] = v ; lastValue = v ; } return sorted ; }
public void clear ( ) ; public boolean contains ( T value ) ; public int size ( ) ; public boolean validate ( ) ; public java . util . Collection < T > toCollection ( ) ; }
public void testModifications ( ) throws Exception { ConnectionObserver testObserver = new ConnectionObserver ( ) { public void connectionLost ( SocketAddress sa ) { } public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { } } ; BlockingQueue < Operation > oQueue = new LinkedBlockingQueue < Operation > ( ) ; BlockingQueue < Operation > rQueue = new LinkedBlockingQueue < Operation > ( ) ; BlockingQueue < Operation > wQueue = new LinkedBlockingQueue < Operation > ( ) ; OperationQueueFactory opQueueFactory = new DirectFactory ( oQueue ) ; OperationQueueFactory rQueueFactory = new DirectFactory ( rQueue ) ; OperationQueueFactory wQueueFactory = new DirectFactory ( wQueue ) ; AuthDescriptor anAuthDescriptor = new AuthDescriptor ( new String [ ] { " PLAIN " } , new PlainCallbackHandler ( " username " , " password " ) ) ; ConnectionFactory f = b . setDaemon ( true ) . setShouldOptimize ( false ) . setFailureMode ( FailureMode . Redistribute ) . setHashAlg ( HashAlgorithm . KETAMA_HASH ) . setInitialObservers ( Collections . singleton ( testObserver ) ) . setOpFact ( new BinaryOperationFactory ( ) ) . setOpTimeout ( 4225 ) . setOpQueueFactory ( opQueueFactory ) . setReadOpQueueFactory ( rQueueFactory ) . setWriteOpQueueFactory ( wQueueFactory ) . setReadBufferSize ( 19 ) . setTranscoder ( new WhalinTranscoder ( ) ) . setUseNagleAlgorithm ( true ) . setLocatorType ( Locator . CONSISTENT ) . setOpQueueMaxBlockTime ( 19 ) . setAuthDescriptor ( anAuthDescriptor ) . build ( ) ; assertEquals ( 4225 , f . getOperationTimeout ( ) ) ; assertEquals ( 19 , f . getReadBufSize ( ) ) ; assertSame ( HashAlgorithm . KETAMA_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof WhalinTranscoder ) ; assertSame ( FailureMode . Redistribute , f . getFailureMode ( ) ) ; assertEquals ( 1 , f . getInitialObservers ( ) . size ( ) ) ; assertSame ( testObserver , f . getInitialObservers ( ) . iterator ( ) . next ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof BinaryOperationFactory ) ; assertSame ( oQueue , f . createOperationQueue ( ) ) ; assertSame ( rQueue , f . createReadOperationQueue ( ) ) ; assertSame ( wQueue , f . createWriteOperationQueue ( ) ) ; assertTrue ( f . isDaemon ( ) ) ; assertFalse ( f . shouldOptimize ( ) ) ; assertTrue ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , 19 ) ; assertSame ( anAuthDescriptor , f . getAuthDescriptor ( ) ) ; MemcachedNode n = new MockMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) ) ; assertTrue ( f . createLocator ( Collections . singletonList ( n ) ) instanceof KetamaNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode (
public static Term make ( final Term t1 , final Term t2 ) { if ( t1 . equals ( t2 ) ) return null ; return make ( new Term [ ] { t1 , t2 } ) ; }
private static void verifyProperty5 ( Node < ? , ? > root ) { verifyProperty5Helper ( root , 0 , - 1 ) ; }
public void changeMenuMode ( ) { if ( mCallback ! = null ) { mCallback . onMenuModeChange ( this ) ;
default CharsWrapper read ( int n ) { CharsWrapper . Builder builder = new CharsWrapper . Builder ( n ) ; for ( int i = 0 ; i < n ; i + + ) { int next = read ( ) ; if ( next = = - 1 ) { break ; } builder . append ( ( char ) next ) ; } return builder . build ( ) ; }
public void tagAlbumCover ( final AlbumInfo albumInfo ) { } final void update ( final AlbumInfo albumInfo ) { if ( DEBUG ) { Log . d ( TAG , " update() " ) ; } if ( mCoverUpdateListener ! = null ) { if ( mIsAlbumCacheEnabled ) { updateAlbumCoverWithCached ( albumInfo ) ; } } } private void updateAlbumCoverWithCached ( final AlbumInfo albumInfo ) { if ( DEBUG ) { Log . d ( TAG , " updateAlbumCoverWithCache(music):  " + albumInfo ) ; } final String coverArtPath = retrieveCoverArtPath ( albumInfo ) ; if ( coverArtPath = = null ) { if ( DEBUG ) { Log . d ( TAG , " Cover not found, attempting download. " ) ; } mCoverUpdateListener . onCoverUpdate ( null , null ) ; mCoverAsyncHelper . downloadCover ( albumInfo ) ; } else if ( coverArtPath . equals ( mAlbumCoverPath ) & & mAlbumCover ! = null ) { if ( DEBUG ) { Log . d ( TAG , " Cover the same as last time, omitting. " ) ; } mCoverUpdateListener . onCoverUpdate ( mAlbumCover , mAlbumCoverPath ) ; } else { if ( DEBUG ) { Log . d ( TAG , " Cover found in cache, decoding. " ) ; } new DecodeAlbumCover ( ) . execute ( coverArtPath ) ; } } interface Callback { void onCoverUpdate ( Bitmap albumCover , String albumCoverPath ) ; } private class DecodeAlbumCover extends AsyncTask < String , Void , Bitmap > { @Override protected final Bitmap doInBackground ( final String . . . pathArray ) { if ( DEBUG ) { Log . d ( TAG , " doInBackground() " ) ; } if ( mAlbumCover ! = null & & ! mAlbumCover . isRecycled ( ) ) { mAlbumCover = null ; } mAlbumCoverPath = pathArray [ 0 ] ; if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . KITKAT ) { mAlbumCover = BitmapFactory . decodeFile ( mAlbumCoverPath ) ; } else { mAlbumCover = Tools . decodeSampledBitmapFromPath ( mAlbumCoverPath , mIconWidth , mIconHeight , false ) ; } return mAlbumCover ; } @Override protected final void onPostExecute ( final Bitmap result ) { super . onPostExecute ( result ) ; if ( mCoverUpdateListener ! = null ) { mCoverUpdateListener . onCoverUpdate ( mAlbumCover , mAlbumCoverPath ) ; } } } }
public void stop ( ) { if ( t ! = null ) {
public boolean add ( final Sentence s , final Item c ) { if ( super . add ( s , c ) ) { concepts . put ( s , c ) ; return true ; } return false ; }
private void jLabel6MouseClicked ( java . awt . event . MouseEvent evt ) { nars . grid2d . TestChamber . main ( new String [ ] { } ) ; this . dispose ( ) ; }
public void seekById ( int songId , long position ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; mpdConnection . sendCommand ( MPDCommand . MPD_CMD_SEEK_ID , Integer . toString ( songId ) , Long . toString ( position ) ) ; }
void addProcessingItem ( IProcessingItem procItem ) ; void addProcessingItem ( IProcessingItem procItem , int parallelismHint ) ; void addStream ( Stream stream ) ; }
public void run ( ) { try { app . oMPDAsyncHelper . oMPD . getPlaylist ( ) . removeById ( positions ) ;
public static void main ( String [ ] args ) { final int ITER = 500 ; final int RANGE = 65536 ; SparseBitSet a = new SparseBitSet ( ) ; CUtility . ASSERT ( ! a . get ( 0 ) & & ! a . get ( 1 ) ) ; CUtility . ASSERT ( ! a . get ( 123329 ) ) ; a . set ( 0 ) ; CUtility . ASSERT ( a . get ( 0 ) & & ! a . get ( 1 ) ) ; a . set ( 1 ) ; CUtility . ASSERT ( a . get ( 0 ) & & a . get ( 1 ) ) ; a . clearAll ( ) ; CUtility . ASSERT ( ! a . get ( 0 ) & & ! a . get ( 1 ) ) ; java . util . Random r = new java . util . Random ( ) ; java . util . Vector v = new java . util . Vector ( ) ; for ( int n = 0 ; n < ITER ; n + + ) { int rr = ( ( r . nextInt ( ) > > > 1 ) % RANGE ) < < 1 ; a . set ( rr ) ; v . addElement ( new Integer ( rr ) ) ; CUtility . ASSERT ( a . get ( rr ) & & ! a . get ( rr + 1 ) & & ! a . get ( rr - 1 ) ) ; for ( int i = 0 ; i < v . size ( ) ; i + + ) CUtility . ASSERT ( a . get ( ( ( Integer ) v . elementAt ( i ) ) . intValue ( ) ) ) ; } SparseBitSet b = ( SparseBitSet ) a . clone ( ) ; CUtility . ASSERT ( a . equals ( b ) & & b . equals ( a ) ) ; for ( int n = 0 ; n < ITER / 2 ; n + + ) { int rr = ( r . nextInt ( ) > > > 1 ) % v . size ( ) ; int m = ( ( Integer ) v . elementAt ( rr ) ) . intValue ( ) ; b . clear ( m ) ; v . removeElementAt ( rr ) ; CUtility . ASSERT ( ! b . get ( m ) ) ; } CUtility . ASSERT ( ! a . equals ( b ) ) ; SparseBitSet c = ( SparseBitSet ) a . clone ( ) ; SparseBitSet d = ( SparseBitSet ) a . clone ( ) ; c . and ( a ) ; CUtility . ASSERT ( c . equals ( a ) & & a . equals ( c ) ) ; c . xor ( a ) ; CUtility . ASSERT ( ! c . equals ( a ) & & c . size ( ) = = 0 ) ; d . or ( b ) ; CUtility . ASSERT ( d . equals ( a ) & & ! b . equals ( d ) ) ; d . and ( b ) ; CUtility . ASSERT ( ! d . equals ( a ) & & b . equals ( d ) ) ; d . xor ( a ) ; CUtility . ASSERT ( ! d . equals ( a ) & & ! b . equals ( d ) ) ; c . or ( d ) ; c . or ( b ) ; CUtility . ASSERT ( c . equals ( a ) & & a . equals ( c ) ) ; c = ( SparseBitSet ) d . clone ( ) ; c . and ( b ) ; CUtility . ASSERT ( c . size ( ) = = 0 ) ; System . out . println ( " Success. " ) ; }
private void windDownResources ( final String action ) { Log . d ( TAG , " Winding down resources. " ) ; serviceWoundDown ( true ) ; if ( ACTION_STREAMING_STOP . equals ( action ) ) { setupServiceControlHandlers ( ) ; } if ( action ! = null ) { sendIntent ( action , NotificationService . class ) ; } if ( mTelephonyManager ! = null ) { mTelephonyManager . listen ( phoneStateListener , PhoneStateListener . LISTEN_NONE ) ; } if ( audioManager ! = null ) { audioManager . abandonAudioFocus ( this ) ; } if ( mediaPlayer ! = null ) { if ( mediaPlayer . isPlaying ( ) ) {
public void testIntervalTree3 ( ) { List < IntervalTree . IntervalData < String > > intervals = new ArrayList < IntervalTree . IntervalData < String > > ( ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 1 , 5 , " a " ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 2 , 6 , " b " ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 3 , 7 , " c " ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 7 , 7 , " d " ) ) ) ; IntervalTree < String > tree = new IntervalTree < String > ( intervals ) ; IntervalTree . IntervalData < String > query = tree . query ( 5 ) ; assertTrue ( " Interval Tree query error. returned= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( " b " , " c " , " a " ) ) ) ; query = tree . query ( 6 ) ; assertTrue ( " Interval Tree query error. returned= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( " b " , " c " ) ) ) ; }
StoreType getStoreType ( ) ; int getFlags ( ) ; int getExpiration ( ) ; byte [ ] getData ( ) ; interface Callback extends OperationCallback { void gotData ( String key , long cas ) ; } }
public SolveInfo solve ( ) { try { query . resolveTerm ( ) ;
public void testFancyWriter ( ) throws IOException { try ( Writer fileWriter = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( file ) , StandardCharsets . UTF_8 ) ) ) { FancyJsonWriter jsonWriter = new FancyJsonWriter ( ) ;
public static boolean include ( String filename ) { return filename . startsWith ( " nal1.multistep " ) ; }
public void forEach ( java . util . function . Consumer < ? super ExternalV > action ) { internalCollection . forEach ( internalV - > action . accept ( readTransformation . apply ( internalV ) ) ) ; }
private void trackImpl ( final Meter tracker , final long now ) { stateLock . lock ( ) ; try { hits + + ;
public static Schema schemaForStructType ( StructType structType ) throws RuntimeException { List < String > fieldNames = Lists . newArrayList ( ) ; List < String > fieldTypes = Lists . newArrayList ( ) ; for ( StructField field : structType . fields ( ) ) { fieldNames . add ( field . name ( ) ) ; DataType fieldType = field . dataType ( ) ; if ( fieldType . equals ( DataTypes . StringType ) ) { fieldTypes . add ( " string " ) ; } else if ( fieldType . equals ( DataTypes . FloatType ) ) { fieldTypes . add ( " float " ) ; } else if ( fieldType . equals ( DataTypes . DoubleType ) ) { fieldTypes . add ( " double " ) ; } else if ( fieldType . equals ( DataTypes . IntegerType ) ) { fieldTypes . add ( " int " ) ; } else if ( fieldType . equals ( DataTypes . LongType ) ) { fieldTypes . add ( " long " ) ; } else { throw new RuntimeException ( " Unsupported Spark SQL field type:  " + fieldType ) ; } } return RecordUtils . schemaFor ( fieldNames , fieldTypes ) ; }
public static BudgetValue backward ( final TruthValue truth , final org . opennars . control . DerivationContext nal ) { return budgetInference ( truthToQuality ( truth ) , 1 , nal ) ; }
public void addPropertyChangeListener ( PropertyChangeListener l ) { support . addPropertyChangeListener ( l ) ; }
abstract public Bag < Task , Sentence > newNovelTaskBag ( Param p ) ; abstract public ConceptProcessor newConceptProcessor ( Param p , ConceptBuilder c ) ; abstract public ConceptBuilder getConceptBuilder ( ) ; public NAR build ( ) { Param p = newParam ( ) ; Operator [ ] operators = DefaultOperators . get ( ) ; Memory m = new Memory ( p , new Cycle ( ) , newConceptProcessor ( p , getConceptBuilder ( ) ) , newNovelTaskBag ( p ) , operators ) ; for ( Operator o : ExampleOperators . get ( ) ) { m . addOperator ( o ) ; } return new NAR ( m , new Perception ( ) ) ; } }
void stateChanged ( final MPDStatus mpdStatus ) { if ( DEBUG ) { Log . d ( TAG , " StreamHandler.stateChanged() " ) ; } final int state = mpdStatus . getState ( ) ; if ( mIsActive ) { switch ( state ) {
public void setAS2SenderModuleFactory ( @Nonnull final ISupplier < AS2SenderModule > aAS2SenderModuleFactory ) { m_aAS2SenderModuleFactory = ValueEnforcer . notNull ( aAS2SenderModuleFactory , " AS2SenderModuleFactory " ) ; }
void drag ( int from , int to ) ; } public interface DropListener { void drop ( int from , int to ) ; } public interface RemoveListener { void remove ( int which ) ; } }
public void onDismiss ( ) { mPopup = null ; mMenu . close ( ) ; if ( mTreeObserver ! = null ) { if ( ! mTreeObserver . isAlive ( ) ) mTreeObserver = mAnchorView . getViewTreeObserver ( ) ; mTreeObserver . removeGlobalOnLayoutListener ( this ) ; mTreeObserver = null ; } ( ( View_HasStateListenerSupport ) mAnchorView ) . removeOnAttachStateChangeListener ( this ) ; }
public void addCoverRequest ( CoverInfo coverInfo ) { if ( DEBUG ) { Log . d ( CoverManager . class . getSimpleName ( ) , " Looking for cover with artist= " + coverInfo . getArtist ( ) + " , album= " + coverInfo . getAlbum ( ) ) ; } this . requests . add ( coverInfo ) ; }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; MyObject myObject = ( MyObject ) o ; return integer = = myObject . integer & & Double . compare ( myObject . decimal , decimal ) = = 0
public void testTimeoutDontwrite ( ) { Operation op = new ExtensibleOperationImpl ( new OperationCallback ( ) { public void complete ( ) { System . err . println ( " Complete. " ) ; } public void receivedStatus ( OperationStatus s ) { System . err . println ( " Received a line. " ) ; } } ) { @Override public void handleLine ( String line ) { System . out . println ( " Woo! A line! " ) ; } @Override public void initialize ( ) { setBuffer ( ByteBuffer . wrap ( " garbage \ r \ n " . getBytes ( ) ) ) ; } } ; try { Thread . sleep ( 1100 ) ; } catch ( InterruptedException ex ) { System . err . println ( " Interrupted when sleeping for timeout nowrite " ) ; } client . mconn . enqueueOperation ( " x " , op ) ; System . err . println ( " Operation attempted: " ) ; System . err . println ( op ) ; System . err . println ( " Trying to get: " ) ; try { client . get ( " x " ) ; String retValString = new String ( ) ; System . err . println ( retValString ) ; } catch ( net . spy . memcached . OperationTimeoutException ex ) { System . err . println ( " Timed out successfully:  " + ex . getMessage ( ) ) ; } System . err . println ( " Op timed out is  " + op . isTimedOut ( ) ) ; assert op . isTimedOut ( ) ; }
< T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
public void volumeChanged ( final MPDStatus mpdStatus , final int oldVolume ) { } private void windDownResources ( ) { Log . d ( TAG , " windDownResources() " ) ; if ( mAudioManager ! = null ) { mIsAudioFocusedOnThis = false ; mAudioManager . abandonAudioFocus ( null ) ; } if ( mNotificationHandler ! = null ) { mNotificationHandler . onDestroy ( ) ; } } }
public boolean collapseItemActionView ( MenuBuilder menu , MenuItemImpl item ) { return false ; }
public void init ( ) { if ( builder = = null ) { builder = new TopologyBuilder ( ) ; logger . debug ( " Sucessfully instantiating TopologyBuilder " ) ; builder . initTopology ( evaluationNameOption . getValue ( ) ) ; logger . debug ( " Sucessfully initializing SAMOA topology with name {} " , evaluationNameOption . getValue ( ) ) ; } preqSource = new PrequentialSourceProcessor ( ) ; preqSource . setStreamSource ( ( InstanceStream ) this . streamTrainOption . getValue ( ) ) ; preqSource . setMaxNumInstances ( instanceLimitOption . getValue ( ) ) ; preqStarter = new PrequentialSourceTopologyStarter ( preqSource , instanceLimitOption . getValue ( ) ) ; builder . addEntranceProcessor ( preqSource , preqStarter ) ; sourcePiOutputStream = builder . createStream ( preqSource ) ; preqStarter . setInputStream ( sourcePiOutputStream ) ; logger . debug ( " Sucessfully instantiating PrequentialSourceProcessor " ) ; classifier = ( Learner ) this . learnerOption . getValue ( ) ; classifier . init ( builder , preqSource . getDataset ( ) , 1 ) ; this . builder . connectInputShuffleStream ( sourcePiOutputStream , classifier . getInputProcessor ( ) ) ; logger . debug ( " Sucessfully instantiating Classifier " ) ; evaluatorPiInputStream = classifier . getResultStream ( ) ; evaluator = new EvaluatorProcessor . Builder ( ( ClassificationPerformanceEvaluator ) this . evaluatorOption . getValue ( ) ) . samplingFrequency ( sampleFrequencyOption . getValue ( ) ) . dumpFile ( dumpFileOption . getFile ( ) ) . build ( ) ; builder . addProcessor ( evaluator ) ; builder . connectInputShuffleStream ( evaluatorPiInputStream , evaluator ) ; logger . debug ( " Sucessfully instantiating EvaluatorProcessor " ) ; prequentialTopology = builder . build ( ) ; logger . debug ( " Sucessfully building the topology " ) ; }
public AS2ClientResponse sendSynchronous ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2ClientRequest aRequest ) { ValueEnforcer . notNull ( aSettings , " ClientSettings " ) ; ValueEnforcer . notNull ( aRequest , " ClientRequest " ) ; final AS2ClientResponse aResponse = createResponse ( ) ; IMessage aMsg = null ; final StopWatch aSW = StopWatch . createdStarted ( ) ; try { final Partnership aPartnership = buildPartnership ( aSettings ) ; aMsg = createMessage ( aPartnership , aRequest ) ; aResponse . setOriginalMessageID ( aMsg . getMessageID ( ) ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " MessageID to send:  " + aMsg . getMessageID ( ) ) ; final boolean bHasRetries = aSettings . getRetryCount ( ) > 0 ; final AS2Session aSession = createSession ( ) ; initCertificateFactory ( aSettings , aSession ) ; initPartnershipFactory ( aSession ) ; initMessageProcessor ( aSession ) ; if ( bHasRetries ) { final IProcessorResenderModule aResender = new ImmediateResenderModule ( ) ; aResender . initDynamicComponent ( aSession , null ) ; aSession . getMessageProcessor ( ) . addModule ( aResender ) ; } aSession . getMessageProcessor ( ) . startActiveModules ( ) ; try { beforeSend ( aSettings , aSession , aMsg ) ; final ICommonsMap < String , Object > aHandleOptions = new CommonsHashMap < > ( ) ; if ( bHasRetries ) aHandleOptions . put ( IProcessorResenderModule . OPTION_RETRIES , Integer . toString ( aSettings . getRetryCount ( ) ) ) ; final AS2SenderModule aSender = m_aAS2SenderModuleFactory . get ( ) ; aSender . initDynamicComponent ( aSession , null ) ; aSender . setAttribute ( AbstractHttpSenderModule . ATTR_CONNECT_TIMEOUT , Integer . toString ( aSettings . getConnectTimeoutMS ( ) ) ) ; aSender . setAttribute ( AbstractHttpSenderModule . ATTR_READ_TIMEOUT , Integer . toString ( aSettings . getReadTimeoutMS ( ) ) ) ; aSession . getMessageProcessor ( ) . addModule ( aSender ) ; aSender . handle ( IProcessorSenderModule . DO_SEND , aMsg , aHandleOptions ) ; } finally { aSession . getMessageProcessor ( ) . stopActiveModules ( ) ; } } catch ( final Throwable t ) { s_aLogger . error ( " Error sending AS2 message " , t ) ; aResponse . setException ( t ) ; } finally { if ( aMsg ! = null & & aMsg . getMDN ( ) ! = null ) { aResponse . setMDN ( aMsg . getMDN ( ) ) ; } } if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Response retrieved:  " + aResponse . getAsString ( ) ) ; aResponse . setExecutionDuration ( aSW . stopAndGetDuration ( ) ) ; return aResponse ; }
String getAttributeObject ( @Nullable String sName ) ; @Nullable String getAttributeAsString ( @Nullable String sName ) ; @Nullable String getAttributeAsString ( @Nullable String sName , @Nullable String sDefault ) ; int getAttributeAsInt ( @Nullable String sName ) ; int getAttributeAsInt ( @Nullable String sName , int nDefault ) ; long getAttributeAsLong ( @Nullable String sName ) ; long getAttributeAsLong ( @Nullable String sName , long nDefault ) ; double getAttributeAsDouble ( @Nullable String sName ) ; double getAttributeAsDouble ( @Nullable String sName , double dDefault ) ; boolean getAttributeAsBoolean ( @Nullable String sName ) ; boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; @Nonnull @ReturnsMutableCopy Enumeration < String > getAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Collection < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; }
public static ArrayList < Term > cloneList ( ArrayList < Term > original ) { if ( original = = null ) { return null ; } ArrayList < Term > arr = new ArrayList < Term > ( original . size ( ) ) ; for ( int i = 0 ; i < original . size ( ) ; i + + ) { arr . add ( ( Term ) ( ( Term ) original . get ( i ) ) . clone ( ) ) ; } return arr ; }
private boolean removeChild ( Node child ) { boolean found = false ; if ( childrenSize = = 0 ) return found ; for ( int i = 0 ; i < childrenSize ; i + + ) { if ( children [ i ] . equals ( child ) ) { found = true ; } else if ( found ) { children [ i - 1 ] = children [ i ] ; } } if ( found ) { childrenSize - - ; children [ childrenSize ] = null ; } return found ; }
IDynamicComponent getComponent ( @Nonnull @Nonempty String sComponentID ) throws ComponentNotFoundException ; @Nonnull @ReturnsMutableCopy Map < String , IDynamicComponent > getAllComponents ( ) ; @Nonnull ICertificateFactory getCertificateFactory ( ) throws ComponentNotFoundException ; @Nonnull IPartnershipFactory getPartnershipFactory ( ) throws ComponentNotFoundException ; @Nonnull IMessageProcessor getMessageProcessor ( ) throws ComponentNotFoundException ; boolean isCryptoVerifyUseCertificateInBodyPart ( ) ; void setCryptoVerifyUseCertificateInBodyPart ( boolean bCryptoVerifyUseCertificateInBodyPart ) ; @Nullable Proxy getHttpProxy ( ) ; void setHttpProxy ( @Nullable Proxy aHttpProxy ) ; }
void processStopRequest ( ) { sendSimpleMpdCommand ( ACTION_STOP ) ; relaxResources ( ) ; if ( mRemoteControlClient ! = null ) { mRemoteControlClient . setPlaybackState ( RemoteControlClient . PLAYSTATE_STOPPED ) ; } stopSelf ( ) ; }
public Object visit ( StmOp p , LoanParser arg ) { Term t1 = ( Term ) p . term_ . accept ( this , arg ) ; ArrayList < Term > opargs = new ArrayList < Term > ( ) ; Iterator < com . googlecode . opennars . parser . loan . Loan . Absyn . Term > iter = p . listterm_ . iterator ( ) ; while ( iter . hasNext ( ) ) { Term t = ( Term ) iter . next ( ) . accept ( this , arg ) ; opargs . add ( t ) ; } Term prod = CompoundTerm . make ( Symbols . PRODUCT_OPERATOR , opargs , memory ) ; return Statement . make ( Symbols . INHERITANCE_RELATION , prod , t1 , memory ) ; }
public static DataSource readHttpRequest ( @Nonnull final IAS2InputStreamProvider aISP , @Nonnull final IAS2HttpResponseHandler aResponseHandler , @Nonnull final IMessage aMsg , @Nullable final IHTTPIncomingDumper aIncomingDumper ) throws IOException , MessagingException { final InputStream aIS = aISP . getInputStream ( ) ; final String [ ] aRequest = _readRequestInfo ( aIS ) ; aMsg . attrs ( ) . putIn ( MA_HTTP_REQ_TYPE , aRequest [ 0 ] ) ; aMsg . attrs ( ) . putIn ( MA_HTTP_REQ_URL , aRequest [ 1 ] ) ; aMsg . attrs ( ) . putIn ( MA_HTTP_REQ_VERSION , aRequest [ 2 ] ) ; final InternetHeaders aHeaders = new InternetHeaders ( aIS ) ; final Enumeration < Header > aEnum = aHeaders . getAllHeaders ( ) ; while ( aEnum . hasMoreElements ( ) ) { final Header aHeader = aEnum . nextElement ( ) ; aMsg . headers ( ) . addHeader ( aHeader . getName ( ) , aHeader . getValue ( ) ) ; } final String sReceivedContentType = AS2HttpHelper . getCleanContentType ( aMsg . getHeader ( CHttpHeader . CONTENT_TYPE ) ) ; byte [ ] aBytePayLoad = null ; DataSource aPayload ; final String sContentLength = aMsg . getHeader ( CHttpHeader . CONTENT_LENGTH ) ; if ( sContentLength = = null ) { final InputStream aRealIS ; final String sTransferEncoding = aMsg . getHeader ( CHttpHeader . TRANSFER_ENCODING ) ; if ( sTransferEncoding ! = null ) { if ( AS2Helper . getWithoutSpaces ( sTransferEncoding ) . equalsIgnoreCase ( " chunked " ) ) { @WillNotClose final TempSharedFileInputStream aSharedIS = TempSharedFileInputStream . getTempSharedFileInputStream ( new ChunkedInputStream ( aIS ) , aMsg . getMessageID ( ) ) ; aRealIS = aSharedIS ; aMsg . setTempSharedFileInputStream ( aSharedIS ) ; } else { sendSimpleHTTPResponse ( aResponseHandler , CHttp . HTTP_LENGTH_REQUIRED ) ; throw new IOException ( " Transfer-Encoding unimplemented:  " + sTransferEncoding ) ; } } else { sendSimpleHTTPResponse ( aResponseHandler , CHttp . HTTP_LENGTH_REQUIRED ) ; throw new IOException ( " Content-Length missing " ) ; } aPayload = new InputStreamDataSource ( aRealIS , aMsg . getAS2From ( ) = = null ? " " : aMsg . getAS2From ( ) , sReceivedContentType , true ) ; } else { final long nContentLength = StringParser . parseLong ( sContentLength , - 1 ) ; if ( nContentLength < 0 | | nContentLength > Integer . MAX_VALUE ) { sendSimpleHTTPResponse ( aResponseHandler , CHttp . HTTP_LENGTH_REQUIRED ) ; throw new IOException ( " Content-Length ' " + sContentLength + " ' is invalid " ) ; } aBytePayLoad = new byte [ ( int ) nContentLength ] ; try ( final DataInputStream aDataIS = new DataInputStream ( aIS ) ) { aDataIS . readFully ( aBytePayLoad ) ; } aPayload = new ByteArrayDataSource ( aBytePayLoad , sReceivedContentType , null ) ; } if ( aIncomingDumper ! = null ) aIncomingDumper . dumpIncomingRequest ( getAllHTTPHeaderLines ( aHeaders ) , aBytePayLoad ! = null ? aBytePayLoad : " Large File Support: body was not read yet " . getBytes ( StandardCharsets . ISO_8859_1 ) , aMsg ) ; return aPayload ;
public void onListItemClick ( ListView l , View v , int position , long id ) { } }
private double [ ] increaseLength ( double [ ] array , int newLength ) { if ( array . length < newLength ) { double [ ] newArray = new double [ newLength ] ; for ( int i = 0 ; i < newLength ; i + + ) { if ( i < array . length ) newArray [ i ] = array [ i ] ; else newArray [ i ] = 0.0 ; } return newArray ; } return array ; }
public static ObjectDeserializer standard ( ) { return builder ( ) . build ( ) ; }
public List < String > listAlbums ( boolean useAlbumArtist ) throws MPDServerException { return listAlbums ( null , useAlbumArtist , false ) ; }
public static King createDarkKing ( ) { return new King ( Piece . DARK ) ; }
public String calculateMIC ( @Nonnull final MimeBodyPart aPart , @Nonnull final ECryptoAlgorithmSign eDigestAlgorithm , final boolean bIncludeHeaders ) throws GeneralSecurityException , MessagingException , IOException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( eDigestAlgorithm , " DigestAlgorithm " ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " BCCryptoHelper.calculateMIC ( " + eDigestAlgorithm + "  [ " + eDigestAlgorithm . getOID ( ) . getId ( ) + " ],  " + bIncludeHeaders + " ) " ) ; final ASN1ObjectIdentifier aMICAlg = eDigestAlgorithm . getOID ( ) ; final MessageDigest aMessageDigest = MessageDigest . getInstance ( aMICAlg . getId ( ) , BouncyCastleProvider . PROVIDER_NAME ) ; if ( bIncludeHeaders ) { final byte [ ] aCRLF = _getAsciiBytes ( CHttp . EOL ) ; final Enumeration < ? > aHeaderLines = aPart . getAllHeaderLines ( ) ; while ( aHeaderLines . hasMoreElements ( ) ) { aMessageDigest . update ( _getAsciiBytes ( ( String ) aHeaderLines . nextElement ( ) ) ) ; aMessageDigest . update ( aCRLF ) ; } aMessageDigest . update ( aCRLF ) ; } try ( final DigestOutputStream aDOS = new DigestOutputStream ( new NullOutputStream ( ) , aMessageDigest ) ; final OutputStream aOS = MimeUtility . encode ( aDOS , aPart . getEncoding ( ) ) ) { aPart . getDataHandler ( ) . writeTo ( aOS ) ; } final byte [ ] aMIC = aMessageDigest . digest ( ) ; final String ret = Base64 . encodeBytes ( aMIC ) + " ,  " + eDigestAlgorithm . getID ( ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( "   MIC =  " + ret ) ; return ret ; }
public void testInterpolationSearch ( ) { int index = InterpolationSearch . find ( valueInArray , sorted ) ; assertTrue ( " Brute force error. expected= " + valueIndex + "  got= " + index , ( index = = valueIndex ) ) ; index = InterpolationSearch . find ( valueNotInArray , sorted ) ; assertTrue ( " Brute force error. expected= " + Integer . MAX_VALUE + "  got= " + index , ( index = = Integer . MAX_VALUE ) ) ; }
public void onTabSelected ( ActionBar . Tab tab , FragmentTransaction fragmentTransaction ) { mViewPager . setCurrentItem ( tab . getPosition ( ) ) ; }
private static void pp ( com . googlecode . opennars . parser . loan . Loan . Absyn . ListSentence foo , int _i_ ) { for ( java . util . Iterator < Sentence > it = foo . iterator ( ) ; it . hasNext ( ) ; ) {
int read ( ) ; char readChar ( ) ; default int readAndSkip ( char [ ] toSkip ) { int c ; do { c = read ( ) ; } while ( c ! = - 1 & & Utils . arrayContains ( toSkip , ( char ) c ) ) ; return c ; } default char readCharAndSkip ( char [ ] toSkip ) { char c ; do { c = readChar ( ) ; } while ( Utils . arrayContains ( toSkip , c ) ) ; return c ; } default char [ ] read ( int n ) { char [ ] chars = new char [ n ] ; for ( int i = 0 ; i < n ; i + + ) { int next = read ( ) ; if ( next = = - 1 ) return Arrays . copyOf ( chars , i ) ; chars [ i ] = ( char ) next ; } return chars ; } default char [ ] readChars ( int n ) { char [ ] chars = new char [ n ] ; for ( int i = 0 ; i < n ; i + + ) { int next = read ( ) ; if ( next = = - 1 ) throw new ParsingException ( " Not enough data available. " ) ; chars [ i ] = ( char ) next ; } return chars ; } CharsWrapper readUntil ( char [ ] stop ) ; CharsWrapper readCharsUntil ( char [ ] stop ) ; int peek ( ) ; int peek ( int n ) ; char peekChar ( ) ; char peekChar ( int n ) ; void skipPeeks ( ) ; }
public void onSharedPreferenceChanged ( final SharedPreferences sharedPreferences , final String key ) { switch ( key ) { case CoverManager . PREFERENCE_CACHE :
public void step ( ) { for ( VisionRay v : vision ) v . step ( ) ; if ( feel_motion ) { feelMotion ( ) ;
public void fire ( NAL nal ) { final TaskLink currentTaskLink = taskLinks . takeOut ( ) ; if ( currentTaskLink = = null ) { return ; } nal . fire ( memory , this , currentTaskLink ) ; taskLinks . putBack ( currentTaskLink ) ; }
public static Term make ( final Term t ) { TreeSet < Term > set = new TreeSet < > ( ) ; set . add ( t ) ; return make ( set ) ; }
public void testAvailableServers ( ) { client . getVersions ( ) ; assertEquals ( new ArrayList < String > ( Collections . singleton ( getExpectedVersionSource ( ) ) ) ,
default void write ( T config , OutputStream output ) { write ( config , output , StandardCharsets . UTF_8 ) ; }
public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { val = new CASValue < T > ( - 1 , null ) ; } rv . set ( val , status ) ; }
public MIC calculateMIC ( @Nonnull final MimeBodyPart aPart , @Nonnull final ECryptoAlgorithmSign eDigestAlgorithm , final boolean bIncludeHeaders ) throws GeneralSecurityException , MessagingException , IOException { ValueEnforcer . notNull ( aPart , " MimeBodyPart " ) ; ValueEnforcer . notNull ( eDigestAlgorithm , " DigestAlgorithm " ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " BCCryptoHelper.calculateMIC ( " + eDigestAlgorithm + "  [ " + eDigestAlgorithm . getOID ( ) . getId ( ) + " ],  " + bIncludeHeaders + " ) " ) ; final ASN1ObjectIdentifier aMICAlg = eDigestAlgorithm . getOID ( ) ; MessageDigest aMessageDigest = MessageDigest . getInstance ( aMICAlg . getId ( ) , m_sSecurityProviderName ) ; if ( false ) aMessageDigest = new LoggingMessageDigest ( aMessageDigest ) ; if ( bIncludeHeaders ) { final Enumeration < String > aHeaderLines = aPart . getAllHeaderLines ( ) ; while ( aHeaderLines . hasMoreElements ( ) ) { final String sHeaderLine = aHeaderLines . nextElement ( ) ; aMessageDigest . update ( _getAllAsciiBytes ( sHeaderLine ) ) ; aMessageDigest . update ( EOF_BYTES ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Using header line ' " + sHeaderLine + " ' for MIC calculation " ) ; } aMessageDigest . update ( EOF_BYTES ) ; } final String sMICEncoding = aPart . getEncoding ( ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Using encoding ' " + sMICEncoding + " ' for MIC calculation " ) ; try ( final DigestOutputStream aDigestOS = new DigestOutputStream ( new NullOutputStream ( ) , aMessageDigest ) ; final OutputStream aEncodedOS = _getEncodingOS ( aDigestOS , sMICEncoding ) ) { aPart . getDataHandler ( ) . writeTo ( aEncodedOS ) ; } final byte [ ] aMIC = aMessageDigest . digest ( ) ; final MIC ret = new MIC ( aMIC , eDigestAlgorithm ) ; if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( "   Calculated MIC =  " + ret . getAsAS2String ( ) ) ; return ret ; }
public boolean inductionOnSucceedingEvents ( final Task newEvent , NAL nal ) { if ( newEvent . budget = = null | | ! newEvent . isParticipatingInTemporalInduction ( ) ) { return false ; } nal . emit ( Events . InduceSucceedingEvent . class , newEvent , nal ) ; if ( newEvent . sentence . isEternal ( ) | | ! isInputOrTriggeredOperation ( newEvent , nal . memory ) ) { return false ; } for ( Task stmLast : stm ) { proceedWithTemporalInduction ( newEvent . sentence , stmLast . sentence , newEvent , nal ) ; } while ( stm . size ( ) + 1 > Parameters . STM_SIZE ) stm . removeFirst ( ) ; stm . addLast ( newEvent ) ; return true ; }
public String toString ( ) { return toString ( getAction ( ) , getMsg ( ) , getOptions ( ) ) ; }
public void testEqualsToInt ( ) { Int zero = new Int ( 0 ) ; Int one = new Int ( 1 ) ; assertFalse ( zero . equals ( one ) ) ; Int anotherZero = new Int ( 1 - 1 ) ; assertTrue ( anotherZero . equals ( zero ) ) ; }
void translate ( Vector3D vector3d ) { translate ( vector3d . get ( 0 ) , vector3d . get ( 1 ) , vector3d . get ( 2 ) ) ; }
public static void main ( String [ ] args ) { NAR nar = new DefaultNARBuilder ( ) . build ( ) ; InferenceTrace it = new InferenceTrace ( nar ) ; nar . addInput ( " <a --> b>. " ) ; nar . addInput ( " <b --> c>. " ) ; nar . addInput ( " <c --> a>. " ) ; nar . finish ( 64 ) ; NWindow n = new NWindow ( " Timeline Test " , new TimelineCanvas ( it , 1000 , 800 ) ) ; n . pack ( ) ; n . setVisible ( true ) ; n . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; }
Set < String > getAllPartnerNames ( ) ; @Nonnull @ReturnsMutableCopy List < ? extends IStringMap > getAllPartners ( ) ; @Nonnull EChange addPartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nonnull EChange removePartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nonnull Partnership getPartnership ( @Nonnull Partnership aPartnership ) throws OpenAS2Exception ; @Nullable Partnership getPartnershipByName ( @Nullable String sName ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllPartnershipNames ( ) ; @Nonnull @ReturnsMutableCopy List < Partnership > getAllPartnerships ( ) ; void updatePartnership ( @Nonnull IMessage aMsg , boolean bOverwrite ) throws OpenAS2Exception ; void updatePartnership ( @Nonnull IMessageMDN aMdn , boolean bOverwrite ) throws OpenAS2Exception ; }
void onCoverUpdate ( Bitmap albumCover , String albumCoverPath ) ; } private class DecodeAlbumCover extends AsyncTask < String , Void , Bitmap > { @Override protected final Bitmap doInBackground ( final String . . . pathArray ) { if ( DEBUG ) { Log . d ( TAG , " doInBackground() " ) ; } mAlbumCoverPath = pathArray [ 0 ] ; if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . KITKAT ) { mAlbumCover = BitmapFactory . decodeFile ( mAlbumCoverPath ) ; } else { mAlbumCover = Tools . decodeSampledBitmapFromPath ( mAlbumCoverPath , mIconWidth , mIconHeight , false ) ; } return mAlbumCover ; } @Override protected final void onPostExecute ( final Bitmap result ) { super . onPostExecute ( result ) ; if ( mCoverUpdateListener ! = null ) { mCoverUpdateListener . onCoverUpdate ( mAlbumCover , mAlbumCoverPath ) ; } } } }
public List < String > listAlbumArtists ( ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; List < String > response = mpdConnection . sendCommand ( MPDCommand . MPD_CMD_LIST_TAG , MPDCommand . MPD_TAG_ALBUM_ARTIST ) ; ArrayList < String > result = new ArrayList < String > ( ) ; for ( String s : response ) { String name = s . substring ( " albumartist:  " . length ( ) ) ; if ( name . length ( ) > 0 ) result . add ( name ) ; } Collections . sort ( result ) ; return result ; }
public Boolean call ( ) throws Exception { for ( int i = 0 ; i < 10 ; i + + ) { assert client . set ( " test " + i , 5 , " value " + i ) . getStatus ( ) . isSuccess ( ) ; assertEquals ( " value " + i , client . get ( " test " + i ) ) ; } Map < String , Object > m = client . getBulk ( " test0 " , " test1 " , " test2 " , " test3 " , " test4 " , " test5 " , " test6 " , " test7 " , " test8 " , " test9 " , " test10 " ) ; for ( int i = 0 ; i < 10 ; i + + ) { assertEquals ( " value " + i , m . get ( " test " + i ) ) ; } return Boolean . TRUE ; }
public E set ( final int i , final E e ) { int m = ( head + i ) % n ; E existing = ( E ) buf [ m ] ; buf [ m ] = e ; return existing ; }
public void testQuerySetLimit ( ) throws Exception { Query query = new Query ( ) ; View view = client . getView ( DESIGN_DOC_W_REDUCE , VIEW_NAME_W_REDUCE ) ; HttpFuture < ViewResponse > future = client . asyncQuery ( view , query . setLimit ( 10 ) ) ; ViewResponse response = future . get ( ) ; assert response ! = null : future . getStatus ( ) ; }
public void parseOptions ( final String sOptions ) throws OpenAS2Exception { setProtocolImportance ( null ) ; setProtocol ( null ) ; setMICAlgImportance ( null ) ; setMICAlg ( null ) ; if ( sOptions ! = null ) {
public boolean onItemLongClick ( AdapterView < ? > av , View v , int position , long id ) { try { MainMenuActivity . notifyUser ( String . format ( getResources ( ) . getString ( R . string . albumAdded ) , itemsList . get ( position ) ) , SearchAlbumActivity . this ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; ArrayList < Music > songs = new ArrayList < Music > ( app . oMPDAsyncHelper . oMPD . find ( MPD . MPD_FIND_ALBUM , itemsList . get ( position ) . toString ( ) ) ) ; app . oMPDAsyncHelper . oMPD . getPlaylist ( ) . add ( songs ) ; } catch ( MPDServerException e ) { e . printStackTrace ( ) ; } return true ; }
public boolean match ( Term t ) { resolveTerm ( ) ; t . resolveTerm ( ) ; List < Var > v1 = new LinkedList < Var > ( ) ; List < Var > v2 = new LinkedList < Var > ( ) ; boolean ok = unify ( v1 , v2 , t ) ; Var . free ( v1 ) ; Var . free ( v2 ) ; return ok ; }
private static void inferToAsym ( Sentence asym , Sentence sym , NAL nal ) { Statement statement = ( Statement ) asym . content ; Term sub = statement . getPredicate ( ) ; Term pre = statement . getSubject ( ) ; Statement content = Statement . make ( statement , sub , pre , statement . getTemporalOrder ( ) , nal . mem ( ) ) ; if ( content = = null ) return ; TruthValue truth = TruthFunctions . reduceConjunction ( sym . truth , asym . truth ) ; BudgetValue budget = BudgetFunctions . forward ( truth , nal ) ; nal . doublePremiseTask ( content , truth , budget , false ) ; }
public void testReadContentTransferEncodingBase64 ( ) throws MessagingException , IOException { final String sHTTP = " Content-Type: text/plain " + HTTPHelper . EOL + " Content-Transfer-Encoding: base64 " + HTTPHelper . EOL + " x-custom: junit " + HTTPHelper . EOL + " Content-Length: 44 " + HTTPHelper . EOL + HTTPHelper . EOL + " VGVzdCBtZXNzYWdlCkxpbmUgMgoKTGluZSA0CkVPRg== " + HTTPHelper . EOL ; InputStream aIS = new StringInputStream ( sHTTP , CCharset . CHARSET_ISO_8859_1_OBJ ) ; final InternetHeaders aHeaders = new InternetHeaders ( aIS ) ; final String sCTE = aHeaders . getHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING ) [ 0 ] ; if ( StringHelper . hasText ( sCTE ) ) aIS = MimeUtility . decode ( aIS , sCTE ) ; final byte [ ] aData = StreamHelper . getAllBytes ( aIS ) ; final ContentType aReceivedContentType = new ContentType ( aHeaders . getHeader ( CAS2Header . HEADER_CONTENT_TYPE ) [ 0 ] ) ; final String sReceivedContentType = aReceivedContentType . toString ( ) ; final MimeBodyPart aReceivedPart = new MimeBodyPart ( ) ; aReceivedPart . setDataHandler ( new ByteArrayDataSource ( aData , sReceivedContentType , null ) . getAsDataHandler ( ) ) ; aReceivedPart . setHeader ( " x-received " , " true " ) ; final NonBlockingByteArrayOutputStream aBAOS = new NonBlockingByteArrayOutputStream ( ) ; aReceivedPart . writeTo ( aBAOS ) ; StreamHelper . close ( aBAOS ) ; final String sMsgPart = aBAOS . getAsString ( CCharset . CHARSET_ISO_8859_1_OBJ ) ; if ( true ) s_aLogger . info ( sMsgPart ) ;
public abstract W createWriter ( ) ; @Override public abstract ConfigParser < Config > createParser ( ) ; @Override public Config createConfig ( ) { return Config . of ( this ) ; } @Override public Config createConcurrentConfig ( ) { return Config . ofConcurrent ( this ) ; } @Override public boolean supportsComments ( ) { return false ; } @Override public void initEmptyFile ( WriterSupplier ws ) throws IOException { try ( Writer writer = ws . get ( ) ) { writer . write ( " {} " ) ; } } }
public void testGetTempSharedFileInputStream ( ) throws Exception { final String inData = " 123456 " ; try ( final InputStream is = new NonBlockingByteArrayInputStream ( inData . getBytes ( ) ) ; final SharedFileInputStream sis = TempSharedFileInputStream . getTempSharedFileInputStream ( is , " myName " ) ;
protected void startImpl ( final long now ) { ThreadInfo threadInfo = getCurrentThreadInfo ( ) ; if ( threadInfo ! = null ) { startWaitTime = threadInfo . getWaitedTime ( ) ;
public static final String reverseWordsByCharWithAdditionalStorage ( String string ) { StringBuilder builder = new StringBuilder ( ) ; char c = 0 ; int index = 0 ; int last = string . length ( ) ; int length = string . length ( ) - 1 ; StringBuilder temp = new StringBuilder ( ) ; for ( int i = length ; i > = 0 ; i - - ) { c = string . charAt ( i ) ; if ( c = = SPACE | | i = = 0 ) { index = ( i = = 0 ) ? 0 : i + 1 ; temp . append ( string . substring ( index , last ) ) ; if ( index ! = 0 ) temp . append ( c ) ; builder . append ( temp ) ; temp . delete ( 0 , temp . length ( ) ) ; last = i ; } } return builder . toString ( ) ; }
public void popDirectoryFromList ( ) { if ( ! absolutePathList . isEmpty ( ) ) { absolutePathList . remove ( absolutePathList . size ( ) - 1 ) ;
void setHeaders ( @Nullable InternetHeaders aHeaders ) ; @Nullable default String getMessageID ( ) { return getHeader ( CAS2Header . HEADER_MESSAGE_ID ) ; } default void setMessageID ( @Nullable final String sMessageID ) { setHeader ( CAS2Header . HEADER_MESSAGE_ID , sMessageID ) ; } @Nonnull String generateMessageID ( ) ; default void updateMessageID ( ) { setMessageID ( generateMessageID ( ) ) ; } @Nonnull @ReturnsMutableObject ( " Design " ) Partnership partnership ( ) ; void setPartnership ( @Nonnull Partnership aPartnership ) ; @Nonnull @Nonempty String getAsString ( ) ; }
public Operator operator ( ) { return Operator . INTERSECTION_EXT ; }
public void readFromBuffer ( ByteBuffer data ) throws IOException { while ( data . remaining ( ) > 0 ) { if ( bytesProcessed < BaseMessage . HEADER_LENGTH ) {
void put ( String name , Object value ) ; Object removeField ( String name ) ; void clear ( ) ; interface Entry { String getName ( ) ; Object getValue ( ) ; < T > T getValue ( Class < T > type ) ; } }
protected boolean queue ( Y task ) { if ( task ! = null ) return buffer . add ( task ) ; return false ; }
public void stratify ( int numFolds ) { throw new UnsupportedOperationException ( " Not yet implemented " ) ; }
public static Term [ ] simplifyIntervals ( Term [ ] components ) { List < Term > ret = new ArrayList < Term > ( ) ; for ( int i = 0 ; i < components . length ; ) { if ( ! ( components [ i ] instanceof Interval ) ) { ret . add ( components [ i ] ) ; i + + ; } else { long ival = ( ( Interval ) components [ i ] ) . time ; int k = 1 ; while ( i + k < components . length & & components [ i + k ] instanceof Interval ) { ival + = ( ( Interval ) components [ i + k ] ) . time ; k + + ; } ret . add ( new Interval ( ival ) ) ; i + = k ; } } return ret . toArray ( new Term [ 0 ] ) ; }
private Term parseAtomicTerm ( String s0 ) throws InvalidInputException { String s = s0 . trim ( ) ; if ( s . length ( ) = = 0 ) { throw new InvalidInputException ( " missing term " ) ; } Operator op = memory . getOperator ( s0 ) ; if ( op ! = null ) { return op ; } if ( s . contains ( "   " ) ) { throw new InvalidInputException ( " invalid term " ) ; } char c = s . charAt ( 0 ) ; if ( c = = Symbols . INTERVAL_PREFIX ) { return Interval . interval ( s ) ; } if ( containVar ( s ) & & ! s . equals ( " # " ) ) { return new Variable ( s ) ;
private void checkContainsOnlySubtables ( Config table , List < String > path ) { for ( Object value : table . valueMap ( ) . values ( ) ) { if ( ! ( value instanceof Config ) ) {
public void keyPressed ( KeyEvent e ) { super . keyPressed ( e ) ; int i = e . getKeyChar ( ) ; System . out . println ( i ) ; switch ( i ) {
public boolean isEnabled ( int position , List < ? extends Item > items , Object item ) ; public void onDataBind ( Context context , View targetView , AbstractViewHolder viewHolder , List < ? extends Item > items , Object item , int position ) ; public View onLayoutInflation ( Context context , View targetView , List < ? extends Item > items ) ; }
float Integrate ( float [ ] arr ) { float ret = 0 ; for ( int i = 0 ; i < arr . length ; i + + ) { ret + = arr [ i ] ; } return ret ; }
public void start ( NAR n ) { this . nar = n ; this . text = new DefaultTextPerception ( n ) ; }
public boolean putIn ( final E newItem , final boolean nameTableInsert ) { if ( nameTableInsert ) { final CharSequence newKey = newItem . getKey ( ) ; final E oldItem = nameTable . put ( newKey , newItem ) ; if ( oldItem ! = null ) { outOfBase ( oldItem ) ; newItem . merge ( oldItem ) ; } } final E overflowItem = intoBase ( newItem ) ; if ( overflowItem ! = null ) { final CharSequence overflowKey = overflowItem . getKey ( ) ;
public static String join ( Collection < String > keys , String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! keys . isEmpty ( ) ) { Iterator < String > itr = keys . iterator ( ) ; sb . append ( itr . next ( ) ) ; while ( itr . hasNext ( ) ) { sb . append ( delimiter ) ; sb . append ( itr . next ( ) ) ; } } return sb . toString ( ) ; }
public void multipleFiles ( ) throws Exception { int nDirs = 10 ; int nFiles = 10 ; FileWatcher watcher = new FileWatcher ( Duration . ZERO , Duration . ZERO , onWatcherException ) ; CountDownLatch latch = new CountDownLatch ( nDirs * nFiles ) ; for ( int i = 0 ; i < nDirs ; i + + ) { Path dir = tmp . resolve ( " sub- " + i ) ; Files . createDirectory ( dir ) ; for ( int j = 0 ; j < nFiles ; j + + ) { Path file = dir . resolve ( " multipleFilesNotifications- " + j ) ; watcher . addWatch ( file , latch : : countDown ) ; } } for ( int i = 0 ; i < nDirs ; i + + ) { for ( int j = 0 ; j < nFiles ; j + + ) { Path dir = tmp . resolve ( " sub- " + i ) ; Path file = dir . resolve ( " multipleFilesNotifications- " + j ) ; writeAndSync ( file , Arrays . asList ( " test " ) ) ; assertTrue ( Files . exists ( file ) ) ; } } assertTrue ( latch . await ( 200 , TimeUnit . MILLISECONDS ) ) ; watcher . stop ( ) ; }
public static void main ( String [ ] args ) { NARBuilder builder = new DefaultNARBuilder ( ) ; NAR nar = builder . build ( ) ; nar . param ( ) . noiseLevel . set ( 0 ) ; Parameters . TEMPORAL_PREDICTION_FEEDBACK_ACCURACY_DIV = 0.01 ; new NARSwing ( nar ) ; new TestChamber ( nar ) ; nar . start ( narUpdatePeriod ) ; }
public void setHttpHeader ( @Nonnull String sName , @Nonnull String sValue ) { httpURLConnection . setRequestProperty ( sName , sValue ) ; }
List < String > sendCommandQueue ( boolean withSeparator ) throws MPDServerException { String commandstr = ( withSeparator ? MPD_CMD_START_BULK_OK : MPD_CMD_START_BULK ) + " \ n " ; for ( MPDCommand command : commandQueue ) { commandstr + = command . toString ( ) ; } commandstr + = MPD_CMD_END_BULK ; commandQueue = new ArrayList < > ( ) ; return sendRawCommand ( new MPDCommand ( commandstr ) ) ; }
private void createDynamicSettings ( String keyPrefix , PreferenceCategory toCategory ) { EditTextPreference prefHost = new EditTextPreference ( this ) ; prefHost . setDialogTitle ( R . string . host ) ; prefHost . setTitle ( R . string . host ) ; prefHost . setSummary ( R . string . hostDescription ) ; prefHost . setDefaultValue ( " " ) ; prefHost . setKey ( keyPrefix + " hostname " ) ; toCategory . addPreference ( prefHost ) ; EditTextPreference prefPort = new EditTextPreference ( this ) ; prefPort . setDialogTitle ( R . string . port ) ; prefPort . setTitle ( R . string . port ) ; prefPort . setSummary ( R . string . portDescription ) ; prefPort . setDefaultValue ( " 6600 " ) ; prefPort . setKey ( keyPrefix + " port " ) ; toCategory . addPreference ( prefPort ) ; EditTextPreference prefPassword = new EditTextPreference ( this ) ; prefPassword . setDialogTitle ( R . string . password ) ; prefPassword . setTitle ( R . string . password ) ; prefPassword . setSummary ( R . string . passwordDescription ) ; prefPassword . setDefaultValue ( " " ) ; prefPassword . setKey ( keyPrefix + " password " ) ; toCategory . addPreference ( prefPassword ) ; onContentChanged ( ) ; EditTextPreference prefStreamingPort = new EditTextPreference ( this ) ; prefStreamingPort . setDialogTitle ( R . string . portStreaming ) ; prefStreamingPort . setTitle ( R . string . portStreaming ) ; prefStreamingPort . setSummary ( R . string . portStreamingDescription ) ; prefStreamingPort . setDefaultValue ( " 8000 " ) ; prefStreamingPort . setKey ( keyPrefix + " portStreaming " ) ; toCategory . addPreference ( prefStreamingPort ) ;
public boolean isActive ( ) ; public void append ( String channel , String s ) ; default public void append ( String s ) { append ( " Inference " , s ) ; } public void onConceptNew ( Concept concept ) ; public void onCycleStart ( long clock ) ; public void onCycleEnd ( long clock ) ; public void onTaskAdd ( Task task , String reason ) ; public void onTaskRemove ( Task task , String reason ) ; }
protected Formula renameVariableArityRelations ( KB kb ) { Formula result = this ; try { if ( this . listP ( ) ) { StringBuilder sb = new StringBuilder ( ) ; Formula f = new Formula ( ) ; f . read ( this . theFormula ) ; int flen = f . listLength ( ) ; String suffix = ( " _ " + ( flen - 1 ) ) ; String arg = null ; sb . append ( " ( " ) ; for ( int i = 0 ; i < flen ; i + + ) { arg = f . getArgument ( i ) ; if ( i > 0 ) { sb . append ( "   " ) ; } if ( ( i = = 0 ) & & kb . isVariableArityRelation ( arg ) & & ! ( arg . endsWith ( suffix ) ) ) { arg + = suffix ; } else if ( listP ( arg ) ) { Formula argF = new Formula ( ) ; argF . read ( arg ) ; arg = argF . renameVariableArityRelations ( kb ) . theFormula ; } sb . append ( arg ) ; } sb . append ( " ) " ) ; f = new Formula ( ) ; f . read ( sb . toString ( ) ) ; result = f ; } } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return result ; }
protected void onTitleChanged ( CharSequence title , int color ) { getSherlock ( ) . dispatchTitleChanged ( title , color ) ; super . onTitleChanged ( title , color ) ; }
public void commit ( Memory memory ) { super . commit ( memory ) ; put ( " concept.count " , conceptNum ) ; put ( " concept.pri.mean " , conceptPriorityMean ) ; put ( " concept.pri.variance " , conceptVariance ) ; for ( int n = 0 ; n < conceptHistogram . length ; n + + ) put ( " concept.pri.histo# " + n , conceptHistogram [ n ] ) ; put ( " concept.belief.mean " , conceptNum > 0 ? ( ( double ) conceptBeliefsSum ) / conceptNum : 0 ) ; put ( " concept.question.mean " , conceptNum > 0 ? ( ( double ) conceptQuestionsSum ) / conceptNum : 0 ) ; put ( " task.novel.total " , memory . novelTasks . size ( ) ) ; put ( " emotion.happy " , memory . emotion . happy ( ) ) ; put ( " emotion.busy " , memory . emotion . busy ( ) ) ; { DataSet fire = TASKLINK_FIRE . get ( ) ; put ( " reason.fire.tasklink.pri.mean " , fire . mean ( ) ) ; put ( " reason.fire.tasklinks " , TASKLINK_FIRE . getHits ( ) ) ; putHits ( REASON ) ; put ( " reason.tasktermlink.pri.mean " , REASON . get ( ) . mean ( ) ) ; } { putValue ( IO_INPUTS_BUFFERED ) ; } { putHits ( CONTRAPOSITION ) ; putHits ( BELIEF_REVISION ) ; put ( " reason.ded_2nd_layer_variable_unification_terms " , DED_SECOND_LAYER_VARIABLE_UNIFICATION_TERMS . getHits ( ) ) ; put ( " reason.ded_2nd_layer_variable_unification " , DED_SECOND_LAYER_VARIABLE_UNIFICATION . getHits ( ) ) ; put ( " reason.ded_conjunction_by_question " , DED_CONJUNCTION_BY_QUESTION . getHits ( ) ) ; putHits ( ANALOGY ) ; } { DataSet d = DERIVATION_LATENCY . get ( ) ; double min = d . min ( ) ; if ( ! Double . isFinite ( min ) ) min = 0 ; double max = d . max ( ) ; if ( ! Double . isFinite ( max ) ) max = 0 ; put ( DERIVATION_LATENCY . name ( ) + " .min " , min ) ; put ( DERIVATION_LATENCY . name ( ) + " .max " , max ) ; put ( DERIVATION_LATENCY . name ( ) + " .mean " , d . mean ( ) ) ; } { putHits ( TASK_ADD_NEW ) ; putHits ( TASK_ADD_NOVEL ) ; put ( " task.new.pri.mean " , TASK_ADD_NEW . get ( ) . mean ( ) ) ; put ( " task.derived " , TASK_DERIVED . getHits ( ) ) ; put ( " task.derived.pri.mean " , TASK_DERIVED . get ( ) . mean ( ) ) ; put ( " task.executed " , TASK_EXECUTED . getHits ( ) ) ; put ( " task.executed.pri.mean " , TASK_EXECUTED . get ( ) . mean ( ) ) ; put ( " task.immediate.process " , TASK_IMMEDIATE_PROCESS . getHits ( ) ) ; } { put ( " task.link_to " , LINK_TO_TASK . getHits ( ) ) ; put ( " task.goal.process " , GOAL_PROCESS . getHits ( ) ) ; put ( " task.judgment.process " , JUDGMENT_PROCESS . getHits ( ) ) ; put ( " task.question.process " , QUESTION_PROCESS . getHits ( ) ) ; } putHits ( SHORT_TERM_MEMORY_UPDATE ) ; { putHits ( SOLUTION_BEST ) ; put ( " task.solved.best.pri.mean " , SOLUTION_BEST . get ( ) . mean ( ) ) ; } {
public void gotData ( String k , int flags , byte [ ] data ) { assert key . equals ( k ) : " Wrong key returned " ; val = new CachedData ( flags , data ) ; }
public final String getKeyStorePassword ( ) { return m_sKeyStorePassword ; }
public CommentedFileConfigBuilder defaultData ( File file ) { super . defaultData ( file ) ; return this ; }
public int compareTo ( final Term that ) { if ( that . getClass ( ) = = getClass ( ) ) return name . compareTo ( that . name ( ) ) ; return that . getClass ( ) . getSimpleName ( ) . compareTo ( getClass ( ) . getSimpleName ( ) ) ;
public ArrayList clausifyWithRenameInfo ( ) { ArrayList result = new ArrayList ( ) ; Formula ans = null ; try { HashMap topLevelVars = new HashMap ( ) ; HashMap scopedRenames = new HashMap ( ) ; HashMap allRenames = new HashMap ( ) ; HashMap standardizedRenames = new HashMap ( ) ; ans = this . equivalencesOut ( ) ; ans = ans . implicationsOut ( ) ; ans = ans . negationsIn ( ) ; ans = ans . renameVariables ( topLevelVars , scopedRenames , allRenames ) ; ans = ans . existentialsOut ( ) ; ans = ans . universalsOut ( ) ; ans = ans . disjunctionsIn ( ) ; ans = ans . standardizeApart ( standardizedRenames ) ; allRenames . putAll ( standardizedRenames ) ; result . add ( ans ) ; result . add ( this ) ; result . add ( allRenames ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return result ; }
protected int forgetRate ( ) { return memory . getTaskForgettingRate ( ) . get ( ) ; }
public static void registerMediaButtonEventReceiverCompat ( AudioManager audioManager , ComponentName receiver ) { if ( sMethodRegisterMediaButtonEventReceiver = = null ) return ; try { sMethodRegisterMediaButtonEventReceiver . invoke ( audioManager , receiver ) ;
void hsim_ElemClicked ( Obj i ) { if ( lastclicked ! = null ) { } lastclicked = i ; }
public String [ ] getCoverUrl ( AlbumInfo albumInfo ) throws Exception { final String storageState = Environment . getExternalStorageState ( ) ; if ( Environment . MEDIA_MOUNTED_READ_ONLY . equals ( storageState ) | | Environment . MEDIA_MOUNTED . equals ( storageState ) ) { final String url = getAbsolutePathForSong ( albumInfo ) ; if ( new File ( url ) . exists ( ) ) return new String [ ] { url } ; } return null ; }
@Override public E put ( final K key , final E value ) { E removed ; synchronized ( items ) { removed = super . put ( key , value ) ; if ( removed ! = null ) { items . remove ( removed ) ; mass - = removed . budget . getPriority ( ) ; } items . add ( value ) ; } return removed ; }
public < T > Collection < T > filterToCollection ( final Collection < ? extends StatsKeyAssociation < T > > associations ) { return Collections . emptyList ( ) ; }
public void onFinish ( NARGraph g ) { if ( includeTermContent ) { for ( final Term a : terms ) { for ( final Term b : terms ) { if ( a = = b ) continue ; if ( a . containTerm ( b ) ) { g . addEdge ( a , b , NAREdge . TermContent ) ; } } } } if ( includeDerivations & & includeBeliefs ) { for ( final Entry < Sentence , Term > s : sentenceTerms . entrySet ( ) ) {
public void testToList ( ) { Struct emptyList = new Struct ( ) ; Struct emptyListToList = new Struct ( new Struct ( " [] " ) , new Struct ( ) ) ; assertEquals ( emptyListToList , emptyList . toList ( ) ) ; }
private static void writeSubTables ( OrganizedTable table , List < String > configPath , CharacterOutput output , TomlWriter writer ) { boolean hasArraysOfTables = ! table . arraysOfTables . isEmpty ( ) ; for ( Iterator < Entry > it = table . subTables . iterator ( ) ; it . hasNext ( ) ; ) { Entry entry = it . next ( ) ;
public Trie . Node createNewNode ( Trie . Node parent , Character character , boolean isWord ) { return ( new TrieMapNode < V > ( parent , character , isWord ) ) ; }
public int getAlbumCount ( String artist , boolean useAlbumArtistTag ) throws MPDServerException { return listAlbums ( artist , useAlbumArtistTag ) . size ( ) ; }
Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public EdgeVis updateEdge ( final E o ) { deadEdges . remove ( o ) ; EdgeVis v = edges . get ( o ) ; if ( v ! = null ) { display . edge ( this , v ) ; return v ; } v = new EdgeVis ( o ) ; edges . put ( o , v ) ; return v ; }
public static Playlist fetchUserPlaylist ( int playlistId , String apiKey ) { return fetch ( " lastfm://playlist/ " + playlistId , apiKey ) ; }
public void handle ( @Nullable final AbstractActiveNetModule aOwner , @Nonnull final Socket aSocket ) { final String sClientInfo = getClientInfo ( aSocket ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " Incoming connection  " + sClientInfo ) ; final AS2Message aMsg = createMessage ( aSocket ) ; final IAS2HttpResponseHandler aResponseHandler = new AS2HttpResponseHandlerSocket ( aSocket ) ; final StopWatch aSW = StopWatch . createdStarted ( ) ; byte [ ] aMsgData = null ; try { aMsgData = readAndDecodeHttpRequest ( new AS2InputStreamProviderSocket ( aSocket ) , aResponseHandler , aMsg ) ; } catch ( final Exception ex ) { final NetException ne = new NetException ( aSocket . getInetAddress ( ) , aSocket . getPort ( ) , ex ) ; ne . terminate ( ) ; } aSW . stop ( ) ; if ( aMsgData ! = null ) {
public StatsKeyMatcher not ( ) { return AllMatcher . INSTANCE ; }
private Sentence selectCandidate ( final Sentence query , final List < Sentence > list ) { float currentBest = 0 ; float beliefQuality ; Sentence candidate = null ; for ( final Sentence judg : list ) { beliefQuality = solutionQuality ( query , judg , memory ) ; if ( beliefQuality > currentBest ) { currentBest = beliefQuality ; candidate = judg ; } } return candidate ; }
public void receivedStatus ( OperationStatus status ) { statuses . put ( n , status ) ; }
public void testCarryForwardWhenNull ( ) { p = new EventTimeHistoryPlanner ( ) ; config = config . withValue ( EventTimeHistoryPlanner . CARRY_FORWARD_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( true ) ) ; assertNoValidationFailures ( p , config ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES , " " ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , null , 200L ) ) ; key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 2 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . UPDATE ) ; assertEquals ( planned . get ( 0 ) . getAs ( " value " ) , " hello " ) ; assertEquals ( planned . get ( 0 ) . getAs ( " startdate " ) , 100L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " enddate " ) , 199L ) ; assertEquals ( planned . get ( 0 ) . getAs ( " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 1 ) ) , MutationType . INSERT ) ; assertEquals ( planned . get ( 1 ) . getAs ( " value " ) , " hello " ) ; assertEquals ( planned . get ( 1 ) . getAs ( " startdate " ) , 200L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " enddate " ) , 253402214400000L ) ; assertEquals ( planned . get ( 1 ) . getAs ( " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_DEFAULT_YES ) ; }
@Override public void append ( final String channel , final String s ) { for ( final LogOutput o : outputs ) o . traceAppend ( channel , s ) ;
public void testNumNonZeroEntries ( ) { assertEquals ( 0 , emptyVector . numNonZeroEntries ( ) ) ; assertEquals ( 3 , array5Vector . numNonZeroEntries ( ) ) ; }
private void printDisjointness ( ) { System . out . println ( " INFO in printDisjointness():  Printing disjoint. " ) ; System . out . println ( ) ; Iterator it = disjoint . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { String term = ( String ) it . next ( ) ; System . out . print ( term + "  is disjoint with  " ) ; System . out . println ( disjoint . get ( term ) ) ; } System . out . println ( ) ; }
public static void main ( String [ ] arg ) { NAR nar = new DiscretinuousBagNARBuilder ( true ) . setConceptBagSize ( 1024 ) . build ( ) ; nar . param ( ) . duration . set ( 5 ) ; nar . param ( ) . noiseLevel . set ( 10 ) ; nar . param ( ) . shortTermMemorySize . set ( 1 ) ; nar . param ( ) . decisionThreshold . set ( impulsivity ) ; NARio nario = new NARio ( nar ) ; new NARSwing ( nar , false ) ; nar . start ( 30 f , 100 ) ; }
default public CharSequence name ( ) { return this . getClass ( ) . getSimpleName ( ) ; }
public String getAsString ( ) { final StringBuilder aSB = new StringBuilder ( ) ; aSB . append ( " MDN From: " ) . append ( getPartnership ( ) . getAllSenderIDs ( ) . getAllAttributes ( ) ) ; aSB . append ( " To: " ) . append ( getPartnership ( ) . getAllReceiverIDs ( ) . getAllAttributes ( ) ) ; aSB . append ( " \ r \ nHeaders:{ " ) ; final Enumeration < ? > aHeaders = getHeaders ( ) . getAllHeaders ( ) ; while ( aHeaders . hasMoreElements ( ) ) { final Header aHeader = ( Header ) aHeaders . nextElement ( ) ; aSB . append ( aHeader . getName ( ) ) . append ( " = " ) . append ( aHeader . getValue ( ) ) ; if ( aHeaders . hasMoreElements ( ) ) aSB . append ( " ,  " ) ; } aSB . append ( " } " ) . append ( " \ r \ nAttributes: " ) . append ( getAllAttributes ( ) . getAllAttributes ( ) ) . append ( " \ r \ nText: \ r \ n " ) . append ( getText ( ) ) . append ( " \ r \ n " ) ; return aSB . toString ( ) ; }
public void add ( final Album album ) throws IOException , MPDException { add ( album , false , false ) ; }
public boolean containsValue ( V value ) { for ( List < Pair < K , V > > list : map ) { for ( Pair < K , V > pair : list ) { if ( pair . value . equals ( value ) ) return true ; } } return false ; }
DataSet get ( ) ; default public String name ( ) { return getKey ( ) . getName ( ) ; } default public void init ( ) { } default public void commit ( DataContainer d , Memory m ) { } public void setCyclesSinceLastUpdate ( long cyclesSinceLastUpdate ) ; abstract public void setActive ( boolean b ) ; }
public V get ( K key ) { BinarySearchTree . Node < K > node = tree . getNode ( key ) ; if ( node instanceof TreeMapNode ) { TreeMapNode < K , V > mapNode = ( TreeMapNode < K , V > ) node ; return mapNode . value ; } return null ; }
public static String [ ] breakUp ( String s , int columns ) { Vector < String > result ; String line ; BreakIterator boundary ; int boundaryStart ; int boundaryEnd ; String word ; String punctuation ; int i ; String [ ] lines ; result = new Vector < String > ( ) ; punctuation = "  .,;:!?' \" " ; lines = s . split ( " \ n " ) ; for ( i = 0 ; i < lines . length ; i + + ) { boundary = BreakIterator . getWordInstance ( ) ; boundary . setText ( lines [ i ] ) ; boundaryStart = boundary . first ( ) ; boundaryEnd = boundary . next ( ) ; line = " " ; while ( boundaryEnd ! = BreakIterator . DONE ) { word = lines [ i ] . substring ( boundaryStart , boundaryEnd ) ; if ( line . length ( ) > = columns ) { if ( word . length ( ) = = 1 ) { if ( punctuation . indexOf ( word . charAt ( 0 ) ) > - 1 ) { line + = word ; word = " " ; } } result . add ( line ) ; line = " " ; } line + = word ; boundaryStart = boundaryEnd ; boundaryEnd = boundary . next ( ) ; } if ( line . length ( ) > 0 ) result . add ( line ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; }
public void printColorBlock ( final Color color , String s ) { StyleContext sc = StyleContext . getDefaultStyleContext ( ) ; MutableAttributeSet aset = getInputAttributes ( ) ; StyleConstants . setBackground ( aset , color ) ; try { int l = doc . getLength ( ) ;
private static Variable makeCommonVariable ( Term v1 , Term v2 ) { return new Variable ( v1 . getName ( ) + v2 . getName ( ) + '$' ) ; }
public boolean containsValue ( List < String > path ) { final int lastIndex = path . size ( ) - 1 ; Map < String , Object > currentMap = map ; for ( String key : path . subList ( 0 , lastIndex ) ) { Object value = currentMap . get ( key ) ; if ( ! ( value instanceof Config ) ) { return false ; } currentMap = ( ( Config ) value ) . asMap ( ) ; } String lastKey = path . get ( lastIndex ) ; return currentMap . containsKey ( lastKey ) ; }
private void reportExecution ( Statement operation , Memory memory ) { Term operator = operation . getPredicate ( ) ; Term arguments = operation . getSubject ( ) ; String argList = arguments . toString ( ) . substring ( 3 ) ; memory . output ( EXE . class , operator + " ( " + argList ) ; }
public final void onRequest ( @Nonnull final HttpServletRequest aHttpRequest , @Nonnull final HttpServletResponse aHttpResponse , @Nonnull final EHttpVersion eHttpVersion , @Nonnull final EHttpMethod eHttpMethod , @Nonnull final IRequestWebScope aRequestScope ) throws ServletException , IOException { final AS2Message aMsg = new AS2Message ( ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_SOURCE_IP , aHttpRequest . getRemoteAddr ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_SOURCE_PORT , aHttpRequest . getRemotePort ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_DESTINATION_IP , aHttpRequest . getLocalAddr ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_DESTINATION_PORT , aHttpRequest . getLocalPort ( ) ) ; aMsg . attrs ( ) . putIn ( HTTPHelper . MA_HTTP_REQ_TYPE , aHttpRequest . getMethod ( ) ) ; aMsg . attrs ( ) . putIn ( HTTPHelper . MA_HTTP_REQ_URL , ServletHelper . getRequestRequestURI ( aHttpRequest ) ) ; aMsg . headers ( ) . setAllHeaders ( aRequestScope . headers ( ) ) ; final boolean bQuoteHeaderValues = getReceiverModule ( ) . attrs ( ) . getAsBoolean ( AbstractActiveNetModule . ATTR_QUOTE_HEADER_VALUES , AbstractActiveNetModule . DEFAULT_QUOTE_HEADER_VALUES ) ; final AS2OutputStreamCreatorHttpServletResponse aResponseHandler = new AS2OutputStreamCreatorHttpServletResponse ( aHttpResponse , bQuoteHeaderValues ) ; final long nContentLength = aHttpRequest . getContentLengthLong ( ) ; if ( nContentLength > Integer . MAX_VALUE ) throw new IllegalStateException ( " Currently only payload with up to 2GB can be handled! " ) ; final byte [ ] aMsgData ; if ( nContentLength > = 0 ) { aMsgData = new byte [ ( int ) nContentLength ] ; try ( final DataInputStream aDataIS = new DataInputStream ( aHttpRequest . getInputStream ( ) ) ) { aDataIS . readFully ( aMsgData ) ; } } else { aMsgData = StreamHelper . getAllBytes ( aHttpRequest . getInputStream ( ) ) ; } final IHTTPIncomingDumper aIncomingDumper = getEffectiveIncomingDumper ( ) ; if ( aIncomingDumper ! = null ) aIncomingDumper . dumpIncomingRequest ( aMsg . headers ( ) . getAllHeaderLines ( true ) , aMsgData , aMsg ) ; handeIncomingMessage ( aHttpRequest , aHttpResponse , aRequestScope , aMsgData , aMsg , aResponseHandler ) ; }
public void copy ( Matrix m ) { for ( int r = 0 ; r < m . rows ; r + + ) { for ( int c = 0 ; c < m . cols ; c + + ) {
public List < Item > getPlaylists ( final boolean sort ) throws MPDServerException { final List < String > response = mConnection . sendCommand ( MPDCommand . MPD_CMD_LISTPLAYLISTS ) ; final List < Item > result = new ArrayList < > ( response . size ( ) ) ; for ( final String line : response ) { if ( line . startsWith ( " playlist " ) ) { final String name = line . substring ( " playlist:  " . length ( ) ) ; if ( null ! = name & & ! name . equals ( STREAMS_PLAYLIST ) ) { result . add ( new PlaylistFile ( name ) ) ; } } } if ( sort ) { Collections . sort ( result ) ; } return result ; }
public static void main ( String [ ] args ) { File localFile = new File ( " local-file.json " ) ; localFile . delete ( ) ; FileConfig conf = FileConfig . builder ( localFile ) . defaultResource ( " some-resource.json " ) . build ( ) ; conf . load ( ) ; System . out . println ( conf ) ; conf . set ( " value " , " added to the local file " ) ; conf . save ( ) ; }
boolean getLine ( ) throws java . io . IOException { String lineStr ; int elem ; if ( m_eof_reached ) { return EOF ; } if ( m_pushback_line ) { m_pushback_line = false ; for ( elem = 0 ; elem < m_line_read ; + + elem ) { if ( false = = CUtility . isspace ( m_line [ elem ] ) ) { break ; } } if ( elem < m_line_read ) { m_line_index = 0 ; return NOT_EOF ; } } while ( true ) { if ( null = = ( lineStr = m_input . readLine ( ) ) ) { m_eof_reached = true ; m_line_index = 0 ; return EOF ; } m_line = ( lineStr + " \ n " ) . toCharArray ( ) ; m_line_read = m_line . length ; + + m_line_number ; elem = 0 ; while ( CUtility . isspace ( m_line [ elem ] ) ) { + + elem ; if ( elem = = m_line_read ) { break ; } } if ( elem < m_line_read ) { break ; } } m_line_index = 0 ; return NOT_EOF ; }
Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public void onCompletion ( MediaPlayer mp ) { Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd = = null ) { return ; } String state = statusMpd . getState ( ) ; if ( state = = null ) { return ; } if ( state = = MPDStatus . MPD_STATE_PLAYING ) {
protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { final View child = getChildAt ( 0 ) ; if ( child = = null ) { return ; } if ( mGravity = = Gravity . TOP ) { child . layout ( 0 , 0 , getMeasuredWidth ( ) , child . getMeasuredHeight ( ) ) ;
boolean handleQuery ( JmDNSImpl dns , long expirationTime ) { return false ; }
public void subtractValues ( DoubleVector toSubtract ) { subtractValues ( toSubtract . getArrayRef ( ) ) ; }
public int compareTo ( Data d ) { if ( this . end < d . end ) return - 1 ; if ( d . end < this . end ) return 1 ; return 0 ; }
public int getConceptBagSize ( ) ; public int getTaskLinkBagLevels ( ) ; public int getTaskLinkBagSize ( ) ; public int getTermLinkBagLevels ( ) ; public int getTermLinkBagSize ( ) ; }
protected Node < T > addValue ( T id ) { Node < T > nodeToReturn = super . addValue ( id ) ; Node < T > nodeAdded = nodeToReturn ; if ( nodeAdded ! = null ) { while ( nodeAdded . parent ! = null ) { this . splay ( nodeAdded ) ; } } return nodeToReturn ; }
private boolean validate ( Node < K > node , java . util . Set < K > keys ) { if ( ! ( node instanceof TreeMapNode ) ) return false ; TreeMapNode < K , V > tmn = ( TreeMapNode < K , V > ) node ; K k = tmn . id ; V v = tmn . value ; if ( k = = null | | v = = null ) return false ; if ( keys . contains ( k ) ) return false ; keys . add ( k ) ; if ( tmn . lesser ! = null & & ! validate ( tmn . lesser , keys ) ) return false ; if ( tmn . greater ! = null & & ! validate ( tmn . greater , keys ) ) return false ; return true ; }
public boolean condition ( final Class channel , final Object signal ) { if ( ! succeeded ) { return false ; } if ( cond ( channel , signal ) ) { onFailure ( channel , signal ) ; succeeded = false ; return false ; } return true ; }
private static void printAll ( ) { int lastCharIndex = SuffixTree . characters . length ; System . out . printf ( " Hash \ tStart \ tEnd \ tSuf \ tfirst \ tlast \ tString \ n " ) ; for ( int key : map . keySet ( ) ) { Edge e = map . get ( key ) ;
public void update ( List < String > path , Object value ) { synchronized ( rootMonitor ) { dataHolder . update ( path , value ) ;
public void propagate_lookaheads ( terminal_set incoming ) throws internal_error { boolean change = false ; if ( ! needs_propagation & & ( incoming = = null | | incoming . empty ( ) ) ) return ; if ( incoming ! = null ) { change = lookahead ( ) . add ( incoming ) ; } if ( change | | needs_propagation ) {
public final void connect ( final String server , final int port , final String password ) throws IOException , MPDException { final InetAddress address = InetAddress . getByName ( server ) ; connect ( address , port , password ) ; }
protected synchronized boolean isUpToDate ( ) { Date mpdlast = mpd . getStatistics ( ) . getDbUpdate ( ) ; Log . d ( TAG , " lastupdate  " + lastUpdate + "  mpd date  " + mpdlast ) ; return ( null ! = lastUpdate & & null ! = mpdlast & & lastUpdate . after ( mpdlast ) ) ; }
public String previous ( ) { if ( history . isEmpty ( ) ) return " " ; index - - ; if ( index < 0 ) index = 0 ; return ( String ) history . get ( index ) ; }
protected void addAlbumPaths ( List < Album > albums ) { if ( ! cacheOK ( ) ) { return ; } for ( Album a : albums ) { Artist artist = a . getArtist ( ) ; String aname = ( artist = = null ? " " : artist . getName ( ) ) ; AlbumCache . AlbumDetails details = cache . getAlbumDetails ( aname , a . getName ( ) ) ; if ( details ! = null ) { a . setPath ( details . path ) ; } Log . d ( " MPD CACHED " , " album  " + a . info ( ) ) ; } Log . d ( " MPD CACHED " , " addAlbumPaths  " + albums . size ( ) ) ; }
public Matrix < T > identity ( ) throws Exception { if ( this . rows ! = this . cols ) throw new Exception ( " Matrix should be a square " ) ; final T element = this . get ( 0 , 0 ) ; final T zero ; final T one ; if ( element instanceof BigDecimal ) { zero = ( T ) BigDecimal . ZERO ; one = ( T ) BigDecimal . ONE ; } else if ( element instanceof BigInteger ) { zero = ( T ) BigInteger . ZERO ; one = ( T ) BigInteger . ONE ; } else if ( element instanceof Long ) { zero = ( T ) new Long ( 0 ) ; one = ( T ) new Long ( 1 ) ; } else if ( element instanceof Double ) { zero = ( T ) new Double ( 0 ) ; one = ( T ) new Double ( 1 ) ; } else if ( element instanceof Float ) { zero = ( T ) new Float ( 0 ) ; one = ( T ) new Float ( 1 ) ; } else { zero = ( T ) new Integer ( 0 ) ; one = ( T ) new Integer ( 1 ) ; } final T array [ ] [ ] = ( T [ ] [ ] ) new Number [ this . rows ] [ this . cols ] ; for ( int i = 0 ; i < this . rows ; + + i ) { for ( int j = 0 ; j < this . cols ; + + j ) { array [ i ] [ j ] = zero ; } } final Matrix < T > identityMatrix = new Matrix < T > ( this . rows , this . cols , array ) ; for ( int i = 0 ; i < this . rows ; + + i ) { identityMatrix . set ( i , i , one ) ; } return identityMatrix ; }
static String parseBasic ( CharacterInput input , TomlParser parser ) { CharsWrapper . Builder builder = new CharsWrapper . Builder ( parser . getInitialStringBuilderCapacity ( ) ) ; boolean escape = false ; char c ; while ( ( c = input . readChar ( ) ) ! = '\"' | | escape ) { if ( escape ) { builder . write ( escape ( c , input ) ) ; escape = false ; } else if ( c = = '\\' ) { escape = true ; } else { builder . write ( c ) ; } } return builder . toString ( ) ; }
public void testRun ( ) { new Expectations ( ) { { pi . getProcessor ( ) ; result = processor ; } } ; task . run ( ) ; new Verifications ( ) { {
private void testDefaultServers ( Supplier < ? > sup ) throws Exception { testDefaultServers ( sup , Arrays . asList ( " example.org " ) ) ; }
void onPullEnded ( ) { if ( DEBUG ) { Log . d ( LOG_TAG , " onPullEnded " ) ; } if ( ! mIsRefreshing ) { reset ( true ) ;
public boolean isEmptyDataAccepted ( ) { return emptyDataAccepted ; }
public static Term make ( TreeSet < Term > set ) { if ( set . size ( ) = = 1 ) { return set . first ( ) ; } Term [ ] argument = set . toArray ( new Term [ set . size ( ) ] ) ; return new IntersectionInt ( makeCompoundName ( NativeOperator . INTERSECTION_INT , argument ) , argument ) ;
protected void advanceObjectsState ( List < DNSStatefulObject > list ) { if ( list ! = null ) { for ( DNSStatefulObject object : list ) {
public byte [ ] encodeString ( String in ) { return super . encodeString ( in ) ; }
public void tearDown ( ) { } @Test public void testGetEnginePrivate ( ) { long expResult = 0 L ; long result = instance . getEnginePrivate ( ) ; assertEquals ( expResult , result ) ; } @Test public void testGetFlags ( ) { List < TapResponseFlag > result = instance . getFlags ( ) ; short expResultVal = 0 ; for ( TapResponseFlag flag : expectedFlags ) { expResultVal = ( short ) ( expResultVal + flag . getFlags ( ) ) ; } short resultVal = 0 ; for ( TapResponseFlag flag : result ) { resultVal = ( short ) ( resultVal + ( int ) flag . getFlags ( ) ) ; } assertEquals ( expResultVal , resultVal ) ; } @Test public void testGetTTL ( ) { int expResult = 0 ; int result = instance . getTTL ( ) ; assertEquals ( expResult , result ) ; } @Test public void testGetReserved1 ( ) { int expResult = 0 ; int result = instance . getReserved1 ( ) ; assertEquals ( expResult , result ) ; } @Test public void testGetReserved2 ( ) { int expResult = 0 ; int result = instance . getReserved2 ( ) ; assertEquals ( expResult , result ) ; } @Test public void testGetReserved3 ( ) { int expResult = 0 ; int result = instance . getReserved3 ( ) ; assertEquals ( expResult , result ) ; } @Test public void testGetVBucketState ( ) { int expResult = 0 ; int result = instance . getVBucketState ( ) ; assertEquals ( expResult , result ) ; } @Test public void testGetItemFlags ( ) { int expResult = ( int ) 0x0200 ; int result = instance . getItemFlags ( ) ; assertEquals ( expResult , result ) ; } @Test public void testGetItemExpiry ( ) { long expResult = 0 L ; long result = instance . getItemExpiry ( ) ; assertEquals ( expResult , result ) ; } @Test public void testGetKey ( ) { String expResult = " a " ; String result = instance . getKey ( ) ; assertEquals ( expResult , result ) ; } @Test public void testGetValue ( ) { ByteBuffer bb = ByteBuffer . allocate ( 8 ) ; bb . put ( 7 , ( byte ) 42 ) ; byte [ ] expResult = bb . array ( ) ; byte [ ] result = instance . getValue ( ) ; assertArrayEquals ( expResult , result ) ; } @Test public void testGetBytes ( ) { byte [ ] result = instance . getBytes ( ) . array ( ) ; assertEquals ( ( byte ) 42 , result [ result . length - 1 ] ) ; } }
public < T > T get ( List < String > path ) { return ( T ) convert ( config . get ( path ) ) ; }
public void event ( final Class event , final Object [ ] arguments ) { if ( event = = Events . ConceptAdd . class ) { onConceptNew ( ( Concept ) arguments [ 0 ] ) ;
CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public Validation atMostOnePathExists ( String . . . paths ) { return new AtMostOnePathExistsValidation ( paths ) ; }
public void getSchemaInvalidDataType ( ) throws Exception { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( MorphlineDeriver . STEP_NAME_CONFIG , " dep1 " ) ; paramMap . put ( MorphlineDeriver . MORPHLINE , getResourcePath ( MORPHLINE_FILE ) ) ; paramMap . put ( MorphlineDeriver . MORPHLINE_ID , " id " ) ; paramMap . put ( MorphlineDeriver . SCHEMA_CONFIG + " . " + ComponentFactory . TYPE_CONFIG_NAME , " flat " ) ; paramMap . put ( MorphlineDeriver . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_NAMES_CONFIG , Lists . newArrayList ( " bar " ) ) ; paramMap . put ( MorphlineDeriver . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_TYPES_CONFIG , Lists . newArrayList ( " boom " ) ) ; final Config config = ConfigFactory . parseMap ( paramMap ) ; MorphlineDeriver deriver = new MorphlineDeriver ( ) ; assertValidationFailures ( deriver , config ) ; }
protected void normalizeVariableNames ( ) { if ( containVar ( ) ) { boolean b = renameVariables ( new HashMap < > ( ) ) ; if ( b ) { setName ( makeName ( ) ) ; } } isConstant = true ; }
public boolean directProcess ( Task task ) { pendingTasks . add ( task ) ; return true ; }
public void swapNode ( Node < T > node , Node < T > next ) ; } private static final class NodeLevelPair < T extends Comparable < T > > { private int level = - 1 ; private Node < T > node = null ; private NodeLevelPair ( int level , Node < T > node ) { this . level = level ; this . node = node ; } } public static class JavaCompatibleSkipList < T extends Comparable < T > > extends java . util . AbstractSet < T > { private SkipList < T > list = null ; public JavaCompatibleSkipList ( SkipList < T > list ) { this . list = list ; } @Override public boolean add ( T value ) { return list . add ( value ) ; } @Override public boolean remove ( Object value ) { return list . remove ( ( T ) value ) ; } @Override public boolean contains ( Object value ) { return list . contains ( ( T ) value ) ; } @Override public int size ( ) { return list . size ( ) ; } @Override public java . util . Iterator < T > iterator ( ) { return ( new SkipListListIterator < T > ( list ) ) ; } private static class SkipListListIterator < T extends Comparable < T > > implements java . util . Iterator < T > { private SkipList < T > list = null ; private SkipList . Node < T > next = null ; private SkipList . Node < T > last = null ; private SkipListListIterator ( SkipList < T > list ) { this . list = list ; this . next = list . head ; } @Override public void remove ( ) { if ( last = = null ) return ; list . remove ( last . data ) ; } @Override public boolean hasNext ( ) { return ( next ! = null ) ; } @Override public T next ( ) { if ( next = = null ) throw new java . util . NoSuchElementException ( ) ; last = next ; next = next . getNext ( 0 ) ; return last . data ; } } } }
public OperationFuture < Boolean > delete ( String key , long cas ) { final CountDownLatch latch = new CountDownLatch ( 1 ) ; final OperationFuture < Boolean > rv = new OperationFuture < Boolean > ( key , latch , operationTimeout , executorService ) ; DeleteOperation . Callback callback = new DeleteOperation . Callback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( s . isSuccess ( ) , s ) ; } @Override public void gotData ( long cas ) { rv . setCas ( cas ) ; } @Override public void complete ( ) { latch . countDown ( ) ; rv . signalComplete ( ) ; } } ; DeleteOperation op ; if ( cas = = 0 ) { op = opFact . delete ( key , callback ) ; } else { op = opFact . delete ( key , cas , callback ) ; } rv . setOperation ( op ) ; mconn . enqueueOperation ( key , op ) ; return rv ; }
public List < String > listAlbums ( boolean sortInsensitive ) throws MPDServerException { return listAlbums ( null , sortInsensitive , false ) ; }
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; final Map < MemcachedNode , Collection < String > > chunks = new HashMap < MemcachedNode , Collection < String > > ( ) ; final NodeLocator locator = conn . getLocator ( ) ; for ( String key : keys ) { validateKey ( key ) ; final MemcachedNode primaryNode = locator . getPrimary ( key ) ; MemcachedNode node = null ; if ( primaryNode . isActive ( ) ) { node = primaryNode ; } else { for ( Iterator < MemcachedNode > i = locator . getSequence ( key ) ; node = = null & & i . hasNext ( ) ; ) { MemcachedNode n = i . next ( ) ; if ( n . isActive ( ) ) { node = n ; } } if ( node = = null ) { node = primaryNode ; } } assert node ! = null : " Didn't find a node for  " + key ; Collection < String > ks = chunks . get ( node ) ; if ( ks = = null ) { ks = new ArrayList < String > ( ) ; chunks . put ( node , ks ) ; } ks . add ( key ) ; } final CountDownLatch latch = new CountDownLatch ( chunks . size ( ) ) ; final Collection < Operation > ops = new ArrayList < Operation > ( ) ; GetOperation . Callback cb = new GetOperation . Callback ( ) { @SuppressWarnings ( " synthetic-access " ) public void receivedStatus ( OperationStatus status ) { if ( ! status . isSuccess ( ) ) { getLogger ( ) . warn ( " Unsuccessful get:  %s " , status ) ; } } public void gotData ( String k , int flags , byte [ ] data ) { Object val = transcoder . decode ( new CachedData ( flags , data ) ) ; if ( val ! = null ) { m . put ( k , val ) ; } } public void complete ( ) { latch . countDown ( ) ; } } ; final Map < MemcachedNode , Operation > mops = new HashMap < MemcachedNode , Operation > ( ) ; for ( Map . Entry < MemcachedNode , Collection < String > > me : chunks . entrySet ( ) ) { Operation op = opFact . get ( me . getValue ( ) , cb ) ; mops . put ( me . getKey ( ) , op ) ; ops . add ( op ) ; } assert mops . size ( ) = = chunks . size ( ) ; checkState ( ) ; conn . addOperations ( mops ) ; return new BulkGetFuture ( m , ops , latch ) ; }
public abstract String getDefaultName ( ) ; public abstract String getDefaultDescription ( ) ; public abstract String getDefaultUsage ( ) ; }
CacheBag < Term , Concept > newSubconceptBag ( ) { if ( getSubconceptBagSize ( ) = = 0 ) return null ; return new CacheBag ( getSubconceptBagSize ( ) ) ; }
void processIntent ( String action , MPD mpd ) { switch ( action ) { case CMD_UPDATE_WIDGET :
@Override public boolean apply ( Item at ) { if ( at instanceof Task ) { Task t = ( Task ) at ; if ( t . sentence ! = null ) if ( t . sentence . stamp ! = null ) { t . sentence . stamp . setCreationTime ( creationTime , duration ) ; } } return true ; }
public String toWord ( ) { float e = getExpectation ( ) ; float t = Parameters . DEFAULT_CREATION_EXPECTATION ; if ( e > t ) { return " TRUE " ; } if ( e < 1 - t ) { return " FALSE " ; } return " UNSURE " ; }
public Concept conceptualize ( final Term term ) { if ( ! term . isConstant ( ) ) { return null ; } final CharSequence n = term . name ( ) ; Concept concept = concept ( n ) ; if ( concept = = null ) { concept = conceptBuilder . newConcept ( term , this ) ; final boolean created = model . addConcept ( concept ) ; if ( ! created ) { return null ; } else { if ( recorder . isActive ( ) ) { recorder . onConceptNew ( concept ) ; } } } return concept ; }
@Test public void testFastBag ( ) { ContinuousBag < NullItem > f = new ContinuousBag ( 4 , 10 ) ; f . putIn ( new NullItem ( .25f ) ) ; assert ( f . size ( ) = = 1 ) ; assert ( f . getMass ( ) > 0 ) ; f . putIn ( new NullItem ( .9f ) ) ; f . putIn ( new NullItem ( .75f ) ) ; System . out . println ( f ) ; assert ( f . items . get ( 0 ) . getPriority ( ) < f . items . get ( 1 ) . getPriority ( ) ) ; assert ( f . size ( ) = = 3 ) ; f . takeOut ( ) ; assert ( f . size ( ) = = 2 ) ; f . takeOut ( ) ; assert ( f . size ( ) = = 1 ) ; f . takeOut ( ) ; assert ( f . size ( ) = = 0 ) ; assert ( f . getMass ( ) = = 0 ) ; }
public void onTerm ( Term t ) { index + + ; VertexDisplay d = displayVertex ( t ) ; d . position ( level , index , priority ) ; deadVertices . remove ( d ) ; levelContents + + ;
public < T > Future < ? > loadData ( Iterator < Map . Entry < String , T > > i ) { Future < Boolean > mostRecent = null ; while ( i . hasNext ( ) ) { Map . Entry < String , T > e = i . next ( ) ; mostRecent = push ( e . getKey ( ) , e . getValue ( ) ) ; watch ( e . getKey ( ) , mostRecent ) ; } return mostRecent = = null ? new ImmediateFuture ( true ) : mostRecent ; }
public boolean aboveThreshold ( ) { return ( summary ( ) > = Parameters . BUDGET_THRESHOLD ) ; }
public boolean equals ( Object obj ) { return iterator . equals ( obj ) ; }
MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull String sAlgorithm ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey key , @Nonnull String sAlgorithm ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert ) throws Exception ; }
public void addNewTask ( final Task t , final String reason ) { synchronized ( newTasks ) { newTasks . add ( t ) ; } emit ( Events . TaskAdd . class , t , reason ) ; output ( t ) ; }
public static void assertResults ( File outputFile , com . yahoo . labs . samoa . TestParams testParams ) throws IOException { LOG . info ( " Checking results file  " + outputFile . getAbsolutePath ( ) ) ; Reader in = new FileReader ( outputFile ) ; Iterable < CSVRecord > records = CSVFormat . EXCEL . withSkipHeaderRecord ( false ) . withIgnoreEmptyLines ( true ) . withDelimiter ( ',' ) . withCommentMarker ( '#' ) . parse ( in ) ; CSVRecord last = null ; Iterator < CSVRecord > iterator = records . iterator ( ) ; CSVRecord header = iterator . next ( ) ; Assert . assertEquals ( " Invalid number of columns " , 5 , header . size ( ) ) ; Assert . assertEquals ( " Unexpected column " , com . yahoo . labs . samoa . TestParams . EVALUATION_INSTANCES , header . get ( 0 ) . trim ( ) ) ; Assert . assertEquals ( " Unexpected column " , com . yahoo . labs . samoa . TestParams . CLASSIFIED_INSTANCES , header . get ( 1 ) . trim ( ) ) ; Assert . assertEquals ( " Unexpected column " , com . yahoo . labs . samoa . TestParams . CLASSIFICATIONS_CORRECT , header . get ( 2 ) . trim ( ) ) ; Assert . assertEquals ( " Unexpected column " , com . yahoo . labs . samoa . TestParams . KAPPA_STAT , header . get ( 3 ) . trim ( ) ) ; Assert . assertEquals ( " Unexpected column " , com . yahoo . labs . samoa . TestParams . KAPPA_TEMP_STAT , header . get ( 4 ) . trim ( ) ) ; while ( iterator . hasNext ( ) ) { last = iterator . next ( ) ; } assertTrue ( String . format ( " Unmet threshold expected %d got %f " , testParams . getEvaluationInstances ( ) , Float . parseFloat ( last . get ( 0 ) ) ) , testParams . getEvaluationInstances ( ) < = Float . parseFloat ( last . get ( 0 ) ) ) ; assertTrue ( String . format ( " Unmet threshold expected %d got %f " , testParams . getClassifiedInstances ( ) , Float . parseFloat ( last . get ( 1 ) ) ) , testParams . getClassifiedInstances ( ) < = Float . parseFloat ( last . get ( 1 ) ) ) ; assertTrue ( String . format ( " Unmet threshold expected %f got %f " , testParams . getClassificationsCorrect ( ) , Float . parseFloat ( last . get ( 2 ) ) ) , testParams . getClassificationsCorrect ( ) < = Float . parseFloat ( last . get ( 2 ) ) ) ; assertTrue ( String . format ( " Unmet threshold expected %f got %f " , testParams . getKappaStat ( ) , Float . parseFloat ( last . get ( 3 ) ) ) , testParams . getKappaStat ( ) < = Float . parseFloat ( last . get ( 3 ) ) ) ; assertTrue ( String . format ( " Unmet threshold expected %f got %f " , testParams . getKappaTempStat ( ) , Float . parseFloat ( last . get ( 4 ) ) ) ,
void connectionStateChanged ( MPDConnectionStateChangedEvent event ) ; void updateStateChanged ( MPDUpdateStateChangedEvent event ) ; }
public T peek ( ) { if ( size < = 0 ) return null ; T t = array [ - - size ] ; return t ; }
long getOpQueueMaxBlockTime ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; boolean isDaemon ( ) ; boolean useNagleAlgorithm ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; int getReadBufSize ( ) ; HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; MetricType enableMetrics ( ) ; MetricCollector getMetricCollector ( ) ; }
public ICommonsList < ICommand > getCommands ( ) { if ( m_aCmds = = null ) m_aCmds = new CommonsArrayList < > ( ) ; return m_aCmds ; }
public static File createFile ( File file ) throws IOException { boolean created = file . createNewFile ( ) ; if ( ! created ) { throw new IOException ( " The file already exists and cannot be created:  " + file ) ; } return file ; }
final void stop ( ) { if ( mAlbumCover ! = null & & ! mAlbumCover . isRecycled ( ) ) { mAlbumCover . recycle ( ) ; } mCoverUpdateListener = null ; if ( mCoverAsyncHelper ! = null ) { mCoverAsyncHelper . removeCoverDownloadListener ( this ) ;
public static double perfNAL ( final NAR n , final String path , final int extraCycles , int repeats , int warmups , boolean gc ) { final String example = NALTest . getExample ( path ) ; Performance p = new Performance ( path , repeats , warmups , gc ) { long totalCycles ; @Override public void init ( ) { System . out . print ( name + " :  " ) ; totalCycles = 0 ; } @Override public void run ( boolean warmup ) { try { n . reset ( ) ; n . addInput ( example ) ; n . step ( 1 ) ; n . finish ( extraCycles ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } totalCycles + = n . memory . getCycleTime ( ) ; } @Override public Performance print ( ) { super . print ( ) ; System . out . print ( " ,  " + df . format ( getCycleTimeMS ( ) / totalCycles * 1000.0 ) + "  uS/cycle,  " + ( ( ( float ) totalCycles ) / ( warmups + repeats ) ) + "  cycles/run " ) ; return this ; } @Override public Performance printCSV ( boolean finalComma ) { super . printCSV ( true ) ; System . out . print ( df . format ( getCycleTimeMS ( ) / totalCycles * 1000.0 ) + " ,  " + ( ( ( float ) totalCycles ) / ( warmups + repeats ) ) ) ; if ( finalComma ) System . out . print ( " ,  " ) ; return this ; } } ; p . print ( ) ; System . out . println ( ) ; return p . getCycleTimeMS ( ) ;
public void testCallingClassName ( ) { assertEquals ( TestEventUtils . class . getName ( ) , EventUtils . getCallingClassName ( ) ) ; }
private void readAdjectives ( ) throws java . io . IOException { System . out . println ( " INFO in WordNet.readAdjectives(): Reading WordNet adjective files " ) ; try { String line ; File adjFile = getWnFile ( " adj_mappings " ) ; if ( adjFile = = null ) { System . out . println ( " INFO in WordNet.readAdjectives():  " + " The adjective mappings file does not exist " ) ; return ; } long t1 = System . currentTimeMillis ( ) ; FileReader r = new FileReader ( adjFile ) ; LineNumberReader lr = new LineNumberReader ( r ) ; while ( ( line = lr . readLine ( ) ) ! = null ) { if ( lr . getLineNumber ( ) % 1000 = = 0 ) System . out . print ( '.' ) ; line = line . trim ( ) ; m = regexPatterns [ 13 ] . matcher ( line ) ; if ( m . matches ( ) ) { adjectiveDocumentationHash . put ( m . group ( 1 ) , m . group ( 3 ) ) ; addSUMOMapping ( m . group ( 4 ) , " 3 " + m . group ( 1 ) ) ; processPointers ( " 3 " + m . group ( 1 ) , m . group ( 2 ) ) ; } else { m = regexPatterns [ 14 ] . matcher ( line ) ; if ( m . matches ( ) ) { adjectiveDocumentationHash . put ( m . group ( 1 ) , m . group ( 3 ) ) ; processPointers ( " 3 " + m . group ( 1 ) , m . group ( 2 ) ) ; } else { if ( line ! = null & & line . length ( ) > 0 & & line . charAt ( 0 ) ! = ';' ) { System . out . println ( ) ; System . out . println ( " Error in WordNet.readAdjectives(): No match in  " + adjFile . getCanonicalPath ( ) + "  for line  " + line ) ; } } } } System . out . println ( " x " ) ; System . out . println ( "    " + ( ( System . currentTimeMillis ( ) - t1 ) / 1000.0 ) + "  seconds to process  " + adjFile . getCanonicalPath ( ) ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; } return ; }
private int refresh ( int playlistVersion ) throws MPDServerException { MPDStatus status = this . mpd . getStatus ( ) ; List < String > response = this . mpd . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_CHANGES , Integer . toString ( playlistVersion ) ) ; List < Music > playlist = Music . getMusicFromList ( response ) ; this . list . clear ( ) ; this . list . addAll ( playlist . subList ( 0 , status . getPlaylistLength ( ) ) ) ; return status . getPlaylistVersion ( ) ; }
public String toString ( ) { final StringBuilder buf = new StringBuilder ( "   " ) ; for ( int i = levels - 1 ; i > = showLevel ; i - - ) { if ( itemTable [ i ] ! = null & & ! itemTable [ i ] . isEmpty ( ) ) { buf . append ( " \ n --- Level  " ) . append ( ( i + 1 ) ) . append ( " : \ n " ) ; for ( final E e : itemTable [ i ] ) { buf . append ( e . toStringBrief ( ) ) . append ( '\n' ) ; } } } return buf . toString ( ) ; }
public void onConcept ( NARGraph g , Concept c ) { super . onConcept ( g , c ) ; priority = c . getPriority ( ) ; level = ( float ) ( priority * 100.0 ) ; if ( mode = = 0 ) { index = concepts . entryIndex ( c ) ; } else { if ( ( lastTerm ! = null ) & & ( c . term . equals ( lastTerm ) ) ) { lastTermVertex . position ( level , index , priority ) ; lastTermVertex . visible = false ; } else index + + ; } VertexDisplay d = updateVertex ( c ) ; d . position ( level , index , priority ) ; deadVertices . remove ( c ) ; levelContents + + ; lastTerm = null ; lastTermVertex = null ; }
private List < EventHandler > getEventHandlers ( final StatsKey key , final boolean create ) { if ( sessionEventHandlers = = null ) return null ; List < EventHandler > eventHandlers = null ; if ( key ! = null ) { eventHandlers = sessionEventHandlers . get ( key ) ; } if ( eventHandlers = = null & & create ) { eventHandlers = createEventHandlerList ( ) ; List < EventHandler > old = sessionEventHandlers . putIfAbsent ( key , eventHandlers ) ; if ( old ! = null ) { eventHandlers = old ; } } return eventHandlers ; }
public void testGetDependencies ( ) { Set < Step > steps = Sets . newHashSet ( ) ; BatchStep step1 = new BatchStep ( " step1 " , ConfigFactory . empty ( ) ) ; BatchStep step2 = new BatchStep ( " step2 " , ConfigFactory . empty ( ) ) ; BatchStep step3 = new BatchStep ( " step3 " , ConfigFactory . empty ( ) ) ; steps . add ( step1 ) ; steps . add ( step2 ) ; steps . add ( step3 ) ; step2 . setDependencyNames ( Sets . newHashSet ( " step1 " ) ) ; step3 . setDependencyNames ( Sets . newHashSet ( " step1 " , " step2 " ) ) ; Set < Step > step1Dependencies = StepUtils . getDependencies ( step1 , steps ) ; Set < Step > step2Dependencies = StepUtils . getDependencies ( step2 , steps ) ; Set < Step > step3Dependencies = StepUtils . getDependencies ( step3 , steps ) ; assertEquals ( step1Dependencies . size ( ) , 0 ) ; assertEquals ( step2Dependencies . size ( ) , 1 ) ; assertEquals ( step3Dependencies . size ( ) , 2 ) ; assertEquals ( step1Dependencies , Sets . newHashSet ( ) ) ; assertEquals ( step2Dependencies , Sets . newHashSet ( step1 ) ) ; assertEquals ( step3Dependencies , Sets . newHashSet ( step1 , step2 ) ) ; }
public View onLayoutInflation ( final Context context , final View targetView , final List < ? extends Item > items ) { targetView . findViewById ( R . id . track_artist ) . setVisibility ( mShowArtist ? View . VISIBLE : View . GONE ) ; return targetView ; }
public void testIncrWithDefTimeout ( ) { tryTimeout ( " incrWithDef " , new Runnable ( ) { public void run ( ) {
public void call ( Iterator < PlannedRow > t ) throws Exception { if ( output = = null ) { output = ( RandomOutput ) OutputFactory . create ( config ) ; } output . applyRandomMutations ( Lists . newArrayList ( t ) ) ; }
public List < String [ ] > listAlbumArtists ( List < Album > albums ) throws MPDServerException { if ( ! cacheOK ( ) ) { return super . listAlbumArtists ( albums ) ; } List < String [ ] > albumartists = new ArrayList < String [ ] > ( ) ; for ( Album a : albums ) { Artist artist = a . getArtist ( ) ; Set < String > aartists = cache . getAlbumArtists ( a . getName ( ) , ( artist = = null ? " " : artist . getName ( ) ) ) ; albumartists . add ( aartists . toArray ( new String [ 0 ] ) ) ; } return albumartists ; }
public static Translator translatorFor ( Properties props ) throws Exception { Translator translator = null ; String translatorName = props . getProperty ( " translator " ) ; if ( translatorName . equals ( " kvp " ) ) { translator = new KVPTranslator ( props ) ; } else if ( translatorName . equals ( " delimited " ) ) { translator = new DelimitedTranslator ( props ) ; } else if ( translatorName . equals ( " avro " ) ) { translator = new AvroTranslator ( props ) ; } else { Class < ? > clazz = Class . forName ( translatorName ) ; Constructor < ? > constructor = clazz . getConstructor ( ) ; translator = ( Translator ) constructor . newInstance ( props ) ; } return translator ; }
public abstract boolean contains ( T value ) ; public abstract T get ( int index ) ; public abstract int size ( ) ; public static < T > List < T > createList ( ListType type ) { switch ( type ) { case ArrayList : return new ArrayList < T > ( ) ; default : return new LinkedList < T > ( ) ; } } public static class LinkedList < T > extends List < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; @Override public void add ( T value ) { add ( new Node < T > ( value ) ) ; } private void add ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > prev = tail ; prev . nextNode = node ; node . previousNode = prev ; tail = node ; } size + + ; } @Override public boolean remove ( T value ) { Node < T > node = head ; while ( node ! = null & & ( ! node . value . equals ( value ) ) ) { node = node . nextNode ; } if ( node = = null ) return false ; if ( node . equals ( tail ) ) tail = node . previousNode ; Node < T > prev = node . previousNode ; Node < T > next = node . nextNode ; if ( prev ! = null & & next ! = null ) { prev . nextNode = next ; next . previousNode = prev ; } else if ( prev ! = null & & next = = null ) { prev . nextNode = null ; } else if ( prev = = null & & next ! = null ) { next . previousNode = null ; head = next ; } else { head = null ; } size - - ; return true ; } @Override public boolean contains ( T value ) { Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . nextNode ; } return false ; } @Override public T get ( int index ) { T result = null ; Node < T > node = head ; int i = 0 ; while ( node ! = null & & i < index ) { node = node . nextNode ; i + + ; } if ( node ! = null ) result = node . value ; return result ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . nextNode ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > previousNode = null ; private Node < T > nextNode = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( previousNode ! = null ) ? previousNode . value : " NULL " ) + "  next= " + ( ( nextNode ! = null ) ? nextNode . value : " NULL " ) ; } } } public static class ArrayList < T > extends List < T > { private static final int GROW_IN_CHUNK_SIZE = 50 ; private static final int SHRINK_IN_CHUNK_SIZE = 50 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int size = 0 ; @Override public void add ( T value ) { if ( size > = array . length ) { T [ ] temp = Arrays . copyOf ( array , size + GROW_IN_CHUNK_SIZE ) ; temp [ size + + ] = value ; array = temp ; } else { array [ size + + ] = value ; } } @Override public boolean remove ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) { for ( int j = i + 1 ; j < size ; j + + ) { array [ j - 1 ] = array [ j ] ; } array [ - - size ] = null ; if ( array . length - size > = SHRINK_IN_CHUNK_SIZE ) { T [ ] temp = Arrays . copyOf ( array , size ) ; array = temp ; } return true ; } } return false ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public T get ( int index ) { if ( index > = size ) return null ; return array [ index ] ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i + + ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } }
public int compare ( final PlaylistFile o1 , final PlaylistFile o2 ) { return StringComparators . compareNatural ( o1 . getFullPath ( ) , o2 . getFullPath ( ) ) ; }
@Override public void update ( ) { taskDerived . commit ( nar . memory . logic . d ( td , 0 ) ) ; }
public void writeAtomic ( ) throws IOException { var config = Config . inMemory ( ) ; Util . populateTest ( config ) ; Path configFile = tmp . resolve ( " config.json " ) ; Path tmpFile = tmp . resolve ( " config.json.new.tmp " ) ; assertFalse ( Files . exists ( configFile ) ) ; assertFalse ( Files . exists ( tmpFile ) ) ; new FancyJsonWriter ( ) . write ( config , configFile , WritingMode . REPLACE_ATOMIC ) ; assertFalse ( Files . exists ( tmpFile ) ) ; assertTrue ( Files . exists ( configFile ) ) ; assertEquals ( Util . EXPECTED_SERIALIZED_FANCY , Files . readString ( configFile ) ) ; new MinimalJsonWriter ( ) . write ( config , configFile , WritingMode . REPLACE_ATOMIC ) ; assertFalse ( Files . exists ( tmpFile ) ) ; assertTrue ( Files . exists ( configFile ) ) ; assertEquals ( Util . EXPECTED_SERIALIZED_MINIMAL , Files . readString ( configFile ) ) ; }
public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . browse , container , false ) ; mList = ( ListView ) view . findViewById ( R . id . list ) ; registerForContextMenu ( mList ) ; mList . setOnItemClickListener ( this ) ; mLoadingView = view . findViewById ( R . id . loadingLayout ) ; mLoadingTextView = ( TextView ) view . findViewById ( R . id . loadingText ) ; mNoResultView = view . findViewById ( R . id . noResultLayout ) ; mLoadingTextView . setText ( getLoadingText ( ) ) ; mPullToRefreshLayout = ( PullToRefreshLayout ) view . findViewById ( R . id . pullToRefresh ) ; return view ; }
public abstract boolean contains ( T value ) ; public abstract T get ( int index ) ; public abstract int size ( ) ; public static < T > List < T > createList ( ListType type ) { switch ( type ) { case ArrayList : return new ArrayList < T > ( ) ; default : return new LinkedList < T > ( ) ; } } public static class ArrayList < T > extends List < T > { private static final int GROW_IN_CHUNK_SIZE = 1000 ; private static final int SHRINK_IN_CHUNK_SIZE = 1000 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int size = 0 ; @Override public void add ( T value ) { if ( size > = array . length ) { array = Arrays . copyOf ( array , size + GROW_IN_CHUNK_SIZE ) ; } array [ size + + ] = value ; } @Override public boolean remove ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) { if ( i ! = size - 1 ) { System . arraycopy ( array , i + 1 , array , i , size - i - 1 ) ; } array [ - - size ] = null ; if ( array . length - size > = SHRINK_IN_CHUNK_SIZE ) { array = Arrays . copyOf ( array , size ) ; } return true ; } } return false ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public T get ( int index ) { if ( index > = size ) return null ; return array [ index ] ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i + + ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } public static class LinkedList < T > extends List < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; @Override public void add ( T value ) { add ( new Node < T > ( value ) ) ; } private void add ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > prev = tail ; prev . nextNode = node ; node . previousNode = prev ; tail = node ; } size + + ; } @Override public boolean remove ( T value ) { Node < T > node = head ; while ( node ! = null & & ( ! node . value . equals ( value ) ) ) { node = node . nextNode ; } if ( node = = null ) return false ; if ( node . equals ( tail ) ) tail = node . previousNode ; Node < T > prev = node . previousNode ; Node < T > next = node . nextNode ; if ( prev ! = null & & next ! = null ) { prev . nextNode = next ; next . previousNode = prev ; } else if ( prev ! = null & & next = = null ) { prev . nextNode = null ; } else if ( prev = = null & & next ! = null ) { next . previousNode = null ; head = next ; } else { head = null ; } size - - ; return true ; } @Override public boolean contains ( T value ) { Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . nextNode ; } return false ; } @Override public T get ( int index ) { T result = null ; Node < T > node = head ; int i = 0 ; while ( node ! = null & & i < index ) { node = node . nextNode ; i + + ; } if ( node ! = null ) result = node . value ; return result ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . nextNode ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > previousNode = null ; private Node < T > nextNode = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( previousNode ! = null ) ? previousNode . value : " NULL " ) + "  next= " + ( ( nextNode ! = null ) ? nextNode . value : " NULL " ) ; } } } }
public void addReceiverIDs ( @Nullable final Map < String , String > aMap ) { m_aReceiverIDs . putAllIn ( aMap ) ; }
public void testDriverMemoryClientMode ( ) { Properties props = new Properties ( ) ; props . setProperty ( Contexts . APPLICATION_SECTION_PREFIX + " . " + Contexts . SPARK_CONF_PROPERTY_PREFIX + " . " + Contexts . SPARK_DEPLOY_MODE_PROPERTY , Contexts . SPARK_DEPLOY_MODE_CLIENT ) ; props . setProperty ( Contexts . APPLICATION_SECTION_PREFIX + " . " + Contexts . DRIVER_MEMORY_PROPERTY , " 2G " ) ; Config config = ConfigFactory . parseProperties ( props ) ; Contexts . initialize ( config , Contexts . ExecutionMode . UNIT_TEST ) ; thrown . expect ( RuntimeException . class ) ; thrown . expectMessage ( " Driver memory can not be set " ) ; Contexts . getSparkSession ( ) . sparkContext ( ) . getConf ( ) ; }
static boolean isInsertionOrderPreserved ( ) { String prop = System . getProperty ( " nightconfig.preserveInsertionOrder " ) ; return ( prop ! = null ) & & ( prop . equals ( " true " ) | | prop . equals ( " 1 " ) ) ; }
public void end ( ) { mTerminated = true ; if ( isStarted ( ) ) { if ( mSortedNodes . size ( ) ! = mNodes . size ( ) ) {
protected void refreshListColorCacheHint ( ) { if ( mList ! = null ) { if ( mLightTheme ) {
void checkCloseActionMenu ( Menu menu ) { if ( mClosingActionMenu ) { return ; } mClosingActionMenu = true ; wActionBar . dismissPopupMenus ( ) ; mClosingActionMenu = false ; }
protected void assertEquivalent ( final String term1String , final String term2String ) throws IOException , InstantiationException , InvocationTargetException , NoSuchMethodException , ParserConfigurationException , IllegalAccessException , SAXException , ClassNotFoundException , ParseException { final Nar n = new Nar ( ) ; try { final Term term1 = np . parseTerm ( term1String ) ;
public void contextDestroyed ( @Nonnull final ServletContextEvent aSce ) { staticDestroy ( ) ; }
String getAttributeObject ( @Nullable String sName ) ; @Nullable String getAttributeAsString ( @Nullable String sName ) ; @Nullable String getAttributeAsString ( @Nullable String sName , @Nullable String sDefault ) ; int getAttributeAsInt ( @Nullable String sName ) ; int getAttributeAsInt ( @Nullable String sName , int nDefault ) ; long getAttributeAsLong ( @Nullable String sName ) ; long getAttributeAsLong ( @Nullable String sName , long nDefault ) ; double getAttributeAsDouble ( @Nullable String sName ) ; double getAttributeAsDouble ( @Nullable String sName , double dDefault ) ; boolean getAttributeAsBoolean ( @Nullable String sName ) ; boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; Enumeration < String > getAttributeNames ( ) ; Set < String > getAllAttributeNames ( ) ; Collection < String > getAllAttributeValues ( ) ; int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; Iterator < Entry < String , String > > iterator ( ) ; }
public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj instanceof StampedConfig ) { return bulkCommentedRead ( view - > {
public void trackChanged ( final MPDStatus mpdStatus , final int oldTrack ) { } @Override public void volumeChanged ( final MPDStatus mpdStatus , final int oldVolume ) { } }
public T cas ( final String key , final T initial , int initialExp , final CASMutation < T > m ) throws Exception { T rv = initial ; boolean done = false ; for ( int i = 0 ; ! done & & i < max ; i + + ) { CASValue < T > casval = client . gets ( key , transcoder ) ; T current = null ; if ( casval ! = null ) { T tmp = casval . getValue ( ) ; current = tmp ; } if ( current ! = null ) { assert casval ! = null : " casval was null with a current value " ; rv = m . getNewValue ( current ) ; if ( client . cas ( key , casval . getCas ( ) , rv , transcoder ) = = CASResponse . OK ) { done = true ; } } else { if ( initial = = null ) { done = true ; rv = null ; } else if ( client . add ( key , initialExp , initial , transcoder ) . get ( ) ) { done = true ; rv = initial ; } } } if ( ! done ) { throw new RuntimeException ( " Couldn't get a CAS in  " + max + "  attempts " ) ; } return rv ; }
C createConcurrentConfig ( ) ; boolean supportsComments ( ) ; default boolean supportsType ( Class < ? > type ) { return InMemoryFormat . DEFAULT_PREDICATE . test ( type ) ; } default boolean isInMemory ( ) { return false ; } }
private boolean isDragItem ( View item ) { return ( item . findViewById ( R . id . icon ) ! = null ) ; }
public void run ( ) { final int state = getRemoteState ( mpdStatus ) ; mRemoteControlClient . editMetadata ( true ) . putString ( MediaMetadataRetriever . METADATA_KEY_ALBUM , mCurrentMusic . getAlbum ( ) ) . putString ( MediaMetadataRetriever . METADATA_KEY_ALBUMARTIST , mCurrentMusic . getAlbumArtist ( ) ) . putString ( MediaMetadataRetriever . METADATA_KEY_ARTIST , mCurrentMusic . getArtist ( ) ) . putLong ( MediaMetadataRetriever . METADATA_KEY_CD_TRACK_NUMBER , ( long ) mCurrentMusic . getTrack ( ) ) . putLong ( MediaMetadataRetriever . METADATA_KEY_DISC_NUMBER , ( long ) mCurrentMusic . getDisc ( ) ) . putLong ( MediaMetadataRetriever . METADATA_KEY_DURATION , mCurrentMusic . getTime ( ) * DateUtils . SECOND_IN_MILLIS ) . putString ( MediaMetadataRetriever . METADATA_KEY_TITLE , mCurrentMusic . getTitle ( ) ) . putBitmap ( RemoteControlClient . MetadataEditor . BITMAP_KEY_ARTWORK , mAlbumCover ) . apply ( ) ; if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . JELLY_BEAN_MR2 ) { mRemoteControlClient . setPlaybackState ( state , lastKnownElapsed , 1.0f ) ; } else { mRemoteControlClient . setPlaybackState ( state ) ; } Log . d ( TAG , " Updated remote client with state  " + state + "  for music  " + mCurrentMusic ) ;
public void handle ( final String sAction , final IMessage aMsg , final Map < String , Object > aOptions ) throws OpenAS2Exception { final List < Throwable > aCauses = new ArrayList < Throwable > ( ) ; boolean bModuleFound = false ; for ( final IProcessorModule aModule : getModules ( ) ) { if ( aModule . canHandle ( sAction , aMsg , aOptions ) ) { try { bModuleFound = true ; aModule . handle ( sAction , aMsg , aOptions ) ; } catch ( final OpenAS2Exception ex ) { aCauses . add ( ex ) ; } } } if ( ! aCauses . isEmpty ( ) ) throw new ProcessorException ( this , aCauses ) ; if ( ! bModuleFound ) throw new NoModuleException ( sAction , aMsg , aOptions ) ;
protected void update ( ) { } public static void main ( String [ ] arg ) { NAR nar = new ContinuousBagNARBuilder ( true ) . setConceptBagSize ( 2048 ) . build ( ) ; new NARSwing ( nar ) ; nar . start ( 30 ) ; NARio nario = new NARio ( nar ) ; nario . TICKS_PER_SECOND = 12 ; } }
protected Map < String , Object > createMetaDataMap ( ) { return new FastPutsLinkedMap < > ( ) ; }
public V get ( K key ) { int hashedKey = hashingFunction ( key ) ; Pair < K , V > pair = array [ hashedKey ] ; if ( pair = = null ) return null ; if ( pair . key . equals ( key ) ) return pair . value ; int start = getNextIndex ( hashedKey ) ; while ( start ! = hashedKey ) { if ( start > = array . length ) { start = 0 ; if ( start = = hashedKey ) break ; } pair = array [ start ] ; if ( pair = = null ) return null ; if ( pair . key . equals ( key ) ) return pair . value ; start = getNextIndex ( start ) ; } return null ; }
public IntervalData < O > query ( long index ) { IntervalData < O > results = null ; if ( index = = center ) { for ( IntervalData < O > data : overlapStart ) { IntervalData < O > temp = data . query ( index ) ; if ( results = = null & & temp ! = null ) results = temp . copy ( ) ; else if ( temp ! = null ) results . combined ( temp ) ; } } else { for ( IntervalData < O > data : overlapStart ) { if ( data . start < = index ) { IntervalData < O > temp = data . query ( index ) ; if ( results = = null & & temp ! = null ) results = temp . copy ( ) ; else if ( temp ! = null ) results . combined ( temp ) ; } else { break ; } } } if ( index < center ) { if ( left ! = null ) { IntervalData < O > temp = left . query ( index ) ; if ( results = = null & & temp ! = null ) results = temp . copy ( ) ; else if ( temp ! = null ) results . combined ( temp ) ; } } else if ( index > center ) { if ( right ! = null ) { IntervalData < O > temp = right . query ( index ) ; if ( results = = null & & temp ! = null ) results = temp . copy ( ) ; else if ( temp ! = null ) results . combined ( temp ) ; } } return results ; }
public void setup ( ) { hsim . obj = new ArrayList < Obj > ( ) ; E = new ArrayList < link > ( ) ; E2 = new ArrayList < link > ( ) ; Sent_s = new ArrayList < Sentence > ( ) ; Sent_i = new ArrayList < Integer > ( ) ; try { Thread . sleep ( 200 ) ; } catch ( InterruptedException ex ) { } background ( 0 ) ;
public void testHashCode ( ) { final Rope r1 = Rope . build ( " alpha " ) ; final Rope r2 = Rope . build ( " beta " ) ; final Rope r3 = Rope . build ( " alpha " ) ; Assert . assertEquals ( r1 . hashCode ( ) , r3 . hashCode ( ) ) ; Assert . assertFalse ( r1 . hashCode ( ) = = r2 . hashCode ( ) ) ; }
private static void ExtractIntervals ( final Memory mem , final List < Long > ivals , final CompoundTerm comp ) { for ( int i = 0 ; i < comp . term . length ; i + + ) { final Term t = comp . term [ i ] ;
public OperationFuture < Boolean > set ( String key , int exp , Object o ) { return asyncStore ( StoreType . set , key , exp , o , transcoder ) ; }
public static boolean isPlaceHolder ( final Term t ) { if ( t . getClass ( ) ! = Term . class ) return false ; CharSequence n = t . name ( ) ; if ( n . length ( ) ! = 1 ) return false ; return n . charAt ( 0 ) = = Symbols . IMAGE_PLACE_HOLDER ; }
private boolean validate ( PatriciaTrie . Node node , String string , java . util . Set < K > keys ) { if ( ! ( node instanceof RadixNode ) ) return false ; RadixNode < K , V > tmn = ( RadixNode < K , V > ) node ; StringBuilder builder = new StringBuilder ( string ) ; builder . append ( tmn . string ) ; String s = builder . toString ( ) ; if ( tmn . type = = PatriciaTrie . WHITE ) { K k = ( K ) s ; V v = tmn . value ; if ( k = = null | | v = = null ) return false ; if ( keys . contains ( k ) ) return false ; keys . add ( k ) ; } for ( int i = 0 ; i < tmn . childrenSize ; i + + ) { PatriciaTrie . Node n = tmn . getChild ( i ) ; if ( n ! = null & & ! validate ( n , s , keys ) ) return false ; } return true ; }
private void logError ( Event event , String notifier ) { LoggerFactory . getLogger ( notifier ) . error ( event . getMessage ( ) ) ; }
public void serializeFields ( Object source , Config destination ) { SerializerContext ctx = new SerializerContext ( this , ( ) - > destination . configFormat ( ) , ( ) - > destination . createSubConfig ( ) ) ; ctx . serializeFields ( source , destination ) ; }
public boolean contains ( List < String > path ) { synchronized ( rootMonitor ) { return config . contains ( path ) ;
public void run ( ) { boolean replace = false ; boolean play = false ; switch ( itemId ) { case ADDNREPLACEPLAY : replace = true ; play = true ; break ; case ADDNREPLACE : replace = true ; break ; case ADDNPLAY : play = true ; break ; } try { app . oMPDAsyncHelper . oMPD . add ( album , replace , play ) ;
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . library_tabs ) ; tabLabels = new CharSequence [ ] { this . getString ( R . string . artists ) , this . getString ( R . string . albums ) , this . getString ( R . string . songs ) , this . getString ( R . string . files ) } ; Resources res = getResources ( ) ; TabHost tabHost = getTabHost ( ) ; tabHost . setOnTabChangedListener ( this ) ; tabHost . addTab ( tabHost . newTabSpec ( " tab_artist " ) . setIndicator ( tabLabels [ 0 ] , res . getDrawable ( R . drawable . ic_tab_artists ) ) . setContent ( new Intent ( LibraryTabActivity . this , ArtistsActivity . class ) ) ) ; tabHost . addTab ( tabHost . newTabSpec ( " tab_album " ) . setIndicator ( tabLabels [ 1 ] , res . getDrawable ( R . drawable . ic_tab_albums ) ) . setContent ( new Intent ( LibraryTabActivity . this , AlbumsActivity . class ) ) ) ; tabHost . addTab ( tabHost . newTabSpec ( " tab_songs " ) . setIndicator ( tabLabels [ 2 ] , res . getDrawable ( R . drawable . ic_tab_songs ) ) . setContent ( new Intent ( LibraryTabActivity . this , SongSearchMessageFragment . class ) ) ) ; tabHost . addTab ( tabHost . newTabSpec ( " tab_files " ) . setIndicator ( tabLabels [ 3 ] , res . getDrawable ( R . drawable . ic_tab_playlists ) ) . setContent ( new Intent ( LibraryTabActivity . this , FSActivity . class ) ) ) ; ( ( MPDApplication ) getApplication ( ) ) . setActivity ( this ) ; final View tmpView = findViewById ( R . id . compatActionbar ) ; if ( tmpView ! = null ) { compatActionBar = ( com . namelessdev . mpdroid . ActionBarLite ) tmpView ;
public boolean isUnknown ( ) { final String name = getName ( ) ; return name = = null | | name . isEmpty ( ) ; }
public final boolean isActive ( ) { return reconnectAttempt . get ( ) = = 0 & & getChannel ( ) ! = null & & getChannel ( ) . isConnected ( ) ;
public void addEntrancePi ( EntranceProcessingItem epi , TopologyStarter starter ) { this . addProcessingItem ( epi ) ; }
Enumeration < String > getAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy ICommonsOrderedSet < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy ICommonsList < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; }
public void add ( T value ) { Node < T > node = new Node < T > ( value ) ; Node < T > prev = null ; Node < T > next = null ; if ( head = = null ) { head = node ; } else { prev = null ; next = head ; while ( next ! = null ) { prev = next ; next = next . nextNode ; } if ( prev ! = null ) prev . nextNode = node ; } node . index = size ; size + + ; generateExpressLanes ( ) ; }
public void addTask ( final Task currentTask , final BudgetValue budget , final Sentence sentence , final Sentence candidateBelief ) { addTask ( new Task ( sentence , budget , currentTask , sentence , candidateBelief ) , " Activated " ) ;
public static String [ ] splitResponse ( final String line ) { final int delimiterIndex = line . indexOf ( ':' ) ; final String [ ] result = new String [ 2 ] ; if ( delimiterIndex = = - 1 ) { throw new InvalidResponseException ( " Failed to parse server response key for line:  " + line ) ; } result [ 0 ] = line . substring ( 0 , delimiterIndex ) ; result [ 1 ] = line . substring ( delimiterIndex + 2 ) ; return result ; }
public Builder mergeFrom ( com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . MultipleExample other ) { if ( other = = com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . MultipleExample . getDefaultInstance ( ) ) return this ; if ( other . hasIncludedExample ( ) ) { mergeIncludedExample ( other . getIncludedExample ( ) ) ; } this . mergeUnknownFields ( other . unknownFields ) ; onChanged ( ) ; return this ; }
public static ImageExt make ( final Term [ ] argument , final short index , final Memory memory ) { CharSequence name = makeImageName ( NativeOperator . IMAGE_EXT , argument , index ) ; Term t = memory . conceptTerm ( name ) ; return ( t ! = null ) ? ( ( ImageExt ) t ) : new ImageExt ( name , argument , index ) ; }
public void testSegmentTree ( ) { { java . util . List < SegmentTree . Data . QuadrantData > segments = new ArrayList < SegmentTree . Data . QuadrantData > ( ) ; segments . add ( new SegmentTree . Data . QuadrantData ( 0 , 1 , 0 , 0 , 0 ) ) ; segments . add ( new SegmentTree . Data . QuadrantData ( 1 , 0 , 1 , 0 , 0 ) ) ; segments . add ( new SegmentTree . Data . QuadrantData ( 2 , 0 , 0 , 1 , 0 ) ) ; segments . add ( new SegmentTree . Data . QuadrantData ( 3 , 0 , 0 , 0 , 1 ) ) ; FlatSegmentTree < SegmentTree . Data . QuadrantData > tree = new FlatSegmentTree < SegmentTree . Data . QuadrantData > ( segments ) ; SegmentTree . Data . QuadrantData query = tree . query ( 0 , 3 ) ; assertTrue ( " Quad tree query error. query=0->3 result= " + query , ( query . quad0 = = 1 & & query . quad1 = = 1 & & query . quad2 = = 1 & & query . quad3 = = 1 ) ) ; query = tree . query ( 2 , 3 ) ; assertTrue ( " Quad tree query error. query=2->3 result= " + query , ( query . quad0 = = 0 & & query . quad1 = = 0 & & query . quad2 = = 1 & & query . quad3 = = 1 ) ) ; query = tree . query ( 0 , 2 ) ; assertTrue ( " Quad tree query error. query=0->2 result= " + query , ( query . quad0 = = 1 & & query . quad1 = = 1 & & query . quad2 = = 1 & & query . quad3 = = 0 ) ) ; } { java . util . List < SegmentTree . Data . RangeMaximumData < Integer > > segments = new ArrayList < SegmentTree . Data . RangeMaximumData < Integer > > ( ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 0 , ( Integer ) 4 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 1 , ( Integer ) 2 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 2 , ( Integer ) 6 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 3 , ( Integer ) 3 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 4 , ( Integer ) 1 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 5 , ( Integer ) 5 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 6 , ( Integer ) 0 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 7 , 17 , ( Integer ) 7 ) ) ; segments . add ( new SegmentTree . Data . RangeMaximumData < Integer > ( 21 , ( Integer ) 10 ) ) ; FlatSegmentTree < SegmentTree . Data . RangeMaximumData < Integer > > tree = new FlatSegmentTree < SegmentTree . Data . RangeMaximumData < Integer > > ( segments , 3 ) ; SegmentTree . Data . RangeMaximumData < Integer > query = tree . query ( 0 , 7 ) ; assertTrue ( " Segment tree query error. query=0->7 result= " + query , query . maximum = = 7 ) ; query = tree . query ( 0 , 21 ) ; assertTrue ( " Segment tree query error. query=0->21 result= " + query , query . maximum = = 10 ) ; query = tree . query ( 2 , 5 ) ; assertTrue ( " Segment tree query error. query=2->5 result= " + query , query . maximum = = 6 ) ; query = tree . query ( 7 ) ; assertTrue ( " Segment tree query error. query=7 result= " + query , query . maximum = = 7 ) ; } { java . util . List < SegmentTree . Data . RangeMinimumData < Integer > > segments = new ArrayList < SegmentTree . Data . RangeMinimumData < Integer > > ( ) ; segments . add ( new SegmentTree . Data . RangeMinimumData < Integer > ( 0 , ( Integer ) 4 ) ) ; segments . add ( new SegmentTree . Data . RangeMinimumData < Integer > ( 1 , ( Integer ) 2 ) ) ; segments . add ( new SegmentTree . Data . RangeMinimumData < Integer > ( 2 , ( Integer ) 6 ) ) ; segments . add ( new SegmentTree . Data . RangeMinimumData < Integer > ( 3 , ( Integer ) 3 ) ) ; segments . add ( new SegmentTree . Data . RangeMinimumData < Integer > ( 4 , ( Integer ) 1 ) ) ; segments . add ( new SegmentTree . Data . RangeMinimumData < Integer > ( 5 , ( Integer ) 5 ) ) ; segments . add ( new SegmentTree . Data . RangeMinimumData < Integer > ( 6 , ( Integer ) 0 ) ) ; segments . add ( new SegmentTree . Data . RangeMinimumData < Integer > ( 17 , ( Integer ) 7 ) ) ; FlatSegmentTree < SegmentTree . Data . RangeMinimumData < Integer > > tree = new FlatSegmentTree < SegmentTree . Data . RangeMinimumData < Integer > > ( segments , 5 ) ; SegmentTree . Data . RangeMinimumData < Integer > query = tree . query ( 0 , 7 ) ; assertTrue ( " Segment tree query error. query=0->7 result= " + query , query . minimum = = 0 ) ; query = tree . query ( 0 , 17 ) ; assertTrue ( " Segment tree query error. query=0->17 result= " + query , query . minimum = = 0 ) ; query = tree . query ( 1 , 3 ) ; assertTrue ( " Segment tree query error. query=1->3 result= " + query , query . minimum = = 2 ) ; query = tree . query ( 7 ) ; assertTrue ( " Segment tree query error. query=7 result= " + query , query . minimum = = null ) ; } { java . util . List < SegmentTree . Data . RangeSumData < Integer > > segments = new ArrayList < SegmentTree . Data . RangeSumData < Integer > > ( ) ; segments . add ( new SegmentTree . Data . RangeSumData < Integer > ( 0 , ( Integer ) 4 ) ) ; segments . add ( new SegmentTree . Data . RangeSumData < Integer > ( 1 , ( Integer ) 2 ) ) ; segments . add ( new SegmentTree . Data . RangeSumData < Integer > ( 2 , ( Integer ) 6 ) ) ; segments . add ( new SegmentTree . Data . RangeSumData < Integer > ( 3 , ( Integer ) 3 ) ) ; segments . add ( new SegmentTree . Data . RangeSumData < Integer > ( 4 , ( Integer ) 1 ) ) ; segments . add ( new SegmentTree . Data . RangeSumData < Integer > ( 5 , ( Integer ) 5 ) ) ; segments . add ( new SegmentTree . Data . RangeSumData < Integer > ( 6 , ( Integer ) 0 ) ) ; segments . add ( new SegmentTree . Data . RangeSumData < Integer > ( 17 , ( Integer ) 7 ) ) ; FlatSegmentTree < SegmentTree . Data . RangeSumData < Integer > > tree = new FlatSegmentTree < SegmentTree . Data . RangeSumData < Integer > > ( segments , 10 ) ; SegmentTree . Data . RangeSumData < Integer > query = tree . query ( 0 , 8 ) ; assertTrue ( " Segment tree query error. query=0->8 result= " + query , query . sum = = 21 ) ; query = tree . query ( 0 , 17 ) ; assertTrue ( " Segment tree query error. query=0->17 result= " + query , query . sum = = 28 ) ; query = tree . query ( 2 , 5 ) ; assertTrue ( " Segment tree query error. query=2->5 result= " + query , query . sum = = 15 ) ; query = tree . query ( 10 , 17 ) ; assertTrue ( " Segment tree query error. query=10->17 result= " + query , query . sum = = 7 ) ; query = tree . query ( 16 ) ; assertTrue ( " Segment tree query error. query=16 result= " + query , query . sum = = null ) ; query = tree . query ( 17 ) ; assertTrue ( " Segment tree query error. query=17 result= " + query , query . sum = = 7 ) ; } { final String RED = " RED " ; final String ORANGE = " ORANGE " ; final String GREEN = " GREEN " ; final String DARK_GREEN = " DARK_GREEN " ; final String BLUE = " BLUE " ; final String PURPLE = " PURPLE " ; final String BLACK = " BLACK " ; java . util . List < SegmentTree . Data . IntervalData < String > > segments = new ArrayList < SegmentTree . Data . IntervalData < String > > ( ) ; segments . add ( ( new SegmentTree . Data . IntervalData < String > ( 2 , 6 , RED ) ) ) ; segments . add ( ( new SegmentTree . Data . IntervalData < String > ( 3 , 5 , ORANGE ) ) ) ; segments . add ( ( new SegmentTree . Data . IntervalData < String > ( 4 , 11 , GREEN ) ) ) ; segments . add ( ( new SegmentTree . Data . IntervalData < String > ( 5 , 10 , DARK_GREEN ) ) ) ; segments . add ( ( new SegmentTree . Data . IntervalData < String > ( 8 , 12 , BLUE ) ) ) ; segments . add ( ( new SegmentTree . Data . IntervalData < String > ( 9 , 14 , PURPLE ) ) ) ; segments . add ( ( new SegmentTree . Data . IntervalData < String > ( 13 , 15 , BLACK ) ) ) ; DynamicSegmentTree < SegmentTree . Data . IntervalData < String > > tree = new DynamicSegmentTree < SegmentTree . Data . IntervalData < String > > ( segments ) ; SegmentTree . Data . IntervalData < String > query = tree . query ( 2 ) ; assertTrue ( " Segment tree query error. query=2 result= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( RED ) ) ) ; query = tree . query ( 4 ) ; assertTrue ( " Segment tree query error. query=4 result= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( RED , ORANGE , GREEN ) ) ) ; query = tree . query ( 9 ) ; assertTrue ( " Segment tree query error. query=9 result= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( GREEN , DARK_GREEN , BLUE , PURPLE ) ) ) ; query = tree . query ( 1 , 16 ) ; assertTrue ( " Segment tree query error. query=1->16 result= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( RED , ORANGE , GREEN , DARK_GREEN , BLUE , PURPLE , BLACK ) ) ) ; query = tree . query ( 7 , 14 ) ; assertTrue ( " Segment tree query error. query=7->14 result= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( GREEN , DARK_GREEN , BLUE , PURPLE , BLACK ) ) ) ; query = tree . query ( 14 , 15 ) ; assertTrue ( " Segment tree query error. query=14->15 result= " + query , collectionsEqual ( query . getData ( ) , Arrays . asList ( PURPLE , BLACK ) ) ) ; } { final String stravinsky = " Stravinsky " ;
public boolean contains ( K key ) { int hashedKey = hashingFunction ( key ) ; List < Pair < K , V > > list = map [ hashedKey ] ; for ( Pair < K , V > pair : list ) { if ( pair . key . equals ( key ) ) return true ; } return false ; }
public static double score ( NAR nn , int maxCycles ) { Parameters . THREADS = 1 ; nextNAR = nn ; requireSuccess = false ; showFail = false ; showSuccess = false ; saveSimilar = false ; showReport = false ; final Collection c = NALTest . params ( ) ; NAR n = nextNAR ; double score = 0 ; for ( Object o : c ) { String examplePath = ( String ) ( ( Object [ ] ) o ) [ 0 ] ; NALTest . saveSimilar = false ; Memory . resetStatic ( ) ; n . reset ( ) ; if ( maxCycles ! = - 1 ) { n . on ( Events . CycleEnd . class , new EventEmitter . EventObserver ( ) { @Override public void event ( Class event , Object [ ] arguments ) { if ( n . time ( ) > maxCycles ) { n . stop ( ) ; } } } ) ; } double s = new NALTestScore ( examplePath ) . run ( ) ; if ( s = = Double . POSITIVE_INFINITY ) s = maxCycles + 1 ; score + = s ; } return score ;
Map < String , Object > valueMap ( ) ; @Override Set < ? extends Entry > entrySet ( ) ; interface Entry extends UnmodifiableConfig . Entry { < T > T setValue ( Object value ) ; } static Config of ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format ) ; } static Config inMemory ( ) { return new SimpleConfig ( InMemoryFormat . defaultInstance ( ) ) ; } static Config wrap ( Map < String , Object > map , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( map , format ) ; } static Config copy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) ) ; } static Config copy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( config , format ) ; } }
public CachedData encode ( Object o ) { return new CachedData ( 0 , String . valueOf ( o ) . getBytes ( ) ) ; }
public abstract void select ( ) ; public abstract Tab setContentDescription ( int resId ) ; public abstract Tab setContentDescription ( CharSequence contentDesc ) ; public abstract CharSequence getContentDescription ( ) ; } public interface TabListener { public void onTabSelected ( Tab tab , FragmentTransaction ft ) ; public void onTabUnselected ( Tab tab , FragmentTransaction ft ) ; public void onTabReselected ( Tab tab , FragmentTransaction ft ) ; } public static class LayoutParams extends MarginLayoutParams { private static final int [ ] ATTRS = new int [ ] { android . R . attr . layout_gravity } ; @ViewDebug.ExportedProperty ( mapping = { @ViewDebug.IntToString ( from = - 1 , to = " NONE " ) , @ViewDebug.IntToString ( from = Gravity . NO_GRAVITY , to = " NONE " ) , @ViewDebug.IntToString ( from = Gravity . TOP , to = " TOP " ) , @ViewDebug.IntToString ( from = Gravity . BOTTOM , to = " BOTTOM " ) , @ViewDebug.IntToString ( from = Gravity . LEFT , to = " LEFT " ) , @ViewDebug.IntToString ( from = Gravity . RIGHT , to = " RIGHT " ) , @ViewDebug.IntToString ( from = Gravity . CENTER_VERTICAL , to = " CENTER_VERTICAL " ) , @ViewDebug.IntToString ( from = Gravity . FILL_VERTICAL , to = " FILL_VERTICAL " ) , @ViewDebug.IntToString ( from = Gravity . CENTER_HORIZONTAL , to = " CENTER_HORIZONTAL " ) , @ViewDebug.IntToString ( from = Gravity . FILL_HORIZONTAL , to = " FILL_HORIZONTAL " ) , @ViewDebug.IntToString ( from = Gravity . CENTER , to = " CENTER " ) , @ViewDebug.IntToString ( from = Gravity . FILL , to = " FILL " ) } ) public int gravity = - 1 ; public LayoutParams ( Context c , AttributeSet attrs ) { super ( c , attrs ) ; TypedArray a = c . obtainStyledAttributes ( attrs , ATTRS ) ; gravity = a . getInt ( 0 , - 1 ) ; a . recycle ( ) ; } public LayoutParams ( int width , int height ) { super ( width , height ) ; this . gravity = Gravity . CENTER_VERTICAL | Gravity . LEFT ; } public LayoutParams ( int width , int height , int gravity ) { super ( width , height ) ; this . gravity = gravity ; } public LayoutParams ( int gravity ) { this ( WRAP_CONTENT , FILL_PARENT , gravity ) ; } public LayoutParams ( LayoutParams source ) { super ( source ) ; this . gravity = source . gravity ; } public LayoutParams ( ViewGroup . LayoutParams source ) { super ( source ) ; } } }
final public static Term make ( final Term [ ] argList , final int temporalOrder , final boolean spatial ) { if ( Parameters . DEBUG ) { Terms . verifyNonNull ( argList ) ; } if ( argList . length = = 0 ) { return null ; } if ( argList . length = = 1 ) { return argList [ 0 ] ; } if ( temporalOrder = = TemporalRules . ORDER_FORWARD ) { final Term [ ] newArgList = spatial ? argList : collapseIntervals ( flatten ( argList , temporalOrder , spatial ) ) ;
public void cancelEditing ( ) { TableCellEditor editor = getCellEditor ( ) ; if ( editor ! = null ) { editor . cancelCellEditing ( ) ;
private void initializeMap ( ) { array = new LinkedList [ hashingKey . intValue ( ) ] ; for ( int i = 0 ; i < array . length ; i + + ) { array [ i ] = new LinkedList < Pair < K , V > > ( ) ; } size = 0 ; }
public Dataset < Row > translate ( JavaRDD raw ) { StreamInput streamInput = ( StreamInput ) getInput ( true ) ; TranslateFunction translateFunction = getTranslateFunction ( config , true ) ; JavaRDD < Row > encoded = raw . map ( streamInput . getMessageEncoderFunction ( ) ) ; TranslationResults translationResults = new TranslationResults ( encoded . flatMap ( translateFunction ) , translateFunction . getProvidingSchema ( ) , streamInput . getProvidingSchema ( ) ) ; BatchStep errored = createErrorStep ( getName ( ) + DEFAULT_ERROR_DATAFRAME_SUFFIX , translationResults . getErrored ( ) ) ; addNewBatchStep ( errored ) ; Dataset < Row > translated = translationResults . getTranslated ( ) ; if ( doesRepartition ( ) ) { translated = translated . repartition ( config . getInt ( REPARTITION_NUM_PARTITIONS_PROPERTY ) ) ; } return translated ; }
public void testReset ( ) { writeSimpleFiles ( BASE_DIR , " txt " , NUM_FILES_IN_DIR ) ; streamSource . init ( BASE_DIR , " txt " ) ; InputStream firstInStream = streamSource . getNextInputStream ( ) ; String firstInput = null ; assertNotNull ( " Unexpected end of input stream list. " , firstInStream ) ; BufferedReader rd1 = new BufferedReader ( new InputStreamReader ( firstInStream ) ) ; try { firstInput = rd1 . readLine ( ) ; } catch ( IOException ioe ) { fail ( " Fail reading from stream at index:0 " + ioe . getMessage ( ) ) ; } streamSource . getNextInputStream ( ) ; try { streamSource . reset ( ) ; } catch ( IOException ioe ) { fail ( " Fail resetting stream source. " + ioe . getMessage ( ) ) ; } InputStream inStream = streamSource . getNextInputStream ( ) ; assertNotNull ( " Unexpected end of input stream list. " , inStream ) ; BufferedReader rd2 = new BufferedReader ( new InputStreamReader ( inStream ) ) ; String inputRead = null ; try { inputRead = rd2 . readLine ( ) ; } catch ( IOException ioe ) { fail ( " Fail reading from stream at index:0 " + ioe . getMessage ( ) ) ; } assertEquals ( " File content is incorrect. " , firstInput , inputRead ) ; }
Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }
public static boolean isServerLocalhost ( ) { return " 127.0.0.1 " . equals ( app . oMPDAsyncHelper . getConnectionSettings ( ) . sServer ) ; }
public void removeStatusChangeListener ( StatusChangeListener listener ) { statusChangedListeners . remove ( listener ) ; }
void updateMessageID ( ) ; @Nonnull @ReturnsMutableObject ( " Design " ) Partnership getPartnership ( ) ; void setPartnership ( @Nonnull Partnership aPartnership ) ; }
public void testIntervalSegmentTree5 ( ) { List < SegmentTree . Data . IntervalData < String > > intervals = new ArrayList < SegmentTree . Data . IntervalData < String > > ( ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 17 , 19 , " a " ) ) ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 5 , 11 , " b " ) ) ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 23 , 23 , " c " ) ) ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 4 , 8 , " d " ) ) ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 15 , 18 , " e " ) ) ) ; intervals . add ( ( new SegmentTree . Data . IntervalData < String > ( 7 , 10 , " f " ) ) ) ; DynamicSegmentTree < SegmentTree . Data . IntervalData < String > > tree = new DynamicSegmentTree < SegmentTree . Data . IntervalData < String > > ( intervals ) ; SegmentTree . Data . IntervalData < String > query = tree . query ( 14 , 16 ) ; assertTrue ( " Segment Tree query error. returned= " + query , tree , collectionsEqual ( query . getData ( ) , Arrays . asList ( " e " ) ) ) ; query = tree . query ( 12 , 14 ) ; assertTrue ( " Segment Tree query error. returned= " + query , tree , collectionsEqual ( query . getData ( ) , Arrays . asList ( ) ) ) ; }
Partnership getPartnership ( ) ; void setText ( String text ) ; String getText ( ) ; void addHeader ( String key , String value ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; }
int AddTemplate ( String name , Point [ ] points ) { Templates = ( Template [ ] ) append ( Templates , new Template ( name , points ) ) ; int num = 0 ; for ( int i = 0 ; i < Templates . length ; i + + ) { if ( Templates [ i ] . Name = = name ) { num + + ; } } return num ; }
public String toString ( ) { if ( channel instanceof Class ) return ( ( Class ) channel ) . getSimpleName ( ) + " :  " + Arrays . toString ( signal ) ; return channel + " :  " + Arrays . toString ( signal ) ; }
< T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
void processPauseRequest ( ) { sendSimpleMpdCommand ( ACTION_PAUSE ) ; updatePlayingInfo ( RemoteControlClient . PLAYSTATE_PAUSED ) ; }
public static < T extends Comparable < T > > T [ ] sort ( int [ ] shells , T [ ] unsorted ) { List < List < T > > subarrays = null ; for ( int gap : shells ) { subarrays = new ArrayList < List < T > > ( gap ) ; for ( int i = 0 ; i < gap ; i + + ) { subarrays . add ( new ArrayList < T > ( 10 ) ) ; } T v = null ; for ( int i = 0 ; i < unsorted . length ; i + + ) { for ( int j = 0 ; j < gap ; j + + ) { if ( i > = unsorted . length ) continue ; v = unsorted [ i + + ] ; List < T > list = subarrays . get ( j ) ; list . add ( v ) ; } } sortSubarrays ( subarrays ) ; int k = 0 ; int iter = 0 ; while ( k < unsorted . length ) { for ( int j = 0 ; j < gap ; j + + ) { if ( k > = unsorted . length ) continue ; unsorted [ k + + ] = subarrays . get ( j ) . get ( iter ) ; } iter + + ; } } return unsorted ; }
public void initialize ( ) { ByteBuffer b = ByteBuffer . allocate ( KeyUtil . getKeyBytes ( key ) . length + OVERHEAD ) ; setArguments ( b , " delete " , key ) ; b . flip ( ) ; setBuffer ( b ) ; }
private byte [ ] exclusiveStopRow ( byte [ ] startRow ) { byte [ ] stopRow = startRow . clone ( ) ; for ( int i = stopRow . length - 1 ; i > = 0 ; i - - ) { if ( stopRow [ i ] < 255 ) { stopRow [ i ] + = 1 ; return stopRow ; } stopRow [ i ] = 0 ; if ( i = = 0 ) { return HConstants . EMPTY_BYTE_ARRAY ; } } return stopRow ; }
boolean isActive ( ) ; boolean isAuthenticated ( ) ; long lastReadDelta ( ) ; void completedRead ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; }
public void onSaveInstanceState ( final Bundle outState ) { outState . putParcelable ( EXTRA_ALBUM , mAlbum ) ; super . onSaveInstanceState ( outState ) ; }
public CharsWrapper read ( int n ) { final char [ ] array = new char [ n ] ; final int offset = Math . min ( deque . size ( ) , n ) ; for ( int i = 0 ; i < offset ; i + + ) { int next = deque . removeFirst ( ) ; if ( next = = EOS ) { return new CharsWrapper ( array , 0 , i ) ; } array [ i ] = ( char ) next ; } int nRead ; try { nRead = reader . read ( array , offset , n - offset ) ; } catch ( IOException e ) { throw ParsingException . readFailed ( e ) ; } return new CharsWrapper ( array , 0 , offset + nRead ) ; }
public void testStupidlyLargeSet ( ) throws Exception { Random r = new Random ( ) ; SerializingTranscoder st = new SerializingTranscoder ( ) ; st . setCompressionThreshold ( Integer . MAX_VALUE ) ; byte data [ ] = new byte [ 10 * 1024 * 1024 ] ; r . nextBytes ( data ) ; try { client . set ( " bigassthing " , 60 , data , st ) . get ( ) ; fail ( " Didn't fail setting bigass thing. " ) ; } catch ( IllegalArgumentException e ) { assertEquals ( " Cannot cache data larger than 1MB  " + " (you tried to cache a  " + data . length + "  byte object) " , e . getMessage ( ) ) ; } client . set ( " k " , 5 , " Blah " ) ; assertEquals ( " Blah " , client . get ( " k " ) ) ; }
public ArrayList instantiatePredVars ( KB kb ) { ArrayList ans = new ArrayList ( ) ; try { if ( this . listP ( ) ) { String arg0 = this . getArgument ( 0 ) ; if ( isLogicalOperator ( arg0 ) & & this . theFormula . matches ( " .* \\ ( \\ s* \\ ?.* " ) ) { List indexedQueryLits = this . prepareIndexedQueryLiterals ( kb ) ; if ( indexedQueryLits = = null ) { ans . add ( this ) ; } else { List substForms = new ArrayList ( ) ; List varQueryTuples = null ; List substTuples = null ; List litsToRemove = null ; Iterator it1 = indexedQueryLits . iterator ( ) ; while ( it1 . hasNext ( ) ) { varQueryTuples = ( List ) it1 . next ( ) ; substTuples = computeSubstitutionTuples ( kb , varQueryTuples ) ; if ( ( substTuples instanceof List ) & & ! ( substTuples . isEmpty ( ) ) ) { if ( substForms . isEmpty ( ) ) { substForms . add ( substTuples ) ; } else { int stSize = substTuples . size ( ) ; int iSize = - 1 ; int sfSize = substForms . size ( ) ; int sfLast = ( sfSize - 1 ) ; for ( int i = 0 ; i < sfSize ; i + + ) { iSize = ( ( List ) substForms . get ( i ) ) . size ( ) ; if ( stSize < iSize ) { substForms . add ( i , substTuples ) ; break ; } if ( i = = sfLast ) { substForms . add ( substTuples ) ; } } } } } if ( ! substForms . isEmpty ( ) ) { Formula f = this ; it1 = substForms . iterator ( ) ; Iterator it2 = null ; while ( it1 . hasNext ( ) ) { substTuples = ( List ) it1 . next ( ) ; litsToRemove = ( List ) substTuples . get ( 0 ) ; it2 = litsToRemove . iterator ( ) ; while ( it2 . hasNext ( ) ) { List lit = ( List ) it2 . next ( ) ; f = f . maybeRemoveMatchingLits ( lit ) ; } } List templates = new ArrayList ( ) ; templates . add ( f . theFormula ) ; Set accumulator = new HashSet ( ) ; String template = null ; String var =   null ; String term = null ; ArrayList quantVars = null ; int i = 0 ; it1 = substForms . iterator ( ) ; while ( it1 . hasNext ( ) ) { substTuples = ( List ) it1 . next ( ) ; if ( ( substTuples instanceof List ) & & ! ( substTuples . isEmpty ( ) ) ) { litsToRemove = ( List ) substTuples . remove ( 0 ) ; List varTuple = ( List ) substTuples . remove ( 0 ) ; it2 = substTuples . iterator ( ) ; while ( it2 . hasNext ( ) ) { List groundLit = ( List ) it2 . next ( ) ; Iterator it3 = templates . iterator ( ) ; while ( it3 . hasNext ( ) ) { template = ( String ) it3 . next ( ) ; quantVars = collectQuantifiedVariables ( template ) ; for ( i = 0 ; i < varTuple . size ( ) ; i + + ) { var =   ( String ) varTuple . get ( i ) ; if ( isVariable ( var ) ) { term = ( String ) groundLit . get ( i ) ; if ( ! quantVars . contains ( var ) ) { List patternStrings = Arrays . asList ( " ( \\ W* \\ ()( \\ s*holds \\ s+ \\ " + var +   " ) ( \ \ W + ) " ,
                                                                          //  " ( \ \ W * \ \ ( ) ( \ \ s * \ \ "  + var +  " ) ( \ \ W + ) " ,
                                                                           " ( \ \ W * ) ( \ \ "  + var +  " ) ( \ \ W + ) "  
                                                                          );
                                                        List patterns = new ArrayList();
                                                        for (int j = 0; j < patternStrings.size(); j++) {
                                                            patterns.add(Pattern.compile((String)(patternStrings.get(j))));
                                                        }
                                                        Pattern p = null;
                                                        Matcher m = null;
                                                        for (int j = 0 ; j < patterns.size() ; j++) {
                                                            p = (Pattern) patterns.get(j);
                                                            m = p.matcher(template);
                                                            template = m.replaceAll( " $1 "  + term +  " $3 " );
                                                        }
                                                    }
                                                }
                                            }
                                            accumulator.add(template);
                                        }
                                    }
                                    templates.clear();
                                    templates.addAll(accumulator);
                                    accumulator.clear();
                                }
                            }
                            ans.addAll(KB.stringsToFormulas(templates));
                        }
                        if (ans.isEmpty()) {
                            ans.add( " reject " );
                        }
                    }

                    //         System.out.println( " INFO in instantiatePredVars ( "  + this +  " ) " );
                    //         System.out.println( " - > "  
                    //                     + ((ans.size() > 20) 
                    //                     ? (ans.subList(0, 5) +  " and "  + (ans.size() - 5) +  " more . . . " )
                    //                     : ans));

                }
            }
        }
        catch (Exception ex) {
            ex.printStackTrace();
        }
        return ans;
    }

public String register ( String clientID ) { String request = " <QUERIES><QUERY CMD= \" REGISTER \" ><CLIENT> " + clientID + " </CLIENT></QUERY></QUERIES> " ; String response = this . executePostRequest ( mApiUrl , request ) ; return extractUserID ( response ) ; }
public void invalidCommand ( ) throws Exception { Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( MorphlineTranslator . ENCODING_KEY , " UTF-8 " ) ; configMap . put ( MorphlineTranslator . ENCODING_MSG , " UTF-8 " ) ; configMap . put ( MorphlineTranslator . MORPHLINE , getResourcePath ( MORPHLINE_FILE ) ) ; configMap . put ( MorphlineTranslator . MORPHLINE_ID , " invalid-command " ) ; configMap . put ( MorphlineTranslator . SCHEMA_CONFIG + " . " + ComponentFactory . TYPE_CONFIG_NAME , " flat " ) ; configMap . put ( MorphlineTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_NAMES_CONFIG , Lists . newArrayList ( " int " , " str " , " float " ) ) ; configMap . put ( MorphlineTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_TYPES_CONFIG , Lists . newArrayList ( " integer " , " string " , " float " ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; translator . configure ( config ) ; Row raw = TestingMessageFactory . get ( " The Key " , DataTypes . StringType , " The Message " , DataTypes . StringType ) ; translator . translate ( raw ) ; }
public void testFindReplaceStringValues ( ) { Config baseConfig = ConfigFactory . parseString ( " a: ${replaceme}, b:  \" ${replaceme} \" ,  " + " c: [${replaceme},  \" hello \" , ${replaceme}], d: [ \" ${replaceme} \" ,  \" world \" ,  " + " \" ${replaceme} \" ], e: { f:  \" ${replaceme} \" , g: [ \" ${replaceme} \" ] } " ) ; Config resolvedConfig = baseConfig . resolveWith ( ConfigFactory . empty ( ) . withValue ( " replaceme " , ConfigValueFactory . fromAnyRef ( " REPLACED " ) ) ) ; Config replacedConfig = ConfigUtils . findReplaceStringValues ( resolvedConfig , " \\ $ \\ {replaceme \\ } " , " REPLACED " ) ; assertEquals ( replacedConfig . getString ( " a " ) , " REPLACED " ) ; assertEquals ( replacedConfig . getString ( " b " ) , " REPLACED " ) ; assertEquals ( replacedConfig . getStringList ( " c " ) . get ( 0 ) , " REPLACED " ) ; assertEquals ( replacedConfig . getStringList ( " c " ) . get ( 1 ) , " hello " ) ; assertEquals ( replacedConfig . getStringList ( " c " ) . get ( 2 ) , " REPLACED " ) ; assertEquals ( replacedConfig . getStringList ( " d " ) . get ( 0 ) , " REPLACED " ) ; assertEquals ( replacedConfig . getStringList ( " d " ) . get ( 1 ) , " world " ) ; assertEquals ( replacedConfig . getStringList ( " d " ) . get ( 2 ) , " REPLACED " ) ; assertEquals ( replacedConfig . getConfig ( " e " ) . getString ( " f " ) , " REPLACED " ) ; assertEquals ( replacedConfig . getConfig ( " e " ) . getStringList ( " g " ) . get ( 0 ) , " REPLACED " ) ; }
private void testValuesOrder ( Config config ) { LinkedHashMap < String , String > mappings = new LinkedHashMap < > ( ) ; for ( int i = 25 ; i > = 0 ; i - - ) { mappings . put ( Character . toString ( ( char ) ( 'a' + i ) ) , Character . toString ( ( char ) ( 'z' - i ) ) ) ; } for ( Entry < String , String > e : mappings . entrySet ( ) ) { config . set ( e . getKey ( ) , e . getValue ( ) ) ; } List < Entry < String , String > > input = new ArrayList < > ( mappings . entrySet ( ) ) ; List < Entry < String , Object > > output = new ArrayList < > ( config . valueMap ( ) . entrySet ( ) ) ; assertEquals ( input . size ( ) , output . size ( ) ) ; for ( int i = 0 ; i < input . size ( ) ; i + + ) { assertEquals ( input . get ( i ) , output . get ( i ) , " Map values mismatched at index:  " + i ) ;
public void testGet ( ) { ( new GetOperationImpl ( " key " , null ) ) . toString ( ) ; }
public static void InternalExperienceFromTask ( Memory memory , Task task , boolean full ) { if ( ! OLD_BELIEVE_WANT_EVALUATE_WONDER_STRATEGY ) { InternalExperienceFromTaskInternal ( memory , task , full ) ;
public void test_expression_comparison_2_10 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch('>'(1, X), error(instantiation_error, instantiation_error(Goal, ArgNo)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " expression_greater_than " , new Int ( 1 ) , new Var ( " X " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 2 ) ; }
public Builder mergeFrom ( com . cloudera . labs . envelope . input . translate . ProtobufMultipleMessage . MultipleExample other ) { if ( other = = com . cloudera . labs . envelope . input . translate . ProtobufMultipleMessage . MultipleExample . getDefaultInstance ( ) ) return this ; if ( other . hasIncludedExample ( ) ) { mergeIncludedExample ( other . getIncludedExample ( ) ) ; } this . mergeUnknownFields ( other . unknownFields ) ; onChanged ( ) ; return this ; }
private static void componentAndStatement ( CompoundTerm compound , short index , Statement statement , short side , NAL nal ) { if ( statement instanceof Inheritance ) { StructuralRules . structuralDecompose1 ( compound , index , statement , nal ) ;
public boolean waitMsg ( Term msg ) { msgs . wait ( msg , mediator , this ) ; return true ; }
public void configureWrongTypeFilepath ( ) { Map < String , Object > configMap = new HashMap < > ( ) ; configMap . put ( SchemaFactory . TYPE_CONFIG_NAME , " protobuf " ) ; configMap . put ( ProtobufSchema . DESCRIPTOR_FILEPATH_CONFIG , new HashMap < > ( ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; ProtobufSchema schema = new ProtobufSchema ( ) ; assertValidationFailures ( schema , config ) ; }
public List < Album > getAlbums ( Artist artist , boolean trackCountNeeded ) throws MPDServerException { List < String > albumNames = null ; List < Album > albums = null ; final Artist unknownArtist = new UnknownArtist ( ) ; if ( artist ! = null ) { albumNames = listAlbums ( artist . getName ( ) , useAlbumArtist ) ; } else { albumNames = listAlbums ( false ) ; artist = unknownArtist ; } if ( null ! = albumNames & & ! albumNames . isEmpty ( ) ) { albums = new ArrayList < Album > ( ) ; for ( String album : albumNames ) { if ( album = = " " ) { albums . add ( new UnknownAlbum ( ) ) ; } else { long songCount = 0 ; long duration = 0 ; long year = 0 ; if ( unknownArtist ! = artist & & ( ( MPD . showAlbumTrackCount ( ) & & trackCountNeeded ) | | MPD . sortAlbumsByYear ( ) ) ) { try { Long [ ] albumDetails = getAlbumDetails ( artist . getName ( ) , album , MPD . useAlbumArtist ( ) ) ; if ( null ! = albumDetails & & 3 = = albumDetails . length ) { songCount = albumDetails [ 0 ] ; duration = albumDetails [ 1 ] ; year = albumDetails [ 2 ] ; } } catch ( MPDServerException e ) { } } albums . add ( new Album ( album , songCount , duration , year , artist . getName ( ) ) ) ; } } } if ( null ! = albums ) { Collections . sort ( albums ) ; } return albums ; }
public Stream < ExternalV > parallelStream ( ) { return internalCollection . parallelStream ( ) . map ( readTransformation ) ; }
public void gotData ( List < View > v ) { views = v ; }
public void decPriority ( final float v ) { setPriority ( and ( priority , v ) ) ; }
public Component getTreeCellEditorComponent ( JTree tree , Object value , boolean selected , boolean expanded , boolean leaf , int row ) { return getEditor ( value ) ; }
public boolean isForceVerify ( ) { return " true " . equals ( getAttribute ( CPartnershipIDs . PA_FORCE_VERIFY ) ) ; }
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { Term t1 = args [ 0 ] ; float priority = operation . getTask ( ) . budget . getPriority ( ) ; String command = " " ; if ( args . length = = 1 + 1 ) { command = t1 . name ( ) . toString ( ) ; } if ( args . length = = 2 + 1 ) { Term t2 = args [ 1 ] ; command = t1 . name ( ) . toString ( ) + " , " + t2 . name ( ) . toString ( ) ; } else if ( args . length = = 3 + 1 ) { Term t2 = args [ 1 ] ; Term t3 = args [ 2 ] ; command = t1 . name ( ) . toString ( ) + " , " + t2 . name ( ) . toString ( ) + " , " + t3 . name ( ) . toString ( ) ; } switch ( command ) { case " right " : rotateRelative ( - 10 ) ; break ; case " right,right " : rotateRelative ( - 20 ) ; break ; case " left " : rotateRelative ( 10 ) ; break ; case " left,left " : rotateRelative ( 20 ) ; break ; case " forward,forward " : thrustRelative ( 3 ) ; break ; case " forward " : thrustRelative ( 1 ) ; break ; case " reverse " : thrustRelative ( - 1 ) ; break ; case " stop " : rover . stop ( ) ; break ; case " random " : randomAction ( ) ; break ; } return null ; }
public void addOnCloseHandler ( Object obj , String methodName ) { try { closeHandlerObject = obj ;
public CachedData encode ( String o ) { return new CachedData ( FLAGS , o . getBytes ( ) , getMaxSize ( ) ) ; }
public String getAsString ( ) { return getAsString ( getAction ( ) , getMsg ( ) , getOptions ( ) ) ; }
private static KdNode createNode ( List < XYZPoint > list , int k , int depth ) { if ( list = = null | | list . size ( ) = = 0 ) return null ; int axis = depth % k ; if ( axis = = X_AXIS ) Collections . sort ( list , X_COMPARATOR ) ; else Collections . sort ( list , Y_COMPARATOR ) ; int mediaIndex = list . size ( ) / 2 ; KdNode node = new KdNode ( k , depth , list . get ( mediaIndex ) ) ; if ( list . size ( ) > 0 ) { if ( ( mediaIndex - 1 ) > = 0 ) { List < XYZPoint > less = list . subList ( 0 , mediaIndex ) ; if ( less . size ( ) > 0 ) { node . lesser = createNode ( less , k , depth + 1 ) ; node . lesser . parent = node ; } } if ( ( mediaIndex + 1 ) < = ( list . size ( ) - 1 ) ) { List < XYZPoint > more = list . subList ( mediaIndex + 1 , list . size ( ) ) ; if ( more . size ( ) > 0 ) { node . greater = createNode ( more , k , depth + 1 ) ; node . greater . parent = node ; } } } return node ; }
@Override public void cell ( Cell c , float px , float py ) { switch ( c . material ) { case StoneWall :
public void remove ( ) { synchronized ( LOCK ) { this . checkConcurrentModification ( ) ;
public void removeWatch ( Path file ) { Path dir = file . getParent ( ) ; WatchedDir watchedDir = watchedDirs . get ( dir ) ; int remainingChildCount = watchedDir . watchedFileCount . decrementAndGet ( ) ; if ( remainingChildCount = = 0 ) { watchedDirs . remove ( dir ) ; } WatchedFile watchedFile = watchedFiles . remove ( file ) ; if ( watchedFile ! = null ) { watchedFile . watchKey . cancel ( ) ;
NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
private void rebuildWorkArea ( ) { panel_workArea . removeAll ( ) ; if ( maximizedRecord = = null ) { panel_workArea . add ( root . getComponent ( ) , BorderLayout . CENTER ) ; } else { DockingRegionMaximized panel = new DockingRegionMaximized ( maximizedRecord ) ; panel_workArea . add ( panel , BorderLayout . CENTER ) ; } revalidate ( ) ; repaint ( ) ; }
public static boolean hasStreamingStep ( Set < Step > steps ) { for ( Step step : steps ) { if ( step instanceof StreamingStep ) { return true ; } } return false ; }
public boolean contains ( T value ) ; public int size ( ) ; public boolean validate ( ) ; public java . util . Set < T > toSet ( ) ; public java . util . Collection < T > toCollection ( ) ; }
public void run ( String args [ ] ) { TextOutput output = new TextOutput ( nar , new PrintWriter ( out , true ) ) ; output . setErrors ( true ) ; output . setErrorStackTrace ( true ) ; InputThread it ; if ( args . length > 0 ) { try { nar . addInput ( new TextInput ( new File ( args [ 0 ] ) ) ) ; } catch ( FileNotFoundException ex ) { System . err . println ( " NARRun.init:  " + ex ) ; } } else { it = new InputThread ( System . in , nar ) ; it . start ( ) ; } while ( true ) { if ( logging ) log ( " NARSBatch.run(): " + "  step  " + nar . time ( ) + "   " + nar . inputChannels . size ( ) ) ; nar . step ( 1 ) ; if ( logging ) log ( " NARSBatch.run(): after tick " + "  step  " + nar . time ( ) + "   " + nar . inputChannels . size ( ) ) ; if ( maxTime > 0 ) { if ( ( nar . inputChannels . isEmpty ( ) ) | | nar . time ( ) = = maxTime ) { break ; } } } System . exit ( 0 ) ; }
public boolean remove ( K key ) { int hashedKey = hashingFunction ( key ) ; List < Pair < K , V > > list = map [ hashedKey ] ; for ( Pair < K , V > pair : list ) { if ( pair . key . equals ( key ) ) { list . remove ( pair ) ; size - - ; return true ; } } return false ; }
public ArrayList < int [ ] > pieceCouldJumpToFrom ( int srcX , int srcY ) { ArrayList < int [ ] > destinations = new ArrayList < int [ ] > ( ) ; if ( pieces [ srcX ] [ srcY ] . isLight ( ) | | pieces [ srcX ] [ srcY ] instanceof King ) { if ( srcY < = HEIGHT - 3 ) { if ( srcX + 2 < WIDTH ) { if ( pieces [ srcX + 2 ] [ srcY + 2 ] = = null ) { if ( pieces [ srcX + 1 ] [ srcY + 1 ] ! = null & & ! pieces [ srcX + 1 ] [ srcY + 1 ] . getColor ( ) . equals ( pieces [ srcX ] [ srcY ] . getColor ( ) ) ) destinations . add ( new int [ ] { srcX + 2 , srcY + 2 } ) ; } } if ( srcX - 2 > = 0 ) { if ( pieces [ srcX - 2 ] [ srcY + 2 ] = = null ) { if ( pieces [ srcX - 1 ] [ srcY + 1 ] ! = null & & ! pieces [ srcX - 1 ] [ srcY + 1 ] . getColor ( ) . equals ( pieces [ srcX ] [ srcY ] . getColor ( ) ) ) destinations . add ( new int [ ] { srcX - 2 , srcY + 2 } ) ; } } } } if ( pieces [ srcX ] [ srcY ] . isDark ( ) | | pieces [ srcX ] [ srcY ] instanceof King ) { if ( srcY > = 2 ) { if ( srcX + 2 < WIDTH ) { if ( pieces [ srcX + 2 ] [ srcY - 2 ] = = null ) { if ( pieces [ srcX + 1 ] [ srcY - 1 ] ! = null & & ! pieces [ srcX + 1 ] [ srcY - 1 ] . getColor ( ) . equals ( pieces [ srcX ] [ srcY ] . getColor ( ) ) ) destinations . add ( new int [ ] { srcX + 2 , srcY - 2 } ) ; } } if ( srcX - 2 > = 0 ) { if ( pieces [ srcX - 2 ] [ srcY - 2 ] = = null ) { if ( pieces [ srcX - 1 ] [ srcY - 1 ] ! = null & & ! pieces [ srcX - 1 ] [ srcY - 1 ] . getColor ( ) . equals ( pieces [ srcX ] [ srcY ] . getColor ( ) ) ) destinations . add ( new int [ ] { srcX - 2 , srcY - 2 } ) ; } } } } return destinations ; }
private static void ReplaceIntervals ( final CompoundTerm comp ) { comp . invalidateName ( ) ; for ( int i = 0 ; i < comp . term . length ; i + + ) { final Term t = comp . term [ i ] ;
public static final long divisionUsingLoop ( int a , int b ) { int absA = Math . abs ( a ) ; int absB = Math . abs ( b ) ; long temp = absA ; int result = 0 ; while ( temp > = 0 ) { temp - = absB ; if ( temp > = 0 ) result + + ; } return ( a > 0 & & b > 0 | | a < 0 & & b < 0 ) ? result : - result ; }
public static void main ( String [ ] arg ) { int controlPeriod = 2 ; NAR n = newNAR ( ) ; TestController qn = new TestController ( n , controlPeriod ) ; qn . setActive ( false ) ; NAR m = newNAR ( ) ; TestController qm = new TestController ( m , controlPeriod ) ; qm . setActive ( false ) ; NAR r = newNAR ( ) ; TestController qr = new TestController ( r , controlPeriod ) { @Override protected void act ( int ignored ) { int action = ( int ) ( Math . random ( ) * getNumActions ( ) ) ; super . act ( action ) ; } } ; qr . setActive ( false ) ; double mm = 0 , nn = 0 , rr = 0 ; int displayCycles = 1000 ; double [ ] nAction = new double [ qn . getNumActions ( ) ] ; long startupPeriod = 2000 ; int resetPeriod = 50000 ; double avgCycleToForget = 0 ; int time = 0 ; while ( true ) {
public static int i ( int from , int to ) { if ( to < from ) return 0 ; return ( Math . abs ( random . nextInt ( ) ) % ( to - from ) ) + from ; }
public GetOperation get ( Collection < String > keys , Callback cb ) { return new GetOperationImpl ( keys , cb ) ; }
private Node < T > findValue ( T value ) { Node < T > node = head ; if ( node = = null ) return null ; else if ( node . value . equals ( value ) ) return node ; int level = node . getLevel ( ) ; Node < T > next = node . getNext ( level ) ; while ( next = = null ) { if ( level > 0 ) next = node . getNext ( - - level ) ; else break ; } while ( next ! = null ) { int comp = next . value . compareTo ( value ) ; if ( comp = = 0 ) { return next ; } else if ( comp = = 1 ) { if ( level > 0 ) level - - ; else return null ; next = node . getNext ( level ) ; } else { node = next ; next = node . getNext ( level ) ; while ( next = = null & & level > 0 ) { next = node . getNext ( - - level ) ; } } } return null ; }
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public void putAll ( UnmodifiableConfig other ) { long stamp = valuesLock . writeLock ( ) ; try { if ( other instanceof StampedConfig ) {
private List < String > waitForChanges ( ) throws MPDServerException { final MPDConnection mpdIdleConnection = mpd . getMpdIdleConnection ( ) ; while ( mpdIdleConnection ! = null & & mpdIdleConnection . isConnected ( ) ) { final List < String > data = mpdIdleConnection . sendCommand ( mIdleCommand ) ; if ( data . isEmpty ( ) ) { continue ; } return data ; } throw new MPDConnectionException ( " IDLE connection lost " ) ; }
public void addToPlaylist ( String playlistName , FilesystemTreeEntry entry ) throws MPDServerException { getMpdConnection ( ) . sendCommand ( MPDCommand . MPD_CMD_PLAYLIST_ADD , playlistName , entry . getFullpath ( ) ) ;
public void computeScroll ( ) { if ( mDragHelper . continueSettling ( true ) ) { if ( ! mCanSlide ) {
static FileConfig ofConcurrent ( String filePath , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return ofConcurrent ( new File ( filePath ) , format ) ; }
public void onPageSelected ( int position ) { refreshQueueIndicator ( position = = 0 ? false : true ) ; }
public static void temporalInduction ( Sentence s1 , Sentence s2 , Memory memory ) { Term t1 = s1 . cloneContent ( ) ; Term t2 = s2 . cloneContent ( ) ; if ( Statement . invalidStatement ( t1 , t2 ) ) { return ; } long time1 = s1 . getOccurenceTime ( ) ; long time2 = s2 . getOccurenceTime ( ) ; long timeDiff = time2 - time1 ; Interval interval = null ; if ( Math . abs ( timeDiff ) > Parameters . DURATION ) { interval = new Interval ( Math . abs ( timeDiff ) ) ; } int order ; if ( timeDiff > Parameters . DURATION ) { order = TemporalRules . ORDER_FORWARD ; } else if ( timeDiff < - Parameters . DURATION ) { order = TemporalRules . ORDER_BACKWARD ; } else { order = TemporalRules . ORDER_CONCURRENT ; } TruthValue givenTruth1 = s1 . truth ; TruthValue givenTruth2 = s2 . truth ; TruthValue truth1 = TruthFunctions . abduction ( givenTruth1 , givenTruth2 ) ; TruthValue truth2 = TruthFunctions . abduction ( givenTruth2 , givenTruth1 ) ; TruthValue truth3 = TruthFunctions . comparison ( givenTruth1 , givenTruth2 ) ; BudgetValue budget1 = BudgetFunctions . forward ( truth1 , memory ) ; BudgetValue budget2 = BudgetFunctions . forward ( truth2 , memory ) ; BudgetValue budget3 = BudgetFunctions . forward ( truth3 , memory ) ; Statement statement1 = Implication . make ( t1 , t2 , order , memory ) ; Statement statement2 = Implication . make ( t2 , t1 , reverseOrder ( order ) , memory ) ; Statement statement3 = Equivalence . make ( t1 , t2 , order , memory ) ; memory . doublePremiseTask ( statement1 , truth1 , budget1 ) ; memory . doublePremiseTask ( statement2 , truth2 , budget2 ) ; memory . doublePremiseTask ( statement3 , truth3 , budget3 ) ; }
public void noDamage ( ) { loX = 1000 ; loY = 1000 ; hiX = - 1 ; hiY = - 1 ; }
protected static String makeImageName ( final Operator op , final ArrayList < Term > arg , final int relationIndex ) { StringBuilder name = new StringBuilder ( 16 ) . append ( Symbols . COMPOUND_TERM_OPENER ) . append ( op ) . append ( Symbols . ARGUMENT_SEPARATOR ) . append ( arg . get ( relationIndex ) . getName ( ) ) ; for ( int i = 0 ; i < arg . size ( ) ; i + + ) { name . append ( Symbols . ARGUMENT_SEPARATOR ) ; if ( i = = relationIndex ) { name . append ( Symbols . IMAGE_PLACE_HOLDER ) ; } else { name . append ( arg . get ( i ) . getName ( ) ) ; } } name . append ( Symbols . COMPOUND_TERM_CLOSER ) ; return name . toString ( ) ; }
public static BudgetValue update ( final Task task , final TruthValue bTruth , Parameters narParameters ) { final TruthValue tTruth = task . sentence . truth ; final float dif = tTruth . getExpDifAbs ( bTruth ) ; final float priority = or ( dif , task . getPriority ( ) ) ; final float durability = aveAri ( dif , task . getDurability ( ) ) ; final float quality = truthToQuality ( bTruth ) ; return new BudgetValue ( priority , durability , quality , narParameters ) ; }
public static void run ( Config config ) throws Exception { Set < Step > steps = extractSteps ( config ) ; LOG . info ( " Steps instatiated " ) ; Contexts . initialize ( config ) ; initializeAccumulators ( steps ) ; if ( hasStreamingStep ( steps ) ) { LOG . info ( " Streaming step(s) identified " ) ; runStreaming ( steps ) ; } else { LOG . info ( " No streaming steps identified " ) ; runBatch ( steps ) ; } LOG . info ( " Runner finished " ) ; }
public boolean equals ( final Object other ) { if ( other instanceof Rope ) { final Rope rope = ( Rope ) other ; if ( rope . hashCode ( ) ! = this . hashCode ( ) | | rope . length ( ) ! = this . length ( ) ) return false ; final Iterator < Character > i1 = this . iterator ( ) ; final Iterator < Character > i2 = rope . iterator ( ) ; while ( i1 . hasNext ( ) ) { final char a = i1 . next ( ) ; final char b = i2 . next ( ) ; if ( a ! = b ) return false ; } return true ; } return false ; }
public void run ( ) { for ( Concept c : s . nar . memory ) { if ( c . desires ! = null & & ! c . desires . isEmpty ( ) ) {
SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; boolean isAuthenticated ( ) ; long lastReadDelta ( ) ; void completedRead ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; }
public boolean handleMessage ( final Message msg ) { boolean result = false ; if ( msg . what = = PREPARE_ASYNC ) { if ( mIsPlaying ) { if ( DEBUG ) { Log . d ( TAG , " Start mediaPlayer buffering. " ) ; } mMediaPlayer . prepareAsync ( ) ; } else { mPreparingStream = false ; windDownResources ( STREAMING_PAUSE ) ; } result = true ; } return result ; }
public E pollFirst ( ) { Map . Entry < E , Object > e = m . pollFirstEntry ( ) ; return e = = null ? null : e . getKey ( ) ; }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o instanceof com . googlecode . opennars . parser . loan . Loan . Absyn . SentImport ) { com . googlecode . opennars . parser . loan . Loan . Absyn . SentImport x = ( com . googlecode . opennars . parser . loan . Loan . Absyn . SentImport ) o ; return this . urilit_ . equals ( x . urilit_ ) ; } return false ; }
public NAR build ( ) { Param p = newParam ( ) ; Operator [ ] operators = DefaultOperators . get ( ) ; Memory m = new Memory ( p , newConceptBag ( p ) , newNovelTaskBag ( p ) , this , operators ) ; return new NAR ( m ) ; }
public void actionPerformed ( ActionEvent e ) { if ( ! isShowing ( ) ) displayed = showCategory ( category ) ;
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; if ( value ! = Integer . MIN_VALUE ) builder . append ( " Node= " ) . append ( string ) . append ( "  value= " ) . append ( value ) . append ( " \ n " ) ; for ( Node c : children ) { builder . append ( c . toString ( ) ) ; } return builder . toString ( ) ; }
public GetOperation get ( String key , Callback callback ) { return new GetOperationImpl ( key , callback ) ; }
public void run ( ) { int oldSong = - 1 ; int oldPlaylistVersion = - 1 ; long oldElapsedTime = - 1 ; String oldState = " " ; int oldVolume = - 1 ; boolean oldUpdating = false ; boolean oldRepeat = false ; boolean oldRandom = false ; boolean oldConnectionState = false ; boolean connectionLost = false ; while ( ! giveup ) { Boolean connectionState = Boolean . valueOf ( mpd . isConnected ( ) ) ;
protected void accumulate ( final Term t , final Cause [ ] path ) { accumulate ( t ) ; for ( Cause s : path ) accumulate ( s ) ;
public void normalizeWeights ( ) { double sumWeights = 0.0 ; for ( int j = 0 ; j < this . weightAttribute . length ; j + + ) { sumWeights + = Math . abs ( this . weightAttribute [ j ] ) ; } for ( int j = 0 ; j < this . weightAttribute . length ; j + + ) { this . weightAttribute [ j ] = this . weightAttribute [ j ] / sumWeights ;
public T dequeue ( ) { if ( ( nextIndex - firstIndex ) < 0 ) return null ; T t = array [ firstIndex ] ; array [ firstIndex + + ] = null ; if ( ( nextIndex - firstIndex ) = = 0 ) { firstIndex = 0 ; nextIndex = 0 ; } else if ( array . length - ( nextIndex - firstIndex ) > = SHRINK_IN_CHUNK_SIZE ) { int newLength = nextIndex - firstIndex ; T [ ] temp = ( T [ ] ) new Object [ newLength ] ; System . arraycopy ( array , firstIndex , temp , 0 , newLength ) ; array = temp ; nextIndex = nextIndex - firstIndex ; firstIndex = 0 ; } return t ; }
public boolean isAnnounced ( ) ; public boolean isCanceling ( ) ; public boolean isCanceled ( ) ; public boolean isClosing ( ) ; public boolean isClosed ( ) ; public boolean waitForAnnounced ( long timeout ) ; public boolean waitForCanceled ( long timeout ) ; }
public void readWriteReadAgain ( ) { File file = new File ( " test.toml " ) ; CommentedConfig parsed = new TomlParser ( ) . parse ( file , FileNotFoundAction . THROW_ERROR ) ; System . out . println ( " --- parsed ---  \ n " + parsed ) ; System . out . println ( " -------------------------------------------- " ) ; java . io . StringWriter sw = new StringWriter ( ) ; TomlWriter writer = new TomlWriter ( ) ; writer . write ( parsed , sw ) ; System . out . println ( " --- written ---  \ n " + sw ) ; System . out . println ( " -------------------------------------------- " ) ; CommentedConfig reparsed = new TomlParser ( ) . parse ( new StringReader ( sw . toString ( ) ) ) ; System . out . println ( " --- reparsed ---  \ n " + reparsed ) ; assertEquals ( parsed , reparsed ) ; }
private static boolean testJavaSkipListMap ( ) { String name = " Java's SkipListMap <String> " ; if ( ! testJavaMap ( javaSkipListMap , String . class , name ) ) return false ; return true ; }
public void testGetStatsSizes ( ) throws Exception { if ( TestConfig . isMembase ( ) | | TestConfig . isCouchbase ( ) | | isMoxi ( ) ) { return ; } client . set ( " sizeinitializer " , 0 , " hi " ) ; Map < SocketAddress , Map < String , String > > stats = client . getStats ( " sizes " ) ; System . out . println ( " Stats sizes:   " + stats ) ; assertEquals ( 1 , stats . size ( ) ) ; Map < String , String > oneStat = stats . values ( ) . iterator ( ) . next ( ) ; String noItemsSmall = oneStat . get ( " 96 " ) ; assertTrue ( Integer . parseInt ( noItemsSmall ) > = 1 ) ; }
public void authComplete ( ) { throw new UnsupportedOperationException ( ) ; }
private View parseDesignDocumentForView ( String dn , String ddn , String viewName , String json ) throws ParseException { View view = null ; if ( json ! = null ) { try { JSONObject base = new JSONObject ( json ) ; if ( base . has ( " error " ) ) { return null ; } if ( base . has ( " views " ) ) { JSONObject views = base . getJSONObject ( " views " ) ; Iterator < ? > itr = views . keys ( ) ; while ( itr . hasNext ( ) ) { String curView = ( String ) itr . next ( ) ; if ( curView . equals ( viewName ) ) { boolean map = views . getJSONObject ( curView ) . has ( " map " ) ; boolean reduce = views . getJSONObject ( curView ) . has ( " reduce " ) ; view = new View ( dn , ddn , viewName , map , reduce ) ; break ; } } } } catch ( JSONException e ) { throw new ParseException ( " Cannot read json:  " + json , 0 ) ; } } return view ; }
public void onPanelSlide ( final View panel , final float slideOffset ) { final ActionBar actionBar = getSupportActionBar ( ) ; if ( slideOffset > 0.3f ) { if ( actionBar . isShowing ( ) ) { actionBar . hide ( ) ; } } else { if ( ! actionBar . isShowing ( ) ) { actionBar . show ( ) ; } } if ( slideOffset < 1.0f ) { nowPlayingSmallFragment . setVisibility ( View . VISIBLE ) ; } else { nowPlayingSmallFragment . setVisibility ( View . GONE ) ; } nowPlayingSmallFragment . setAlpha ( 1.0f - slideOffset ) ; }
public void gotData ( ViewResponseReduced response ) { vr = response ; }
public void handleLine ( String line ) { assert getState ( ) = = OperationState . READING : " Read `` " + line + " '' when in  " + getState ( ) + "  state " ; getCallback ( ) . receivedStatus ( matchStatus ( line , STORED , NOT_FOUND , EXISTS ) ) ; transitionState ( OperationState . COMPLETE ) ; }
public void deriveMultipleDependencies ( ) throws Exception { Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " dep1 " , null ) ; dependencies . put ( " dep2 " , null ) ; Deriver deriver = new MorphlineDeriver ( ) ; deriver . derive ( dependencies ) ; }
public String removeComment ( List < String > path ) { String result = super . removeComment ( path ) ; autoSave ( ) ; return result ; }
public boolean empty ( ) { return Formula . empty ( theFormula ) ; }
public void shutdown ( ) throws MPDServerException { if ( mpdConnection = = null ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } mpdConnection . sendCommand ( MPD_CMD_KILL ) ; }
public void testReadHttpRequestStreamMessage ( ) throws Exception { final IAS2HttpResponseHandler mockedResponseHandler = MOCK_RH ; NonBlockingByteArrayInputStream is = new NonBlockingByteArrayInputStream ( m_sChunkedMessage . getBytes ( StandardCharsets . UTF_8 ) ) ; AS2Message aMsg = new AS2Message ( ) ; IAS2InputStreamProvider mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; final DataSource resRegular = HTTPHelper . readHttpRequest ( mockStreamProvider , mockedResponseHandler , aMsg ) ; is = new NonBlockingByteArrayInputStream ( m_sChunkedMessage . getBytes ( StandardCharsets . UTF_8 ) ) ; aMsg = new AS2Message ( ) ; mockStreamProvider = new MockAS2InputStreamProvider ( is ) ; final DataSource resStream = HTTPHelper . readHttpRequest ( mockStreamProvider , mockedResponseHandler , aMsg ) ; assertTrue ( " Compare regular and stream read " , _compareLineByLine ( resRegular . getInputStream ( ) , resStream . getInputStream ( ) ) ) ;
private static boolean testKdTree ( ) { { if ( debug > 1 ) System . out . println ( " k-d tree with node. " ) ; java . util . List < KdTree . XYZPoint > points = new ArrayList < KdTree . XYZPoint > ( ) ; KdTree . XYZPoint p1 = new KdTree . XYZPoint ( 2 , 3 ) ; points . add ( p1 ) ; KdTree . XYZPoint p2 = new KdTree . XYZPoint ( 5 , 4 ) ; points . add ( p2 ) ; KdTree . XYZPoint p3 = new KdTree . XYZPoint ( 9 , 6 ) ; points . add ( p3 ) ; KdTree . XYZPoint p4 = new KdTree . XYZPoint ( 4 , 7 ) ; points . add ( p4 ) ; KdTree . XYZPoint p5 = new KdTree . XYZPoint ( 8 , 1 ) ; points . add ( p5 ) ; KdTree . XYZPoint p6 = new KdTree . XYZPoint ( 7 , 2 ) ; points . add ( p6 ) ; KdTree < KdTree . XYZPoint > kdTree = new KdTree < KdTree . XYZPoint > ( points ) ; if ( debug > 1 ) System . out . println ( kdTree . toString ( ) ) ; Collection < KdTree . XYZPoint > result = kdTree . nearestNeighbourSearch ( 1 , p3 ) ; if ( debug > 1 ) System . out . println ( " NNS for  " + p3 + "  result= " + result + " \ n " ) ; KdTree . XYZPoint search = new KdTree . XYZPoint ( 1 , 4 ) ; result = kdTree . nearestNeighbourSearch ( 4 , search ) ; if ( debug > 1 ) System . out . println ( " NNS for  " + search + "  result= " + result + " \ n " ) ; kdTree . remove ( p6 ) ; if ( debug > 1 ) System . out . println ( " Removed  " + p6 + " \ n " + kdTree . toString ( ) ) ; kdTree . remove ( p4 ) ; if ( debug > 1 ) System . out . println ( " Removed  " + p4 + " \ n " + kdTree . toString ( ) ) ; kdTree . remove ( p3 ) ; if ( debug > 1 ) System . out . println ( " Removed  " + p3 + " \ n " + kdTree . toString ( ) ) ; kdTree . remove ( p5 ) ; if ( debug > 1 ) System . out . println ( " Removed  " + p5 + " \ n " + kdTree . toString ( ) ) ; kdTree . remove ( p1 ) ; if ( debug > 1 ) System . out . println ( " Removed  " + p1 + " \ n " + kdTree . toString ( ) ) ; kdTree . remove ( p2 ) ; if ( debug > 1 ) System . out . println ( " Removed  " + p2 + " \ n " + kdTree . toString ( ) ) ; if ( debug > 1 ) System . out . println ( ) ; } return true ; }
public EChange setVerifyUseCertificateInBodyPart ( @Nonnull final ETriState eValue ) { return setAttribute ( CPartnershipIDs . PA_VERIFY_USE_CERT_IN_BODY_PART , eValue . isUndefined ( ) ? null : Boolean . toString ( eValue . getAsBooleanValue ( ) ) ) ;
public void onSolution ( Sentence belief ) { System . out . println ( belief ) ; String rpart = belief . toString ( ) . split ( " =/> " ) [ 1 ] ; Prediction ( belief , rpart , - 1 , val ) ; }
public boolean isCompressed ( @Nonnull final String sContentType ) throws AS2Exception { ValueEnforcer . notNull ( sContentType , " ContentType " ) ; final ContentType aContentType = AS2HttpHelper . parseContentType ( sContentType ) ; if ( aContentType = = null ) return false ; final String sSmimeType = aContentType . getParameter ( " smime-type " ) ; return sSmimeType ! = null & & sSmimeType . equalsIgnoreCase ( " compressed-data " ) ; }
public static Boolean isNetworkConnected ( Context context , int . . . allowedNetworkTypes ) { for ( int attempt = 0 ; attempt < MAX_RETRY ; attempt + + ) { if ( innerIsNetworkConnected ( context , allowedNetworkTypes ) ) { return true ; } else { try { Thread . sleep ( 500 ) ; } catch ( InterruptedException e ) { } } } return false ; }
protected ArrayList < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { Term content = args [ 0 ] ; anticipateTime = memory . time ( ) + ( int ) ( memory . getDuration ( ) * anticipateDurations ) ; anticipateTerm = content ; return null ; }
public Concept concept ( final Term term ) { if ( ! term . isConstant ( ) ) { return null ; } final String n = term . getName ( ) ; Concept concept = concepts . get ( n ) ; if ( concept = = null ) { concept = conceptBuilder . newConcept ( term , this ) ; final boolean created = concepts . putIn ( concept ) ; if ( ! created ) { return null ; } else { if ( recorder . isActive ( ) ) { recorder . onConceptNew ( concept ) ; } } } return concept ; }
default void parseConfig ( InputStream input , T destination ) throws IOException { Reader reader = new BufferedReader ( new InputStreamReader ( input , StandardCharsets . UTF_8 ) ) ; parseConfig ( reader , destination ) ; }
public Operation clone ( ) { return new Operation ( cloneTerms ( ) , getTemporalOrder ( ) , isConstant ( ) , containsVar ( ) , getComplexity ( ) , hashCode ( ) ) ; }
public < C > void on ( final Class < ? extends C > event , final Observer < ? extends C > o ) { if ( null = = event | | null = = o ) return ; events . putIfAbsent ( event , new ConcurrentHashMap < Observer , String > ( ) ) ; events . get ( event ) . putIfAbsent ( o , " " ) ; }
public void incrementCounter ( String name ) { incrementCounter ( name , 1 ) ; }
public boolean containsValue ( Object value ) { return internalMap . containsValue ( searchTransformation . apply ( value ) ) ; }
public void stateChanged ( final MPDStatus mpdStatus , final String oldState ) { if ( mpdStatus = = null ) { Log . w ( TAG , " Null mpdStatus received in stateChanged " ) ;
private void inputFieldKeyReleased ( KeyEvent event ) { int code = event . getKeyCode ( ) ; if ( code = = 38 ) inputField . setText ( history . previous ( ) ) ;
X509Certificate getCertificate ( IMessage msg , String partnershipType ) throws OpenAS2Exception ; PrivateKey getPrivateKey ( IMessage msg , X509Certificate cert ) throws OpenAS2Exception ; X509Certificate getCertificate ( IMessageMDN msg , String partnershipType ) throws OpenAS2Exception ; PrivateKey getPrivateKey ( IMessageMDN msg , X509Certificate cert ) throws OpenAS2Exception ; }
public Rope append ( final char c ) { return Rope . cat ( this , Rope . build ( String . valueOf ( c ) ) ) ; }
public static final boolean isPalindromeWithAdditionalStorage ( String string ) { final String reversed = new StringBuilder ( string ) . reverse ( ) . toString ( ) ; return string . equals ( reversed ) ; }
public void testViewDocsWithErrors ( ) throws Exception { HttpOperation op = new DocsOperationImpl ( null , new ViewCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { } @Override public void gotData ( ViewResponse response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; } } ) ; HttpResponse response = new BasicHttpResponse ( HttpVersion . HTTP_1_1 , 200 , " " ) ; String entityString = " { \" total_rows \" :0, \" rows \" :[], \" errors \" : [{ \" from " + " \" : \" 127.0.0.1:5984 \" , \" reason \" : \" Design document `_design/test " + " foobar` missing in database `test_db_b`. \" },{ \" from \" : \" http:// " + " localhost:5984/_view_merge/ \" , \" reason \" : \" Design document ` " + " _design/testfoobar` missing in database `test_db_c`. \" }]} " ; StringEntity entity = new StringEntity ( entityString ) ; response . setEntity ( entity ) ; op . handleResponse ( response ) ; }
public static Row convertToRow ( StructType schema , Record record ) { LOG . debug ( " Converting Record to Row: {} " , record ) ; List < Object > values = Lists . newArrayList ( ) ; ListMultimap < String , Object > activeFields = record . getFields ( ) ; for ( StructField field : schema . fields ( ) ) { String fieldName = field . name ( ) ; DataType fieldDataType = field . dataType ( ) ; Object recordValue = null ; if ( activeFields . containsKey ( fieldName ) ) { recordValue = record . getFirstValue ( fieldName ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Converting Field[{} => {}] to DataType[{}]] " , fieldName , recordValue , fieldDataType ) ; } if ( null ! = recordValue ) { try { Object result = RowUtils . toRowValue ( recordValue , field . dataType ( ) ) ; values . add ( result ) ; } catch ( Exception e ) { throw new RuntimeException ( String . format ( " Error converting Field[%s => %s] to DataType[%s] " , fieldName , recordValue , fieldDataType ) , e ) ; } } else { if ( field . nullable ( ) ) { LOG . trace ( " Setting Field[{} => null] for DataType[{}] " , fieldName , fieldDataType ) ; values . add ( null ) ; } else { throw new RuntimeException ( String . format ( " Error converting Field[%s => null] for DataType[%s]: DataType  " + " cannot contain 'null' " , fieldName , fieldDataType ) ) ; } } } Row result = RowFactory . create ( values . toArray ( ) ) ; LOG . trace ( " Converted Record to Row: {} " , result ) ; return result ; }
public void removeGlobalEventHandler ( EventHandler eventHandler ) { globalEventHandlers . remove ( eventHandler ) ; }
public static Term [ ] toSortedSetArray ( final Term . . . arg ) { switch ( arg . length ) { case 0 : return EmptyTermArray ; case 1 : return new Term [ ] { arg [ 0 ] } ; case 2 : Term a = arg [ 0 ] ; Term b = arg [ 1 ] ; int c = a . compareTo ( b ) ; if ( Parameters . DEBUG ) { boolean equal = a . equals ( b ) ; if ( ( equal & & ( c ! = 0 ) ) | | ( ! equal & & ( c = = 0 ) ) ) { throw new RuntimeException ( " invalid order:  " + a + "  =  " + b ) ; } } if ( c < 0 ) return new Term [ ] { a , b } ; else if ( c > 0 ) return new Term [ ] { b , a } ; else if ( c = = 0 ) return new Term [ ] { a } ; } TreeSet < Term > s = new TreeSet ( ) ; for ( Term a : arg ) s . add ( a ) ; return s . toArray ( new Term [ s . size ( ) ] ) ;
public boolean add ( C seq ) { return ( this . addSequence ( seq ) ! = null ) ; }
public boolean executeDecision ( final Task t ) { if ( memory . allowExecution ) { Term content = t . getTerm ( ) ; if ( content instanceof Operation & & ! content . hasVarDep ( ) & & ! content . hasVarIndep ( ) ) { Operation op = ( Operation ) content ; Operator oper = op . getOperator ( ) ; op . setTask ( t ) ; if ( ! oper . call ( op , memory ) ) { return false ; } this . memory . lastDecision = t ; successfulOperationHandler ( this . memory ) ; return true ; } } return false ; }
public EChange removePartnership ( @Nonnull final Partnership aPartnership ) { ValueEnforcer . notNull ( aPartnership , " Partnership " ) ; return EChange . valueOf ( m_aMap . remove ( aPartnership . getName ( ) ) ! = null ) ; }
void playlistChanged ( MPDPlaylistChangedEvent event ) ; void trackChanged ( MPDTrackChangedEvent event ) ; void stateChanged ( MPDStateChangedEvent event ) ; void repeatChanged ( MPDRepeatChangedEvent event ) ; void randomChanged ( MPDRandomChangedEvent event ) ; void connectionStateChanged ( MPDConnectionStateChangedEvent event ) ; void updateStateChanged ( MPDUpdateStateChangedEvent event ) ; }
private Row deriveRow ( Config deriverConfig ) { ParseJSONDeriver deriver = new ParseJSONDeriver ( ) ; ValidationAssert . assertNoValidationFailures ( deriver , deriverConfig ) ; deriver . configure ( deriverConfig ) ; String json = " { \ n " + "    \" f1 \" :  \ 'hello \ ', \ n " + "    \" f2 \" : 1.2, \ n " + "    \" f3 \" : true, \ n " + "    \" f4 \" : { \ n " + "      \" f41 \" :  \ 'world \ ' \ n " + "   }, \ n " + "    \" f5 \" : [ \ n " + "      \" v5 \" \ n " + "   ], \ n " + "    \" f6 \" : [ \ n " + "     { \ n " + "        \" f611 \" : [false, false] \ n " + "     } \ n " + "   ] \ n " + " } " ; Row message = new RowWithSchema ( SchemaUtils . stringValueSchema ( ) , json ) ; Dataset < Row > dependency = Contexts . getSparkSession ( ) . createDataFrame ( Lists . newArrayList ( message ) , message . schema ( ) ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " source " , dependency ) ; List < Row > derivedRows = deriver . derive ( dependencies ) . collectAsList ( ) ; assertEquals ( 1 , derivedRows . size ( ) ) ; return derivedRows . iterator ( ) . next ( ) ; }
protected void initClient ( ) throws Exception { initClient ( new DefaultConnectionFactory ( ) { @Override
public static synchronized HashAlgorithm lookupHashAlgorithm ( String name ) { validateName ( name ) ; return REGISTRY . get ( name . toLowerCase ( ) ) ; }
public void onDestroy ( ) { app . oMPDAsyncHelper . removeStatusChangeListener ( this ) ; super . onDestroy ( ) ; }
public void wrongConfigBothListProvided ( ) throws Exception { List < String > includeFields = Arrays . asList ( " sourceid " , " sourcename " , " sourcestatus " ) ; List < String > excludeFields = Arrays . asList ( " loadtype " , " loaddate " , " loadtime " , " loadsize " , " producttype " ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " dataSource1 " , null ) ; dependencies . put ( " dataSource2 " , null ) ; Config config = ConfigFactory . empty ( ) . withValue ( SelectDeriver . INCLUDE_FIELDS , ConfigValueFactory . fromAnyRef ( includeFields ) ) . withValue ( SelectDeriver . EXCLUDE_FIELDS , ConfigValueFactory . fromAnyRef ( excludeFields ) ) . withValue ( SelectDeriver . STEP_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " dataSource1 " ) ) ; SelectDeriver selectderiver = new SelectDeriver ( ) ; selectderiver . configure ( config ) ; selectderiver . derive ( dependencies ) ; }
public static Similarity make ( Term subject , Term predicate , Memory memory ) { if ( invalidStatement ( subject , predicate ) ) { return null ; } if ( subject . compareTo ( predicate ) > 0 ) { return make ( predicate , subject , memory ) ; } String name = makeStatementName ( subject , NativeOperator . SIMILARITY , predicate ) ; Term t = memory . nameToTerm ( name ) ; if ( t ! = null ) { return ( Similarity ) t ; } ArrayList < Term > argument = argumentsToList ( subject , predicate ) ; return new Similarity ( argument ) ; }
Map < String , Object > valueMap ( ) ; @Override Set < ? extends Entry > entrySet ( ) ; interface Entry extends UnmodifiableConfig . Entry { < T > T setValue ( Object value ) ; } Config createSubConfig ( ) ; default void update ( String path , Object value ) { set ( path , value ) ; } default void update ( List < String > path , Object value ) { set ( path , value ) ; } static Config of ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format , false ) ; } static Config ofConcurrent ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format , true ) ; } static Config inMemory ( ) { return InMemoryFormat . defaultInstance ( ) . createConfig ( ) ; } static Config inMemoryConcurrent ( ) { return InMemoryFormat . defaultInstance ( ) . createConcurrentConfig ( ) ; } static Config wrap ( Map < String , Object > map , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( map , format ) ; } static Config copy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) , false ) ; } static Config copy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( config , format , false ) ; } static Config concurrentCopy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) , true ) ; } static Config concurrentCopy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( config , format , true ) ; } }
protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; if ( mUseLargestChild ) { final int orientation = getOrientation ( ) ;
public void testExcludeFieldsHash ( ) { Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " dep1 " , testDataFrame ( ) ) ; Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( HashDeriver . EXCLUDE_FIELDS_CONFIG , Lists . newArrayList ( " c1 " , " c2 " ) ) ; Config config = ConfigFactory . parseMap ( configMap ) ; HashDeriver d = new HashDeriver ( ) ; assertNoValidationFailures ( d , config ) ; d . configure ( config ) ; Dataset < Row > derived = d . derive ( dependencies ) ; assertEquals ( 1 , derived . count ( ) ) ; assertEquals ( testDataFrame ( ) . schema ( ) . size ( ) + 1 , derived . schema ( ) . size ( ) ) ; assertTrue ( Lists . newArrayList ( derived . schema ( ) . fieldNames ( ) ) . contains ( HashDeriver . DEFAULT_HASH_FIELD_NAME ) ) ; assertEquals ( " 71fb4bf2f54627f64c60ca5e396d1ccc " ,
public void testConceptInstancing ( ) throws Narsese . InvalidInputException { NAR n = new NAR ( new Plugins ( ) ) ; String statement1 = " <a --> b>. " ; Term a = np . parseTerm ( " a " ) ; assertTrue ( a ! = null ) ; Term a1 = np . parseTerm ( " a " ) ; assertTrue ( a . equals ( a1 ) ) ; n . addInput ( statement1 ) ; n . step ( 4 ) ; n . addInput ( "  <a  --> b>.   " ) ; n . step ( 1 ) ; n . addInput ( "  <a--> b>.   " ) ; n . step ( 1 ) ; String statement2 = " <a --> c>. " ; n . addInput ( statement2 ) ; n . step ( 4 ) ; Term a2 = np . parseTerm ( " a " ) ; assertTrue ( a2 ! = null ) ; Concept ca = n . memory . concept ( a2 ) ; assertTrue ( ca ! = null ) ; assertEquals ( true , n . memory . concepts . iterator ( ) . hasNext ( ) ) ;
protected void removeTask ( final TaskExecution t ) { System . out . println ( "   TASK remove:  " + t ) ; t . t . setPriority ( 0 ) ; tasksToRemove . add ( t ) ; }
public final long getAttributeAsLong ( @Nullable final String sName , final long nDefault ) { final String sValue = getAttributeObject ( sName ) ; return AbstractReadOnlyAttributeContainer . getAsLong ( sName , sValue , nDefault ) ; }
public void resetLearning ( ) { adwin = new ADWIN ( ( double ) this . deltaAdwinOption . getValue ( ) ) ; }
static int parseLifetime ( String lifetime ) { Matcher dhmsMatcher = LIFETIME_DHMS . matcher ( lifetime ) ; Matcher hmsMatcher = LIFETIME_HMS . matcher ( lifetime ) ; Matcher secondsMatcher = LIFETIME_SECS . matcher ( lifetime ) ; if ( dhmsMatcher . matches ( ) ) { int days = 0 , hours = 0 , minutes = 0 , seconds = 0 ;
private static Sentence addToTable ( final Sentence newSentence , final List < Sentence > table , final int capacity ) { final float rank1 = rankBelief ( newSentence ) ; float rank2 ; int i = 0 ; for ( final Sentence judgment2 : table ) { rank2 = rankBelief ( judgment2 ) ; if ( rank1 > = rank2 ) { if ( newSentence . equivalentTo ( judgment2 ) ) { return null ; } table . add ( i , newSentence ) ; break ; } i + + ; } if ( table . size ( ) > = capacity ) { if ( table . size ( ) > capacity ) { Sentence removed = table . remove ( table . size ( ) - 1 ) ; return removed ; } } else if ( i = = table . size ( ) ) { table . add ( newSentence ) ; } return null ; }
public void mouseEntered ( java . awt . event . MouseEvent evt ) { jLabel9MouseEntered ( evt ) ; }
private static void _setProxyToRequestConfig ( @Nonnull final RequestConfig . Builder aConfBuilder , @Nullable final Proxy aProxy ) { try {
public synchronized void timeOut ( ) { timedout = true ; callback . complete ( ) ; }
public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { MPDAsyncHelper . this . obtainMessage ( EVENT_TRACK , Tools . toObjectArray ( mpdStatus , oldTrack ) )
public static EContentTransferEncoding getFromIDCaseInsensitiveOrDefault ( @Nullable final String sID , @Nullable final EContentTransferEncoding eDefault ) { return EnumHelper . getFromIDCaseInsensitiveOrDefault ( EContentTransferEncoding . class , sID , eDefault ) ; }
public void clear ( ) { mCommandQueueStringLength = getStartLength ( ) ; mCommandQueue . clear ( ) ; }
private void jButton2ActionPerformed ( java . awt . event . ActionEvent evt ) { nar . addInput ( " <1 --> set>. :|: " ) ; jButton2 . setText ( " X " ) ; field [ 0 ] = 1 ; check_field ( ) ; narstart ( ) ; }
void pushSubGoal ( SubGoalTree goals ) { env . currentContext . goalsToEval . pushSubGoal ( goals ) ; }
private E takeOutFirst ( final int level ) { final E selected = itemTable [ level ] . get ( 0 ) ; itemTable [ level ] . remove ( 0 ) ; mass - = ( level + 1 ) ; refresh ( ) ; return selected ; }
public static void negotiate ( Object parent , Object child ) { if ( parent instanceof UsesExpectedSchema & & child instanceof DeclaresExpectingSchema ) { ( ( UsesExpectedSchema ) parent ) . receiveExpectedSchema ( ( ( DeclaresExpectingSchema ) child ) . getExpectingSchema ( ) ) ; } if ( child instanceof UsesProvidedSchema & & parent instanceof DeclaresProvidingSchema ) { ( ( UsesProvidedSchema ) child ) . receiveProvidedSchema (
public static IParser createParser ( String theory , HashMap < Term , Integer > mapping ) { return new Parser ( theory , mapping ) ; }
public void teardown ( ) { } @Test public void testJoin ( ) { Collection < String > keys = new LinkedList < String > ( ) ; keys . add ( " key1 " ) ; keys . add ( " key1 " ) ; keys . add ( " key1 " ) ; assert StringUtils . join ( keys , " , " ) . compareTo ( " key1,key2,key3 " ) = = 0 ; } }
protected void initButtons ( ) { bn_float = new AwesomeButton ( '\uf0de' ) ; bn_float . setToolTipText ( " Pop Out to Floating Window " ) ; bn_close = new AwesomeButton ( '\uf00d' ) ; label_title = new javax . swing . JLabel ( ) ; label_title . setText ( content . getTitle ( ) ) ; label_title . setIcon ( content . getIcon ( ) ) ; }
public void testIntervalSequence ( ) { NAR n = new NAR ( ) ; Memory m = n . memory ; List < Interval > a11 = Interval . intervalTimeSequence ( 1 , 1 , m ) ; assertEquals ( 1 , a11 . size ( ) ) ; assertEquals ( Interval . interval ( 1 , m ) , a11 . get ( 0 ) ) ; assertEquals ( Interval . interval ( 0 ) , a11 . get ( 0 ) ) ; List < Interval > a12 = Interval . intervalTimeSequence ( 1 , 2 , m ) ; assertEquals ( a11 , a12 ) ; { long halfDuration = ( n . param ) . duration . get ( ) / 2 ; List < Interval > ad1 = Interval . intervalTimeSequence ( halfDuration , 1 , m ) ; assertEquals ( 1 , ad1 . size ( ) ) ; assertEquals ( Interval . interval ( 1 ) , ad1 . get ( 0 ) ) ; List < Interval > ad2 = Interval . intervalTimeSequence ( halfDuration , 2 , m ) ; assertEquals ( 2 , ad2 . size ( ) ) ; } {
int getAttributeAsInt ( @Nullable String sName ) ; int getAttributeAsInt ( @Nullable String sName , int nDefault ) ; long getAttributeAsLong ( @Nullable String sName ) ; long getAttributeAsLong ( @Nullable String sName , long nDefault ) ; double getAttributeAsDouble ( @Nullable String sName ) ; double getAttributeAsDouble ( @Nullable String sName , double dDefault ) ; boolean getAttributeAsBoolean ( @Nullable String sName ) ; boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; Enumeration < String > getAttributeNames ( ) ; Set < String > getAllAttributeNames ( ) ; Collection < String > getAllAttributeValues ( ) ; int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; Iterator < Entry < String , String > > iterator ( ) ; }
public GetsOperation gets ( String key , GetsOperation . Callback cb ) { return new GetOperationImpl ( key , cb ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmEquiv p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmImpPred p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmImpRet p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmImpConc p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmEqvPred p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmEqvConc p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmConj p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmDisj p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmPar p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmSeq p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmNot p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmPst p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmPres p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmFut p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInher p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmSim p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInst p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmProp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmInPp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmOp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmTrm p , A arg ) ; } }
default < R > R bulkUpdate ( Function < ? super Config , R > action ) { return bulkCommentedUpdate ( action ) ; }
public void explain ( long t , FireConcept f ) { Term term = f . getCurrentConcept ( ) . term ; TaskLink link = f . getCurrentTaskLink ( ) ; addVertex ( f ) ; addVertex ( term ) ; addVertex ( link ) ; addEdge ( term , link , new UniqueEdge ( " tasklink " ) ) ; addEdge ( link , f , new UniqueEdge ( " fire " ) ) ; at ( f , t , " fire " ) ;
IPartnershipFactory getPartnershipFactory ( ) throws ComponentNotFoundException ; @Nonnull IMessageProcessor getMessageProcessor ( ) throws ComponentNotFoundException ; boolean isCryptoSignIncludeCertificateInBodyPart ( ) ; void setCryptoSignIncludeCertificateInBodyPart ( boolean bCryptoSignIncludeCertificateInBodyPart ) ; boolean isCryptoVerifyUseCertificateInBodyPart ( ) ; void setCryptoVerifyUseCertificateInBodyPart ( boolean bCryptoVerifyUseCertificateInBodyPart ) ; @Nullable Proxy getHttpProxy ( ) ; void setHttpProxy ( @Nullable Proxy aHttpProxy ) ; }
public double subtractIfLessThan ( ArrayRealVector aa , ArrayRealVector bb , ArrayRealVector result , double maxDistance ) { double a [ ] = aa . getDataRef ( ) ; double b [ ] = bb . getDataRef ( ) ; double r [ ] = result . getDataRef ( ) ; double maxDistanceSq = maxDistance * maxDistance ; double d = 0 ; for ( int i = 0 ; i < a . length ; i + + ) { double ab = a [ i ] - b [ i ] ; d + = ab * ab ; if ( d > maxDistanceSq ) return Double . POSITIVE_INFINITY ; r [ i ] = ab ; } return Math . sqrt ( d ) ; }
public final boolean isNotificationPersistent ( ) { final boolean result ; if ( oMPDAsyncHelper . getConnectionSettings ( ) . persistentNotification & & ! mIsNotificationOverridden ) { result = true ; } else { result = false ; } if ( DEBUG ) { Log . d ( TAG , " Notification is persistent:  " + result ) ; } return result ; }
public void testNoneArrivingOneExistingNoCurrentFlag ( ) { p = new BitemporalHistoryPlanner ( ) ; p . configure ( configWithoutCurrentFlag ) ; existing . add ( new RowWithSchema ( existingSchemaWithoutCurrentFlag , " a " , " hello " , 100L , 100L , 253402214400000L , 1L , 253402214400000L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 0 ) ; }
public abstract NAR addInput ( final Task t ) ; public void step_start ( ) { } public void step_finished ( ) { for ( SensoryChannel ch : reportResultsTo ) { for ( Task t : results ) { ch . addInput ( t ) ; } } results . clear ( ) ; } public double topDownPriority ( Term t ) { double prioritysum = 0.0f ; int k = 0 ; for ( SensoryChannel chan : reportResultsTo ) { prioritysum + = chan . priority ( t ) ; k + + ; } return prioritysum / ( double ) reportResultsTo . size ( ) ; } public double priority ( Term t ) { if ( this instanceof NAR ) { Concept c = ( ( NAR ) this ) . memory . concept ( t ) ; if ( c ! = null ) { return c . getPriority ( ) ; } } return 0.0 ; } }
private void updateAudioNameText ( final MPDStatus status ) { String optionalTrackInfo = null ; if ( currentSong ! = null & & isAudioNameTextEnabled & & ! status . isState ( MPDStatus . STATE_STOPPED ) ) { final String extension = getExtension ( currentSong . getFullpath ( ) ) . toUpperCase ( ) ; final long bitRate = status . getBitrate ( ) ; final int bitsPerSample = status . getBitsPerSample ( ) ; final int sampleRate = status . getSampleRate ( ) ; if ( ! extension . isEmpty ( ) ) { optionalTrackInfo = extension ; } if ( bitRate > 0 L ) { if ( optionalTrackInfo ! = null ) { optionalTrackInfo + = "  |  " ; } optionalTrackInfo + = bitRate + " kbps " ; } if ( bitsPerSample > 0 ) { if ( optionalTrackInfo ! = null ) { optionalTrackInfo + = "  |  " ; } optionalTrackInfo + = bitsPerSample + " bits " ; } if ( sampleRate > 1000 ) { if ( optionalTrackInfo ! = null ) { optionalTrackInfo + = "  |  " ; } optionalTrackInfo + = sampleRate / 1000 + " kHz " ; } if ( optionalTrackInfo ! = null ) { audioNameText . setText ( optionalTrackInfo ) ; audioNameText . setVisibility ( View . VISIBLE ) ; } } if ( optionalTrackInfo = = null | | currentSong = = null ) { audioNameText . setVisibility ( View . GONE ) ;
public void testNullMissing ( ) { String delimited = " val1 2 34 " ; Config config = ConfigFactory . empty ( ) . withValue ( DelimitedTranslator . SCHEMA_CONFIG + " . " + ComponentFactory . TYPE_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( " flat " ) ) . withValue ( DelimitedTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_NAMES_CONFIG , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " field1 " , " field2 " , " field3 " , " field4 " , " field5 " ) ) ) . withValue ( DelimitedTranslator . SCHEMA_CONFIG + " . " + FlatSchema . FIELD_TYPES_CONFIG , ConfigValueFactory . fromIterable ( Lists . newArrayList ( " string " , " int " , " long " , " int " , " boolean " ) ) ) . withValue ( DelimitedTranslator . DELIMITER_CONFIG_NAME , ConfigValueFactory . fromAnyRef ( "   " ) ) ; DelimitedTranslator t = new DelimitedTranslator ( ) ; assertNoValidationFailures ( t , config ) ; t . configure ( config ) ; Row raw = TestingMessageFactory . get ( " testkey " , DataTypes . StringType , delimited , DataTypes . StringType ) ; Row r = t . translate ( raw ) . iterator ( ) . next ( ) ; assertEquals ( r . length ( ) , 5 ) ; assertEquals ( r . get ( 0 ) , " val1 " ) ; assertEquals ( r . get ( 1 ) , 2 ) ; assertEquals ( r . get ( 2 ) , 34L ) ; assertEquals ( r . get ( 3 ) , null ) ; assertEquals ( r . get ( 4 ) , null ) ; }
public boolean hasNext ( ) { return ( ( queue . firstIndex + index ) < queue . lastIndex ) ; }
public Concept sampleNextConcept ( ) ; public void init ( Memory m ) ; public void conceptRemoved ( Concept c ) ; public Memory getMemory ( ) ; }
protected void load ( @Nullable @WillClose final InputStream aIS ) throws AS2Exception { final PartnerMap aNewPartners = new PartnerMap ( ) ; final PartnershipMap aNewPartnerships = new PartnershipMap ( ) ; if ( aIS ! = null ) { final IMicroDocument aDocument = MicroReader . readMicroXML ( aIS ) ; if ( aDocument = = null ) throw new AS2Exception ( " Failed to read the XML partnership information " ) ; final IMicroElement aRoot = aDocument . getDocumentElement ( ) ; for ( final IMicroElement eRootNode : aRoot . getAllChildElements ( ) ) { final String sNodeName = eRootNode . getTagName ( ) ; if ( sNodeName . equals ( " partner " ) ) { final Partner aNewPartner = loadPartner ( eRootNode ) ; aNewPartners . addPartner ( aNewPartner ) ; } else if ( sNodeName . equals ( " partnership " ) ) { final Partnership aNewPartnership = loadPartnership ( eRootNode , aNewPartners ) ; if ( aNewPartnerships . getPartnershipByName ( aNewPartnership . getName ( ) ) ! = null ) throw new AS2Exception ( " Partnership with name ' " + aNewPartnership . getName ( ) + " ' is defined more than once " ) ; aNewPartnerships . addPartnership ( aNewPartnership ) ; } else { if ( LOGGER . isWarnEnabled ( ) ) LOGGER . warn ( " Invalid element ' " + sNodeName + " ' in XML partnership file " ) ; } } } setPartners ( aNewPartners ) ; setPartnerships ( aNewPartnerships ) ; }
public DispositionOptions setMICAlg ( @Nullable final String sMICAlg ) { m_sMICAlg = sMICAlg ; return this ; }
protected void asyncUpdate ( ) { try { items = app . oMPDAsyncHelper . oMPD . getAlbums ( artist , isCountPossiblyDisplayed ) ;
public void write ( final Writer out ) throws IOException { this . rope . write ( out , this . offset , this . length ) ; }
public void after ( ) throws IOException { Repetitions . get ( true ) ; Contexts . closeSparkSession ( ) ; }
public boolean containsTerm ( final Term t ) { return Terms . contains ( term , t ) ;
public long decr ( String key , int by , long def ) { return mutateWithDefault ( Mutator . decr , key , by , def , 0 ) ; }
public static Term make ( Term term1 , Term term2 , Memory memory ) { TreeSet < Term > set ; if ( ( term1 instanceof SetExt ) & & ( term2 instanceof SetExt ) ) { set = new TreeSet < > ( ( ( CompoundTerm ) term1 ) . cloneTermsList ( ) ) ; set . addAll ( ( ( CompoundTerm ) term2 ) . cloneTermsList ( ) ) ; return SetExt . make ( set , memory ) ; } if ( ( term1 instanceof SetInt ) & & ( term2 instanceof SetInt ) ) { set = new TreeSet < > ( ( ( CompoundTerm ) term1 ) . cloneTermsList ( ) ) ; set . retainAll ( ( ( CompoundTerm ) term2 ) . cloneTermsList ( ) ) ; return SetInt . make ( set , memory ) ; } if ( term1 instanceof IntersectionInt ) { set = new TreeSet < > ( ( ( CompoundTerm ) term1 ) . cloneTermsList ( ) ) ; if ( term2 instanceof IntersectionInt ) { set . addAll ( ( ( CompoundTerm ) term2 ) . cloneTermsList ( ) ) ; } else { set . add ( term2 . clone ( ) ) ; } } else if ( term2 instanceof IntersectionInt ) { set = new TreeSet < > ( ( ( CompoundTerm ) term2 ) . cloneTermsList ( ) ) ; set . add ( term1 . clone ( ) ) ; } else { set = new TreeSet < > ( ) ; set . add ( term1 . clone ( ) ) ; set . add ( term2 . clone ( ) ) ; } return make ( set , memory ) ; }
public void gotData ( String k , int flags , byte [ ] data ) { T val = tc . decode ( new CachedData ( flags , data ) ) ; if ( val ! = null ) { m . put ( k , val ) ;
public boolean isHalted ( ) ; public boolean hasOpenAlternatives ( ) ; public S getSolution ( ) throws NoSolutionException ; public Q getQuery ( ) ; public java . util . List < ? extends T > getBindingVars ( ) throws nars . prolog . NoSolutionException ; }
public int peek ( int n ) { final int diff = n - deque . size ( ) ; if ( diff > = 0 ) { for ( int i = 0 ; i < = diff ; i + + ) { int read = directRead ( ) ; deque . addLast ( read ) ; if ( read = = EOS ) { return EOS ; } } } return deque . get ( n ) ; }
public void configure ( Config config ) { this . config = config ; if ( ! config . hasPath ( JDBC_CONFIG_URL ) ) { throw new RuntimeException ( " JDBC input requires ' " + JDBC_CONFIG_URL + " ' property " ) ; } if ( ! config . hasPath ( JDBC_CONFIG_TABLENAME ) ) { throw new RuntimeException ( " JDBC input requires ' " + JDBC_CONFIG_TABLENAME + " ' property " ) ; } if ( ! config . hasPath ( JDBC_CONFIG_USERNAME ) ) { throw new RuntimeException ( " JDBC input requires ' " + JDBC_CONFIG_USERNAME + " ' property " ) ; } if ( ! config . hasPath ( JDBC_CONFIG_PASSWORD ) ) { throw new RuntimeException ( " JDBC input requires ' " + JDBC_CONFIG_PASSWORD + " ' property " ) ;
public ConfigParser < Config > createParser ( ) { return new YamlParser ( this ) ; }
static boolean conditionalAbd ( Term cond1 , Term cond2 , Statement st1 , Statement st2 , Memory memory ) { if ( ! ( st1 instanceof Implication ) | | ! ( st2 instanceof Implication ) ) { return false ; } if ( ! ( cond1 instanceof Conjunction ) & & ! ( cond2 instanceof Conjunction ) ) { return false ; } Term term1 = null ; Term term2 = null ; if ( cond1 instanceof Conjunction ) { term1 = CompoundTerm . reduceComponents ( ( Conjunction ) cond1 , cond2 , memory ) ; } if ( cond2 instanceof Conjunction ) { term2 = CompoundTerm . reduceComponents ( ( Conjunction ) cond2 , cond1 , memory ) ; } if ( ( term1 = = null ) & & ( term2 = = null ) ) { return false ; } Task task = memory . currentTask ; Sentence sentence = task . getSentence ( ) ; Sentence belief = memory . currentBelief ; TruthValue value1 = sentence . getTruth ( ) ; TruthValue value2 = belief . getTruth ( ) ; Term content ; TruthValue truth = null ; BudgetValue budget ; if ( term1 ! = null ) { if ( term2 ! = null ) { content = Statement . make ( st2 , term2 , term1 , memory ) ; } else { content = term1 ; } if ( sentence . isQuestion ( ) ) { budget = BudgetFunctions . backwardWeak ( value2 , memory ) ; } else { truth = TruthFunctions . abduction ( value2 , value1 ) ; budget = BudgetFunctions . forward ( truth , memory ) ; } memory . doublePremiseTask ( content , truth , budget ) ; } if ( term2 ! = null ) { if ( term1 ! = null ) { content = Statement . make ( st1 , term1 , term2 , memory ) ; } else { content = term2 ; } if ( sentence . isQuestion ( ) ) { budget = BudgetFunctions . backwardWeak ( value2 , memory ) ; } else { truth = TruthFunctions . abduction ( value1 , value2 ) ; budget = BudgetFunctions . forward ( truth , memory ) ; } memory . doublePremiseTask ( content , truth , budget ) ; } return true ; }
public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd = = null ) { return ; } String state = statusMpd . getState ( ) ; if ( state = = null | | state . equals ( prevMpdState ) ) { return ; } if ( state . equals ( MPDStatus . MPD_STATE_PLAYING ) ) { isPaused = false ;
NEGATION { @Override public String toString ( ) { return " -- " ; } } , DISJUNCTION { @Override public String toString ( ) { return " || " ; } } ,
public void actionPerformed ( ActionEvent ae ) { nlpGui . nextScenePressed ( ) ; }
public URL get ( String url ) throws MalformedURLException { String parsed = null ; if ( url . startsWith ( " http:// " ) ) { HttpURLConnection connection = null ; try { URL u = new URL ( url ) ; connection = ( HttpURLConnection ) u . openConnection ( ) ; InputStream in = new BufferedInputStream ( connection . getInputStream ( ) , 8192 ) ; byte buffer [ ] = new byte [ 8192 ] ; int read = in . read ( buffer ) ; if ( read < buffer . length ) { buffer [ read ] = '\0' ; } parsed = parse ( new String ( buffer ) , handlers ) ; } catch ( IOException e ) { } finally { if ( null ! = connection ) { connection . disconnect ( ) ; } } } return new URL ( null = = parsed ? url : parsed ) ; }
PrivateKey getPrivateKey ( IMessageMDN msg , X509Certificate cert ) throws OpenAS2Exception ; }
public final ICommonsMap < String , Object > options ( ) { return m_aOptions ; }
void clearGlobalEventHandlers ( ) ; void clearEventHandlers ( ) ; void fireEvent ( EventType eventType , StatsKey key , Object target ) ; }
public int refresh ( int playlistVersion ) throws MPDServerException { MusicList playlist = new MusicList ( list ) ; List file = new LinkedList ( ) ; String [ ] args = new String [ 1 ] ; args [ 0 ] = Integer . toString ( playlistVersion ) ; MPDStatus status = this . mpd . getStatus ( ) ; List response = this . mpd . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_CHANGES , args ) ; Iterator it = response . iterator ( ) ; while ( it . hasNext ( ) ) { String line = ( String ) it . next ( ) ; if ( line . startsWith ( " file:  " ) ) { if ( file . size ( ) ! = 0 ) { playlist . add ( new Music ( file ) ) ; file . clear ( ) ; } } file . add ( line ) ; } if ( file . size ( ) ! = 0 ) { playlist . add ( new Music ( file ) ) ; } this . list . clear ( ) ; this . list . addAll ( playlist . subList ( 0 , status . getPlaylistLength ( ) ) ) ; return status . getPlaylistVersion ( ) ; }
public int get ( String key ) { if ( root = = null ) return Integer . MIN_VALUE ; MapNode < C > n = ( MapNode < C > ) root ; int length = ( key . length ( ) - 1 ) ; for ( int i = 0 ; i < = length ; i + + ) { char c = key . charAt ( i ) ; int index = n . childIndex ( c ) ; if ( index > = 0 ) { n = ( MapNode < C > ) n . getChild ( index ) ; } else { return Integer . MIN_VALUE ; } } if ( n ! = null ) return n . value ; return Integer . MIN_VALUE ; }
public void putAll ( Map < ? extends K , ? extends ExternalV > m ) { internalMap . putAll ( new TransformingMap ( m , writeTransformation , o - > o , o - > o ) ) ; }
public void event ( final Class event , final Object . . . arguments ) { if ( event = = CycleStop . class ) {
Library getLibrary ( String name ) ; Library loadLibrary ( String className ) throws Exception ; void unloadLibrary ( String name ) throws Exception ; SolveInfo solve ( String st ) throws Exception ; SolveInfo solveNext ( ) throws Exception ; void solveHalt ( ) ; void solveEnd ( ) ; boolean hasOpenAlternatives ( ) ; String toString ( Term term ) ; void addOutputListener ( OutputListener l ) ; void removeOutputListener ( OutputListener l ) ; void removeAllOutputListeners ( ) ; void setSpy ( boolean state ) ; void addSpyListener ( SpyListener l ) ; void removeSpyListener ( SpyListener l ) ; void removeAllSpyListeners ( ) ; void addExceptionListener ( ExceptionListener l ) ; void removeExceptionListener ( ExceptionListener l ) ; void removeAllExceptionListeners ( ) ; }
List < String [ ] > sendCommandQueueSeparated ( ) throws MPDServerException { return separatedQueueResults ( sendCommandQueue ( true ) ) ; }
public AlbumsFragment init ( Artist artist , Genre genre ) { isCountPossiblyDisplayed = true ; this . artist = artist ; this . genre = genre ; return this ; }
private static void addEntries ( JarOutputStream jo , File [ ] files , String baseDir , String rootDir ) { for ( int i = 0 ; i < files . length ; i + + ) {
public String toString ( ) { return " update_after " ; }
public void onBackPressed ( ) { if ( currentDisplayMode = = DisplayMode . MODE_LIBRARY ) { final int fmStackCount = fragmentManager . getBackStackEntryCount ( ) ; if ( fmStackCount > 0 ) { super . onBackPressed ( ) ; return ; } } if ( currentDisplayMode ! = DisplayMode . MODE_NOWPLAYING ) { switchMode ( DisplayMode . MODE_NOWPLAYING ) ; mDrawerList . setItemChecked ( 0 , true ) ; return ; } final SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( this ) ; final boolean exitConfirmationRequired = settings . getBoolean ( " enableExitConfirmation " , false ) ; if ( exitConfirmationRequired & & backPressExitCount < 1 ) { Tools . notifyUser ( String . format ( getResources ( ) . getString ( R . string . backpressToQuit ) ) , this ) ; backPressExitCount + = 1 ; exitCounterReset . postDelayed ( new Runnable ( ) { @Override public void run ( ) { backPressExitCount = 0 ; } } , 5000 ) ; } else { System . exit ( 0 ) ; } return ; }
public String toString ( ) { return new ToStringGenerator ( this ) . append ( " data " , m_aData ) . append ( " MDN " , m_aMDN ) . getToString ( ) ; }
public static Term make ( final Collection < Term > set ) { if ( set . isEmpty ( ) ) return null ; Term [ ] argument = set . toArray ( new Term [ set . size ( ) ] ) ; Arrays . sort ( argument ) ; return make ( argument ) ; }
Map < String , Object > valueMap ( ) ; @Override Set < ? extends Entry > entrySet ( ) ; interface Entry extends UnmodifiableConfig . Entry { < T > T setValue ( Object value ) ; } Config createSubConfig ( ) ; default void update ( String path , Object value ) { set ( path , value ) ; } default void update ( List < String > path , Object value ) { set ( path , value ) ; } static Config of ( ConfigFormat < ? extends Config > format ) { return new SimpleConfig ( format , false ) ; } static Config ofConcurrent ( ConfigFormat < ? extends Config > format ) { return new SimpleConfig ( format , true ) ; } static Config inMemory ( ) { return InMemoryFormat . defaultInstance ( ) . createConfig ( ) ; } static Config inMemoryConcurrent ( ) { return InMemoryFormat . defaultInstance ( ) . createConcurrentConfig ( ) ; } static Config wrap ( Map < String , Object > map , ConfigFormat < ? > format ) { return new SimpleConfig ( map , format ) ; } static Config copy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) , false ) ; } static Config copy ( UnmodifiableConfig config , ConfigFormat < ? > format ) { return new SimpleConfig ( config , format , false ) ; } static Config concurrentCopy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) , true ) ; } static Config concurrentCopy ( UnmodifiableConfig config , ConfigFormat < ? > format ) { return new SimpleConfig ( config , format , true ) ; } }
protected Collection < Music > genericSearch ( final String searchCommand , final String type , final String strToFind ) throws MPDServerException { final List < String > response = mConnection . sendCommand ( searchCommand , type , strToFind ) ; return Music . getMusicFromList ( response , true ) ; }
abstract public boolean allow ( Statement st ) ; public void remove ( final Sentence s ) { removeEdge ( s ) ; } public void add ( final Sentence s ) { boolean include = false ; if ( s . content instanceof CompoundTerm ) { CompoundTerm cs = ( CompoundTerm ) s . content ; if ( cs instanceof Statement ) { Statement st = ( Statement ) cs ; if ( allow ( st ) ) { Term subject = st . getSubject ( ) ; Term predicate = st . getPredicate ( ) ; addVertex ( subject ) ; addVertex ( predicate ) ; addEdge ( subject , predicate , s ) ; } } } } }
public void decQuality ( float v ) { quality . setValue ( UtilityFunctions . and ( quality . getValue ( ) , v ) ) ; }
public void bindView ( View view , Context context , Cursor cursor ) { ChildViewCache views = ( ChildViewCache ) view . getTag ( ) ; int flags = 0 ; if ( mFlagsCol ! = INVALID_INDEX ) { flags = cursor . getInt ( mFlagsCol ) ; } if ( views . mText1 ! = null ) { String text1 = getStringOrNull ( cursor , mText1Col ) ; setViewText ( views . mText1 , text1 ) ; } if ( views . mText2 ! = null ) { CharSequence text2 = getStringOrNull ( cursor , mText2UrlCol ) ; if ( text2 ! = null ) { text2 = formatUrl ( text2 ) ; } else { text2 = getStringOrNull ( cursor , mText2Col ) ; } if ( TextUtils . isEmpty ( text2 ) ) { if ( views . mText1 ! = null ) { views . mText1 . setSingleLine ( false ) ; views . mText1 . setMaxLines ( 2 ) ; } } else { if ( views . mText1 ! = null ) { views . mText1 . setSingleLine ( true ) ; views . mText1 . setMaxLines ( 1 ) ; } } setViewText ( views . mText2 , text2 ) ; } if ( views . mIcon1 ! = null ) { setViewDrawable ( views . mIcon1 , getIcon1 ( cursor ) , View . INVISIBLE ) ; } if ( views . mIcon2 ! = null ) { setViewDrawable ( views . mIcon2 , getIcon2 ( cursor ) , View . GONE ) ; } if ( mQueryRefinement = = REFINE_ALL | | ( mQueryRefinement = = REFINE_BY_ENTRY
public void setParameterParsers ( @Nullable final ICommonsMap < String , AbstractParameterParser > aParameterParsers ) { m_aParameterParsers = aParameterParsers ; }
public void testBTree ( ) { TestData data = Utils . generateTestData ( 1000 ) ; String bstName = " B-Tree " ; BTree < Integer > bst = new BTree < Integer > ( 2 ) ; Collection < Integer > bstCollection = bst . toCollection ( ) ; assertTrue ( TreeTest . testTree ( bst , Integer . class , bstName , data . unsorted , data . invalid ) ) ; assertTrue ( JavaCollectionTest . testCollection ( bstCollection , Integer . class , bstName , data . unsorted , data . sorted , data . invalid ) ) ;
public void byteMessageValid ( ) throws Exception { new Expectations ( ) { { config . getString ( MorphlineTranslator . ENCODING_KEY ) ; result = " UTF-8 " ; config . getString ( MorphlineTranslator . ENCODING_MSG ) ; result = " UTF-16 " ; config . getString ( MorphlineTranslator . MORPHLINE ) ; result = getResourcePath ( MORPHLINE_FILE ) ; config . getString ( MorphlineTranslator . MORPHLINE_ID ) ; result = " encoding-message " ; config . getStringList ( MorphlineTranslator . FIELD_NAMES ) ; result = Lists . newArrayList ( " int " , " str " , " float " ) ; config . getStringList ( MorphlineTranslator . FIELD_TYPES ) ; result = Lists . newArrayList ( " int " , " string " , " float " ) ; } } ; byteMorphline . configure ( config ) ; String message = " \ u16b7 " ; Iterable < Row > result = byteMorphline . translate ( " The Key " . getBytes ( " UTF-8 " ) , message . getBytes ( " UTF-16 " ) ) ; Row row = result . iterator ( ) . next ( ) ; Assert . assertNotNull ( " Row is null " , result ) ; Assert . assertEquals ( " Invalid number of fields " , 3 , row . length ( ) ) ; Assert . assertEquals ( " Invalid field value " , 123 , row . get ( 0 ) ) ; Assert . assertEquals ( " Invalid field value " , message , row . get ( 1 ) ) ; Assert . assertEquals ( " Invalid field value " , 234 F , row . get ( 2 ) ) ; }
protected float calcTrackOffset ( ) { return ( showTicks ) ? trackWidth + 2 : trackWidth / 2 + 2 ; }
final void stop ( ) { MPDroidService . MPD_ASYNC_HELPER . removeTrackPositionListener ( this ) ; mRemoteControlClient . setOnGetPlaybackPositionListener ( null ) ; mRemoteControlClient . setPlaybackPositionUpdateListener ( null ) ; }
public List < Album > getAlbums ( final Artist artist , final boolean trackCountNeeded ) throws MPDServerException { final List < Album > albums = getAlbums ( artist , trackCountNeeded , false ) ; if ( artist ! = null & & ! artist . isUnknown ( ) ) { return Item . merged ( albums , getAlbums ( artist , trackCountNeeded , true ) ) ; } return albums ; }
public CASValue < Object > gets ( String key ) { return gets ( key , transcoder ) ; }
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; setContentView ( R . layout . artists ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; final String album = ( String ) this . getIntent ( ) . getStringExtra ( " album " ) ; this . setTitle ( album ) ; pd = ProgressDialog . show ( this , getResources ( ) . getString ( R . string . loading ) , getResources ( ) . getString ( R . string . loadingSongs ) ) ; app . oMPDAsyncHelper . addAsyncExecListener ( this ) ; iJobID = app . oMPDAsyncHelper . execAsync ( new Runnable ( ) { @Override public void run ( ) { try { MPDApplication app = ( MPDApplication ) getApplication ( ) ; dispMusic = new ArrayList < Music > ( app . oMPDAsyncHelper . oMPD . find ( MPD . MPD_FIND_ALBUM , album ) ) ; } catch ( MPDServerException e ) { } } } ) ; registerForContextMenu ( getListView ( ) ) ; }
public void unloadDefaults ( Object [ ] keysAndValues ) { for ( int i = 0 , c = keysAndValues . length ; i < c ; i = i + 2 ) { UIManager . getLookAndFeelDefaults ( ) . put ( keysAndValues [ i ] , null ) ;
public void storePartnership ( ) throws OpenAS2Exception { final String sFilename = getFilename ( ) ; if ( ! containsAttribute ( ATTR_DISABLE_BACKUP ) ) { long nIndex = 0 ; File aBackupFile ; do { aBackupFile = new File ( sFilename + '.' + StringHelper . getLeadingZero ( nIndex , 7 ) ) ; nIndex + + ; } while ( aBackupFile . exists ( ) ) ; s_aLogger . info ( " backing up  " + sFilename + "  to  " + aBackupFile . getName ( ) ) ; final File fr = new File ( sFilename ) ; FileOperations . renameFile ( fr , aBackupFile ) ; } final IMicroDocument aDoc = new MicroDocument ( ) ; final IMicroElement ePartnerships = aDoc . appendElement ( " partnerships " ) ; for ( final IStringMap aAttrs : getAllPartners ( ) ) { final IMicroElement ePartner = ePartnerships . appendElement ( " partner " ) ; for ( final Map . Entry < String , String > aAttr : aAttrs ) ePartner . setAttribute ( aAttr . getKey ( ) , aAttr . getValue ( ) ) ; } for ( final Partnership aPartnership : getAllPartnerships ( ) ) { final IMicroElement ePartnership = ePartnerships . appendElement ( " partnership " ) ; ePartnership . setAttribute ( PARTNER_NAME , aPartnership . getName ( ) ) ; final IMicroElement eSender = ePartnership . appendElement ( " sender " ) ; for ( final Map . Entry < String , String > aAttr : aPartnership . getAllSenderIDs ( ) ) eSender . setAttribute ( aAttr . getKey ( ) , aAttr . getValue ( ) ) ; final IMicroElement eReceiver = ePartnership . appendElement ( " receiver " ) ; for ( final Map . Entry < String , String > aAttr : aPartnership . getAllReceiverIDs ( ) ) eReceiver . setAttribute ( aAttr . getKey ( ) , aAttr . getValue ( ) ) ; for ( final Map . Entry < String , String > aAttr : aPartnership . getAllAttributes ( ) ) ePartnership . appendElement ( " attribute " ) . setAttribute ( " name " , aAttr . getKey ( ) ) . setAttribute ( " value " , aAttr . getValue ( ) ) ; } if ( MicroWriter . writeToFile ( aDoc , new File ( sFilename ) ) . isFailure ( ) ) throw new OpenAS2Exception ( " Failed to write to file  " + sFilename ) ;
public Integer [ ] sort ( Integer [ ] input ) { return HeapSort . sort ( input ) ; }
public void testRangeValues ( ) { Set < Step > steps = Sets . newHashSet ( ) ; Map < String , Object > loopStepConfigMap = Maps . newHashMap ( ) ; loopStepConfigMap . put ( LoopStep . MODE_PROPERTY , LoopStep . MODE_PARALLEL ) ; loopStepConfigMap . put ( LoopStep . SOURCE_PROPERTY , LoopStep . SOURCE_RANGE ) ; loopStepConfigMap . put ( LoopStep . RANGE_START_PROPERTY , 5 ) ; loopStepConfigMap . put ( LoopStep . RANGE_END_PROPERTY , 7 ) ; Config loopStepConfig = ConfigFactory . parseMap ( loopStepConfigMap ) ; RefactorStep loopStep = new LoopStep ( " loop_step " , loopStepConfig ) ; steps . add ( loopStep ) ; Map < String , Object > step1ConfigMap = Maps . newHashMap ( ) ; step1ConfigMap . put ( " dependencies " , Lists . newArrayList ( " loop_step " ) ) ; Config step1Config = ConfigFactory . parseMap ( step1ConfigMap ) ; Step step1 = new BatchStep ( " step1 " , step1Config ) ; steps . add ( step1 ) ; Set < Step > unrolled = loopStep . refactor ( steps ) ; assertEquals ( unrolled . size ( ) , 4 ) ; assertNotNull ( StepUtils . getStepForName ( " loop_step " , unrolled ) . get ( ) ) ; assertNotNull ( StepUtils . getStepForName ( " step1_5 " , unrolled ) . get ( ) ) ; assertNotNull ( StepUtils . getStepForName ( " step1_6 " , unrolled ) . get ( ) ) ; assertNotNull ( StepUtils . getStepForName ( " step1_7 " , unrolled ) . get ( ) ) ; assertEquals ( StepUtils . getStepForName ( " loop_step " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_5 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_6 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; assertEquals ( StepUtils . getStepForName ( " step1_7 " , unrolled ) . get ( ) . getDependencyNames ( ) , Sets . newHashSet ( " loop_step " ) ) ; }
public boolean process ( ContentEvent event ) { if ( event instanceof AttributeContentEvent ) { AttributeContentEvent ace = ( AttributeContentEvent ) event ; Long learningNodeId = Long . valueOf ( ace . getLearningNodeId ( ) ) ; Integer obsIndex = Integer . valueOf ( ace . getObsIndex ( ) ) ; AttributeClassObserver obs = localStats . get ( learningNodeId , obsIndex ) ; if ( obs = = null ) { obs = ace . isNominal ( ) ? newNominalClassObserver ( ) : newNumericClassObserver ( ) ; localStats . put ( ace . getLearningNodeId ( ) , obsIndex , obs ) ; } obs . observeAttributeClass ( ace . getAttrVal ( ) , ace . getClassVal ( ) , ace . getWeight ( ) ) ; } else if ( event instanceof ComputeContentEvent ) { ComputeContentEvent cce = ( ComputeContentEvent ) event ; Long learningNodeId = Long . valueOf ( cce . getLearningNodeId ( ) ) ; double [ ] preSplitDist = cce . getPreSplitDist ( ) ; Map < Integer , AttributeClassObserver > learningNodeRowMap = localStats . row ( learningNodeId ) ; List < AttributeSplitSuggestion > suggestions = new Vector < AttributeSplitSuggestion > ( ) ; for ( Entry < Integer , AttributeClassObserver > entry : learningNodeRowMap . entrySet ( ) ) { AttributeClassObserver obs = entry . getValue ( ) ; AttributeSplitSuggestion suggestion = obs . getBestEvaluatedSplitSuggestion ( splitCriterion , preSplitDist , entry . getKey ( ) . intValue ( ) , binarySplit ) ; if ( suggestion ! = null ) { suggestions . add ( suggestion ) ; } } AttributeSplitSuggestion [ ] bestSuggestions = suggestions . toArray ( new AttributeSplitSuggestion [ suggestions . size ( ) ] ) ; Arrays . sort ( bestSuggestions ) ; AttributeSplitSuggestion bestSuggestion = null ; AttributeSplitSuggestion secondBestSuggestion = null ; if ( bestSuggestions . length > = 1 ) { bestSuggestion = bestSuggestions [ bestSuggestions . length - 1 ] ; if ( bestSuggestions . length > = 2 ) { secondBestSuggestion = bestSuggestions [ bestSuggestions . length - 2 ] ; } } LocalResultContentEvent lcre = new LocalResultContentEvent ( cce . getSplitId ( ) , bestSuggestion , secondBestSuggestion ) ; computationResultStream . put ( lcre ) ; logger . debug ( " Finish compute event " ) ; } else if ( event instanceof DeleteContentEvent ) { DeleteContentEvent dce = ( DeleteContentEvent ) event ; Long learningNodeId = Long . valueOf ( dce . getLearningNodeId ( ) ) ; localStats . rowMap ( ) . remove ( learningNodeId ) ; } return false ; }
public void testIPv6Host ( ) throws Exception { List < InetSocketAddress > addrs = AddrUtil . getAddresses ( " ::1:80 " ) ; assertEquals ( 1 , addrs . size ( ) ) ; assertEquals ( " localhost " , addrs . get ( 0 ) . getHostName ( ) ) ; assertEquals ( 80 , addrs . get ( 0 ) . getPort ( ) ) ; }
public int closestIndex ( double p ) { int r ; int s = size ( ) ; for ( r = 0 ; r < resolution ; r + + ) { if ( index [ r ] > p ) { break ; } } if ( r = = resolution ) r = resolution - 1 ; int i = ( int ) Math . round ( r * ( ( double ) s ) / ( resolution - 1 ) ) ; if ( i < 0 ) i = 0 ; if ( i > = s ) i = s - 1 ; return i ; }
public void execute ( Map < V , ProcessingGraphCanvas . VertexDisplay > displayed ) { vertexArray = new ArrayList < > ( graph . vertexSet ( ) ) ; mxRectangle initialBounds = null ; int n = vertexArray . size ( ) ; dispX = new double [ n ] ; dispY = new double [ n ] ; cellLocation = new double [ n ] [ ] ; isMoveable = new boolean [ n ] ; neighbors = new int [ n ] [ ] ; radius = new double [ n ] ; radiusSquared = new double [ n ] ; minDistanceLimitSquared = minDistanceLimit * minDistanceLimit ; if ( forceConstant < 0.001 ) { forceConstant = 0.001 ; } forceConstantSquared = forceConstant * forceConstant ; for ( int i = 0 ; i < n ; i + + ) { V vertex = vertexArray . get ( i ) ; VertexDisplay vd = displayed . get ( vertex ) ; cellLocation [ i ] = new double [ 2 ] ; indices . put ( vertex , i ) ; double width = vd . getRadius ( ) * 2f ; double height = vd . getRadius ( ) * 2f ; double x , y ; if ( vd = = null ) { x = 0 ; y = 0 ; } else { x = vd . getX ( ) ; y = vd . getY ( ) ; } cellLocation [ i ] [ 0 ] = x + width / 2.0 ; cellLocation [ i ] [ 1 ] = y + height / 2.0 ; radius [ i ] = Math . min ( width , height ) ; radiusSquared [ i ] = radius [ i ] * radius [ i ] ; dispX [ i ] = 0 ; dispY [ i ] = 0 ; isMoveable [ i ] = true ; V v = vertexArray . get ( i ) ; if ( ! graph . containsVertex ( v ) ) continue ; Set < E > edges = graph . edgesOf ( v ) ; List < V > cells = new ArrayList ( edges . size ( ) ) ; for ( E e : edges ) { if ( isResetEdges ( ) ) { } if ( isDisableEdgeStyle ( ) ) { } V source = graph . getEdgeSource ( e ) ; V target = graph . getEdgeTarget ( e ) ; if ( source ! = v ) cells . add ( source ) ; else if ( target ! = v ) cells . add ( target ) ; } neighbors [ i ] = new int [ cells . size ( ) ] ; for ( int j = 0 ; j < cells . size ( ) ; j + + ) { Integer index = indices . get ( cells . get ( j ) ) ; if ( index ! = null ) { neighbors [ i ] [ j ] = index . intValue ( ) ; } else { neighbors [ i ] [ j ] = i ; } } } temperature = initialTemp ; if ( maxIterations = = 0 ) { maxIterations = 20.0 * Math . sqrt ( n ) ; } for ( iteration = 0 ; iteration < maxIterations ; iteration + + ) { if ( ! allowedToRun ) { return ; } calcRepulsion ( ) ; calcAttraction ( ) ; calcPositions ( ) ; reduceTemperature ( ) ; } double minx = 0 , miny = 0 , maxx = 0 , maxy = 0 ; for ( int i = 0 ; i < vertexArray . size ( ) ; i + + ) { V vertex = vertexArray . get ( i ) ; ProcessingGraphCanvas . VertexDisplay vd = displayed . get ( vertex ) ; if ( vd ! = null ) { float r = vd . getRadius ( ) ; double x = ( cellLocation [ i ] [ 0 ] - r / 2f ) ; double y = ( cellLocation [ i ] [ 1 ] - r / 2f ) ; vd . setPosition ( ( float ) x , ( float ) y ) ; if ( i = = 0 ) { minx = maxx = x ; miny = maxy = y ; } else { if ( x < minx ) minx = x ; if ( y < miny ) miny = y ; if ( x > maxx ) maxx = x ; if ( y > maxy ) maxy = y ; } } } double dx = - ( maxx + minx ) / 2f ; double dy = - ( maxy + miny ) / 2f ; if ( initialBounds ! = null ) { dx + = initialBounds . getX ( ) ; dy + = initialBounds . getY ( ) ; } for ( VertexDisplay vd : displayed . values ( ) ) vd . movePosition ( ( float ) dx , ( float ) dy ) ;
public static Row appendSurrogateKey ( Row row , String fieldName ) { return RowUtils . append ( row , fieldName , DataTypes . StringType , false , UUID . randomUUID ( ) . toString ( ) ) ; }
private static void transformSubjectPI ( CompoundTerm subject , Term predicate , NAL nal ) { TruthValue truth = nal . getCurrentTask ( ) . sentence . truth ; BudgetValue budget ; Inheritance inheritance ; Term newSubj , newPred ; if ( subject instanceof Product ) { Product product = ( Product ) subject ;
public final IDynamicComponent getComponent ( @Nonnull @Nonempty final String sComponentID ) throws AS2ComponentNotFoundException { ValueEnforcer . notEmpty ( sComponentID , " ComponentID " ) ; final IDynamicComponent aComponent = m_aComponents . get ( sComponentID ) ; if ( aComponent = = null ) throw new AS2ComponentNotFoundException ( sComponentID ) ; return aComponent ; }
public Implication clone ( ) { return new Implication ( name ( ) , cloneTerms ( ) , isConstant ( ) , containVar ( ) , complexity , temporalOrder ) ; }
public E processNext ( final float forgetCycles , final Memory m ) { final E x = takeNext ( ) ; if ( x ! = null ) {
protected void init ( boolean pretty ) { GsonBuilder builder = new GsonBuilder ( ) . addSerializationExclusionStrategy ( new ExclusionStrategy ( ) { @Override public boolean shouldSkipField ( FieldAttributes fa ) { return fa . getName ( ) . equals ( " derivationChain " ) ; } @Override public boolean shouldSkipClass ( Class < ? > type ) { return false ; } } ) . enableComplexMapKeySerialization ( ) . serializeNulls ( ) . disableHtmlEscaping ( ) ; if ( pretty ) { builder . setPrettyPrinting ( ) ; } gson = builder . create ( ) ;
abstract public void onCycleEnd ( long clock ) ; abstract public void onTaskAdd ( Task task , String reason ) ; abstract public void onTaskRemove ( Task task , String reason ) ; }
boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; Set < String > listSaslMechanisms ( ) ; }
public String generateMessageID ( ) { final StringBuilder aSB = new StringBuilder ( ) ; final String sDateFormat = getPartnership ( ) . getDateFormat ( DEFAULT_DATE_FORMAT ) ; aSB . append ( " < " ) . append ( CAS2Info . NAME ) . append ( " - " ) . append ( DateHelper . getFormattedDateNow ( sDateFormat ) ) ; final DecimalFormat aRandomFormatter = new DecimalFormat ( " 0000 " ) ; int nRandom ; if ( AS2GlobalSettings . isUseSecureRandom ( ) ) nRandom = VerySecureRandom . getInstance ( ) . nextInt ( 10000 ) ; else nRandom = new Random ( ) . nextInt ( 10000 ) ; aSB . append ( '-' ) . append ( aRandomFormatter . format ( nRandom ) ) ; final Partnership aPartnership = getMessage ( ) . getPartnership ( ) ; final String sReceiverID = aPartnership . getReceiverAS2ID ( ) ; final String sSenderID = aPartnership . getSenderAS2ID ( ) ; aSB . append ( '@' ) . append ( sReceiverID ) . append ( '_' ) . append ( sSenderID ) ; return aSB . append ( '>' ) . toString ( ) ; }
public boolean interlinkConcepts ( final Task newEvent , DerivationContext nal ) { if ( newEvent . budget = = null | | ! newEvent . isParticipatingInTemporalInductionOnSucceedingEvents ( ) ) { return false ; } nal . emit ( Events . InduceSucceedingEvent . class , newEvent , nal ) ; if ( newEvent . sentence . isEternal ( ) | | ! isInputOrOperation ( newEvent ) ) { return false ; } if ( Parameters . TEMPORAL_INDUCTION_ON_SUCCEEDING_EVENTS ) { for ( Task stmLast : stm ) { Concept OldConc = this . concept ( stmLast . getTerm ( ) ) ; if ( OldConc ! = null ) { TermLink template = new TermLink ( newEvent . getTerm ( ) , TermLink . TEMPORAL ) ; if ( OldConc . termLinkTemplates = = null ) OldConc . termLinkTemplates = new ArrayList < > ( ) ; OldConc . termLinkTemplates . add ( template ) ; OldConc . buildTermLinks ( newEvent . getBudget ( ) ) ; } } } while ( stm . size ( ) + 1 > Parameters . STM_SIZE ) stm . removeFirst ( ) ; stm . addLast ( newEvent ) ; return true ; }
public void clear ( ) { mMap . clear ( ) ; mOrder . clear ( ) ; }
public void tableChanged ( TableModelEvent tableModelEvent ) { fireTableChanged ( tableModelEvent ) ; }
public int compare ( GenericRecord r1 , GenericRecord r2 ) { return compareTimestamp ( r1 , r2 , timestampFieldName ) ; }
public static NAR LoadFromFile ( String name ) throws FileNotFoundException , IOException , ClassNotFoundException { FileInputStream inStream = new FileInputStream ( name ) ; ObjectInputStream stream = new ObjectInputStream ( inStream ) ; NAR ret = ( NAR ) stream . readObject ( ) ; ret . memory . event = new EventEmitter ( ) ; ret . plugins = new ArrayList < > ( ) ; new Plugins ( ) . init ( ret ) ; return ret ; }
public void directProcess ( final Task task ) { char type = task . getSentence ( ) . punctuation ; switch ( type ) { case Symbols . JUDGMENT_MARK : processJudgment ( task ) ; break ; case Symbols . GOAL_MARK : processGoal ( task ) ; break ; case Symbols . QUESTION_MARK : case Symbols . QUEST_MARK : processQuestion ( task ) ; break ; default : return ; } if ( task . aboveThreshold ( ) ) { linkToTask ( task ) ; } if ( entityObserver . isActive ( ) ) { entityObserver . refresh ( displayContent ( ) ) ;
public String toString ( ) { return super . toString ( ) + "  Cas:  " + cas + "  Exp:  " + exp + "  Flags:  " + flags + "  Data Length:  " + data . length ;
abstract public boolean contains ( final E it ) ; abstract public E get ( final CharSequence key ) ; abstract public Set < CharSequence > keySet ( ) ; abstract public int getCapacity ( ) ; abstract public float getMass ( ) ; abstract public boolean putIn ( final E newItem ) ; abstract public int size ( ) ; abstract public E takeOut ( ) ; abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } protected float forgetCycles ( ) { return forgettingRate . getCycles ( ) ; } public void forget ( final E x ) { float forgetCycles = forgetCycles ( ) ; if ( forgetCycles > 0 ) { BudgetFunctions . forget ( x . budget , forgetCycles , RELATIVE_THRESHOLD ) ; } } public final boolean putBack ( final E oldItem ) { forget ( oldItem ) ; return putIn ( oldItem ) ; } synchronized public E processNext ( boolean forget ) { final E x = takeOut ( ) ; if ( x ! = null ) { if ( forget ) { forget ( x ) ; } boolean r = putIn ( x ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else { return null ; } } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; @Override public abstract Iterator < E > iterator ( ) ; }
public Iterator < E > descendingIterator ( ) { return new Iterator < E > ( ) { int pos = size - 1 ;
MutatatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }
public String toString ( ) { final StringBuffer buff = new StringBuffer ( ) ; buff . append ( " [ " ) ; synchronized ( mLOCK ) { for ( final Iterator < ? > itr = iterator ( ) ; itr . hasNext ( ) ; ) { buff . append ( itr . next ( ) ) ; if ( itr . hasNext ( ) ) { buff . append ( " ,  " ) ; } } } buff . append ( " ] " ) ; return buff . toString ( ) ; }
public String validArgs ( ) { return this . validArgs ( null , null ) ; }
protected void toByteArray ( DataOutputStream dout ) throws IOException { super . toByteArray ( dout ) ; dout . writeShort ( _priority ) ; dout . writeShort ( _weight ) ; dout . writeShort ( _port ) ; try { dout . write ( _server . getBytes ( " UTF-8 " ) ) ;
Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
public void onFinish ( NARGraph g ) { if ( includeSyntax > 0 ) { for ( final Term a : terms . keySet ( ) ) { if ( a instanceof CompoundTerm ) { CompoundTerm c = ( CompoundTerm ) a ; g . addVertex ( c . operator ( ) ) ; g . addEdge ( c . operator ( ) , c , new TermType ( ) ) ; if ( includeSyntax - 1 > 0 ) { recurseTermComponents ( g , c , includeSyntax - 1 ) ; } } } } if ( includeTermContent ) { for ( final Term a : terms . keySet ( ) ) { for ( final Term b : terms . keySet ( ) ) { if ( a = = b ) { continue ; } if ( a . containsTerm ( b ) ) { g . addVertex ( a ) ; g . addVertex ( b ) ; g . addEdge ( a , b , new TermContent ( ) ) ; } if ( b . containsTerm ( a ) ) { g . addVertex ( a ) ; g . addVertex ( b ) ; g . addEdge ( b , a , new TermContent ( ) ) ; } } } } if ( includeDerivations & & includeBeliefs ) { for ( final Entry < Sentence , Concept > s : sentenceTerms . entrySet ( ) ) { final Sentence derivedSentence = s . getKey ( ) ; final Collection < Term > schain = derivedSentence . stamp . getChain ( ) ; final Concept derived = s . getValue ( ) ; for ( final Entry < Sentence , Concept > t : sentenceTerms . entrySet ( ) ) { if ( s = = t ) { continue ; } final Sentence deriverSentence = t . getKey ( ) ; final Concept deriver = t . getValue ( ) ; if ( derived = = deriver ) { continue ; } final Collection < Term > tchain = deriverSentence . stamp . getChain ( ) ; if ( schain . contains ( deriverSentence . content ) ) { g . addVertex ( derived ) ; g . addVertex ( deriver ) ; g . addEdge ( deriver , derived , new TermDerivation ( ) ) ; } if ( tchain . contains ( derivedSentence . content ) ) { g . addVertex ( derived ) ; g . addVertex ( deriver ) ; g . addEdge ( derived , deriver , new TermDerivation ( ) ) ; } } } } if ( includeTermLinks ) { for ( Entry < TermLink , Concept > et : termLinks . entrySet ( ) ) { TermLink t = et . getKey ( ) ; Concept from = et . getValue ( ) ; Concept to = terms . get ( t . target ) ; if ( to ! = null ) { g . addEdge ( from , to , new TermLinkEdge ( t ) ) ; } } } if ( includeTaskLinks ) { for ( Entry < TaskLink , Concept > et : taskLinks . entrySet ( ) ) {
Set < String > getAllPartnershipNames ( ) ; @Nonnull @ReturnsMutableCopy List < Partnership > getAllPartnerships ( ) ; @Nonnull IPartnershipMap getPartnershipMap ( ) ; }
public void testNoneArrivingNoneExisting ( ) { p = new BitemporalHistoryPlanner ( ) ; p . configure ( config ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 0 ) ; }
public void onCreateOptionsMenu ( Menu menu , MenuInflater inflater ) { super . onCreateOptionsMenu ( menu , inflater ) ; inflater . inflate ( R . menu . mpd_playlistmenu , menu ) ; menu . removeItem ( R . id . PLM_EditPL ) ; }
public float reportFixture ( Fixture fixture , Vec2 point , Vec2 normal , float fraction ) { Body body = fixture . getBody ( ) ; Object userData = body . getUserData ( ) ; m_hit = true ; m_point = point ; m_normal = normal ; return fraction ; }
static void elimiVarDep ( CompoundTerm compound , Term component , boolean compoundTask , DerivationContext nal ) { Term comp = null ; for ( Term t : compound ) { Term [ ] unify = new Term [ ] { t , component } ; if ( Variables . unify ( Symbols . VAR_DEPENDENT , unify ) ) { comp = t ; break ; } if ( Variables . unify ( Symbols . VAR_QUERY , unify ) ) { comp = t ; break ; } } if ( comp = = null ) { return ; } Term content = reduceComponents ( compound , comp , nal . mem ( ) ) ; if ( ( content = = null ) | | ( ( content instanceof Statement ) & & ( ( Statement ) content ) . invalid ( ) ) ) { return ; } Task task = nal . getCurrentTask ( ) ; Sentence sentence = task . sentence ; Sentence belief = nal . getCurrentBelief ( ) ; TruthValue v1 = sentence . truth ; TruthValue v2 = belief . truth ; TruthValue truth = null ; BudgetValue budget ; if ( sentence . isQuestion ( ) | | sentence . isQuest ( ) ) { budget = ( compoundTask ? BudgetFunctions . backward ( v2 , nal ) : BudgetFunctions . backwardWeak ( v2 , nal ) ) ; } else { if ( sentence . isGoal ( ) ) { truth = ( compoundTask ? TruthFunctions . desireDed ( v1 , v2 ) : TruthFunctions . desireInd ( v1 , v2 ) ) ; } else { truth = ( compoundTask ? TruthFunctions . anonymousAnalogy ( v1 , v2 ) : TruthFunctions . anonymousAnalogy ( v2 , v1 ) ) ; } budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; } nal . doublePremiseTask ( content , truth , budget , false , false ) ; }
public byte depth ( ) { return Rope . depth ( this . rope ) ; }
public void handleIO ( ) throws IOException { if ( shutDown ) { throw new IOException ( " No IO while shut down " ) ; } handleInputQueue ( ) ; getLogger ( ) . debug ( " Done dealing with queue. " ) ; long delay = 0 ; if ( ! reconnectQueue . isEmpty ( ) ) { long now = System . currentTimeMillis ( ) ; long then = reconnectQueue . firstKey ( ) ; delay = Math . max ( then - now , 1 ) ; } getLogger ( ) . debug ( " Selecting with delay of %sms " , delay ) ; assert selectorsMakeSense ( ) : " Selectors don't make sense. " ; int selected = selector . select ( delay ) ; Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; if ( selectedKeys . isEmpty ( ) & & ! shutDown ) { getLogger ( ) . debug ( " No selectors ready, interrupted:  " + Thread . interrupted ( ) ) ; if ( + + emptySelects > DOUBLE_CHECK_EMPTY ) { for ( SelectionKey sk : selector . keys ( ) ) { getLogger ( ) . info ( " %s has %s, interested in %s " , sk , sk . readyOps ( ) , sk . interestOps ( ) ) ; if ( sk . readyOps ( ) ! = 0 ) { getLogger ( ) . info ( " %s has a ready op, handling IO " , sk ) ; handleIO ( sk ) ; } else { queueReconnect ( ( MemcachedNode ) sk . attachment ( ) ) ; } } assert emptySelects < EXCESSIVE_EMPTY : " Too many empty selects " ; } } else { getLogger ( ) . debug ( " Selected %d, selected %d keys " , selected , selectedKeys . size ( ) ) ; emptySelects = 0 ; for ( SelectionKey sk : selectedKeys ) { handleIO ( sk ) ; } selectedKeys . clear ( ) ; } if ( ! shutDown & & ! reconnectQueue . isEmpty ( ) ) { attemptReconnects ( ) ;
public String toStringArff ( ) { StringBuffer text = new StringBuffer ( ) ; text . append ( ARFF_RELATION ) . append ( "   " ) . append ( Utils . quote ( getRelationName ( ) ) ) . append ( " \ n \ n " ) ; for ( int i = 0 ; i < numAttributes ( ) ; i + + ) { text . append ( attribute ( i ) . toString ( ) ) . append ( " \ n " ) ; } text . append ( " \ n " ) . append ( ARFF_DATA ) . append ( " \ n " ) ; text . append ( toString ( ) ) ; return text . toString ( ) ;
public void addCoverRequest ( CoverInfo coverInfo , CoverDownloadListener listener , boolean insertFirst ) { this . helpersByCoverInfo . put ( coverInfo , listener ) ; if ( insertFirst ) { this . requests . addFirst ( coverInfo ) ;
public static float w2c ( float v ) { return v / ( v + Parameters . NEAR_FUTURE ) ; }
public void doWrites ( ) { HttpOperation op ; while ( ( op = writeQ . poll ( ) ) ! = null ) { if ( ! op . isTimedOut ( ) & & ! op . isCancelled ( ) ) {
public void testEngineInitialization ( ) { Prolog engine = new Prolog ( ) ; assertEquals ( 4 , engine . getCurrentLibraries ( ) . length ) ; assertNotNull ( engine . getLibrary ( " nars.prolog.lib.BasicLibrary " ) ) ; assertNotNull ( engine . getLibrary ( " nars.prolog.lib.ISOLibrary " ) ) ; assertNotNull ( engine . getLibrary ( " nars.prolog.lib.IOLibrary " ) ) ; assertNotNull ( engine . getLibrary ( " nars.prolog.lib.JavaLibrary " ) ) ; }
public String getAsString ( ) { final StringBuilder aSB = new StringBuilder ( ) ; aSB . append ( " Message From: " ) . append ( getPartnership ( ) . getAllSenderIDs ( ) ) ; aSB . append ( " \ nTo: " ) . append ( getPartnership ( ) . getAllReceiverIDs ( ) ) ; aSB . append ( " \ nHeaders: " ) . append ( getHeadersDebugFormatted ( ) ) . append ( " \ nAttributes: " ) . append ( getAllAttributes ( ) ) ; final IMessageMDN aMDN = getMDN ( ) ; if ( aMDN ! = null ) aSB . append ( " \ nMDN: " ) . append ( aMDN . getAsString ( ) ) ; return aSB . toString ( ) ; }
public void testFNV1A64 ( ) { HashMap < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " " , 0x84222325L ) ; exp . put ( "   " , 0x8601817fL ) ; exp . put ( " hello world! " , 0xcd5a2672L ) ; exp . put ( " Lorem ipsum dolor sit amet, consectetuer adipiscing elit. " , 0xbec309a8L ) ; exp . put ( " wd:com.google " , 0x097b3f26L ) ; exp . put ( " wd:com.google  " , 0x1c6c1732L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( HashAlgorithm . FNV1A_64_HASH , me . getKey ( ) ,
public void testConvertFromResults ( ) { byte [ ] rowKey = Bytes . add ( Bytes . toBytes ( " GOOG: " ) , Bytes . toBytes ( 1000L ) ) ; byte [ ] cf = Bytes . toBytes ( " cf1 " ) ; byte [ ] clordid = Bytes . toBytes ( " clordid " ) ; byte [ ] orderqty = Bytes . toBytes ( " orderqty " ) ; byte [ ] leavesqty = Bytes . toBytes ( " leavesqty " ) ; byte [ ] cumqty = Bytes . toBytes ( " cumqty " ) ; List < Cell > cells1 = Lists . newArrayList ( ( Cell ) new KeyValue ( rowKey , cf , clordid , 1000L , Bytes . toBytes ( " abcd " ) ) , new KeyValue ( rowKey , cf , orderqty , 1000L , Bytes . toBytes ( 100 ) ) , new KeyValue ( rowKey , cf , leavesqty , 1000L , Bytes . toBytes ( 10 ) ) , new KeyValue ( rowKey , cf , cumqty , 1000L , Bytes . toBytes ( 5 ) ) ) ; Result result1 = Result . create ( cells1 ) ; byte [ ] rowKey2 = Bytes . add ( Bytes . toBytes ( " AAPL: " ) , Bytes . toBytes ( 1004L ) ) ; List < Cell > cells2 = Lists . newArrayList ( ( Cell ) new KeyValue ( rowKey2 , cf , clordid , 1004L , Bytes . toBytes ( " efgh " ) ) , new KeyValue ( rowKey2 , cf , orderqty , 1004L , Bytes . toBytes ( 99 ) ) , new KeyValue ( rowKey2 , cf , leavesqty , 1004L , Bytes . toBytes ( 9 ) ) , new KeyValue ( rowKey2 , cf , cumqty , 1004L , Bytes . toBytes ( 4 ) ) ) ; Result result2 = Result . create ( cells2 ) ; List < Row > rows = serde . convertFromResults ( new Result [ ] { result1 , result2 } ) ; assertEquals ( " Two Rows should be returned " , 2 , rows . size ( ) ) ; assertEquals ( " Symbol should be GOOG " , " GOOG " , RowUtils . getAs ( String . class , rows . get ( 0 ) , " symbol " ) ) ; assertEquals ( " Transacttime should be 1000L " , 1000L , RowUtils . getAs ( Long . class , rows . get ( 0 ) , " transacttime " ) . longValue ( ) ) ; assertEquals ( " Clordid should be abcd " , " abcd " , RowUtils . getAs ( String . class , rows . get ( 0 ) , " clordid " ) ) ; assertEquals ( " Orderqty should be 100 " , 100 , RowUtils . getAs ( Integer . class , rows . get ( 0 ) , " orderqty " ) . intValue ( ) ) ; assertEquals ( " Leavesqty should be 10 " , 10 , RowUtils . getAs ( Integer . class , rows . get ( 0 ) , " leavesqty " ) . intValue ( ) ) ; assertEquals ( " Cumqty should be 5 " , 5 , RowUtils . getAs ( Integer . class , rows . get ( 0 ) , " cumqty " ) . intValue ( ) ) ; assertEquals ( " Symbol should be AAPL " , " AAPL " , RowUtils . getAs ( String . class , rows . get ( 1 ) , " symbol " ) ) ; assertEquals ( " Transacttime should be 1004L " , 1004L , RowUtils . getAs ( Long . class , rows . get ( 1 ) , " transacttime " ) . longValue ( ) ) ; assertEquals ( " Clordid should be efgh " , " efgh " , RowUtils . getAs ( String . class , rows . get ( 1 ) , " clordid " ) ) ; assertEquals ( " Orderqty should be 99 " , 99 , RowUtils . getAs ( Integer . class , rows . get ( 1 ) , " orderqty " ) . intValue ( ) ) ; assertEquals ( " Leavesqty should be 9 " , 9 , RowUtils . getAs ( Integer . class , rows . get ( 1 ) , " leavesqty " ) . intValue ( ) ) ; assertEquals ( " Cumqty should be 4 " , 4 , RowUtils . getAs ( Integer . class , rows . get ( 1 ) , " cumqty " ) . intValue ( ) ) ; }
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; setContentView ( R . layout . playlist_activity ) ; this . setTitle ( R . string . nowPlaying ) ; app . oMPDAsyncHelper . addStatusChangeListener ( this ) ; ListView list = getListView ( ) ; registerForContextMenu ( list ) ; Button button = ( Button ) findViewById ( R . id . headerButton ) ; button . setVisibility ( View . VISIBLE ) ; button . setOnClickListener ( this ) ; Button title = ( Button ) findViewById ( R . id . headerText ) ; title . setText ( this . getTitle ( ) ) ; title . setOnClickListener ( this ) ; ImageView icon = ( ImageView ) findViewById ( R . id . headerIcon ) ; icon . setImageDrawable ( getResources ( ) . getDrawable ( R . drawable . ic_tab_playlists_selected ) ) ;
public static Set < Lookup > lookupsFor ( Properties props ) { Set < Lookup > lookups = Sets . newHashSet ( ) ; if ( ! props . containsKey ( " lookups " ) ) { return lookups ; } String [ ] lookupNames = props . getProperty ( " lookups " ) . split ( Pattern . quote ( " , " ) ) ; for ( String lookupName : lookupNames ) { Properties lookupProps = PropertiesUtils . prefixProperties ( props , " lookup. " + lookupName + " . " ) ; Lookup lookup = new Lookup ( lookupProps , lookupName ) ; lookups . add ( lookup ) ; } return lookups ; }
public int compare ( Row first , Row second ) { BigDecimal firstNanos = first . < BigDecimal > getAs ( nanoField . name ( ) ) ; BigDecimal secondNanos = second . < BigDecimal > getAs ( nanoField . name ( ) ) ; Integer firstSeqNum = first . < Integer > getAs ( seqNumField . name ( ) ) ; Integer secondSeqNum = second . < Integer > getAs ( seqNumField . name ( ) ) ; if ( firstNanos . equals ( secondNanos ) ) { return firstSeqNum . compareTo ( secondSeqNum ) ;
public String toStringBrief ( ) { value + = 50 ; final String s = toString ( ) ; value - = 50 ; if ( s . length ( ) > 4 ) { return s . substring ( 0 , 4 ) ;
public void testParameters ( ) throws Exception { Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( SQLDeriver . QUERY_FILE_CONFIG_NAME , getClass ( ) . getResource ( " /sql/query_with_parameters.sql " ) . getPath ( ) ) ; configMap . put ( SQLDeriver . PARAMETER_PREFIX_CONFIG_NAME + " .param1 " , " val1 " ) ; configMap . put ( SQLDeriver . PARAMETER_PREFIX_CONFIG_NAME + " .param2 " , " val2 " ) ; Config config = ConfigFactory . parseMap ( configMap ) ; SQLDeriver deriver = new SQLDeriver ( ) ; assertNoValidationFailures ( deriver , config ) ; deriver . configure ( config ) ; Row result = deriver . derive ( Maps . < String , Dataset < Row > > newHashMap ( ) ) . collectAsList ( ) . get ( 0 ) ; assertEquals ( RowFactory . create ( " val1 " , " val2 " , " val1 " ) , result ) ; }
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o instanceof com . googlecode . opennars . parser . loan . Loan . Absyn . TrmLit ) { com . googlecode . opennars . parser . loan . Loan . Absyn . TrmLit x = ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmLit ) o ; return this . literal_ . equals ( x . literal_ ) ; } return false ; }
public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View view = inflater . inflate ( R . layout . browse , container , false ) ; loadingView = view . findViewById ( R . id . loadingLayout ) ; loadingTextView = ( TextView ) view . findViewById ( R . id . loadingText ) ; noResultView = view . findViewById ( R . id . noResultLayout ) ; loadingView . setVisibility ( View . VISIBLE ) ; loadingTextView . setText ( getLoadingText ( ) ) ; return view ; }
public Iterator < T > iterator ( ) { return ( new ArrayQueueIterator < T > ( this ) ) ; }
@Override public void onFinished ( ) { float forgetCycles = memory . param . conceptForgetDurations . getCycles ( ) ; concepts . putBack ( currentConcept , forgetCycles , memory ) ; }
public void addPreHandler ( Object obj , String methodName ) { try { preHandlerMethod = obj . getClass ( ) . getMethod ( methodName , new Class < ? > [ ] { GWinApplet . class , GWinData . class } ) ;
public final void onReceive ( final Context context , final Intent intent ) { final String action = intent . getAction ( ) ; final KeyEvent event = intent . getParcelableExtra ( Intent . EXTRA_KEY_EVENT ) ; Log . d ( TAG , " Intent:  " + intent + "  received with context:  " + context + "  with action:  " + action ) ; if ( event ! = null & & event . getAction ( ) = = KeyEvent . ACTION_DOWN & & Intent . ACTION_MEDIA_BUTTON . equals ( action ) ) {
public void update ( long start , long end , D data ) { if ( start > = this . start & & end < = this . end & & data ! = null ) { this . range . add ( ( ( D ) data . copy ( ) ) ) ; } if ( start = = this . start & & end = = this . end ) { if ( this . data = = null ) this . data = ( ( D ) data . copy ( ) ) ;
public void testLongToBinaryString ( ) { long a = Math . abs ( RANDOM . nextLong ( ) ) ; String check = Long . toBinaryString ( a ) ; String result1 = Longs . toBinaryUsingBigDecimal ( a ) ; assertTrue ( " toBinary using BigDecimal error. random= " + a + "  expected= \ n " + check + " \ ngot= \ n " + result1 + " \ n " , ( check . equals ( result1 ) ) ) ; String result2 = Longs . toBinaryUsingDivideAndModulus ( a ) ; assertTrue ( " toBinary using BigDecimal error. random= " + a + "  expected= \ n " + check + " \ ngot= \ n " + result2 + " \ n " , ( check . equals ( result2 ) ) ) ; String result3 = Longs . toBinaryUsingShiftsAndModulus ( a ) ; assertTrue ( " toBinary using BigDecimal error. random= " + a + "  expected= \ n " + check + " \ ngot= \ n " + result3 + " \ n " , ( check . equals ( result3 ) ) ) ; }
int getSelectionOps ( ) ; ByteBuffer getRbuf ( ) ; ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; boolean isAuthenticated ( ) ; long lastReadDelta ( ) ; void completedRead ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }
public static void main ( final String [ ] args ) { final int repeats = 2 ; final int warmups = 1 ; final int maxConcepts = 2000 ; final int extraCycles = 2048 ; final int randomExtraCycles = 512 ; final Nar n = new Nar ( ) ; final Collection c = NALTest . params ( ) ; while ( true ) { for ( final Object o : c ) {
public HttpHeaderMap getResponseHeaderFields ( ) throws AS2Exception { if ( m_aCloseableHttpResponse = = null ) throw new AS2Exception ( " No response as message was yet sent " ) ; final Header [ ] aHeaders = m_aCloseableHttpResponse . getAllHeaders ( ) ; final HttpHeaderMap ret = new HttpHeaderMap ( ) ; for ( final Header aHeader : aHeaders ) ret . addHeader ( aHeader . getName ( ) , aHeader . getValue ( ) ) ; return ret ; }
public void testChar ( ) throws Exception { assertEquals ( 'c' , tc . decode ( tc . encode ( 'c' ) ) ) ; }
public void testUpdate ( ) throws Exception { assertNull ( client . get ( " test1 " ) ) ; client . replace ( " test1 " , 5 , " test1value " ) ; assertNull ( client . get ( " test1 " ) ) ; }
public MPDStatistics getStatistics ( ) throws MPDServerException { List response = mpdConnection . sendCommand ( MPD_CMD_STATISTICS ) ; return new MPDStatistics ( response ) ; }
private synchronized boolean searchLoop ( Term t , Prolog engine , boolean block , boolean remove , EngineRunner er ) { boolean found = false ; do { found = search ( t , engine , remove ) ; if ( found ) return true ; er . setSolving ( false ) ; try { wait ( ) ; } catch ( InterruptedException e ) { break ; } } while ( block ) ; return false ; }
public OperationFuture < Long > asyncDecr ( String key , int by ) { return asyncMutate ( Mutator . decr , key , by , 0 , - 1 ) ; }
public void remove ( ) { heap . replaceNode ( last ) ; }
R visit ( DifferenceInt p , A arg ) ; R visit ( Disjunction p , A arg ) ; R visit ( Equivalence p , A arg ) ; R visit ( EquivalenceAfter p , A arg ) ; R visit ( EquivalenceWhen p , A arg ) ; R visit ( ImageExt p , A arg ) ; R visit ( ImageInt p , A arg ) ; R visit ( Implication p , A arg ) ; R visit ( ImplicationAfter p , A arg ) ; R visit ( ImplicationBefore p , A arg ) ; R visit ( Inheritance p , A arg ) ; R visit ( Instance p , A arg ) ; R visit ( InstanceProperty p , A arg ) ; R visit ( IntersectionExt p , A arg ) ; R visit ( IntersectionInt p , A arg ) ; R visit ( Negation p , A arg ) ; R visit ( NumericLiteral p , A arg ) ; R visit ( Product p , A arg ) ; R visit ( Property p , A arg ) ; R visit ( SetExt p , A arg ) ; R visit ( SetInt p , A arg ) ; R visit ( Similarity p , A arg ) ; R visit ( TenseFuture p , A arg ) ; R visit ( TensePast p , A arg ) ; R visit ( TensePresent p , A arg ) ; R visit ( StringLiteral p , A arg ) ; R visit ( URIRef p , A arg ) ; R visit ( Variable p , A arg ) ; R visit ( Term p , A arg ) ; }
protected void act ( int action ) { Param p = nar . param ( ) ; switch ( action ) { case 0 : p . conceptCyclesToForget . set ( 12 ) ; break ;
public String toString ( ) { return " AlbumInfo{ " + " artist=' " + artist + '\'' +
private static final long pow ( long a , long x , long p ) { if ( x = = 0 ) return 1 ; if ( x = = 1 ) return a % p ; if ( x % 2 ! = 0 ) return ( a * pow ( a , x - 1 , p ) ) % p ; final long temp = pow ( a , x / 2 , p ) % p ; return ( temp * temp ) % p ; }
public final void onAudioFocusChange ( final int focusChange ) { if ( DEBUG ) { Log . d ( TAG , " StreamHandler.onAudioFocusChange() with  " + focusChange ) ; } final float duckVolume = 0.2f ; switch ( focusChange ) { case AudioManager . AUDIOFOCUS_GAIN :
public BlockingQueue < Operation > createOperationQueue ( ) { return new ArrayBlockingQueue < Operation > ( getOpQueueLen ( ) ) ; }
public void clearComments ( ) { commentMap . clear ( ) ; for ( Object o : map . values ( ) ) { if ( o instanceof CommentedConfig ) {
public boolean canHandle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) { if ( ! sAction . equals ( IProcessorSenderModule . DO_SENDMDN ) ) return false ; return aMsg instanceof AS2Message ; }
public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { if ( authDescriptor ! = null ) { if ( authDescriptor . authThresholdReached ( ) ) {
public void taskBuffersStartPlay ( BagObserver bagObserver , String s ) { novelTasks . addBagObserver ( bagObserver , s ) ; }
private void tapAck ( TapConnectionProvider conn , TapOpcode opcode , int opaque , OperationCallback cb ) { final Operation op = conn . getOpFactory ( ) . tapAck ( opcode , opaque , cb ) ; conn . addOp ( op ) ; }
public static void main ( String [ ] args ) throws Narsese . InvalidInputException { int dimensions = 1 ; NAR n = new NAR ( new Default ( ) ) ; TermVectors t = new TermVectors ( n , dimensions ) ; n . believe ( " <a --> b> " , Eternal , 1f , 0.9f ) ; n . believe ( " <b --> a> " , Eternal , 1f , 0.9f ) ; n . believe ( " <(*,a,b,c) --> d> " , Eternal , 1f , 0.9f ) ; n . believe ( " <(&&,d,b,c) --> a> " , Eternal , 1f , 0.9f ) ; n . run ( 50 ) ; t . map . run ( 300 ) ; System . out . println ( t . graph ) ; System . out . println ( t . map ) ; Collection items = t . map . keys ( ) ; List < Object > rows = new ArrayList ( items . size ( ) ) ; double [ ] [ ] m = new double [ items . size ( ) ] [ dimensions ] ; int j = 0 ; for ( Object i : items ) { rows . add ( i ) ; m [ j + + ] = t . map . getPosition ( i ) . getDataRef ( ) ; } new NWindow ( " dimensionalized terms " , new MatrixPanel ( rows , m ) ) . show ( 600 , 400 , true ) ;
public void drawit ( ) { background ( 0 , 0 , 0 ) ; strokeCap ( SQUARE ) ; strokeJoin ( PROJECT ) ; for ( final Object edge : graph . edgeSet ( ) ) { final VertexDisplay elem1 = vertices . get ( graph . getEdgeSource ( edge ) ) ; final VertexDisplay elem2 = vertices . get ( graph . getEdgeTarget ( edge ) ) ; if ( ( elem1 = = null ) | | ( elem2 = = null ) ) continue ; stroke ( getEdgeColor ( edge ) , ( elem1 . alpha + elem2 . alpha ) / 2f * 255 f / 2f ) ; strokeWeight ( ( elem1 . radius + elem2 . radius ) / 2.0f / 3.8f ) ; float x1 = elem1 . x ; float y1 = elem1 . y ; float x2 = elem2 . x ; float y2 = elem2 . y ; float cx = ( x1 + x2 ) / 2.0f ; float cy = ( y1 + y2 ) / 2.0f ; drawArrow ( x1 , y1 , x2 , y2 ) ; } noStroke ( ) ; for ( final VertexDisplay d : vertices . values ( ) ) d . draw ( ) ;
public void configure ( Config config ) { format = config . getString ( FORMAT_CONFIG ) ; path = config . getString ( PATH_CONFIG ) ; if ( format . equals ( CSV_FORMAT ) ) { options = new ConfigUtils . OptionMap ( config ) . resolve ( " sep " , CSV_SEPARATOR_CONFIG ) . resolve ( " encoding " , CSV_ENCODING_CONFIG ) . resolve ( " quote " , CSV_QUOTE_CONFIG ) . resolve ( " escape " , CSV_ESCAPE_CONFIG ) . resolve ( " comment " , CSV_COMMENT_CONFIG ) . resolve ( " header " , CSV_HEADER_CONFIG ) . resolve ( " inferSchema " , CSV_INFER_SCHEMA_CONFIG ) . resolve ( " ignoreLeadingWhiteSpace " , CSV_IGNORE_LEADING_CONFIG ) . resolve ( " ignoreTrailingWhiteSpace " , CSV_IGNORE_TRAILING_CONFIG ) . resolve ( " nullValue " , CSV_NULL_VALUE_CONFIG ) . resolve ( " nanValue " , CSV_NAN_VALUE_CONFIG ) . resolve ( " positiveInf " , CSV_POS_INF_CONFIG ) . resolve ( " negativeInf " , CSV_NEG_INF_CONFIG ) . resolve ( " dateFormat " , CSV_DATE_CONFIG ) . resolve ( " timestampFormat " , CSV_TIMESTAMP_CONFIG ) . resolve ( " maxColumns " , CSV_MAX_COLUMNS_CONFIG ) . resolve ( " maxCharsPerColumn " , CSV_MAX_CHARS_COLUMN_CONFIG ) . resolve ( " maxMalformedLogPerPartition " , CSV_MAX_MALFORMED_LOG_CONFIG ) . resolve ( " mode " , CSV_MODE_CONFIG ) ; } if ( format . equals ( CSV_FORMAT ) | | format . equals ( JSON_FORMAT ) ) { if ( config . hasPath ( FIELD_NAMES_CONFIG ) | | config . hasPath ( FIELD_TYPES_CONFIG ) ) { List < String > names = config . getStringList ( FIELD_NAMES_CONFIG ) ; List < String > types = config . getStringList ( FIELD_TYPES_CONFIG ) ; this . schema = RowUtils . structTypeFor ( names , types ) ; } else if ( config . hasPath ( AVRO_FILE_CONFIG ) | | config . hasPath ( AVRO_LITERAL_CONFIG ) ) { Schema avroSchema ; if ( config . hasPath ( AVRO_FILE_CONFIG ) ) { try { File avroFile = new File ( config . getString ( AVRO_FILE_CONFIG ) ) ; avroSchema = new Schema . Parser ( ) . parse ( avroFile ) ; } catch ( IOException e ) { throw new RuntimeException ( " Error parsing Avro schema file " , e ) ; } } else { avroSchema = new Schema . Parser ( ) . parse ( config . getString ( AVRO_LITERAL_CONFIG ) ) ; } this . schema = AvroUtils . structTypeFor ( avroSchema ) ; } } if ( format . equals ( INPUT_FORMAT_FORMAT ) ) { inputType = config . getString ( INPUT_FORMAT_TYPE_CONFIG ) ; keyType = config . getString ( INPUT_FORMAT_KEY_CONFIG ) ; valueType = config . getString ( INPUT_FORMAT_VALUE_CONFIG ) ; } if ( config . hasPath ( " translator " ) ) { translatorConfig = config . getConfig ( " translator " ) ;
< T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < Boolean > prepend ( String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; Future < CASResponse > asyncCAS ( String key , long casId , int exp , Object value ) ; < T > OperationFuture < CASResponse > asyncCAS ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; < T > CASResponse cas ( String key , long casId , int exp , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; CASResponse cas ( String key , long casId , int exp , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public String getAsXMLString ( ) { final IMicroContainer aCont = new MicroContainer ( ) ; for ( final Serializable x : m_aResults ) aCont . appendElement ( " result " ) . appendText ( x . toString ( ) ) ; return MicroWriter . getNodeAsString ( aCont ) ; }
public static Term make ( ArrayList < Term > argList , Memory memory ) { if ( argList . size ( ) = = 1 ) { return argList . get ( 0 ) ; } if ( argList . size ( ) ! = 2 ) { return null ; } if ( ( argList . get ( 0 ) instanceof SetExt ) & & ( argList . get ( 1 ) instanceof SetExt ) ) { TreeSet < Term > set = new TreeSet < Term > ( ( ( CompoundTerm ) argList . get ( 0 ) ) . cloneComponents ( ) ) ; set . removeAll ( ( ( CompoundTerm ) argList . get ( 1 ) ) . cloneComponents ( ) ) ; return SetExt . make ( set , memory ) ; } String name = makeCompoundName ( InnateOperator . DIFFERENCE_EXT , argList ) ; Term t = memory . nameToTerm ( name ) ; return ( t ! = null ) ? t : new DifferenceExt ( argList ) ; }
public boolean hasReadOp ( ) { throw new UnsupportedOperationException ( ) ; }
public boolean iAmTheOnlyOne ( JmDNSImpl jmDNSImpl ) { String name = this . getName ( ) . toLowerCase ( ) ; return jmDNSImpl . getLocalHost ( ) . getName ( ) . equals ( name ) | | jmDNSImpl . getServices ( ) . keySet ( ) . contains ( name ) ;
public void derive ( ) throws Exception { StructType existingSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " field1 " , DataTypes . IntegerType , true ) , DataTypes . createStructField ( " field2 " , DataTypes . StringType , true ) ) ) ; List < Row > existingRows = Lists . newArrayList ( ) ; existingRows . add ( RowFactory . create ( 1000 , " Envelopes " ) ) ; existingRows . add ( RowFactory . create ( 1001 , " Stamps " ) ) ; Dataset < Row > existingDF = Contexts . getSparkSession ( ) . createDataFrame ( existingRows , existingSchema ) ; StructType newSchema = DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " field1 " , DataTypes . IntegerType , true ) , DataTypes . createStructField ( " field2 " , DataTypes . StringType , true ) , DataTypes . createStructField ( " field3 " , DataTypes . StringType , true ) ) ) ; List < Row > newRows = Lists . newArrayList ( ) ; newRows . add ( RowFactory . create ( 1000 , " Envelopes " , " Nope " ) ) ; newRows . add ( RowFactory . create ( 1001 , " Stamps " , " Nope " ) ) ; newRows . add ( RowFactory . create ( 1000 , " Stamps " , " Yep " ) ) ; newRows . add ( RowFactory . create ( 1000 , " Staplers " , " Yep " ) ) ; newRows . add ( RowFactory . create ( 1001 , " Envelopes " , " Yep " ) ) ; Dataset < Row > newDF = Contexts . getSparkSession ( ) . createDataFrame ( newRows , newSchema ) ; Map < String , Dataset < Row > > dependencies = new HashMap < > ( ) ; dependencies . put ( " New " , newDF ) ; dependencies . put ( " Existing " , existingDF ) ; Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( ExcludeDeriver . EXCLUSION_COMPARE_CONFIG , " New " ) ; paramMap . put ( ExcludeDeriver . EXCLUSION_WITH_CONFIG , " Existing " ) ; paramMap . put ( ExcludeDeriver . EXCLUSION_FIELDS_CONFIG , Lists . newArrayList ( " field1 " , " field2 " ) ) ; config = ConfigFactory . parseMap ( paramMap ) ; ExcludeDeriver excludeDeriver = new ExcludeDeriver ( ) ; assertNoValidationFailures ( excludeDeriver , config ) ; excludeDeriver . configure ( config ) ; Dataset < Row > results = excludeDeriver . derive ( dependencies ) ; assertNotNull ( " Results is null " , results ) ; assertNotNull ( " Invalid schema " , results . schema ( ) ) ; assertEquals ( " Invalid schema field count " , 3 , results . schema ( ) . fieldNames ( ) . length ) ; assertEquals ( " Invalid schema field name " , " field3 " , results . schema ( ) . fieldNames ( ) [ 2 ] ) ; assertEquals ( " Invalid schema field name " , DataTypes . StringType , results . schema ( ) . fields ( ) [ 2 ] . dataType ( ) ) ; assertEquals ( " Invalid row count " , 3 , results . count ( ) ) ; }
public void onRestoreInstanceState ( Parcelable state ) { SavedState ss = ( SavedState ) state ; super . onRestoreInstanceState ( ss . getSuperState ( ) ) ; setProgress ( ss . progress ) ; setSecondaryProgress ( ss . secondaryProgress ) ; }
String executeRequest ( final HttpUriRequest request ) { final AndroidHttpClient client = prepareRequest ( ) ; final HttpResponse response ; final StatusLine statusLine ; final int statusCode ; final HttpEntity entity ; InputStream content = null ; String result = null ; try { response = client . execute ( request ) ; statusLine = response . getStatusLine ( ) ; statusCode = statusLine . getStatusCode ( ) ; if ( CoverManager . urlExists ( statusCode ) ) { entity = response . getEntity ( ) ; content = entity . getContent ( ) ; result = readInputStream ( content ) ; } else { Log . w ( TAG , " Failed to download cover : HTTP status code :  " + statusCode ) ; } } catch ( final IOException e ) { Log . e ( TAG , " Failed to download cover. " , e ) ; } catch ( final IllegalStateException e ) { Log . e ( TAG , " Illegal state exception when downloading. " , e ) ; } finally { if ( content ! = null ) { try { content . close ( ) ; } catch ( final IOException e ) { Log . e ( TAG , " Failed to close the content. " , e ) ; } } if ( client ! = null ) { client . close ( ) ; } } if ( DEBUG ) { Log . d ( TAG , " HTTP response:  " + result ) ; } return result ; }
public static final boolean powerOfTwoUsingRecursion ( int number ) { if ( number = = 1 ) return true ; if ( number = = 0 | | number % 2 ! = 0 ) return false ; return powerOfTwoUsingRecursion ( number / 2 ) ; }
< T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public void insertAttributeAt ( int i ) { throw new UnsupportedOperationException ( " Not yet implemented " ) ; }
public < T > void execute ( final List < Callable < T > > tasks ) { if ( tasks . isEmpty ( ) ) return ; else if ( tasks . size ( ) = = 1 ) {
public Task perceive ( String line ) { for ( TextReaction p : parsers ) { Object result = p . react ( line ) ; if ( result ! = null ) { if ( result instanceof Task ) { return ( Task ) result ; } else if ( result . equals ( Boolean . TRUE ) ) return null ; } } memory . output ( Output . ERR . class , " Invalid input:  " + line ) ; return null ; }
public String toString ( ) { final StringBuilder builder = new StringBuilder ( ) ; for ( Vertex < T > v : verticies ) builder . append ( v . toString ( ) ) ; return builder . toString ( ) ; }
public Object next ( ) throws IOException { if ( ! finished ) { finished = true ; return task ; } return null ; }
public static Schema schemaFor ( StructType structType ) { return schemaFor ( structType , null , null ) ; }
public void onClick ( DialogInterface dialog , int which ) { switch ( which ) { case AlertDialog . BUTTON_NEGATIVE :
public static void main ( String [ ] args ) throws Exception { int cycles = 1000 ; int inputDelay = 20 ; NAR nar = new DefaultNARBuilder ( ) . build ( ) ; new TestChamber ( nar , false ) ; NARTrace t = new NARTrace ( nar ) ; TextInput i = new TextInput ( new File ( " nal/TestChamber/TestChamberIndependentExperience/switch_on_door_opened.nal " ) ) { int c = 0 ; @Override public Object next ( ) throws IOException { if ( c + + % 2 = = 0 ) return super . next ( ) ; else return inputDelay + " \ n " ; } } ; nar . addInput ( i ) ; nar . finish ( 1 ) ; System . out . println ( nar . time ( ) ) ; nar . finish ( cycles ) ; System . out . println ( nar . time ( ) ) ; new NWindow ( " _ " , new Timeline2DCanvas (
public Map < String , T > get ( long timeout , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { if ( ! latch . await ( timeout , unit ) ) { throw new TimeoutException ( " Operation timed out. " ) ; } for ( Operation op : ops ) { if ( op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } } return rvMap ; }
public Concept newConcept ( Term t , Memory m ) { Bag < TaskLink , Task > taskLinks = new LevelBag < > ( getTaskLinkBagLevels ( ) , getTaskLinkBagSize ( ) ) ; Bag < TermLink , TermLink > termLinks = new LevelBag < > ( getTermLinkBagLevels ( ) , getTermLinkBagSize ( ) ) ; return new Concept ( t , taskLinks , termLinks , m ) ; }
public void onViewCreated ( View view , Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ) ; if ( items ! = null ) { ( ( ListView ) list ) . setAdapter ( getCustomListAdapter ( ) ) ;
public boolean run ( Integer [ ] unsorted , Integer [ ] sorted , String input ) { this . input = input ; Stack . LinkedStack < Integer > linkedStack = new Stack . LinkedStack < Integer > ( ) ; Collection < Integer > lCollection = linkedStack . toCollection ( ) ; if ( ! testJavaCollection ( lCollection , Integer . class , name , unsorted , sorted , input ) ) return false ; return true ; }
void load ( ) ; @Override void close ( ) ; @Override default FileConfig checked ( ) { return new CheckedFileConfig ( this ) ; } static FileConfig of ( File file , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return builder ( file , format ) . build ( ) ; } static FileConfig of ( File file ) { ConfigFormat format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getName ( ) ) ; } return of ( file , format ) ; } static FileConfig of ( String filePath , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return of ( new File ( filePath ) , format ) ; } static FileConfig of ( String filePath ) { return of ( new File ( filePath ) ) ; } static FileConfig ofConcurrent ( File file , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return builder ( file , format ) . concurrent ( ) . build ( ) ; } static FileConfig ofConcurrent ( File file ) { return builder ( file ) . concurrent ( ) . build ( ) ; } static FileConfig ofConcurrent ( String filePath , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return ofConcurrent ( new File ( filePath ) , format ) ; } static FileConfig ofConcurrent ( String filePath ) { return ofConcurrent ( new File ( filePath ) ) ; } static FileConfigBuilder < Config > builder ( File file , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new FileConfigBuilder < > ( file , format ) ; } static FileConfigBuilder < Config > builder ( File file ) { ConfigFormat format = FormatDetector . detect ( file ) ; if ( format = = null | | ! format . supportsComments ( ) ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getName ( ) ) ; } return builder ( file , format ) ; } static FileConfigBuilder < Config > builder ( String filePath , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return builder ( new File ( filePath ) , format ) ; } static FileConfigBuilder < Config > builder ( String filePath ) { return builder ( new File ( filePath ) ) ; } }
protected MimeBodyPart secure ( @Nonnull final IMessage aMsg ) throws Exception { MimeBodyPart aDataBP = aMsg . getData ( ) ; final Partnership aPartnership = aMsg . getPartnership ( ) ; final boolean bEncrypt = aPartnership . getAttribute ( CPartnershipIDs . PA_ENCRYPT ) ! = null ; final boolean bSign = aPartnership . getAttribute ( CPartnershipIDs . PA_SIGN ) ! = null ; if ( bEncrypt | | bSign ) { final ICertificateFactory aCertFactory = getSession ( ) . getCertificateFactory ( ) ; if ( bSign ) { final X509Certificate aSenderCert = aCertFactory . getCertificate ( aMsg , ECertificatePartnershipType . SENDER ) ; final PrivateKey aSenderKey = aCertFactory . getPrivateKey ( aMsg , aSenderCert ) ; final String sAlgorithm = aPartnership . getAttribute ( CPartnershipIDs . PA_SIGN ) ; final ECryptoAlgorithm eAlgorithm = ECryptoAlgorithm . getFromIDOrNull ( sAlgorithm ) ; aDataBP = AS2Util . getCryptoHelper ( ) . sign ( aDataBP , aSenderCert , aSenderKey , eAlgorithm ) ; final DataHistoryItem aHistoryItem = new DataHistoryItem ( aDataBP . getContentType ( ) ) ; aMsg . getHistory ( ) . addItem ( aHistoryItem ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Signed data " + aMsg . getLoggingText ( ) ) ; } if ( bEncrypt ) { final X509Certificate aReceiverCert = aCertFactory . getCertificate ( aMsg , ECertificatePartnershipType . RECEIVER ) ; final String sAlgorithm = aPartnership . getAttribute ( CPartnershipIDs . PA_ENCRYPT ) ; final ECryptoAlgorithm eAlgorithm = ECryptoAlgorithm . getFromIDOrNull ( sAlgorithm ) ; aDataBP = AS2Util . getCryptoHelper ( ) . encrypt ( aDataBP , aReceiverCert , eAlgorithm ) ; final DataHistoryItem aHistoryItem = new DataHistoryItem ( aDataBP . getContentType ( ) ) ; aMsg . getHistory ( ) . addItem ( aHistoryItem ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Encrypted data " + aMsg . getLoggingText ( ) ) ; } } return aDataBP ; }
public void incPriority ( final float v ) { priority . setValue ( or ( priority . getValue ( ) , v ) ) ; }
OperationCallback getCallback ( ) ; void cancel ( ) ; OperationState getState ( ) ; ByteBuffer getBuffer ( ) ; void writeComplete ( ) ; void initialize ( ) ; void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; void handleLine ( String line ) ; }
void spy ( String action , Engine env ) { mediator . spy ( action , env ) ; }
private void emit_helpers ( ) throws java . io . IOException { if ( CUtility . DEBUG ) { CUtility . ASSERT ( null ! = m_spec ) ; CUtility . ASSERT ( null ! = m_outstream ) ; } m_outstream . println ( " \ tprivate boolean yy_eof_done = false; " ) ; if ( null ! = m_spec . m_eof_code ) { m_outstream . print ( " \ tprivate void yy_do_eof () " ) ; if ( null ! = m_spec . m_eof_throw_code ) { m_outstream . println ( ) ; m_outstream . print ( " \ t \ tthrows  " ) ; m_outstream . println ( new String ( m_spec . m_eof_throw_code , 0 , m_spec . m_eof_throw_read ) ) ; m_outstream . println ( " \ t \ t{ " ) ; } else { m_outstream . println ( "  { " ) ; } m_outstream . println ( " \ t \ tif (false == yy_eof_done) { " ) ; m_outstream . print ( new String ( m_spec . m_eof_code , 0 , m_spec . m_eof_read ) ) ; m_outstream . println ( " \ t \ t} " ) ; m_outstream . println ( " \ t \ tyy_eof_done = true; " ) ; m_outstream . println ( " \ t} " ) ; } emit_states ( ) ; m_outstream . println ( " \ tprivate void yybegin (int state) { " ) ; m_outstream . println ( " \ t \ tyy_lexical_state = state; " ) ; m_outstream . println ( " \ t} " ) ; m_outstream . println ( " \ tprivate int yy_advance () " ) ; m_outstream . println ( " \ t \ tthrows java.io.IOException { " ) ; m_outstream . println ( " \ t \ tint next_read; " ) ; m_outstream . println ( " \ t \ tint i; " ) ; m_outstream . println ( " \ t \ tint j; " ) ; m_outstream . println ( ) ; m_outstream . println ( " \ t \ tif (yy_buffer_index < yy_buffer_read) { " ) ; m_outstream . println ( " \ t \ t \ treturn yy_buffer[yy_buffer_index++]; " ) ; m_outstream . println ( " \ t \ t} " ) ; m_outstream . println ( ) ; m_outstream . println ( " \ t \ tif (0 != yy_buffer_start) { " ) ; m_outstream . println ( " \ t \ t \ ti = yy_buffer_start; " ) ; m_outstream . println ( " \ t \ t \ tj = 0; " ) ; m_outstream . println ( " \ t \ t \ twhile (i < yy_buffer_read) { " ) ; m_outstream . println ( " \ t \ t \ t \ tyy_buffer[j] = yy_buffer[i]; " ) ; m_outstream . println ( " \ t \ t \ t \ t++i; " ) ; m_outstream . println ( " \ t \ t \ t \ t++j; " ) ; m_outstream . println ( " \ t \ t \ t} " ) ; m_outstream . println ( " \ t \ t \ tyy_buffer_end = yy_buffer_end - yy_buffer_start; " ) ; m_outstream . println ( " \ t \ t \ tyy_buffer_start = 0; " ) ; m_outstream . println ( " \ t \ t \ tyy_buffer_read = j; " ) ; m_outstream . println ( " \ t \ t \ tyy_buffer_index = j; " ) ; m_outstream . println ( " \ t \ t \ tnext_read = yy_reader.read(yy_buffer, " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tyy_buffer_read, " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tyy_buffer.length - yy_buffer_read); " ) ; m_outstream . println ( " \ t \ t \ tif (-1 == next_read) { " ) ; m_outstream . println ( " \ t \ t \ t \ treturn YY_EOF; " ) ; m_outstream . println ( " \ t \ t \ t} " ) ; m_outstream . println ( " \ t \ t \ tyy_buffer_read = yy_buffer_read + next_read; " ) ; m_outstream . println ( " \ t \ t} " ) ; m_outstream . println ( ) ; m_outstream . println ( " \ t \ twhile (yy_buffer_index >= yy_buffer_read) { " ) ; m_outstream . println ( " \ t \ t \ tif (yy_buffer_index >= yy_buffer.length) { " ) ; m_outstream . println ( " \ t \ t \ t \ tyy_buffer = yy_double(yy_buffer); " ) ; m_outstream . println ( " \ t \ t \ t} " ) ; m_outstream . println ( " \ t \ t \ tnext_read = yy_reader.read(yy_buffer, " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tyy_buffer_read, " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tyy_buffer.length - yy_buffer_read); " ) ; m_outstream . println ( " \ t \ t \ tif (-1 == next_read) { " ) ; m_outstream . println ( " \ t \ t \ t \ treturn YY_EOF; " ) ; m_outstream . println ( " \ t \ t \ t} " ) ; m_outstream . println ( " \ t \ t \ tyy_buffer_read = yy_buffer_read + next_read; " ) ; m_outstream . println ( " \ t \ t} " ) ; m_outstream . println ( " \ t \ treturn yy_buffer[yy_buffer_index++]; " ) ; m_outstream . println ( " \ t} " ) ; m_outstream . println ( " \ tprivate void yy_move_end () { " ) ; m_outstream . println ( " \ t \ tif (yy_buffer_end > yy_buffer_start && " ) ; m_outstream . println ( " \ t \ t    ' \\ n' == yy_buffer[yy_buffer_end-1]) " ) ; m_outstream . println ( " \ t \ t \ tyy_buffer_end--; " ) ; m_outstream . println ( " \ t \ tif (yy_buffer_end > yy_buffer_start && " ) ; m_outstream . println ( " \ t \ t    ' \\ r' == yy_buffer[yy_buffer_end-1]) " ) ; m_outstream . println ( " \ t \ t \ tyy_buffer_end--; " ) ; m_outstream . println ( " \ t} " ) ; m_outstream . println ( " \ tprivate boolean yy_last_was_cr=false; " ) ; m_outstream . println ( " \ tprivate void yy_mark_start () { " ) ; if ( m_spec . m_count_lines | | true = = m_spec . m_count_chars ) { if ( m_spec . m_count_lines ) { m_outstream . println ( " \ t \ tint i; " ) ; m_outstream . println ( " \ t \ tfor (i = yy_buffer_start;  " + " i < yy_buffer_index; ++i) { " ) ; m_outstream . println ( " \ t \ t \ tif (' \\ n' == yy_buffer[i] && !yy_last_was_cr) { " ) ; m_outstream . println ( " \ t \ t \ t \ t++yyline; " ) ; m_outstream . println ( " \ t \ t \ t} " ) ; m_outstream . println ( " \ t \ t \ tif (' \\ r' == yy_buffer[i]) { " ) ; m_outstream . println ( " \ t \ t \ t \ t++yyline; " ) ; m_outstream . println ( " \ t \ t \ t \ tyy_last_was_cr=true; " ) ; m_outstream . println ( " \ t \ t \ t} else yy_last_was_cr=false; " ) ; m_outstream . println ( " \ t \ t} " ) ; } if ( m_spec . m_count_chars ) { m_outstream . println ( " \ t \ tyychar = yychar " ) ; m_outstream . println ( " \ t \ t \ t+ yy_buffer_index - yy_buffer_start; " ) ; } } m_outstream . println ( " \ t \ tyy_buffer_start = yy_buffer_index; " ) ; m_outstream . println ( " \ t} " ) ; m_outstream . println ( " \ tprivate void yy_mark_end () { " ) ; m_outstream . println ( " \ t \ tyy_buffer_end = yy_buffer_index; " ) ; m_outstream . println ( " \ t} " ) ; m_outstream . println ( " \ tprivate void yy_to_mark () { " ) ; m_outstream . println ( " \ t \ tyy_buffer_index = yy_buffer_end; " ) ; m_outstream . println ( " \ t \ tyy_at_bol =  " + " (yy_buffer_end > yy_buffer_start) && " ) ; m_outstream . println ( " \ t \ t             " + " (' \\ r' == yy_buffer[yy_buffer_end-1] || " ) ; m_outstream . println ( " \ t \ t             " + "  ' \\ n' == yy_buffer[yy_buffer_end-1] || " ) ; m_outstream . println ( " \ t \ t             " + "  2028/*LS*/ == yy_buffer[yy_buffer_end-1] || " ) ; m_outstream . println ( " \ t \ t             " + "  2029/*PS*/ == yy_buffer[yy_buffer_end-1]); " ) ; m_outstream . println ( " \ t} " ) ; m_outstream . println ( " \ tprivate java.lang.String yytext () { " ) ; m_outstream . println ( " \ t \ treturn (new java.lang.String(yy_buffer, " ) ; m_outstream . println ( " \ t \ t \ tyy_buffer_start, " ) ; m_outstream . println ( " \ t \ t \ tyy_buffer_end - yy_buffer_start)); " ) ; m_outstream . println ( " \ t} " ) ; m_outstream . println ( " \ tprivate int yylength () { " ) ; m_outstream . println ( " \ t \ treturn yy_buffer_end - yy_buffer_start; " ) ; m_outstream . println ( " \ t} " ) ; m_outstream . println ( " \ tprivate char[] yy_double (char buf[]) { " ) ; m_outstream . println ( " \ t \ tint i; " ) ; m_outstream . println ( " \ t \ tchar newbuf[]; " ) ; m_outstream . println ( " \ t \ tnewbuf = new char[2*buf.length]; " ) ; m_outstream . println ( " \ t \ tfor (i = 0; i < buf.length; ++i) { " ) ; m_outstream . println ( " \ t \ t \ tnewbuf[i] = buf[i]; " ) ; m_outstream . println ( " \ t \ t} " ) ; m_outstream . println ( " \ t \ treturn newbuf; " ) ; m_outstream . println ( " \ t} " ) ; m_outstream . println ( " \ tprivate final int YY_E_INTERNAL = 0; " ) ; m_outstream . println ( " \ tprivate final int YY_E_MATCH = 1; " ) ; m_outstream . println ( " \ tprivate java.lang.String yy_error_string[] = { " ) ; m_outstream . println ( " \ t \ t \" Error: Internal error. \\ n \" , " ) ; m_outstream . println ( " \ t \ t \" Error: Unmatched input. \\ n \" " ) ; m_outstream . println ( " \ t}; " ) ; m_outstream . println ( " \ tprivate void yy_error (int code,boolean fatal) { " ) ; m_outstream . println ( " \ t \ tjava.lang.System.out.print(yy_error_string[code]); " ) ; m_outstream . println ( " \ t \ tjava.lang.System.out.flush(); " ) ; m_outstream . println ( " \ t \ tif (fatal) { " ) ; m_outstream . println ( " \ t \ t \ tthrow new Error( \" Fatal Error. \\ n \" ); " ) ; m_outstream . println ( " \ t \ t} " ) ; m_outstream . println ( " \ t} " ) ; m_outstream . println ( " \ tprivate int[][] unpackFromString " + " (int size1, int size2, String st) { " ) ; m_outstream . println ( " \ t \ tint colonIndex = -1; " ) ; m_outstream . println ( " \ t \ tString lengthString; " ) ; m_outstream . println ( " \ t \ tint sequenceLength = 0; " ) ; m_outstream . println ( " \ t \ tint sequenceInteger = 0; " ) ; m_outstream . println ( ) ; m_outstream . println ( " \ t \ tint commaIndex; " ) ; m_outstream . println ( " \ t \ tString workString; " ) ; m_outstream . println ( ) ; m_outstream . println ( " \ t \ tint res[][] = new int[size1][size2]; " ) ; m_outstream . println ( " \ t \ tfor (int i= 0; i < size1; i++) { " ) ; m_outstream . println ( " \ t \ t \ tfor (int j= 0; j < size2; j++) { " ) ; m_outstream . println ( " \ t \ t \ t \ tif (sequenceLength != 0) { " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tres[i][j] = sequenceInteger; " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tsequenceLength--; " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tcontinue; " ) ; m_outstream . println ( " \ t \ t \ t \ t} " ) ; m_outstream . println ( " \ t \ t \ t \ tcommaIndex = st.indexOf(','); " ) ; m_outstream . println ( " \ t \ t \ t \ tworkString = (commaIndex==-1) ? st : " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tst.substring(0, commaIndex); " ) ; m_outstream . println ( " \ t \ t \ t \ tst = st.substring(commaIndex+1); " ) ; m_outstream . println ( " \ t \ t \ t \ tcolonIndex = workString.indexOf(':'); " ) ; m_outstream . println ( " \ t \ t \ t \ tif (colonIndex == -1) { " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tres[i][j]=Integer.parseInt(workString); " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tcontinue; " ) ; m_outstream . println ( " \ t \ t \ t \ t} " ) ; m_outstream . println ( " \ t \ t \ t \ tlengthString = " ) ; m_outstream . println ( " \ t \ t \ t \ t \ tworkString.substring(colonIndex+1); " ) ; m_outstream . println ( " \ t \ t \ t \ tsequenceLength= " + " Integer.parseInt(lengthString); " ) ; m_outstream . println ( " \ t \ t \ t \ tworkString= " + " workString.substring(0,colonIndex); " ) ; m_outstream . println ( " \ t \ t \ t \ tsequenceInteger= " + " Integer.parseInt(workString); " ) ; m_outstream . println ( " \ t \ t \ t \ tres[i][j] = sequenceInteger; " ) ; m_outstream . println ( " \ t \ t \ t \ tsequenceLength--; " ) ; m_outstream . println ( " \ t \ t \ t} " ) ; m_outstream . println ( " \ t \ t} " ) ; m_outstream . println ( " \ t \ treturn res; " ) ; m_outstream . println ( " \ t} " ) ; }
private void finishWithAction ( final ActionItem action , final String extra , final String overrideLabel ) { final Intent i = new Intent ( ) ; final Bundle b = new Bundle ( ) ; b . putString ( BUNDLE_ACTION_STRING , action . mActionString ) ; if ( extra ! = null ) { b . putString ( BUNDLE_ACTION_EXTRA , extra ) ; } i . putExtra ( LocaleConstants . EXTRA_BUNDLE , b ) ; i . putExtra ( LocaleConstants . EXTRA_STRING_BLURB , overrideLabel = = null ? action . mLabel : overrideLabel ) ; setResult ( RESULT_OK , i ) ; finish ( ) ; }
Iterable < Row > translate ( K key , V value ) throws Exception ; StructType getSchema ( ) ; }
public void incFontDimension ( ) ; public void decFontDimension ( ) ; public void setFontDimension ( int dimension ) ; public int getFontDimension ( ) ; }
public static StructType buildSchema ( Map < String , HBaseSerde . ColumnDef > columnDefinitions ) { List < String > fieldNames = Lists . newArrayList ( ) ; List < String > fieldTypes = Lists . newArrayList ( ) ; for ( Map . Entry < String , HBaseSerde . ColumnDef > columnDef : columnDefinitions . entrySet ( ) ) { fieldNames . add ( columnDef . getValue ( ) . name ) ; fieldTypes . add ( columnDef . getValue ( ) . type ) ; } return SchemaUtils . structTypeFor ( fieldNames , fieldTypes ) ; }
public static ActionPanelContext createPanelContext ( NlpStoryGui storyGui ) { ActionPanelContext resultPanelContext = new ActionPanelContext ( ) ; resultPanelContext . panel = new JPanel ( ) ; EnumTypeType [ ] possibleActionTypes = { EnumTypeType . METAPROXIMITY , EnumTypeType . METAINSIDE , EnumTypeType . METAMOTION , EnumTypeType . METAONSTAGE , EnumTypeType . CUSTOM } ; resultPanelContext . typeDropdown = new JComboBox ( possibleActionTypes ) ; resultPanelContext . typeDropdown . addActionListener ( new ComboBoxUpdateListener ( ) ) ; resultPanelContext . typeDropdown . setRenderer ( new ComboboxItemRenderer ( ) ) ; resultPanelContext . typeDropdown . setPreferredSize ( new Dimension ( 120 , 20 ) ) ; resultPanelContext . textfieldParameters = new JTextField [ 2 ] ; resultPanelContext . textfieldParameters [ 0 ] = new JTextField ( ) ; resultPanelContext . textfieldParameters [ 1 ] = new JTextField ( ) ; JPanel dropdownAndParameterPanel = new JPanel ( ) ; dropdownAndParameterPanel . setLayout ( new GridLayout ( 3 , 1 , 0 , 8 ) ) ; dropdownAndParameterPanel . add ( resultPanelContext . typeDropdown ) ; dropdownAndParameterPanel . add ( resultPanelContext . textfieldParameters [ 0 ] ) ; dropdownAndParameterPanel . add ( resultPanelContext . textfieldParameters [ 1 ] ) ; JPanel leftPanel = new JPanel ( ) ; leftPanel . setLayout ( new BorderLayout ( ) ) ; JButton transferButton = new JButton ( " >> " ) ; transferButton . addActionListener ( new TransferButtonListener ( resultPanelContext ) ) ; leftPanel . add ( transferButton , BorderLayout . EAST ) ; leftPanel . add ( dropdownAndParameterPanel , BorderLayout . CENTER ) ; BorderLayout mainLayout = new BorderLayout ( ) ; resultPanelContext . actionTable = createActionTable ( resultPanelContext . items , resultPanelContext ) ; resultPanelContext . panel . setLayout ( mainLayout ) ; resultPanelContext . panel . add ( leftPanel , BorderLayout . WEST ) ; resultPanelContext . panel . add ( resultPanelContext . actionTable , BorderLayout . CENTER ) ; return resultPanelContext ; }
private boolean delete ( RedBlackNode < T > node ) { if ( node . parent = = null ) { return true ; } RedBlackNode < T > parent = ( RedBlackNode < T > ) node . parent ; RedBlackNode < T > sibling = node . getSibling ( ) ; if ( sibling . color = = Color . Red ) { parent . color = Color . Red ; sibling . color = Color . Black ; if ( node . equals ( parent . lesser ) ) { rotateLeft ( parent ) ; parent = ( RedBlackNode < T > ) node . parent ; sibling = node . getSibling ( ) ; } else if ( node . equals ( parent . greater ) ) { rotateRight ( parent ) ; parent = ( RedBlackNode < T > ) node . parent ; sibling = node . getSibling ( ) ; } else { System . err . println ( " Yikes! I'm not related to my parent. " ) ; return false ; } } if ( parent . color = = Color . Black & & sibling . color = = Color . Black & & ( ( RedBlackNode < T > ) sibling . lesser ) . color = = Color . Black & & ( ( RedBlackNode < T > ) sibling . greater ) . color = = Color . Black ) { sibling . color = Color . Red ; boolean result = delete ( parent ) ; if ( ! result ) return false ; } else if ( parent . color = = Color . Red & & sibling . color = = Color . Black & & ( ( RedBlackNode < T > ) sibling . lesser ) . color = = Color . Black & & ( ( RedBlackNode < T > ) sibling . greater ) . color = = Color . Black ) { sibling . color = Color . Red ; parent . color = Color . Black ; } else { if ( sibling . color = = Color . Black ) { if ( node . equals ( parent . lesser ) & & ( ( RedBlackNode < T > ) sibling . lesser ) . color = = Color . Red & & ( ( RedBlackNode < T > ) sibling . greater ) . color = = Color . Black ) { sibling . color = Color . Red ; ( ( RedBlackNode < T > ) sibling . lesser ) . color = Color . Red ; rotateRight ( sibling ) ; parent = ( RedBlackNode < T > ) node . parent ; sibling = node . getSibling ( ) ; } else if ( node . equals ( parent . greater ) & & ( ( RedBlackNode < T > ) sibling . lesser ) . color = = Color . Black & & ( ( RedBlackNode < T > ) sibling . greater ) . color = = Color . Red ) { sibling . color = Color . Red ; ( ( RedBlackNode < T > ) sibling . greater ) . color = Color . Red ; rotateLeft ( sibling ) ; parent = ( RedBlackNode < T > ) node . parent ; sibling = node . getSibling ( ) ; } } sibling . color = parent . color ; parent . color = Color . Black ; if ( node . equals ( parent . lesser ) ) { ( ( RedBlackNode < T > ) sibling . greater ) . color = Color . Black ; rotateLeft ( node . parent ) ; } else if ( node . equals ( parent . greater ) ) { ( ( RedBlackNode < T > ) sibling . lesser ) . color = Color . Black ; rotateRight ( node . parent ) ; } else { System . err . println ( " Yikes! I'm not related to my parent.  " + node . toString ( ) ) ; return false ; } } return true ; }
protected String executeRequest ( HttpRequestBase request ) { StringBuilder builder = new StringBuilder ( ) ; HttpResponse response ; StatusLine statusLine ; int statusCode ; HttpEntity entity = null ; InputStream content = null ; BufferedReader reader ; String line ; try { response = client . execute ( request ) ; statusLine = response . getStatusLine ( ) ; statusCode = statusLine . getStatusCode ( ) ; entity = response . getEntity ( ) ; content = entity . getContent ( ) ; if ( statusCode = = 200 ) { reader = new BufferedReader ( new InputStreamReader ( content ) ) ; while ( ( line = reader . readLine ( ) ) ! = null ) { builder . append ( line ) ; } } else { Log . e ( AbstractWebCover . class . toString ( ) , " Failed to download cover : HTTP status code :  " + statusCode ) ; } } catch ( Exception e ) { Log . e ( AbstractWebCover . class . toString ( ) , " Failed to download cover : " + e ) ; } finally { { if ( entity ! = null ) { try { entity . consumeContent ( ) ; } catch ( IOException e ) { } } try { if ( content ! = null ) { content . close ( ) ; } } catch ( IOException e ) { } } } return builder . toString ( ) ; }
public String toString ( ) { return isCategory ( ) ? category : test . getTestName ( ) ; }
public String getFilename ( ) throws InvalidParameterException { return getAttributeAsStringRequired ( PARAM_FILENAME ) ; }
public void testOneArrivingOneExistingWhereArrivingSameTimeAsExistingWithDifferentValues ( ) { p = new EventTimeHistoryPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , EventTimeHistoryPlanner . FAR_FUTURE_MILLIS , EventTimeHistoryPlanner . CURRENT_FLAG_YES , " " ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 100L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 1 ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . UPDATE ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " startdate " ) , 100L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " enddate " ) , EventTimeHistoryPlanner . FAR_FUTURE_MILLIS ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_YES ) ; }
public Object clone ( ) { IndexedTreeMap < K , V > clone = null ; try { clone = ( IndexedTreeMap < K , V > ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new InternalError ( ) ; } clone . root = null ; clone . size = 0 ; clone . modCount = 0 ; clone . entrySet = null ; clone . navigableKeySet = null ; clone . descendingMap = null ; try { clone . buildFromSorted ( size , entrySet ( ) . iterator ( ) , null , null ) ; } catch ( java . io . IOException cannotHappen ) { } catch ( ClassNotFoundException cannotHappen ) { } return clone ; }
public boolean equals ( Object obj ) { return vertex . equals ( obj ) ; }
public ProcessingItem connectInputShuffleStream ( Stream inputStream ) { return this . addInputStream ( inputStream , EventAllocationType . SHUFFLE ) ; }
public void enableOutput ( int id ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; mpdConnection . sendCommand ( MPDCommand . MPD_CMD_OUTPUTENABLE , Integer . toString ( id ) ) ; }
public String [ ] getCoverUrl ( final AlbumInfo albumInfo ) throws Exception { final String storageState = Environment . getExternalStorageState ( ) ; if ( Environment . MEDIA_MOUNTED_READ_ONLY . equals ( storageState ) | | Environment . MEDIA_MOUNTED . equals ( storageState ) ) { final String url = getAbsolutePathForSong ( albumInfo ) ; if ( new File ( url ) . exists ( ) ) { return new String [ ] { url } ; } } return null ; }
public T get ( ) throws InterruptedException , ExecutionException { latch . await ( ) ; if ( op ! = null & & op . isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } return obj ; }
public final Sentence clone ( final Term t ) { return new Sentence ( t , punctuation , truth ! = null ? new TruthValue ( truth ) : null ,
public String [ ] getCoverUrl ( AlbumInfo albumInfo ) throws Exception { String coverUrl ; if ( userId = = null ) { initializeUserId ( ) ; } if ( userId = = null ) { return new String [ 0 ] ; } try { coverUrl = getCoverUrl ( albumInfo . getArtist ( ) , albumInfo . getAlbum ( ) ) ; if ( coverUrl ! = null ) { return new String [ ] { coverUrl } ; } } catch ( Exception ex ) { e ( GracenoteCover . class . getName ( ) , " GracenoteCover fetch failure :  " + ex ) ; } return new String [ 0 ] ; }
public void debug ( ) throws Exception { Entry < K , V > e = getFirstEntry ( ) ; while ( e ! = null ) {
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int key = 0 ; key < array . length ; key + + ) { List < Pair < K , V > > list = array [ key ] ; for ( int item = 0 ; item < list . size ( ) ; item + + ) { Pair < K , V > p = list . get ( item ) ; V value = p . value ; if ( value ! = null ) builder . append ( key ) . append ( " = " ) . append ( value ) . append ( " ,  " ) ; } } return builder . toString ( ) ; }
public Object visit ( TrmInInt p , LoanParser arg ) { Term t1 = ( Term ) p . term_1 . accept ( this , arg ) ; Term t2 = ( Term ) p . term_2 . accept ( this , arg ) ; ArrayList < Term > ts = new ArrayList < Term > ( ) ; ts . add ( t1 ) ; ts . add ( t2 ) ; return CompoundTerm . make ( Symbols . INTERSECTION_INT_OPERATOR , ts , memory ) ; }
protected synchronized boolean updateConnection ( ) { if ( ! enabled ) { Log . d ( TAG , " is disabled " ) ; return false ; } if ( mpd = = null ) { Log . d ( TAG , " no MPD!  " ) ; return false ; } if ( mpd . isMpdConnectionNull ( ) ) { Log . d ( TAG , " no MPDConnection!  " ) ; return false ; } if ( this . server = = null ) { try { this . server = mpd . getHostAddress ( ) . getHostName ( ) ; this . port = mpd . getHostPort ( ) ; } catch ( final MPDConnectionException ignored ) { } this . filesdir = MPDApplication . getInstance ( ) . getCacheDir ( ) ; Log . d ( TAG , " server  " + server + "  port  " + port + "  dir  " + filesdir ) ; if ( ! load ( ) ) { refresh ( true ) ; } } return true ; }
Partnership getPartnershipByName ( @Nullable String sName ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllPartnershipNames ( ) ; @Nonnull @ReturnsMutableCopy List < Partnership > getAllPartnerships ( ) ; void updatePartnership ( @Nonnull IMessage aMsg , boolean bOverwrite ) throws OpenAS2Exception ; void updatePartnership ( @Nonnull IMessageMDN aMdn , boolean bOverwrite ) throws OpenAS2Exception ; }
void updatePartnership ( IMessageMDN aMdn , boolean bOverwrite ) throws OpenAS2Exception ; void setPartnerships ( List < Partnership > aPartnerships ) ; List < Partnership > getPartnerships ( ) ; Map < String , StringMap > getPartners ( ) ; }
private static boolean testQuadTree ( ) { int size = 16000 ; java . util . Set < QuadTree . XYPoint > set = new java . util . HashSet < QuadTree . XYPoint > ( size ) ; while ( set . size ( ) < size ) { float x = RANDOM . nextInt ( size ) ; float y = RANDOM . nextInt ( size ) ; QuadTree . XYPoint xyPoint = new QuadTree . XYPoint ( x , y ) ; set . add ( xyPoint ) ; } java . util . List < QuadTree . XYPoint > query = new java . util . ArrayList < QuadTree . XYPoint > ( size ) ; for ( int j = 0 ; j < size ; j + + ) { float x = RANDOM . nextInt ( size ) ; float y = RANDOM . nextInt ( size ) ; QuadTree . XYPoint xyPoint = new QuadTree . XYPoint ( x , y ) ; query . add ( xyPoint ) ; } long beforeInsert ; long beforeQuery ; long beforeMemory ; long beforeTreeQuery ; long beforeRemove ; long afterInsert ; long afterQuery ; long afterMemory ; long afterTreeQuery ; long afterRemove ; long insertTime ; long queryTime ; long removeTime ; long treeMemory ; long treeQuery ; { QuadTree . PointRegionQuadTree < QuadTree . XYPoint > tree = new QuadTree . PointRegionQuadTree < QuadTree . XYPoint > ( 0 , 0 , size , size ) ; beforeMemory = DataStructures . getMemoryUse ( ) ; { beforeInsert = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : set ) { tree . insert ( p . getX ( ) , p . getY ( ) ) ; } afterInsert = System . nanoTime ( ) ; insertTime = afterInsert - beforeInsert ; System . out . println ( " PointRegionQuadTree insertTime= " + insertTime / 100000 d + "  ms " ) ; } afterMemory = DataStructures . getMemoryUse ( ) ; treeMemory = afterMemory - beforeMemory ; System . out . println ( " PointRegionQuadTree treeMemory= " + treeMemory ) ; for ( QuadTree . XYPoint p : set ) { java . util . List < QuadTree . XYPoint > result = tree . queryRange ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; if ( result . size ( ) < = 0 ) return false ; } { beforeQuery = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : query ) { tree . queryRange ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; } afterQuery = System . nanoTime ( ) ; queryTime = afterQuery - beforeQuery ; System . out . println ( " PointRegionQuadTree queryTime= " + queryTime / 100000 d + "  ms " ) ; } beforeTreeQuery = System . nanoTime ( ) ; java . util . List < QuadTree . XYPoint > result = tree . queryRange ( 0 , 0 , size , size ) ; afterTreeQuery = System . nanoTime ( ) ; treeQuery = afterTreeQuery - beforeTreeQuery ; System . out . println ( " PointRegionQuadTree wholeTreeQuery= " + treeQuery / 100000 d + "  ms " ) ; Collections . sort ( result ) ; QuadTree . XYPoint prev = null ; for ( QuadTree . XYPoint p : result ) { if ( prev ! = null & & prev . equals ( p ) ) return false ; prev = p ; } { beforeRemove = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : set ) { boolean removed = tree . remove ( p . getX ( ) , p . getY ( ) ) ; if ( ! removed ) return false ; } afterRemove = System . nanoTime ( ) ; removeTime = afterRemove - beforeRemove ; System . out . println ( " PointRegionQuadTree removeTime= " + removeTime / 100000 d + "  ms " ) ; } } { QuadTree . MxCifQuadTree < QuadTree . AxisAlignedBoundingBox > tree = new QuadTree . MxCifQuadTree < QuadTree . AxisAlignedBoundingBox > ( 0 , 0 , size , size , 10 , 10 ) ; beforeMemory = DataStructures . getMemoryUse ( ) ; { beforeInsert = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : set ) { tree . insert ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; } afterInsert = System . nanoTime ( ) ; insertTime = afterInsert - beforeInsert ; System . out . println ( " MxCifQuadTree insertTime= " + insertTime / 100000 d + "  ms " ) ; } afterMemory = DataStructures . getMemoryUse ( ) ; treeMemory = afterMemory - beforeMemory ; System . out . println ( " MxCifQuadTree treeMemory= " + treeMemory ) ; for ( QuadTree . XYPoint p : set ) { java . util . List < QuadTree . AxisAlignedBoundingBox > result = tree . queryRange ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; if ( result . size ( ) < = 0 ) return false ; } { beforeQuery = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : query ) { tree . queryRange ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; } afterQuery = System . nanoTime ( ) ; queryTime = afterQuery - beforeQuery ; System . out . println ( " MxCifQuadTree queryTime= " + queryTime / 100000 d + "  ms " ) ; } beforeTreeQuery = System . nanoTime ( ) ; java . util . List < QuadTree . AxisAlignedBoundingBox > result = tree . queryRange ( 0 , 0 , size , size ) ; afterTreeQuery = System . nanoTime ( ) ; treeQuery = afterTreeQuery - beforeTreeQuery ; System . out . println ( " MxCifQuadTree wholeTreeQuery= " + treeQuery / 100000 d + "  ms " ) ; Collections . sort ( result ) ; QuadTree . AxisAlignedBoundingBox prev = null ; for ( QuadTree . AxisAlignedBoundingBox p : result ) { if ( prev ! = null & & prev . equals ( p ) ) { return false ; } prev = p ; } { beforeRemove = System . nanoTime ( ) ; for ( QuadTree . XYPoint p : set ) { boolean removed = tree . remove ( p . getX ( ) , p . getY ( ) , 1 , 1 ) ; if ( ! removed ) return false ; } afterRemove = System . nanoTime ( ) ; removeTime = afterRemove - beforeRemove ; System . out . println ( " MxCifQuadTree removeTime= " + removeTime / 100000 d + "  ms " ) ; } } return true ; }
public static void parseMDN ( @Nonnull final IMessage aMsg , @Nonnull final X509Certificate aReceiverCert , final boolean bAllowCertificateInBodyPart ) throws Exception { final IMessageMDN aMdn = aMsg . getMDN ( ) ; MimeBodyPart aMainPart = aMdn . getData ( ) ; final ICryptoHelper aCryptoHelper = getCryptoHelper ( ) ; final boolean bForceVerify = " true " . equals ( aMsg . getPartnership ( ) . getAttribute ( CPartnershipIDs . PA_FORCE_VERIFY ) ) ; if ( bForceVerify | | aCryptoHelper . isSigned ( aMainPart ) ) { aMainPart = aCryptoHelper . verify ( aMainPart , aReceiverCert , bAllowCertificateInBodyPart , bForceVerify ) ; } final MimeMultipart aReportParts = new MimeMultipart ( aMainPart . getDataHandler ( ) . getDataSource ( ) ) ; final ContentType aReportType = new ContentType ( aReportParts . getContentType ( ) ) ; if ( aReportType . getBaseType ( ) . equalsIgnoreCase ( " multipart/report " ) ) {
< T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String mechs [ ] , CallbackHandler cbh ) throws OperationException ; }
public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; app = ( MPDApplication ) getActivity ( ) . getApplicationContext ( ) ; try { Activity activity = this . getActivity ( ) ;
public static Term make ( ArrayList < Term > argList , int temporalOrder , final Memory memory ) { if ( argList . isEmpty ( ) ) { return null ; } if ( argList . size ( ) = = 1 ) { return argList . get ( 0 ) ; } if ( temporalOrder = = TemporalRules . ORDER_FORWARD ) { final String name = makeCompoundName ( NativeOperator . SEQUENCE , argList ) ;
public void testDijstraDirectedWihtNegativeWeights ( ) { { if ( debug > 0 ) System . out . println ( " Directed Graph with Negative Weights. " ) ;
public void push ( final long t , final float f ) { if ( resetRangeEachCycle ) min = max = f ; for ( int i = historySize - 1 ; i > = 1 ; i - - ) { final float g = values [ i ] = values [ i - 1 ] ; if ( i > 1 ) { if ( g < min ) min = g ; if ( g > max ) max = g ; } } values [ 0 ] = f ; lastT = t ; }
public void train ( double [ ] x , double lr , double corruption_level ) { double [ ] tilde_x = new double [ n_visible ] ; double [ ] y = new double [ n_hidden ] ; double [ ] z = new double [ n_visible ] ; double [ ] L_vbias = new double [ n_visible ] ; double [ ] L_hbias = new double [ n_hidden ] ; if ( corruption_level > 0 ) { get_corrupted_input ( x , tilde_x , 1 - corruption_level ) ; } else { tilde_x = x ; } getEncoded ( tilde_x , y , true , false ) ; get_reconstructed_input ( y , z ) ; for ( int i = 0 ; i < n_visible ; i + + ) { L_vbias [ i ] = x [ i ] - z [ i ] ; vbias [ i ] + = lr * L_vbias [ i ] ; } for ( int i = 0 ; i < n_hidden ; i + + ) { L_hbias [ i ] = 0 ; for ( int j = 0 ; j < n_visible ; j + + ) { L_hbias [ i ] + = W [ i ] [ j ] * L_vbias [ j ] ; } L_hbias [ i ] * = y [ i ] * ( 1 - y [ i ] ) ; hbias [ i ] + = lr * L_hbias [ i ] ; } for ( int i = 0 ; i < n_hidden ; i + + ) { for ( int j = 0 ; j < n_visible ; j + + ) {
protected void beliefReason ( Sentence belief , Term beliefTerm , Term taskTerm , NAL nal ) { Memory memory = nal . memory ; if ( Memory . randomNumber . nextDouble ( ) < INTERNAL_EXPERIENCE_RARE_PROBABILITY ) { Operator op = memory . getOperator ( nonInnateBeliefOperators [ Memory . randomNumber . nextInt ( nonInnateBeliefOperators . length ) ] ) ; Product prod = new Product ( new Term [ ] { belief . content } ) ; if ( op ! = null & & prod ! = null ) { Term new_term = Inheritance . make ( prod , op ) ; Sentence sentence = new Sentence ( new_term , Symbols . GOAL_MARK , new TruthValue ( 1 , Parameters . DEFAULT_JUDGMENT_CONFIDENCE ) , new Stamp ( memory ) ) ; float quality = BudgetFunctions . truthToQuality ( sentence . truth ) ; BudgetValue budget = new BudgetValue ( Parameters . DEFAULT_GOAL_PRIORITY * INTERNAL_EXPERIENCE_PRIORITY_MUL , Parameters . DEFAULT_GOAL_DURABILITY * INTERNAL_EXPERIENCE_DURABILITY_MUL , quality ) ; Task newTask = new Task ( sentence , budget ) ; nal . derivedTask ( newTask , false , false , null , null ) ; } } if ( beliefTerm instanceof Implication & & Memory . randomNumber . nextDouble ( ) < = INTERNAL_EXPERIENCE_PROBABILITY ) { Implication imp = ( Implication ) beliefTerm ;
public static void main ( String [ ] args ) throws Exception { Parameters . DEFAULT_JUDGMENT_PRIORITY = 0.5f ; NAR n = new ContinuousBagNARBuilder ( true ) . setConceptBagSize ( 16192 ) . build ( ) ; n . param ( ) . noiseLevel . set ( 40 ) ; KIFInput k = new KIFInput ( " /home/me/sigma/KBs/Merge.kif " ) ; k . setIncludeSubclass ( true ) ; k . setIncludeInstance ( true ) ; k . setIncludeSubrelation ( true ) ; k . setIncludeRelatedInternalConcept ( true ) ; k . start ( ) ; n . addInput ( k ) ; TextOutput t = new TextOutput ( n , System . out ) ; t . setErrors ( true ) ; t . setErrorStackTrace ( true ) ; n . finish ( 4000 ) ; n . param ( ) . cycleMemory . set ( 512 ) ; t . stop ( ) ; new NARSwing ( n ) ; System . err . println ( new NARState ( n ) . measure ( ) ) ; }
public void onResume ( ) { super . onResume ( ) ; SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( activity ) ; showAlbumArtist = settings . getBoolean ( " showAlbumArtist " , true ) ; try { updateTrackInfo ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } updateStatus ( null ) ; new Thread ( new Runnable ( ) { @Override public void run ( ) { try { final int volume = app . oMPDAsyncHelper . oMPD . getStatus ( ) . getVolume ( ) ; handler . post ( new Runnable ( ) { @Override public void run ( ) { progressBarVolume . setProgress ( volume ) ; if ( volume = = - 1 ) { progressBarVolume . setEnabled ( false ) ; progressBarVolume . setVisibility ( View . GONE ) ; volumeIcon . setVisibility ( View . GONE ) ; } } } ) ; } catch ( MPDServerException e ) { e . printStackTrace ( ) ; } } } ) . start ( ) ; if ( currentSong ! = null ) { downloadCover ( currentSong . getAlbumInfo ( ) ) ;
public static boolean regionMatches ( boolean ignoreCase , Segment text , int offset , char [ ] match ) { int length = offset + match . length ; char [ ] textArray = text . array ; if ( length > text . offset + text . count ) return false ; for ( int i = offset , j = 0 ; i < length ; i + + , j + + ) { char c1 = textArray [ i ] ; char c2 = match [ j ] ; if ( ignoreCase ) { c1 = Character . toUpperCase ( c1 ) ; c2 = Character . toUpperCase ( c2 ) ; } if ( c1 ! = c2 ) return false ; } return true ; }
public void decision ( double . . . confidences ) { String i = " " ; for ( int n = 0 ; n < confidences . length ; n + + ) { i + = " <<c " + n + "  --> decision> =/> goal>. " + " \ n " ; } for ( int n = 0 ; n < confidences . length ; n + + ) { i + = " <(^pick,p " + n + " ) =/> <c " + n + "  --> decision>>. " + " \ n " ; } for ( int n = 0 ; n < confidences . length ; n + + ) { double c = confidences [ n ] ; i + = " <c " + n + "  --> decision>. :|: %1.00; " + Texts . n2 ( ( float ) c ) + " % \ n " ; } i + = " goal! " ; System . out . println ( i ) ; System . out . println ( Arrays . toString ( confidences ) ) ; NAR n = new Default ( ) . build ( ) ; n . addInput ( i ) ; new Output ( n ) { @Override public void event ( Class c , Object . . . args ) { Object o = args [ 0 ] ; if ( c = = OUT . class ) { if ( o instanceof Task ) { Sentence s = ( ( Task ) o ) . sentence ; if ( s . punctuation = = '!' ) { System . out . println ( o ) ; } } } if ( c = = EXE . class ) { System . out . println ( " EXE:  " + n . time ( ) + " :  " + o ) ; } } } ; n . run ( 2000 ) ; System . out . println ( ) ;
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { if ( args . length < 2 ) { return null ; } if ( ( ( args . length - 2 ) % 2 ) ! = 0 ) { return null ; } if ( ! ( args [ 0 ] instanceof Term ) ) { return null ; } if ( ! ( args [ 1 ] instanceof Term ) ) { return null ; } if ( ! context . prologInterpreters . containsKey ( args [ 1 ] ) ) { return null ; } Prolog prologInterpreter = context . prologInterpreters . get ( args [ 1 ] ) ; Term queryTerm = ( Term ) args [ 0 ] ; String query = getStringOfTerm ( queryTerm ) ; VariableInfo [ ] variableInfos = translateNarsArgumentsToQueryVariableInfos ( args ) ; prologParseAndExecuteAndDereferenceInput ( prologInterpreter , query , variableInfos ) ; memory . output ( Prolog . class , query + "  | TODO " ) ; Term [ ] resultTerms = getResultVariablesFromPrologVariables ( variableInfos , memory ) ; int i ; Term [ ] resultInnerProductTerms = new Term [ 2 + resultTerms . length * 2 ] ; resultInnerProductTerms [ 0 ] = args [ 0 ] ; resultInnerProductTerms [ 1 ] = args [ 1 ] ; for ( i = 0 ; i < resultTerms . length ; i + + ) { resultInnerProductTerms [ 2 + i * 2 + 0 ] = args [ 2 + i * 2 ] ; resultInnerProductTerms [ 2 + i * 2 + 1 ] = resultTerms [ i ] ; } Inheritance operatorInheritance = Operation . make ( Product . make ( resultInnerProductTerms , memory ) , this , memory ) ; Inheritance resultInheritance = Inheritance . make ( operatorInheritance , new Term ( " prolog_evaluation " ) , memory ) ; memory . output ( Task . class , resultInheritance ) ; ArrayList < Task > results = new ArrayList < > ( 1 ) ; results . add ( memory . newTask ( resultInheritance , Symbols . JUDGMENT_MARK , 1f , 0.99f , Parameters . DEFAULT_JUDGMENT_PRIORITY , Parameters . DEFAULT_JUDGMENT_DURABILITY ) ) ; return results ; }
X509Certificate getCertificate ( @Nonnull IMessageMDN aMDN , @Nullable ECertificatePartnershipType ePartnershipType ) throws OpenAS2Exception ; @Nullable X509Certificate getCertificateOrNull ( @Nonnull IMessageMDN aMDN , @Nullable ECertificatePartnershipType ePartnershipType ) throws OpenAS2Exception ; @Nonnull PrivateKey getPrivateKey ( @Nullable IMessageMDN aMDN , @Nullable X509Certificate aCert ) throws OpenAS2Exception ; }
public void configToObjectToConfig ( ) throws Exception { ObjectConverter converter = new ObjectConverter ( ) ; MyObject object = converter . toObject ( config , MyObject : : new ) ; Config myConfig = Config . inMemory ( ) ; converter . toConfig ( object , myConfig ) ; System . out . println ( " Original config:  " + config ) ; System . out . println ( " New config:  " + myConfig ) ; System . out . println ( " Object:  " + object ) ; assert myConfig . equals ( config ) : " Invalid conversion! " ; }
public DockingPickRecord pickContainer ( Point containerPoint ) { Rectangle bounds = getBounds ( ) ; bounds . x = bounds . y = 0 ; if ( ! bounds . contains ( containerPoint ) ) { return null ; } if ( containerPoint . y < bounds . y + bounds . height / 3 ) { return new DockingPickRecord ( this , SwingUtilities . NORTH ) ; } if ( containerPoint . y > bounds . y + bounds . height * 2 / 3 ) { return new DockingPickRecord ( this , SwingUtilities . SOUTH ) ; } if ( containerPoint . x < bounds . x + bounds . width / 3 ) { return new DockingPickRecord ( this , SwingUtilities . WEST ) ; } if ( containerPoint . x > bounds . x + bounds . width * 2 / 3 ) { return new DockingPickRecord ( this , SwingUtilities . EAST ) ; } return new DockingPickRecord ( this , SwingUtilities . CENTER ) ; }
protected void print ( final Class c , final Object o ) { Color defaultColor = Color . WHITE ; print ( LogPanel . getChannelColor ( c ) , c . getSimpleName ( ) + " :  " , false , 1 ) ; print ( defaultColor , LogPanel . getText ( o , showStamp , nar ) + '\n' , false , 1 ) ; }
private void populate ( Integer [ ] values ) { for ( int v : values ) { put ( v , v ) ;
public boolean contains ( Object value ) { return list . contains ( ( T ) value ) ; }
public boolean onOpenSubMenu ( MenuBuilder subMenu ) { return true ; }
Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key , int hold ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
public void testApplicationNameProvided ( ) { Properties props = new Properties ( ) ; props . setProperty ( " application.name " , " test " ) ; Config config = ConfigFactory . parseProperties ( props ) ; Contexts . closeSparkSession ( true ) ; Contexts . initialize ( config , Contexts . ExecutionMode . UNIT_TEST ) ; SparkConf sparkConf = Contexts . getSparkSession ( ) . sparkContext ( ) . getConf ( ) ; assertEquals ( sparkConf . get ( " spark.app.name " ) , " test " ) ; }
public boolean add ( E element ) { if ( capacity = = 500 ) System . out . println ( "  +  " + element + "   " + contains ( element ) ) ; boolean b = addIfAbsent ( element ) ; if ( capacity = = 500 ) System . out . println ( b + "   " + size ( ) ) ; return b ; }
public static void setHTTPOutgoingDumper ( @Nullable final IHTTPOutgoingDumper aHttpDumper ) { s_aHTTPOutgoingDumper = aHttpDumper ; if ( aHttpDumper ! = null ) s_aLogger . info ( " Using the following handler to dump outgoing requests:  " + aHttpDumper ) ;
EChange removePartnership ( @Nonnull Partnership aPartnership ) throws AS2Exception ; @Nonnull Partnership getPartnership ( @Nonnull Partnership aPartnership ) throws AS2Exception ; @Nullable Partnership getPartnershipByName ( @Nullable String sName ) ; @Nonnull @ReturnsMutableCopy ICommonsSet < String > getAllPartnershipNames ( ) ; @Nonnull @ReturnsMutableCopy ICommonsList < Partnership > getAllPartnerships ( ) ; void updatePartnership ( @Nonnull IMessage aMsg , boolean bOverwrite ) throws AS2Exception ; void updatePartnership ( @Nonnull IMessageMDN aMdn , boolean bOverwrite ) throws AS2Exception ; }
private void handleConnectionFailure ( final MPDCommandResult result , final MPDServerException ex ) { result . setLastException ( ex ) ; try { Thread . sleep ( 500L ) ; } catch ( final InterruptedException ignored ) { } try { innerConnect ( ) ;
public boolean isDecisionQuestionGen ( ) { return Parameters . QUESTION_GENERATION_ON_DECISION_MAKING ; }
public void testGraphPlan ( String input , String expected ) throws IOException { NAR n = new DefaultNARBuilder ( ) . build ( ) ; AtomicBoolean success = new AtomicBoolean ( false ) ; System . out . println ( input ) ; n . addOutput ( new Output ( ) { @Override public void output ( Class channel , Object o ) { if ( o . toString ( ) . contains ( expected ) ) success . set ( true ) ; } } ) ; n . addInput ( input ) ; n . finish ( 25 ) ; assertTrue ( success . get ( ) ) ; }
public void update ( Timeline2DCanvas l , float timeScale , float yScale ) { TreeMap < Long , List < Events . InferenceEvent > > time = trace . time ; timepoints . putAll ( time . subMap ( l . getStart ( ) , l . getEnd ( ) ) ) ; }
SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
public void actionPerformed ( ActionEvent e ) { if ( this . concept = = null ) { this . concept = nar . memory . concept ( term ) ; } if ( this . concept = = null ) { return ; } popup ( nar , concept ) ; }
public void removeByPosition ( int position ) { Music music = ( Music ) list . get ( position ) ; if ( music ! = null ) { list . remove ( position ) ;
public List < Artist > getArtists ( Genre genre , boolean useAlbumArtist ) throws MPDServerException { List < String > artistNames = useAlbumArtist ? listAlbumArtists ( genre ) : listArtists ( genre . getName ( ) , true ) ; final List < Artist > artists = new ArrayList < > ( artistNames . size ( ) ) ; if ( null ! = artistNames & & ! artistNames . isEmpty ( ) ) { for ( String artist : artistNames ) { artists . add ( new Artist ( artist ) ) ; } } Collections . sort ( artists ) ; return artists ; }
public void stop ( ) { nar . off ( Events . CycleStop . class , this ) ; }
public void reset ( ) { event . emit ( ResetStart . class ) ; decisionBlock = 0 ; concepts . clear ( ) ; novelTasks . clear ( ) ; newTasks . clear ( ) ; this . seq_current . clear ( ) ; cycle = 0 ; inputPausedUntil = 0 ; emotion . set ( 0.5f , 0.5f ) ; resetStatic ( ) ; event . emit ( ResetEnd . class ) ; }
public EntranceProcessingItem createEntrancePi ( EntranceProcessor entranceProcessor ) { S4EntranceProcessingItem entrancePi = new S4EntranceProcessingItem ( entranceProcessor , app ) ; entrancePi . setParalellism ( 1 ) ; return entrancePi ; }
public void lerpPriority ( final float targetValue , final float momentum ) { setPriority ( ( getPriority ( ) * momentum ) + ( ( 1f - momentum ) * targetValue ) ) ; }
public void testFullyQualifiedClassNameSamePackage ( ) { String expected = " com.jakewharton.test.SomeClass " ; String actual = cleanActivityName ( " com.jakewharton.test " , " com.jakewharton.test.SomeClass " ) ; assertThat ( expected , equalTo ( actual ) ) ; }
public String getParameter ( @Nonnull final String sKey ) throws InvalidParameterException { if ( sKey = = null ) throw new InvalidParameterException ( " Invalid key " , this , sKey , null ) ; final int nWantedChars = sKey . length ( ) ; final int nMax = ( int ) Math . pow ( 10 , nWantedChars ) ; if ( false ) { if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Init SecureRandom " ) ; final SecureRandom aRandom = VerySecureRandom . getInstance ( ) ; if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Finished init SecureRandom " ) ; return StringHelper . getLeadingZero ( aRandom . nextInt ( nMax ) , nWantedChars ) ; } return StringHelper . getLeadingZero ( new Random ( ) . nextInt ( nMax ) , nWantedChars ) ; }
int UpdateSOM ( float [ ] viewField , float reward ) { for ( int i = 0 ; i < viewField . length ; i + + ) { if ( viewField [ i ] > 0.1f ) { String s = " <{ \" " + String . valueOf ( i ) + " \" } --> [on]>. :|: " ; if ( ! lastInput . equals ( s ) ) { nar . addInput ( s ) ; } lastInput = s ; } } lastAction = 0 ; k + + ; if ( k % 4 = = 0 ) { nar . addInput ( " <SELF --> [good]>! :|: " ) ; } if ( reward > 0 ) { System . out . println ( " good mr_nars " ) ; nar . addInput ( " <SELF --> [good]>. :|: " ) ; } if ( reward < 0 ) { System . out . println ( " bad mr_nars " ) ; nar . addInput ( " (--,<SELF --> [good]>). :|: " ) ; } nar . step ( 500 ) ; if ( lastAction = = 0 & & random ( 1.0f ) < Alpha ) { lastAction = ( int ) random ( ( float ) nActions ) ; if ( lastAction = = 1 ) { nar . executeDummyDecision ( " Right(SELF) " ) ; } if ( lastAction = = 2 ) { nar . executeDummyDecision ( " Left(SELF) " ) ; } } return lastAction ; }
public static boolean containVarIndep ( String n ) { return n . indexOf ( Symbols . VAR_INDEPENDENT ) > = 0 ; }
String setComment ( String comment ) ; String removeComment ( ) ; } @Override CommentedConfig createSubConfig ( ) ; static CommentedConfig of ( ConfigFormat < ? extends CommentedConfig , ? super CommentedConfig , ? super CommentedConfig > format ) { return new SimpleCommentedConfig ( format , false ) ; } static CommentedConfig ofConcurrent ( ConfigFormat < ? extends CommentedConfig , ? super CommentedConfig , ? super CommentedConfig > format ) { return new SimpleCommentedConfig ( format , false ) ; } static CommentedConfig inMemory ( ) { return InMemoryCommentedFormat . defaultInstance ( ) . createConfig ( ) ; } static CommentedConfig inMemoryConcurrent ( ) { return InMemoryCommentedFormat . defaultInstance ( ) . createConcurrentConfig ( ) ; } static CommentedConfig wrap ( Map < String , Object > map , ConfigFormat < ? , ? , ? > format ) { return new SimpleCommentedConfig ( map , format ) ; } static CommentedConfig copy ( UnmodifiableConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , false ) ; } static CommentedConfig copy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleCommentedConfig ( config , format , false ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , false ) ; } static CommentedConfig copy ( UnmodifiableCommentedConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleCommentedConfig ( config , format , false ) ; } static CommentedConfig concurrentCopy ( UnmodifiableConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , true ) ; } static CommentedConfig concurrentCopy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleCommentedConfig ( config , format , true ) ; } static CommentedConfig concurrentCopy ( UnmodifiableCommentedConfig config ) { return new SimpleCommentedConfig ( config , config . configFormat ( ) , true ) ; } static CommentedConfig concurrentCopy ( UnmodifiableCommentedConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleCommentedConfig ( config , format , true ) ; } static CommentedConfig fake ( Config config ) { if ( config instanceof CommentedConfig ) { return ( CommentedConfig ) config ; } return new FakeCommentedConfig ( config ) ; } }
public void draw ( ) { background ( 0 , 0 , 0 ) ; pushMatrix ( ) ; hnav . Transform ( ) ; hrend_DrawBegin ( ) ; drawGround ( ) ; drawObjects ( ) ; drawParticles ( ) ; hrend_DrawEnd ( ) ; popMatrix ( ) ; hrend_DrawGUI ( ) ; realtime = System . nanoTime ( ) / 1.0e9 ; if ( time % automataPeriod = = 0 ) { cells . Exec ( ) ;
final void addCallback ( final FullSizeCallback callback ) { mFullSizeListener = callback ; }
< T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public boolean containsKey ( final K key ) { return mInternalMap . containsKey ( key ) ; }
protected void execute ( final Operation op , final Task task ) { Operator oper = op . getOperator ( ) ; op . setTask ( task ) ; oper . call ( op , memory ) ;
static void dedConjunctionByQuestion ( final Sentence sentence , final Sentence belief , final Memory memory ) { if ( sentence = = null | | belief = = null | | ! sentence . isJudgment ( ) | | ! belief . isJudgment ( ) ) { return ; } Term term1 = sentence . content ; Term term2 = belief . content ; for ( final Concept concept : memory . concepts ) {
public void before ( ) throws Exception { utility . createTable ( TABLE , new byte [ ] [ ] { CF1 } ) ; }
private String retrieveCoverArtPath ( ) { final ICoverRetriever cache = new CachedCover ( app ) ; String coverArtPath = null ; String [ ] coverArtPaths = null ; try { coverArtPaths = cache . getCoverUrl ( mCurrentMusic . getAlbumInfo ( ) ) ; } catch ( final Exception e ) { Log . d ( TAG , " Failed to get the cover URL from the cache. " , e ) ; } if ( coverArtPaths ! = null & & coverArtPaths . length > 0 ) { coverArtPath = coverArtPaths [ 0 ] ; } return coverArtPath ; }
public void removeMeter ( String name ) { if ( meters . containsKey ( name ) ) { meters . remove ( name ) ;
private static BudgetValue parseBudget ( String s , char punctuation , TruthValue truth ) throws InvalidInputException { float priority , durability ; switch ( punctuation ) { case JUDGMENT_MARK : priority = Parameters . DEFAULT_JUDGMENT_PRIORITY ; durability = Parameters . DEFAULT_JUDGMENT_DURABILITY ; break ; case QUESTION_MARK : priority = Parameters . DEFAULT_QUESTION_PRIORITY ; durability = Parameters . DEFAULT_QUESTION_DURABILITY ; break ; case GOAL_MARK : priority = Parameters . DEFAULT_GOAL_PRIORITY ; durability = Parameters . DEFAULT_GOAL_DURABILITY ; break ; case QUEST_MARK : priority = Parameters . DEFAULT_QUEST_PRIORITY ; durability = Parameters . DEFAULT_QUEST_DURABILITY ; break ; default : throw new InvalidInputException ( " unknown punctuation: ' " + punctuation + " ' " ) ; } if ( s ! = null ) { int i = s . indexOf ( VALUE_SEPARATOR ) ; if ( i < 0 ) { priority = Float . parseFloat ( s ) ; } else { priority = Float . parseFloat ( s . substring ( 0 , i ) ) ; durability = Float . parseFloat ( s . substring ( i + 1 ) ) ; } } float quality = ( truth = = null ) ? 1 : BudgetFunctions . truthToQuality ( truth ) ; return new BudgetValue ( priority , durability , quality ) ; }
public void handleMessage ( Message msg ) { switch ( msg . what ) { case EVENT_COVERDOWNLOADED :
public boolean onPrepareActionMode ( android . view . ActionMode mode , android . view . Menu menu ) { return mCallback . onPrepareActionMode ( mActionMode , mActionMode . getMenu ( ) ) ; }
private void convertConfigsToObject ( Collection < ? > src , Collection < Object > dst , List < Class < ? > > dstElementTypes , int currentLevel ) { final Class < ? > currentType = dstElementTypes . get ( currentLevel ) ; for ( Object elem : src ) { if ( elem = = null ) {
public static void parseMDN ( @Nonnull final IMessage aMsg , @Nonnull final X509Certificate aReceiverCert , final boolean bAllowCertificateInBodyPart ) throws Exception { final IMessageMDN aMdn = aMsg . getMDN ( ) ; MimeBodyPart aMainPart = aMdn . getData ( ) ; final ICryptoHelper aCryptoHelper = getCryptoHelper ( ) ; final boolean bDisableVerify = aMsg . getPartnership ( ) . isDisableVerify ( ) ; final boolean bMsgIsSigned = aCryptoHelper . isSigned ( aMainPart ) ; final boolean bForceVerify = aMsg . getPartnership ( ) . isForceVerify ( ) ; if ( bMsgIsSigned & & bDisableVerify ) { s_aLogger . info ( " Message claims to be signed but signature validation is disabled " + aMsg . getLoggingText ( ) ) ; } else if ( bMsgIsSigned | | bForceVerify ) { if ( bForceVerify & & ! bMsgIsSigned ) s_aLogger . info ( " Forced verify MDN signature " + aMsg . getLoggingText ( ) ) ; else if ( s_aLogger . isDebugEnabled ( ) ) s_aLogger . debug ( " Verifying MDN signature " + aMsg . getLoggingText ( ) ) ; aMainPart = aCryptoHelper . verify ( aMainPart , aReceiverCert , bAllowCertificateInBodyPart , bForceVerify ) ; } final MimeMultipart aReportParts = new MimeMultipart ( aMainPart . getDataHandler ( ) . getDataSource ( ) ) ; final ContentType aReportType = new ContentType ( aReportParts . getContentType ( ) ) ; if ( aReportType . getBaseType ( ) . equalsIgnoreCase ( " multipart/report " ) ) {
private void reset ( ) { m_spec = null ; m_group = null ; m_ingroup = null ; }
public Instances getDataset ( ) ; public boolean implementsMicroClusterer ( ) ; public Clustering getMicroClusteringResult ( ) ; }
public void testNoneArrivingOneExisting ( ) { p = new EventTimeHistoryPlanner ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , EventTimeHistoryPlanner . FAR_FUTURE_MILLIS , EventTimeHistoryPlanner . CURRENT_FLAG_YES , " " ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 0 ) ; }
public void onDataBind ( Context context , View targetView , List < ? > items , Object item , int position ) { ( ( TextView ) targetView . findViewById ( android . R . id . text1 ) ) . setText ( item . toString ( ) ) ; }
public abstract List < GenericRecord > decode ( Iterator < Tuple2 < String , String > > inputs ) ; public abstract Schema getSchema ( ) ; public abstract Object extractGroupByKey ( String key , String message ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmDisj p , A arg ) { return visitDefault ( p , arg ) ; } public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmPar p , A arg ) { return visitDefault ( p , arg ) ; }
public Matcher matcher ( final Pattern pattern ) { return pattern . matcher ( this . sequence ) ; }
private boolean parseFalse ( CharacterInput input ) { CharsWrapper chars = input . readChars ( 4 ) ; if ( ! chars . contentEquals ( FALSE_LAST ) ) throw new ParsingException ( " Invalid value: f " + new CharsWrapper ( chars ) + "  - expected boolean false " ) ; return false ; }
private void decorate ( int x0 , int x1 , int floor ) { if ( floor < 1 ) return ; boolean rocks = true ; addEnemyLine ( x0 + 1 , x1 - 1 , floor - 1 ) ; int s = random . nextInt ( 4 ) ; int e = random . nextInt ( 4 ) ; if ( floor - 2 > 0 ) { if ( ( x1 - 1 - e ) - ( x0 + 1 + s ) > 1 ) { for ( int x = x0 + 1 + s ; x < x1 - 1 - e ; x + + ) { level . setBlock ( x , floor - 2 , ( byte ) ( 2 + 2 * 16 ) ) ; } } } s = random . nextInt ( 4 ) ; e = random . nextInt ( 4 ) ; if ( floor - 4 > 0 ) { if ( ( x1 - 1 - e ) - ( x0 + 1 + s ) > 2 ) { for ( int x = x0 + 1 + s ; x < x1 - 1 - e ; x + + ) { if ( rocks ) { if ( x ! = x0 + 1 & & x ! = x1 - 2 & & random . nextInt ( 3 ) = = 0 ) { if ( random . nextInt ( 4 ) = = 0 ) { level . setBlock ( x , floor - 4 , ( byte ) ( 4 + 2 + 1 * 16 ) ) ; } else { level . setBlock ( x , floor - 4 , ( byte ) ( 4 + 1 + 1 * 16 ) ) ; } } else if ( random . nextInt ( 4 ) = = 0 ) { if ( random . nextInt ( 4 ) = = 0 ) { level . setBlock ( x , floor - 4 , ( byte ) ( 2 + 1 * 16 ) ) ; } else { level . setBlock ( x , floor - 4 , ( byte ) ( 1 + 1 * 16 ) ) ; } } else { level . setBlock ( x , floor - 4 , ( byte ) ( 0 + 1 * 16 ) ) ; } } } } } int length = x1 - x0 - 2 ;
public void onPause ( ) { mApp . oMPDAsyncHelper . removeStatusChangeListener ( this ) ; super . onPause ( ) ; }
private IcsSpinner createSpinner ( ) { final IcsSpinner spinner = new IcsSpinner ( getContext ( ) , null , R . attr . actionDropDownStyle ) ; spinner . setLayoutParams ( new LinearLayout . LayoutParams ( LinearLayout . LayoutParams . WRAP_CONTENT , LinearLayout . LayoutParams . MATCH_PARENT ) ) ; spinner . setOnItemSelectedListener ( this ) ; return spinner ; }
MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bAllowCertificateInBodyPart ) throws Exception ; }
public String generateMessageID ( ) { final CompositeParameters aParams = new CompositeParameters ( false ) . add ( " date " , new DateParameters ( ) ) . add ( " msg " , new MessageParameters ( this ) ) . add ( " rand " , new RandomParameters ( ) ) ; final String sIDFormat = getPartnership ( ) . getMessageIDFormat ( DEFAULT_ID_FORMAT ) ; final StringBuilder aSB = new StringBuilder ( ) ; aSB . append ( '<' ) ; try { aSB . append ( aParams . format ( sIDFormat ) ) ; } catch ( final InvalidParameterException ex ) { aSB . append ( sIDFormat ) ; } aSB . append ( '>' ) ; return aSB . toString ( ) ; }
private static void addVariable ( StreamTokenizer_s st , Vector variables ) { String tptpVariable ; if ( st . sval . charAt ( 0 ) = = '?' | | st . sval . charAt ( 0 ) = = '@' ) { tptpVariable = translateWord ( st , false ) ;
public static KeyframeSet ofKeyframe ( Keyframe . . . keyframes ) { int numKeyframes = keyframes . length ; boolean hasFloat = false ; boolean hasInt = false ; boolean hasOther = false ; for ( int i = 0 ; i < numKeyframes ; + + i ) { if ( keyframes [ i ] instanceof FloatKeyframe ) { hasFloat = true ; } else if ( keyframes [ i ] instanceof IntKeyframe ) { hasInt = true ; } else { hasOther = true ; } } if ( hasFloat & & ! hasInt & & ! hasOther ) { FloatKeyframe floatKeyframes [ ] = new FloatKeyframe [ numKeyframes ] ;
private Dataset < Row > createBulkMutations ( int num ) { List < Row > records = new ArrayList < > ( ) ; long beginTime = 1_000_000_000 ; for ( int i = 0 ; i < num ; + + i ) { Row insertRow = new RowWithSchema ( planningSchema , SYMBOLS [ i % SYMBOLS . length ] , beginTime + i , Integer . toString ( i ) , i , i % 10 , i + i % 10 ) ; records . add ( insertRow ) ; } return Contexts . getSparkSession ( ) . createDataFrame ( records , planningSchema ) ; }
private static < K extends Number , V > boolean validate ( ArrayNode < K > parent , ArrayNode < K > node ) { if ( parent ! = null ) { if ( ! parent . key . equals ( node . parent . key ) ) return false ; if ( parent . level + 1 ! = node . level ) return false ; } int children = 0 ; for ( int i = 0 ; i < node . children . length ; i + + ) { Node < K > child = node . getChild ( i ) ; if ( child ! = null ) { children + + ; if ( child instanceof KeyValueNode ) { KeyValueNode < K , V > kvChild = ( KeyValueNode < K , V > ) child ; if ( ! validate ( node , kvChild ) ) return false ; } else if ( child instanceof ArrayNode ) { ArrayNode < K > arrayNode = ( ArrayNode < K > ) child ; if ( ! validate ( node , arrayNode ) ) return false ; } else { return false ; } } } return ( children = = node . numberOfChildren ) ; }
private static void trim ( ) { while ( buf_ . length ( ) > 0 & & buf_ . charAt ( 0 ) = = ' ' ) buf_ . deleteCharAt ( 0 ) ; while ( buf_ . length ( ) > 0 & & buf_ . charAt ( buf_ . length ( ) - 1 ) = = ' ' ) buf_ . deleteCharAt ( buf_ . length ( ) - 1 ) ;
public void testBooleanEncoding ( ) throws Exception { assertTrue ( tu . decodeBoolean ( tu . encodeBoolean ( true ) ) ) ; assertFalse ( tu . decodeBoolean ( tu . encodeBoolean ( false ) ) ) ; }
public void init ( ) throws ServletException { settings ( ) . setMultipartEnabled ( false ) ; handlerRegistry ( ) . registerHandler ( EHttpMethod . POST , new AS2ReceiveXServletHandlerCodeConfig ( ) , false ) ; }
public static Term make ( final CompoundTerm compound , Collection < Term > components ) { Term [ ] c = components . toArray ( new Term [ components . size ( ) ] ) ; return make ( compound , c ) ; }
public boolean nextInput ( ) { if ( changed ) { if ( data = = null ) { } else { final String cert = " 0.99 " ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < data . length ; i + + ) { String freq = nf . format ( data [ i ] ) ; String s = " <(*, " + id + " _ " + i + " , " + id + " ) --> array_value_ " + i + " >. % " + freq + " ; " + cert + " % \ n " ; sb . append ( s ) ; } new TextInput ( nar , sb . toString ( ) ) ; } changed = false ; } return true ; }
public void testPlanner ( ) { List < Row > rows = Lists . newArrayList ( RowFactory . create ( " a " , 1 , false ) , RowFactory . create ( " b " , 2 , true ) ) ; StructType schema = new StructType ( new StructField [ ] { new StructField ( " field1 " , DataTypes . StringType , false , null ) , new StructField ( " field2 " , DataTypes . IntegerType , false , null ) , new StructField ( " field3 " , DataTypes . BooleanType , false , null ) } ) ; Dataset < Row > data = Contexts . getSparkSession ( ) . createDataFrame ( rows , schema ) ; BulkPlanner p = new DeletePlanner ( ) ; p . configure ( ConfigFactory . empty ( ) ) ; List < Tuple2 < MutationType , Dataset < Row > > > planned = p . planMutationsForSet ( data ) ; assertEquals ( 1 , planned . size ( ) ) ; assertEquals ( MutationType . DELETE , planned . get ( 0 ) . _1 ( ) ) ; assertEquals ( data , planned . get ( 0 ) . _2 ( ) ) ; }
public void run ( ) { while ( run ) { boolean allNull = true ; dirsIter : for ( Iterator < WatchedDir > it = watchedDirs . values ( ) . iterator ( ) ; it . hasNext ( ) & & run ; ) { WatchedDir watchedDir = it . next ( ) ; WatchKey key = watchedDir . watchService . poll ( ) ; if ( key = = null ) { continue ; } allNull = false ; for ( WatchEvent < ? > event : key . pollEvents ( ) ) { if ( ! run ) { break dirsIter ; } if ( event . kind ( ) ! = StandardWatchEventKinds . ENTRY_MODIFY ) { continue ; } Path childPath = ( ( WatchEvent < Path > ) event ) . context ( ) ; Path filePath = watchedDir . dir . resolve ( childPath ) ; WatchedFile watchedFile = watchedFiles . get ( filePath ) ; if ( watchedFile ! = null ) { watchedFile . changeHandler . run ( ) ; } } key . reset ( ) ; } if ( allNull ) { LockSupport . parkNanos ( SLEEP_TIME_NANOS ) ; } } for ( WatchedDir watchedDir : watchedDirs . values ( ) ) { try { watchedDir . watchService . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } watchedDirs . clear ( ) ; watchedFiles . clear ( ) ; }
private static boolean testArrayQueue ( ) { String aName = " Queue [array] " ; Queue . ArrayQueue < Integer > aQueue = new Queue . ArrayQueue < Integer > ( ) ; Collection < Integer > aCollection = aQueue . toCollection ( ) ; if ( ( validateStructure | | validateContents ) & & ! testQueue ( aQueue , aName ) ) return false ; if ( ! testJavaCollection ( aCollection , Type . Integer , aName ) ) return false ; return true ; }
private void heapDown ( Node < T > node ) { Node < T > left = node . left ; Node < T > right = node . right ; if ( left = = null & & right = = null ) { return ; } Node < T > nodeToMove = null ; int compare = ( type = = TYPE . MIN ) ? 1 : - 1 ; if ( left ! = null & & right ! = null & & node . value . compareTo ( left . value ) = = compare & & node . value . compareTo ( right . value ) = = compare ) { compare = ( type = = TYPE . MIN ) ? - 1 : 1 ; if ( right . value . compareTo ( left . value ) = = compare ) { nodeToMove = right ; } else if ( left . value . compareTo ( right . value ) = = compare ) { nodeToMove = left ; } else { nodeToMove = right ; } } else if ( right ! = null & & node . value . compareTo ( right . value ) = = compare ) { nodeToMove = right ; } else if ( left ! = null & & node . value . compareTo ( left . value ) = = compare ) { nodeToMove = left ; } else { nodeToMove = right ; } if ( nodeToMove = = null ) return ; Node < T > nodeParent = node . parent ; if ( nodeParent = = null ) { root = nodeToMove ; root . parent = null ; Node < T > nodeToMoveLeft = nodeToMove . left ; Node < T > nodeToMoveRight = nodeToMove . right ; if ( node . left . equals ( nodeToMove ) ) { nodeToMove . left = node ; nodeToMove . right = node . right ; } else { nodeToMove . left = node . left ; nodeToMove . right = node ; } node . parent = nodeToMove ; node . left = nodeToMoveLeft ; node . right = nodeToMoveRight ; } else { if ( nodeParent . left . equals ( node ) ) { nodeParent . left = nodeToMove ; nodeToMove . parent = nodeParent ; } else { nodeParent . right = nodeToMove ; nodeToMove . parent = nodeParent ; } Node < T > nodeLeft = node . left ; Node < T > nodeRight = node . right ; Node < T > nodeToMoveLeft = nodeToMove . left ; Node < T > nodeToMoveRight = nodeToMove . right ; if ( node . left . equals ( nodeToMove ) ) { nodeToMove . right = nodeRight ; if ( nodeRight ! = null ) nodeRight . parent = nodeToMove ; nodeToMove . left = node ; node . parent = nodeToMove ; } else { nodeToMove . left = nodeLeft ; if ( nodeLeft ! = null ) nodeLeft . parent = nodeToMove ; nodeToMove . right = node ; node . parent = nodeToMove ; } node . left = nodeToMoveLeft ; if ( nodeToMoveLeft ! = null ) nodeToMoveLeft . parent = node ; node . right = nodeToMoveRight ; if ( nodeToMoveRight ! = null ) nodeToMoveRight . parent = node ; } heapDown ( node ) ; }
public Future < String > set ( String key , int exp , Object o ) { return asyncStore ( StoreOperation . StoreType . set , key , exp , o ) ; }
public void run ( ) { try { final boolean isRandom = app . oMPDAsyncHelper . oMPD
void dragElems ( ) { if ( dragged & & selected ! = null ) {
public void configure ( Config config ) { String connectionString = config . getString ( ZooKeeperConnection . CONNECTION_CONFIG ) ; keyFieldNames = config . getStringList ( KEY_FIELD_NAMES_CONFIG ) ; schema = ComponentFactory . create ( Schema . class , config . getConfig ( SCHEMA_CONFIG ) , true ) . getSchema ( ) ; if ( config . hasPath ( ZNODE_PREFIX_CONFIG ) ) { znodePrefix = config . getString ( ZNODE_PREFIX_CONFIG ) ; } else { znodePrefix = DEFAULT_ZNODE_PREFIX ; } connection = new ZooKeeperConnection ( connectionString ) ; if ( config . hasPath ( SESSION_TIMEOUT_MS_CONFIG ) ) { connection . setSessionTimeoutMs ( config . getInt ( SESSION_TIMEOUT_MS_CONFIG ) ) ; } if ( config . hasPath ( CONNECTION_TIMEOUT_MS_CONFIG ) ) { connection . setConnectionTimeoutMs ( config . getInt ( CONNECTION_TIMEOUT_MS_CONFIG ) ) ;
public static void main ( String [ ] args ) { HashMap < String , Integer > map = new HashMap < > ( ) ; map . put ( " oxooo " + " \ n " + " xxooo " + " \ n " + " oxooo " + " \ n " + " oxooo " + " \ n " + " oxooo " + " \ n " , 1 ) ; map . put ( " oxxoo " + " \ n " + " xoxoo " + " \ n " + " ooxoo " + " \ n " + " ooxoo " + " \ n " + " ooxoo " + " \ n " , 1 ) ; map . put ( " oooxo " + " \ n " + " ooxxo " + " \ n " + " oooxo " + " \ n " + " oooxo " + " \ n " + " oooxo " + " \ n " , 1 ) ; map . put ( " oooox " + " \ n " + " oooxx " + " \ n " + " oooox " + " \ n " + " oooox " + " \ n " + " oooox " + " \ n " , 1 ) ; map . put ( " ooooo " + " \ n " + " xxxxx " + " \ n " + " xooox " + " \ n " + " xooox " + " \ n " + " xxxxx " + " \ n " , 0 ) ; map . put ( " xxxxx " + " \ n " + " xooox " + " \ n " + " xooox " + " \ n " + " xooox " + " \ n " + " xxxxx " + " \ n " , 0 ) ; map . put ( " ooooo " + " \ n " + " ooooo " + " \ n " + " xxxxx " + " \ n " + " xooox " + " \ n " + " xxxxx " + " \ n " , 0 ) ; map . put ( " ooooo " + " \ n " + " oxxxx " + " \ n " + " oxoox " + " \ n " + " oxoox " + " \ n " + " oxxxx " + " \ n " , 0 ) ; map . put ( " ooooo " + " \ n " + " xxxxx " + " \ n " + " xooox " + " \ n " + " xooox " + " \ n " + " xxxxx " + " \ n " , 0 ) ; NAR nar = new NAR ( ) ; NARSwing . themeInvert ( ) ; new NARSwing ( nar ) ; nar . param . noiseLevel . set ( 0 ) ; for ( String example : map . keySet ( ) ) { int solution = map . get ( example ) ; inputExample ( nar , example , solution ) ; nar . step ( 1000 ) ; } inputExample ( nar , " ooxoo " + " \ n " + " ooxoo " + " \ n " + " ooxoo " + " \ n " + " ooxoo " + " \ n " + " ooxoo " + " \ n " , - 1 ) ; try { nar . askNow ( " <?what --> EXAMPLE> " , new AnswerHandler ( ) { @Override public void onSolution ( Sentence belief ) { System . out . println ( belief ) ; } } ) ; } catch ( Narsese . InvalidInputException ex ) { } nar . step ( 100000 ) ; }
public Data copy ( ) { return new RangeMaximumData < N > ( maximum ) ; }
public void testBSF ( ) { final Integer [ ] inOrder = testBST . getBFS ( ) ; final Integer [ ] expectation = new Integer [ ] { 4 , 2 , 5 , 1 , 3 } ; for ( int i = 0 ; i < inOrder . length ; i + + ) { Assert . assertTrue ( inOrder [ i ] = = expectation [ i ] ) ;
public void handle ( @Nonnull final String sAction , @Nonnull final IMessage aMsg , @Nullable final Map < String , Object > aOptions ) throws OpenAS2Exception { String sResendAction = ( String ) aOptions . get ( IProcessorResenderModule . OPTION_RESEND_ACTION ) ; if ( sResendAction = = null ) { s_aLogger . warn ( " The resending action is missing - default to message sending! " ) ; sResendAction = IProcessorSenderModule . DO_SEND ; } final String sRetries = ( String ) aOptions . get ( IProcessorResenderModule . OPTION_RETRIES ) ; int nRetries ; if ( sRetries ! = null ) nRetries = Integer . parseInt ( sRetries ) ; else { s_aLogger . warn ( " The resending retry count is missing - default to  " + IProcessorResenderModule . DEFAULT_RETRIES + " ! " ) ; nRetries = IProcessorResenderModule . DEFAULT_RETRIES ; } final ResendItem aItem = new ResendItem ( sResendAction , nRetries , aMsg , getResendDelayMS ( ) ) ; m_aRWLock . writeLocked ( ( ) - > m_aItems . add ( aItem ) ) ; s_aLogger . info ( " Message put in resend queue " + aMsg . getLoggingText ( ) ) ; }
static Config of ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format ) ; }
public void update ( Effect nextEffect ) { if ( active ) { nar . stop ( ) ; executed = false ; if ( path = = null | | path . size ( ) < = 0 & & ! executed_going ) { for ( int i = 0 ; i < 5 ; i + + ) { nar . step ( 1 ) ; if ( executed ) { break ; } } } if ( needpizza ) { hungry - - ; if ( hungry < 0 ) { hungry = 100 ; for ( GridObject obj : space . objects ) { if ( obj instanceof Pizza ) { nar . addInput ( " < " + ( ( Pizza ) obj ) . doorname + " --> at>! " ) ; } } } } } if ( ! target . equals ( lasttarget ) | | target . equals ( lasttarget ) & & ( " pick " . equals ( opname ) | | " activate " . equals ( opname ) | | " deactivate " . equals ( opname ) ) ) { getfeedback = true ; } lasttarget = target ; PVector current = new PVector ( x , y ) ; if ( nextEffect = = null ) { path = Grid2DSpace . Shortest_Path ( space , this , current , target ) ;
public String toString ( ) { return " Result[isSuccessful= " + isSuccessful ( ) + " , errorCode= " + errorCode + " , httpErrorCode= " + httpErrorCode + " , errorMessage= " + errorMessage + " , status= " + status + " ] " ;
protected Node addSequence ( C seq ) { if ( root = = null ) { if ( this . creator = = null ) root = createNewNode ( null , null , BLACK ) ; else root = this . creator . createNewNode ( null , null , BLACK ) ; } int indexIntoParent = - 1 ; int indexIntoString = - 1 ; Node node = root ; for ( int i = 0 ; i < = seq . length ( ) ; ) { indexIntoString = i ; indexIntoParent + + ; if ( i = = seq . length ( ) ) break ; char c = seq . charAt ( i ) ; if ( node . partOfThis ( c , indexIntoParent ) ) { i + + ; continue ; } else if ( node . string ! = null & & indexIntoParent < node . string . length ) { break ; } Node child = node . getChildBeginningWithChar ( c ) ; if ( child ! = null ) { indexIntoParent = 0 ; node = child ; i + + ; } else { break ; } } Node addedNode = null ; if ( node . string ! = null & & indexIntoParent < node . string . length ) { char [ ] parentString = Arrays . copyOfRange ( node . string , 0 , indexIntoParent ) ; char [ ] refactorString = Arrays . copyOfRange ( node . string , indexIntoParent , node . string . length ) ; Node parent = node . parent ; if ( indexIntoString < seq . length ( ) ) { if ( parent ! = null ) parent . removeChild ( node ) ; Node newParent = null ; if ( this . creator = = null ) newParent = createNewNode ( parent , parentString , BLACK ) ; else newParent = this . creator . createNewNode ( parent , parentString , BLACK ) ; if ( parent ! = null ) parent . addChild ( newParent ) ; Node newNode1 = node ; newNode1 . parent = newParent ; newNode1 . string = refactorString ; newParent . addChild ( newNode1 ) ; CharSequence newString = seq . subSequence ( indexIntoString , seq . length ( ) ) ; Node newNode2 = null ; if ( this . creator = = null ) newNode2 = createNewNode ( newParent , newString . toString ( ) . toCharArray ( ) , WHITE ) ; else newNode2 = this . creator . createNewNode ( newParent , newString . toString ( ) . toCharArray ( ) , WHITE ) ; newParent . addChild ( newNode2 ) ; addedNode = newNode2 ; } else { if ( parent ! = null ) parent . removeChild ( node ) ; Node newParent = null ; if ( this . creator = = null ) newParent = createNewNode ( parent , parentString , WHITE ) ; else newParent = this . creator . createNewNode ( parent , parentString , WHITE ) ; if ( parent ! = null ) parent . addChild ( newParent ) ; addedNode = newParent ; Node newNode1 = node ; newNode1 . parent = newParent ; newNode1 . string = refactorString ; newParent . addChild ( newNode1 ) ; } } else if ( node . string ! = null & & seq . length ( ) = = indexIntoString ) { if ( node . type = = WHITE ) return null ; node . type = WHITE ; addedNode = node ; } else if ( node . string ! = null ) { CharSequence newString = seq . subSequence ( indexIntoString , seq . length ( ) ) ; Node newNode = null ; if ( this . creator = = null ) newNode = createNewNode ( node , newString . toString ( ) . toCharArray ( ) , WHITE ) ; else newNode = this . creator . createNewNode ( node , newString . toString ( ) . toCharArray ( ) , WHITE ) ; node . addChild ( newNode ) ; addedNode = newNode ; } else { Node newNode = null ; if ( this . creator = = null ) newNode = createNewNode ( node , seq . toString ( ) . toCharArray ( ) , WHITE ) ; else newNode = this . creator . createNewNode ( node , seq . toString ( ) . toCharArray ( ) , WHITE ) ; node . addChild ( newNode ) ; addedNode = newNode ; } size + + ; return addedNode ; }
@Override public String toString ( ) { return super . toString ( ) + " { " + items . getClass ( ) . getSimpleName ( ) + " } " ; }
long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }
public void connectionLost ( SocketAddress sa ) { } public void connectionEstablished ( SocketAddress sa , int reconnectCount ) { } } ; BlockingQueue < Operation > oQueue = new LinkedBlockingQueue < Operation > ( ) ; BlockingQueue < Operation > rQueue = new LinkedBlockingQueue < Operation > ( ) ; BlockingQueue < Operation > wQueue = new LinkedBlockingQueue < Operation > ( ) ; OperationQueueFactory opQueueFactory = new DirectFactory ( oQueue ) ; OperationQueueFactory rQueueFactory = new DirectFactory ( rQueue ) ; OperationQueueFactory wQueueFactory = new DirectFactory ( wQueue ) ; ConnectionFactory f = b . setDaemon ( true ) . setShouldOptimize ( false ) . setFailureMode ( FailureMode . Redistribute ) . setHashAlg ( HashAlgorithm . KETAMA_HASH ) . setInitialObservers ( Collections . singleton ( testObserver ) ) . setOpFact ( new BinaryOperationFactory ( ) ) . setOpTimeout ( 4225 ) . setOpQueueFactory ( opQueueFactory ) . setReadOpQueueFactory ( rQueueFactory ) . setWriteOpQueueFactory ( wQueueFactory ) . setReadBufferSize ( 19 ) . setTranscoder ( new WhalinTranscoder ( ) ) . setUseNagleAlgorithm ( true ) . setLocatorType ( Locator . CONSISTENT ) . setOpQueueMaxBlockTime ( 19 ) . build ( ) ; assertEquals ( 4225 , f . getOperationTimeout ( ) ) ; assertEquals ( 19 , f . getReadBufSize ( ) ) ; assertSame ( HashAlgorithm . KETAMA_HASH , f . getHashAlg ( ) ) ; assertTrue ( f . getDefaultTranscoder ( ) instanceof WhalinTranscoder ) ; assertSame ( FailureMode . Redistribute , f . getFailureMode ( ) ) ; assertEquals ( 1 , f . getInitialObservers ( ) . size ( ) ) ; assertSame ( testObserver , f . getInitialObservers ( ) . iterator ( ) . next ( ) ) ; assertTrue ( f . getOperationFactory ( ) instanceof BinaryOperationFactory ) ; assertSame ( oQueue , f . createOperationQueue ( ) ) ; assertSame ( rQueue , f . createReadOperationQueue ( ) ) ; assertSame ( wQueue , f . createWriteOperationQueue ( ) ) ; assertTrue ( f . isDaemon ( ) ) ; assertFalse ( f . shouldOptimize ( ) ) ; assertTrue ( f . useNagleAlgorithm ( ) ) ; assertEquals ( f . getOpQueueMaxBlockTime ( ) , 19 ) ; MemcachedNode n = new MockMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) ) ; assertTrue ( f . createLocator ( Collections . singletonList ( n ) ) instanceof KetamaNodeLocator ) ; SocketChannel sc = SocketChannel . open ( ) ; try { assertTrue ( f . createMemcachedNode ( InetSocketAddress . createUnresolved ( " localhost " , 11211 ) , sc , 1 ) instanceof BinaryMemcachedNodeImpl ) ; } finally { sc . close ( ) ; } } public void testProtocolSetterBinary ( ) { assertTrue ( b . setProtocol ( Protocol . BINARY ) . build ( ) . getOperationFactory ( ) instanceof BinaryOperationFactory ) ; } public void testProtocolSetterText ( ) { assertTrue ( b . setProtocol ( Protocol . TEXT ) . build ( ) . getOperationFactory ( ) instanceof AsciiOperationFactory ) ; } static class DirectFactory implements OperationQueueFactory { private final BlockingQueue < Operation > queue ; public DirectFactory ( BlockingQueue < Operation > q ) { super ( ) ; queue = q ; } public BlockingQueue < Operation > create ( ) { return queue ; } } }
public void readFrom ( File file , boolean merge ) throws IOException { if ( ! merge ) asMap ( ) . clear ( ) ; new HoconParser ( ) . parseConfig ( file , this ) ; }
public abstract String getParameter ( @Nonnull String sKey ) throws InvalidParameterException ; public void setParameters ( @Nonnull final String sEncodedParams ) throws InvalidParameterException { final StringTokenizer aParams = new StringTokenizer ( sEncodedParams , " =, " , false ) ; while ( aParams . hasMoreTokens ( ) ) { final String sKey = aParams . nextToken ( ) . trim ( ) ; if ( ! aParams . hasMoreTokens ( ) ) throw new InvalidParameterException ( " Invalid value " , this , sKey , null ) ; final String sValue = aParams . nextToken ( ) ; setParameter ( sKey , sValue ) ; } } public void setParameters ( @Nullable final String sFormat , @Nullable final String sDelimiters , @Nonnull final String sValue ) throws AS2Exception { final ICommonsList < String > aKeys = StringHelper . getExploded ( ',' , sFormat ) ; final StringTokenizer aValueTokens = new StringTokenizer ( sValue , sDelimiters , false ) ; for ( final String sKey : aKeys ) { if ( ! aValueTokens . hasMoreTokens ( ) ) throw new AS2Exception ( " Invalid value: Format= " + sFormat + " , value= " + sValue ) ; if ( sKey . length ( ) > 0 ) setParameter ( sKey , aValueTokens . nextToken ( ) ) ; } } @Nonnull public String format ( @Nullable final String sFormat ) throws InvalidParameterException { if ( LOGGER . isTraceEnabled ( ) ) LOGGER . trace ( " Formatting ' " + sFormat + " ' " ) ; final StringBuilder aSB = new StringBuilder ( ) ; if ( sFormat ! = null ) for ( int nNext = 0 ; nNext < sFormat . length ( ) ; + + nNext ) { int nPrev = nNext ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) { aSB . append ( sFormat . substring ( nPrev , sFormat . length ( ) ) ) ; break ; } if ( nNext > nPrev ) { aSB . append ( sFormat . substring ( nPrev , nNext ) ) ; } nPrev = nNext + 1 ; nNext = sFormat . indexOf ( '$' , nPrev ) ; if ( nNext = = - 1 ) throw new InvalidParameterException ( " Invalid key (missing closing $) " ) ; if ( nNext = = nPrev ) aSB . append ( '$' ) ; else { final String sParameterName = sFormat . substring ( nPrev , nNext ) ; aSB . append ( getParameter ( sParameterName ) ) ; } } if ( LOGGER . isTraceEnabled ( ) ) LOGGER . trace ( " Formatted value is now ' " + aSB . toString ( ) + " ' " ) ; return aSB . toString ( ) ; } @Override public String toString ( ) { return new ToStringGenerator ( this ) . getToString ( ) ; } }
protected void updateHttpHeaders ( @Nonnull final IAS2HttpHeaderWrapper aConn , @Nonnull final IMessage aMsg ) { final Partnership aPartnership = aMsg . getPartnership ( ) ; aConn . setHttpHeader ( CAS2Header . HEADER_CONNECTION , CAS2Header . DEFAULT_CONNECTION ) ; aConn . setHttpHeader ( CAS2Header . HEADER_USER_AGENT , CAS2Header . DEFAULT_USER_AGENT ) ; aConn . setHttpHeader ( CAS2Header . HEADER_DATE , DateHelper . getFormattedDateNow ( CAS2Header . DEFAULT_DATE_FORMAT ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_MESSAGE_ID , aMsg . getMessageID ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_MIME_VERSION , CAS2Header . DEFAULT_MIME_VERSION ) ; aConn . setHttpHeader ( CAS2Header . HEADER_CONTENT_TYPE , aMsg . getContentType ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_AS2_VERSION , CAS2Header . DEFAULT_AS2_VERSION ) ; aConn . setHttpHeader ( CAS2Header . HEADER_RECIPIENT_ADDRESS , aPartnership . getAS2URL ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_AS2_FROM , aPartnership . getSenderAS2ID ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_AS2_TO , aPartnership . getReceiverAS2ID ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_SUBJECT , aMsg . getSubject ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_FROM , aPartnership . getSenderEmail ( ) ) ; aConn . setHttpHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING , aMsg . getHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING ) ) ; final String sDispTo = aPartnership . getAS2MDNTo ( ) ; if ( sDispTo ! = null ) aConn . setHttpHeader ( CAS2Header . HEADER_DISPOSITION_NOTIFICATION_TO , sDispTo ) ; final String sDispositionOptions = aPartnership . getAS2MDNOptions ( ) ; if ( sDispositionOptions ! = null ) aConn . setHttpHeader ( CAS2Header . HEADER_DISPOSITION_NOTIFICATION_OPTIONS , sDispositionOptions ) ; final String sReceiptOption = aPartnership . getAS2ReceiptOption ( ) ; if ( sReceiptOption ! = null ) aConn . setHttpHeader ( CAS2Header . HEADER_RECEIPT_DELIVERY_OPTION , sReceiptOption ) ; final String sContententDisposition = aMsg . getContentDisposition ( ) ; if ( sContententDisposition ! = null ) aConn . setHttpHeader ( CAS2Header . HEADER_CONTENT_DISPOSITION , sContententDisposition ) ;
BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) ; long decr ( String key , int by ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; }
protected void initCertificateFactory ( @Nonnull final AS2ClientSettings aSettings , @Nonnull final AS2Session aSession ) throws AS2Exception { final StringMap aParams = new StringMap ( ) ; aParams . putIn ( AbstractCertificateFactory . ATTR_TYPE , aSettings . getKeyStoreType ( ) . getID ( ) ) ; final CertificateFactory aCertFactory = createCertificateFactory ( ) ; aCertFactory . initDynamicComponent ( aSession , aParams ) ; if ( aSettings . getKeyStoreFile ( ) ! = null ) { if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " Loading AS2 client keystore from file  " + aSettings . getKeyStoreFile ( ) ) ; aCertFactory . setFilename ( aSettings . getKeyStoreFile ( ) . getAbsolutePath ( ) ) ; aCertFactory . setPassword ( aSettings . getKeyStorePassword ( ) ) ; aCertFactory . setSaveChangesToFile ( aSettings . isSaveKeyStoreChangesToFile ( ) ) ; aCertFactory . load ( ) ; } else if ( aSettings . getKeyStoreBytes ( ) ! = null & & aSettings . getKeyStorePassword ( ) ! = null ) { if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " Loading AS2 client keystore from byte array. No changes will be saved. " ) ; aCertFactory . setPassword ( aSettings . getKeyStorePassword ( ) ) ; aCertFactory . setSaveChangesToFile ( false ) ; try ( final NonBlockingByteArrayInputStream aBAIS = new NonBlockingByteArrayInputStream ( aSettings . getKeyStoreBytes ( ) ) ) { aCertFactory . load ( aBAIS , aSettings . getKeyStorePassword ( ) . toCharArray ( ) ) ; } } else { if ( LOGGER . isInfoEnabled ( ) ) LOGGER . warn ( " No AS2 client keystore data was provided. Signing and encryption/decryption will most likely fail. " ) ; aCertFactory . setSaveChangesToFile ( false ) ; } if ( aSettings . getReceiverCertificate ( ) ! = null ) { try { aCertFactory . addCertificate ( aSettings . getReceiverKeyAlias ( ) , aSettings . getReceiverCertificate ( ) , false ) ; } catch ( final AS2CertificateExistsException ex ) { } } aSession . setCertificateFactory ( aCertFactory ) ; }
public void wrongConfigUnknownColumnIncludeFields ( ) throws Exception { List < String > includeFields = Arrays . asList ( " sourceid " , " sourcename " , " sourcestatus " , " TestField " ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; Dataset < Row > inputdataframe = testDataframe ( ) ; dependencies . put ( " dataSource1 " , inputdataframe ) ; Config config = ConfigFactory . empty ( ) . withValue ( SelectDeriver . INCLUDE_FIELDS , ConfigValueFactory . fromAnyRef ( includeFields ) ) . withValue ( SelectDeriver . STEP_NAME_CONFIG , ConfigValueFactory . fromAnyRef ( " dataSource1 " ) ) ; SelectDeriver selectderiver = new SelectDeriver ( ) ; selectderiver . configure ( config ) ; selectderiver . derive ( dependencies ) ; }
public int size ( ) { int is = sizeItems ( ) ; int in = nameTable . size ( ) ; if ( is ! = in ) { System . err . println ( this . getClass ( ) + "  inconsistent index: items= " + is + "  names= " + in + " , capacity= " + getCapacity ( ) ) ; new Exception ( ) . printStackTrace ( ) ; ; } return nameTable . size ( ) ; }
private List < Music > genericSearch ( String searchCommand , String type , String strToFind ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; List < String > response = mpdConnection . sendCommand ( searchCommand , type , strToFind ) ; return Music . getMusicFromList ( response , true ) ; }
Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }
public boolean addAll ( int location , final Collection < ? extends T > collection ) { boolean result = false ; if ( ! collection . isEmpty ( ) ) { synchronized ( mLOCK ) { cleanPhantomReferences ( ) ; for ( final T element : collection ) { add ( location + + , element ) ; } result = true ; } } return result ; }
public void configure ( Config config ) { LOG . debug ( " Configuring Morphline Translator " ) ; this . keyEncoding = config . getString ( ENCODING_KEY ) ; this . messageEncoding = config . getString ( ENCODING_MSG ) ; this . morphlineFile = config . getString ( MORPHLINE ) ; this . morphlineId = config . getString ( MORPHLINE_ID ) ; List < String > fieldNames = config . getStringList ( FIELD_NAMES ) ; List < String > fieldTypes = config . getStringList ( FIELD_TYPES ) ; this . doesAppendRaw = TranslatorUtils . doesAppendRaw ( config ) ; if ( this . doesAppendRaw ) { fieldNames . add ( TranslatorUtils . getAppendRawKeyFieldName ( config ) ) ; fieldTypes . add ( " binary " ) ; fieldNames . add ( TranslatorUtils . getAppendRawValueFieldName ( config ) ) ; fieldTypes . add ( " binary " ) ; } this . schema = RowUtils . structTypeFor ( fieldNames , fieldTypes ) ; }
public boolean waitForQueues ( long timeout , TimeUnit unit ) { CountDownLatch blatch = broadcastOp ( new BroadcastOpFactory ( ) { @Override public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { return opFact . noop ( new OperationCallback ( ) { @Override public void complete ( ) { latch . countDown ( ) ; } @Override public void receivedStatus ( OperationStatus s ) { } } ) ; } } , mconn . getLocator ( ) . getAll ( ) , false ) ; try {
public void testDeletes ( ) throws Exception { truncate ( ) ; ZooKeeperOutput zkOutput = new ZooKeeperOutput ( ) ; assertNoValidationFailures ( zkOutput , config ) ; zkOutput . configure ( config ) ; Row row1 = new RowWithSchema ( schema , " hello " , 100 , 1000L , true , 1.0f , - 1.0 ) ; Row row2 = new RowWithSchema ( schema , " world " , - 100 , - 1000L , false , - 1.0f , 1.0 ) ; List < Row > upsertPlan = Lists . newArrayList ( PlannerUtils . setMutationType ( row1 , MutationType . UPSERT ) , PlannerUtils . setMutationType ( row2 , MutationType . UPSERT ) ) ; zkOutput . applyRandomMutations ( upsertPlan ) ; Row delete = new RowWithSchema ( keySchema , " hello " , 100 , 1000L ) ; List < Row > deletePlan = Lists . newArrayList ( PlannerUtils . setMutationType ( delete , MutationType . DELETE ) ) ; zkOutput . applyRandomMutations ( deletePlan ) ; Row filter1 = new RowWithSchema ( keySchema , " hello " , 100 , 1000L ) ; Row filter2 = new RowWithSchema ( keySchema , " world " , - 100 , - 1000L ) ; List < Row > filters = Lists . newArrayList ( filter1 , filter2 ) ; List < Row > rows = Lists . newArrayList ( zkOutput . getExistingForFilters ( filters ) ) ; assertEquals ( rows . size ( ) , 1 ) ; assertEquals ( rows . get ( 0 ) , row2 ) ; }
public boolean remove ( int value ) { Node prev = null ; Node node = head ; while ( node ! = null & & ( node . value ! = value ) ) { prev = node ; node = node . nextNode ; } if ( node = = null ) return false ; Node next = node . nextNode ; if ( prev ! = null & & next ! = null ) { prev . nextNode = next ; } else if ( prev ! = null & & next = = null ) { prev . nextNode = null ; } else if ( prev = = null & & next ! = null ) { head = next ; } else { head = null ; } int prevIndex = prev . index ; node = prev ; while ( node ! = null ) { node = node . nextNode ; if ( node ! = null ) node . index = + + prevIndex ; } size - - ; generateExpressLanes ( ) ; return true ; }
Map < String , Object > valueMap ( ) ; @Override Set < ? extends Entry > entrySet ( ) ; interface Entry extends UnmodifiableConfig . Entry { < T > T setValue ( Object value ) ; } Config createSubConfig ( ) ; static Config of ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format ) ; } static Config inMemory ( ) { return new SimpleConfig ( InMemoryFormat . defaultInstance ( ) ) ; } static Config wrap ( Map < String , Object > map , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( map , format ) ; } static Config copy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) ) ; } static Config copy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( config , format ) ; } }
abstract public E pickOut ( final CharSequence key ) ; public void printAll ( ) { for ( CharSequence k : keySet ( ) ) { E v = get ( k ) ; System . out . println ( "    " + k + "   " + v + "  ( " + v . getClass ( ) . getSimpleName ( ) + " ) " ) ; } } protected float forgetCycles ( ) { return forgettingRate . getCycles ( ) ; } public void forget ( final E x ) { float forgetCycles = forgetCycles ( ) ; if ( forgetCycles > 0 ) { BudgetFunctions . forget ( x . budget , forgetCycles , RELATIVE_THRESHOLD ) ; } } public final boolean putBack ( final E oldItem ) { forget ( oldItem ) ; return putIn ( oldItem ) ; } synchronized public E processNext ( boolean forget ) { final E x = takeOut ( ) ; if ( x ! = null ) { if ( forget ) { forget ( x ) ; } boolean r = putIn ( x ) ; if ( ! r ) { throw new RuntimeException ( " Bag.processNext " ) ; } return x ; } else { return null ; } } abstract public Collection < E > values ( ) ; abstract public float getAveragePriority ( ) ; @Override public abstract Iterator < E > iterator ( ) ; }
public List < String > listAlbumArtists ( final Genre genre ) throws IOException , MPDException { return listAlbumArtists ( genre , true ) ; }
MemcachedConnection createConnection ( List < InetSocketAddress > addrs ) throws IOException ; MemcachedNode createMemcachedNode ( SocketAddress sa , SocketChannel c , int bufSize ) ; BlockingQueue < Operation > createOperationQueue ( ) ; BlockingQueue < Operation > createReadOperationQueue ( ) ; BlockingQueue < Operation > createWriteOperationQueue ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; boolean isDaemon ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; }
public Builder append ( String str , int begin , int end ) { write ( str , begin , end ) ; return this ; }
protected HeaderTransformer createDefaultHeaderTransformer ( ) { return new DefaultHeaderTransformer ( ) ; }
boolean hasMetaData ( ) ; MetaData getMetaData ( ) ; public double d ( String fieldName ) ; public long i ( String fieldName ) ; default public double sum ( ) { return d ( " sum " ) ; } default public double max ( ) { return d ( " max " ) ; } default public double min ( ) { return d ( " min " ) ; } default public long hits ( ) { return i ( " hits " ) ; } default public double median ( ) { return ( max ( ) + min ( ) ) / 2.0 ; } default public double mean ( ) { long h = hits ( ) ; if ( h = = 0 ) return 0 ; return ( sum ( ) / h ) ; } }
Path getNioPath ( ) ; void save ( ) ; void load ( ) ; @Override void close ( ) ; @Override default FileConfig checked ( ) { return new CheckedFileConfig ( this ) ; } static FileConfig of ( File file ) { return of ( file . toPath ( ) ) ; } static FileConfig of ( File file , ConfigFormat < ? extends Config > format ) { return of ( file . toPath ( ) , format ) ; } static FileConfig of ( Path file ) { ConfigFormat format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return of ( file , format ) ; } static FileConfig of ( Path file , ConfigFormat < ? extends Config > format ) { return builder ( file , format ) . build ( ) ; } static FileConfig of ( String filePath ) { return of ( Paths . get ( filePath ) ) ; } static FileConfig of ( String filePath , ConfigFormat < ? > format ) { return of ( Paths . get ( filePath ) , format ) ; } static FileConfig ofConcurrent ( File file ) { return ofConcurrent ( file . toPath ( ) ) ; } static FileConfig ofConcurrent ( File file , ConfigFormat < ? > format ) { return ofConcurrent ( file . toPath ( ) , format ) ; } static FileConfig ofConcurrent ( Path file ) { return builder ( file ) . concurrent ( ) . build ( ) ; } static FileConfig ofConcurrent ( Path file , ConfigFormat < ? > format ) { return builder ( file , format ) . concurrent ( ) . build ( ) ; } static FileConfig ofConcurrent ( String filePath ) { return ofConcurrent ( Paths . get ( filePath ) ) ; } static FileConfig ofConcurrent ( String filePath , ConfigFormat < ? > format ) { return ofConcurrent ( Paths . get ( filePath ) , format ) ; } static FileConfigBuilder builder ( File file ) { return builder ( file . toPath ( ) ) ; } static FileConfigBuilder builder ( File file , ConfigFormat < ? > format ) { return builder ( file . toPath ( ) , format ) ; } static FileConfigBuilder builder ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return builder ( file , format ) ; } static FileConfigBuilder builder ( Path file , ConfigFormat < ? > format ) { return new FileConfigBuilder ( file , format ) ; } static FileConfigBuilder builder ( String filePath ) { return builder ( Paths . get ( filePath ) ) ; } static FileConfigBuilder builder ( String filePath , ConfigFormat < ? > format ) { return builder ( Paths . get ( filePath ) , format ) ; } }
public void configure ( Config config ) { schema = SchemaFactory . create ( config . getConfig ( SCHEMA_CONFIG ) , true ) . getSchema ( ) ; encoder = RowEncoder . apply ( schema ) . resolveAndBind ( ( Seq ) schema . toAttributes ( ) , SimpleAnalyzer$ . MODULE$ ) ; converter = new JsonToStruct ( schema , new scala . collection . immutable . HashMap < String , String > ( ) , null ) ; }
long resolveTerm ( long count ) { Term tt = getTerm ( ) ; if ( tt ! = this ) { return tt . resolveTerm ( count ) ;
public String toString ( ) { StringBuilder text = new StringBuilder ( ) ; for ( int i = 0 ; i < numInstances ( ) ; i + + ) { text . append ( instance ( i ) . toString ( ) ) ; if ( i < numInstances ( ) - 1 ) { text . append ( '\n' ) ; } } return text . toString ( ) ; }
private String _getDispositionText ( @Nonnull final AS2Exception ex ) { if ( m_bSendExceptionsInMDN ) { final String sExceptionText ; if ( m_bSendExceptionStackTraceInMDN ) { sExceptionText = StackTraceHelper . getStackAsString ( ex , true , CHttp . EOL ) ; } else { if ( ex instanceof AS2ProcessorException ) sExceptionText = ( ( AS2ProcessorException ) ex ) . getShortToString ( ) ; else sExceptionText = ex . toString ( ) ; } return CHttp . EOL + MessageParameters . getEscapedString ( sExceptionText ) ; } return " " ; }
public void run ( ) { mBackPressExitCount = 0 ; }
private E takeOutFirst ( final int level ) { final E selected = itemTable [ level ] . removeFirst ( ) ; removeMass ( selected ) ; return selected ; }
public Operation tapBackfill ( final String id , final long date , final int runTime , final TimeUnit timeunit ) throws IOException , ConfigurationException { final TapConnectionProvider conn ; if ( vBucketAware ) { conn = new TapConnectionProvider ( baseList , bucketName , usr , pwd ) ; } else { conn = new TapConnectionProvider ( addrs ) ; } final CountDownLatch latch = new CountDownLatch ( 1 ) ; final Operation op = conn . getOpFactory ( ) . tapBackfill ( id , date , new TapOperation . Callback ( ) { public void receivedStatus ( OperationStatus status ) { } public void gotData ( ResponseMessage tapMessage ) { rqueue . add ( tapMessage ) ; messagesRead + + ; } public void gotAck ( TapOpcode opcode , int opaque ) { rqueue . add ( new TapAck ( conn , opcode , opaque , this ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ) ; synchronized ( omap ) { omap . put ( op , conn ) ; } conn . addOp ( op ) ; if ( runTime > 0 ) { Runnable r = new Runnable ( ) { @Override public void run ( ) { try { Thread . sleep ( TimeUnit . MILLISECONDS . convert ( runTime , timeunit ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } conn . shutdown ( ) ; synchronized ( omap ) { omap . remove ( op ) ; } } } ; new Thread ( r ) . start ( ) ; } return op ; }
public void getSchemaInvalidDataType ( final @Mocked Config config ) throws Exception { new Expectations ( ) { { config . getString ( MorphlineTranslator . MORPHLINE ) ; result = getResourcePath ( MORPHLINE_FILE ) ; config . getStringList ( MorphlineTranslator . FIELD_NAMES ) ; result = Lists . newArrayList ( " bar " , " foo " ) ; config . getStringList ( MorphlineTranslator . FIELD_TYPES ) ; result = Lists . newArrayList ( " int " , " boom " ) ; } } ; Deriver deriver = new MorphlineDeriver ( ) ; deriver . configure ( config ) ; }
public abstract void show ( ) ; public abstract void play ( ) ; public abstract void stop ( ) ; public abstract void append ( String s ) ; public abstract void openLogFile ( ) ; public abstract void closeLogFile ( ) ; public abstract boolean isLogging ( ) ; }
private static int [ ] add ( int integer , int [ ] bucket ) { int size = bucket [ 0 ] ; int length = bucket . length ; int [ ] result = bucket ; if ( size > = length ) { result = Arrays . copyOf ( result , ( ( length * 3 ) / 2 ) + 1 ) ; } result [ size ] = integer ; result [ 0 ] = + + size ; return result ; }
public void testCompressedObject ( ) throws Exception { tc . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = tc . encode ( c ) ; assertEquals ( SerializingTranscoder . SERIALIZED | SerializingTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , tc . decode ( cd ) ) ; }
public static void error ( final String tag , final String message , final Throwable tr ) { android . util . Log . e ( tag , message , tr ) ; }
public void takeoverVbuckets ( int [ ] vbucketlist ) { message . setVbucketlist ( vbucketlist ) ; message . setFlags ( TapFlag . TAKEOVER_VBUCKETS ) ; }
public boolean isIconfiedByDefault ( ) { return mIconifiedByDefault ; }
public static boolean fireConcept ( final DerivationContext nal , final int numTaskLinks ) { for ( int i = 0 ; i < numTaskLinks ; i + + ) { if ( nal . currentConcept . taskLinks . size ( ) = = 0 ) { return false ; } nal . currentTaskLink = nal . currentConcept . taskLinks . takeNext ( ) ; if ( nal . currentTaskLink = = null ) { return false ; } if ( nal . currentTaskLink . budget . aboveThreshold ( ) ) { fireTaskLink ( nal , nal . memory . narParameters . TERMLINK_MAX_REASONED ) ; } nal . currentConcept . taskLinks . putBack ( nal . currentTaskLink , nal . memory . cycles ( nal . memory . param . taskLinkForgetDurations ) , nal . memory ) ; } return true ; }
private void readObject ( final java . io . ObjectInputStream in ) throws IOException , ClassNotFoundException { m_aPartnership = ( Partnership ) in . readObject ( ) ; m_aAttributes = ( Map < String , String > ) in . readObject ( ) ; m_aHistory = ( DataHistory ) in . readObject ( ) ; try { m_aHeaders = new InternetHeaders ( in ) ; if ( in . read ( ) = = 1 ) { m_aData = new MimeBodyPart ( in ) ; } } catch ( final MessagingException me ) { throw new IOException ( " Messaging exception:  " + me . getMessage ( ) ) ; } m_aMDN = ( IMessageMDN ) in . readObject ( ) ; if ( m_aMDN ! = null ) {
public void testGearBagDistribution ( ) { GearBag g = new GearBag ( 100 , 1000 ) ; int [ ] r ; r = CurveBagTest . testRemovalPriorityDistribution ( 2 , 500 , 0.8f , 0.6f , g ) ; / * System . out . println ( Arrays . toString ( r ) ) ;
private void applyAttributes ( ) { if ( plainText . length ( ) > 0 ) { for ( AttributeRun bsar : baseStyle ) styledText . addAttribute ( bsar . atype , bsar . value ) ; Iterator < AttributeRun > iter = atrun . iterator ( ) ; AttributeRun ar ; while ( iter . hasNext ( ) ) { ar = iter . next ( ) ; if ( ar . end = = Integer . MAX_VALUE ) styledText . addAttribute ( ar . atype , ar . value ) ; else { try { styledText . addAttribute ( ar . atype , ar . value , ar . start , ar . end ) ; } catch ( Exception excp ) { System . out . println ( " Dumping  " + ar ) ; excp . printStackTrace ( ) ; iter . remove ( ) ; } } } } invalidLayout = true ; }
void init ( ) { if ( mEvaluator = = null ) { mEvaluator = ( mValueType = = Integer . class ) ? sIntEvaluator : ( mValueType = = Float . class ) ? sFloatEvaluator : null ; } if ( mEvaluator ! = null ) {
public static final int levenshteinDistanceRecursive ( String s , String t ) { final int sLength = s . length ( ) ; final int tLength = t . length ( ) ; final char [ ] sChars = s . toCharArray ( ) ; final char [ ] tChars = t . toCharArray ( ) ; int cost = 0 ; if ( ( sLength > 0 & & tLength > 0 ) & & sChars [ 0 ] ! = tChars [ 0 ] ) cost = 1 ; if ( sLength = = 0 ) return tLength ;
public static void parseMDN ( @Nonnull final IMessage aMsg , @Nullable final X509Certificate aReceiverCert , final boolean bUseCertificateInBodyPart , @Nullable final Consumer < ? super X509Certificate > aEffectiveCertificateConsumer , @Nonnull final AS2ResourceHelper aResHelper ) throws Exception { final String sLoggingText = aMsg . getLoggingText ( ) ; LOGGER . info ( " Start parsing MDN of " + sLoggingText ) ; final IMessageMDN aMDN = aMsg . getMDN ( ) ; MimeBodyPart aMainPart = aMDN . getData ( ) ; final ICryptoHelper aCryptoHelper = getCryptoHelper ( ) ; final boolean bDisableVerify = aMsg . partnership ( ) . isDisableVerify ( ) ; final boolean bMsgIsSigned = aCryptoHelper . isSigned ( aMainPart ) ; final boolean bForceVerify = aMsg . partnership ( ) . isForceVerify ( ) ; if ( bMsgIsSigned & & bDisableVerify ) { LOGGER . info ( " Message claims to be signed but signature validation is disabled " + sLoggingText ) ; } else if ( bMsgIsSigned | | bForceVerify ) { if ( bForceVerify & & ! bMsgIsSigned ) LOGGER . info ( " Forced verify MDN signature " + sLoggingText ) ; else if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Verifying MDN signature " + sLoggingText ) ; final Wrapper < X509Certificate > aCertHolder = new Wrapper < > ( ) ; aMainPart = aCryptoHelper . verify ( aMainPart , aReceiverCert , bUseCertificateInBodyPart , bForceVerify , aCertHolder : : set , aResHelper ) ; if ( aEffectiveCertificateConsumer ! = null ) aEffectiveCertificateConsumer . accept ( aCertHolder . get ( ) ) ; aMDN . attrs ( ) . putIn ( AS2Message . ATTRIBUTE_RECEIVED_SIGNED , true ) ; if ( aCertHolder . isSet ( ) ) aMsg . attrs ( ) . putIn ( AS2Message . ATTRIBUTE_RECEIVED_SIGNATURE_CERTIFICATE , CertificateHelper . getPEMEncodedCertificate ( aCertHolder . get ( ) ) ) ; LOGGER . info ( " Successfully verified signature of MDN of message " + sLoggingText ) ; } final MimeMultipart aReportParts = new MimeMultipart ( aMainPart . getDataHandler ( ) . getDataSource ( ) ) ; final ContentType aReportType = AS2HttpHelper . parseContentType ( aReportParts . getContentType ( ) ) ; if ( aReportType ! = null & & aReportType . getBaseType ( ) . equalsIgnoreCase ( " multipart/report " ) ) {
static Music build ( final Collection < String > response ) { String album = null ; String artist = null ; String albumArtist = null ; String composer = null ; String fullPath = null ; int disc = UNDEFINED_INT ; long date = - 1L ; String genre = null ; long time = - 1L ; String title = null ; int totalTracks = UNDEFINED_INT ; int track = UNDEFINED_INT ; int songId = UNDEFINED_INT ; int songPos = UNDEFINED_INT ; String name = null ; for ( final String [ ] pair : Tools . splitResponse ( response ) ) { switch ( pair [ KEY ] ) { case " file " : fullPath = pair [ VALUE ] ; if ( ! fullPath . isEmpty ( ) & & fullPath . contains ( " :// " ) ) { final int pos = fullPath . indexOf ( '#' ) ; if ( pos > 1 ) { name = fullPath . substring ( pos + 1 , fullPath . length ( ) ) ; fullPath = fullPath . substring ( 0 , pos ) ; } } break ; case " Album " : album = pair [ VALUE ] ; break ; case " AlbumArtist " : albumArtist = pair [ VALUE ] ; break ; case " Artist " : artist = pair [ VALUE ] ; break ; case " Composer " : composer = pair [ VALUE ] ; break ; case " Date " : try { final Matcher matcher = DATE_DELIMITER . matcher ( pair [ VALUE ] ) ; date = Long . parseLong ( matcher . replaceAll ( " " ) ) ; } catch ( final NumberFormatException e ) { Log . warning ( TAG , " Not a valid date. " , e ) ; } break ; case " Disc " : final int discIndex = pair [ VALUE ] . indexOf ( '/' ) ; try { if ( discIndex = = - 1 ) { disc = Integer . parseInt ( pair [ VALUE ] ) ; } else { disc = Integer . parseInt ( pair [ VALUE ] . substring ( 0 , discIndex ) ) ; } } catch ( final NumberFormatException e ) { Log . warning ( TAG , " Not a valid disc number. " , e ) ; } break ; case " Genre " : genre = pair [ VALUE ] ; break ; case " Id " : try { songId = Integer . parseInt ( pair [ VALUE ] ) ; } catch ( final NumberFormatException e ) { Log . error ( TAG , " Not a valid song ID. " , e ) ; } break ; case " Name " : if ( name = = null ) { name = pair [ VALUE ] ; } break ; case " Pos " : try { songPos = Integer . parseInt ( pair [ VALUE ] ) ; } catch ( final NumberFormatException e ) { Log . error ( TAG , " Not a valid song position. " , e ) ; } break ; case " Time " : try { time = Long . parseLong ( pair [ VALUE ] ) ; } catch ( final NumberFormatException e ) { Log . error ( TAG , " Not a valid time number. " , e ) ; } break ; case " Title " : title = pair [ VALUE ] ; break ; case " Track " : final int trackIndex = pair [ VALUE ] . indexOf ( '/' ) ; try { if ( trackIndex = = - 1 ) { track = Integer . parseInt ( pair [ VALUE ] ) ; } else { track = Integer . parseInt ( pair [ VALUE ] . substring ( 0 , trackIndex ) ) ; totalTracks = Integer . parseInt ( pair [ VALUE ] . substring ( trackIndex + 1 ) ) ; } } catch ( final NumberFormatException e ) { Log . warning ( TAG , " Not a valid track number. " , e ) ; } break ; default : break ; } } return new Music ( album , artist , albumArtist , composer , fullPath , disc , date , genre , time , title , totalTracks , track , songId , songPos , name ) ;
public void addFaces ( int i , double d , double d1 , double d2 , String s ) { typeVector . addElement ( new Integer ( i ) ) ; colorVector . addElement ( new Color ( ( float ) d , ( float ) d1 , ( float ) d2 ) ) ; shapesVector . addElement ( shapeVector = new Vector ( ) ) ; if ( s ! = null ) {
public static FileOperationManager getFileOperationManager ( ) { return s_aFOM ; }
public void missingFields ( ) throws Exception { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( ExcludeDeriver . EXCLUSION_COMPARE_CONFIG , " Compare " ) ; paramMap . put ( ExcludeDeriver . EXCLUSION_WITH_CONFIG , " With " ) ; config = ConfigFactory . parseMap ( paramMap ) ; ExcludeDeriver excludeDeriver = new ExcludeDeriver ( ) ; excludeDeriver . configure ( config ) ; }
< R > R bulkUpdate ( Function < ? super Config , R > action ) ; default void bulkUpdate ( Consumer < ? super Config > action ) { bulkUpdate ( config - > { action . accept ( config ) ; return null ; } ) ; } @Override ConcurrentConfig createSubConfig ( ) ; }
public void testCompressedObject ( ) throws Exception { tc . setCompressionThreshold ( 8 ) ; Calendar c = Calendar . getInstance ( ) ; CachedData cd = tc . encode ( c ) ; assertEquals ( WhalinTranscoder . SERIALIZED | WhalinTranscoder . COMPRESSED , cd . getFlags ( ) ) ; assertEquals ( c , tc . decode ( cd ) ) ; }
public String serialiseSentences ( List < Sentence > tasks , Memory memory ) { com . googlecode . opennars . parser . loan . Loan . Absyn . BaseRule br = new com . googlecode . opennars . parser . loan . Loan . Absyn . BaseR ( this . getBaseURI ( ) . toString ( ) ) ; return null ; }
public Term visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmExDif p , A arg ) { Term term_1 = p . term_1 . accept ( this , arg ) ; Term term_2 = p . term_2 . accept ( this , arg ) ; return new com . googlecode . opennars . parser . loan . Loan . Absyn . TrmExDif ( term_1 , term_2 ) ; }
void write ( char c ) ; default void write ( char . . . chars ) { write ( chars , 0 , chars . length ) ; } void write ( char [ ] chars , int offset , int length ) ; default void write ( String s ) { write ( s , 0 , s . length ( ) ) ; } void write ( String s , int offset , int length ) ; default void write ( CharsWrapper cw ) { write ( cw . chars , cw . offset , cw . limit - cw . offset ) ; } }
protected void replaceNodeWithNode ( Node < T > nodeToRemoved , Node < T > replacementNode ) { if ( replacementNode ! = null ) { Node < T > replacementNodeLesser = replacementNode . lesser ; Node < T > replacementNodeGreater = replacementNode . greater ; Node < T > nodeToRemoveLesser = nodeToRemoved . lesser ; if ( nodeToRemoveLesser ! = null & & ! nodeToRemoveLesser . equals ( replacementNode ) ) { replacementNode . lesser = nodeToRemoveLesser ; nodeToRemoveLesser . parent = replacementNode ; } Node < T > nodeToRemoveGreater = nodeToRemoved . greater ; if ( nodeToRemoveGreater ! = null & & ! nodeToRemoveGreater . equals ( replacementNode ) ) { replacementNode . greater = nodeToRemoveGreater ; nodeToRemoveGreater . parent = replacementNode ; } Node < T > replacementParent = replacementNode . parent ; if ( replacementParent ! = null & & ! replacementParent . equals ( nodeToRemoved ) ) { Node < T > replacementParentLesser = replacementParent . lesser ; Node < T > replacementParentGreater = replacementParent . greater ; if ( replacementParentLesser ! = null & & replacementParentLesser . equals ( replacementNode ) ) { replacementParent . lesser = replacementNodeGreater ; if ( replacementNodeGreater ! = null ) replacementNodeGreater . parent = replacementParent ; } else if ( replacementParentGreater ! = null & & replacementParentGreater . equals ( replacementNode ) ) { replacementParent . greater = replacementNodeLesser ; if ( replacementNodeLesser ! = null ) replacementNodeLesser . parent = replacementParent ; } } } Node < T > parent = nodeToRemoved . parent ; if ( parent = = null ) {
private void write ( String str ) throws IOException { writer . write ( str ) ; lineBreaks = 0 ; }
private static final void showResult ( Integer [ ] unsorted , Integer [ ] result ) { System . out . println ( " Unsorted:  " + print ( unsorted ) ) ; System . out . println ( " Sorted:  " + print ( result ) ) ; System . out . flush ( ) ; }
public String showSizes ( ) { StringBuilder buf = new StringBuilder ( "   " ) ; int l = 0 ; for ( Collection < E > items : level ) { if ( ( items ! = null ) & & ( ! items . isEmpty ( ) ) ) { l + + ; buf . append ( items . size ( ) ) . append ( ' ' ) ; } } return " Levels:  " + Integer . toString ( l ) + " , sizes:  " + buf ; }
public String getDescription ( ) { return attrs ( ) . getAsString ( ATTR_DESCRIPTION ) ; }
public static Map < GenericRecord , List < GenericRecord > > recordsByKey ( List < GenericRecord > records , List < String > keyFieldNames ) { Map < GenericRecord , List < GenericRecord > > recordsByKey = Maps . newHashMap ( ) ; if ( records . size ( ) > 0 ) { Schema keySchema = RecordUtils . subsetSchema ( records . get ( 0 ) . getSchema ( ) , keyFieldNames ) ; for ( GenericRecord record : records ) { GenericRecord key = RecordUtils . subsetRecord ( record , keySchema ) ; if ( ! recordsByKey . containsKey ( key ) ) { recordsByKey . put ( key , new ArrayList < GenericRecord > ( ) ) ; } List < GenericRecord > rowsForKey = recordsByKey . get ( key ) ; rowsForKey . add ( record ) ; } } return recordsByKey ; }
@Override public void onChildSolution ( Task child , Sentence belief ) { System . out . println ( belief ) ; }
X509Certificate getCertificate ( IMessageMDN msg , String partnershipType ) throws OpenAS2Exception ; PrivateKey getPrivateKey ( IMessageMDN msg , X509Certificate cert ) throws OpenAS2Exception ; }
void updateWeight ( int delta ) { weight + = delta ; Entry < K , V > p = parent ; while ( p ! = null ) { p . weight + = delta ;
< T > T remove ( List < String > path ) ; void clear ( ) ; default UnmodifiableConfig unmodifiable ( ) { return new UnmodifiableConfig ( ) { @Override public < T > T get ( List < String > path ) { return Config . this . get ( path ) ; } @Override public boolean contains ( List < String > path ) { return Config . this . contains ( path ) ; } @Override public int size ( ) { return Config . this . size ( ) ; } @Override public Map < String , Object > valueMap ( ) { return Collections . unmodifiableMap ( Config . this . valueMap ( ) ) ; } @Override public Set < ? extends Entry > entrySet ( ) { return Config . this . entrySet ( ) ; } @Override public ConfigFormat < ? , ? , ? > configFormat ( ) { return Config . this . configFormat ( ) ; } } ; } default Config checked ( ) { return new CheckedConfig ( this ) ; } Map < String , Object > valueMap ( ) ; @Override Set < ? extends Entry > entrySet ( ) ; interface Entry extends UnmodifiableConfig . Entry { < T > T setValue ( Object value ) ; } static Config of ( ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new SimpleConfig ( format ) ; } static Config inMemory ( ) { return new SimpleConfig ( InMemoryFormat . defaultInstance ( ) ) ; } static Config wrap ( Map < String , Object > map , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( map , format ) ; } static Config copy ( UnmodifiableConfig config ) { return new SimpleConfig ( config , config . configFormat ( ) ) ; } static Config copy ( UnmodifiableConfig config , ConfigFormat < ? , ? , ? > format ) { return new SimpleConfig ( config , format ) ; } }
public boolean onMenuItemClick ( final MenuItem item ) { return onOptionsItemSelected ( item ) ; }
public boolean contains ( T value ) { if ( root = = null ) return false ; Node < T > node = getNode ( root , value ) ; return ( node ! = null ) ; }
private void addThread ( long pid , int id ) { synchronized ( threads ) { threads . put ( ( int ) pid , id ) ;
public void handle ( final AbstractNetModule owner , @Nonnull final Socket aSocket ) { final String sClientInfo = getClientInfo ( aSocket ) ; s_aLogger . info ( " Incoming connection  " + sClientInfo ) ; final AS2Message aMsg = createMessage ( aSocket ) ; byte [ ] aMsgData = null ; final StopWatch aSW = new StopWatch ( true ) ; try { aMsgData = HTTPUtil . readData ( aSocket , aMsg ) ; } catch ( final Exception ex ) { final NetException ne = new NetException ( aSocket . getInetAddress ( ) , aSocket . getPort ( ) , ex ) ; ne . terminate ( ) ; } aSW . stop ( ) ; if ( aMsgData ! = null ) {
void onCoverUpdate ( Bitmap albumCover , String albumCoverPath ) ; } private class DecodeAlbumCover extends AsyncTask < String , Void , Bitmap > { @Override protected final Bitmap doInBackground ( final String . . . pathArray ) { if ( DEBUG ) { Log . d ( TAG , " doInBackground() " ) ; } if ( mAlbumCover ! = null & & ! mAlbumCover . isRecycled ( ) ) { mAlbumCover . recycle ( ) ; } mAlbumCoverPath = pathArray [ 0 ] ; if ( Build . VERSION . SDK_INT > = Build . VERSION_CODES . KITKAT ) { mAlbumCover = BitmapFactory . decodeFile ( mAlbumCoverPath ) ; } else { mAlbumCover = Tools . decodeSampledBitmapFromPath ( mAlbumCoverPath , mIconWidth , mIconHeight , false ) ; } return mAlbumCover ; } @Override protected final void onPostExecute ( final Bitmap result ) { super . onPostExecute ( result ) ; if ( mCoverUpdateListener ! = null ) { mCoverUpdateListener . onCoverUpdate ( mAlbumCover , mAlbumCoverPath ) ; } } } }
public boolean equals ( final Object o ) { if ( o = = this ) return true ; if ( o = = null | | ! getClass ( ) . equals ( o . getClass ( ) ) ) return false ; final MIC rhs = ( MIC ) o ; return Arrays . equals ( m_aMICBytes , rhs . m_aMICBytes ) & & _getUnified ( m_eDigestAlgorithm ) . equals ( _getUnified ( rhs . m_eDigestAlgorithm ) ) ; }
private static boolean testSegmentTree ( ) { { if ( debug > 1 ) System . out . println ( " Quadrant Segment Tree. " ) ; java . util . List < NonOverlappingSegment < QuadrantData > > segments = new ArrayList < NonOverlappingSegment < QuadrantData > > ( ) ; segments . add ( new NonOverlappingSegment < QuadrantData > ( 0 , new QuadrantData ( 1 , 0 , 0 , 0 ) ) ) ; segments . add ( new NonOverlappingSegment < QuadrantData > ( 1 , new QuadrantData ( 0 , 1 , 0 , 0 ) ) ) ; segments . add ( new NonOverlappingSegment < QuadrantData > ( 2 , new QuadrantData ( 0 , 0 , 1 , 0 ) ) ) ; segments . add ( new NonOverlappingSegment < QuadrantData > ( 3 , new QuadrantData ( 0 , 0 , 0 , 1 ) ) ) ; FlatSegmentTree < QuadrantData > tree = new FlatSegmentTree < QuadrantData > ( segments ) ; if ( debug > 1 ) System . out . println ( tree ) ; QuadrantData query = tree . query ( 0 , 3 ) ; if ( debug > 1 ) System . out . println ( " 0->3:  " + query + " \ n " ) ; tree . update ( 1 , new QuadrantData ( 0 , 0 , 1 , 0 ) ) ; tree . update ( 2 , new QuadrantData ( 0 , 1 , 0 , 0 ) ) ; tree . update ( 3 , new QuadrantData ( 1 , 0 , 0 , 0 ) ) ; if ( debug > 1 ) System . out . println ( tree ) ; query = tree . query ( 2 , 3 ) ; if ( debug > 1 ) System . out . println ( " 2->3:  " + query + " \ n " ) ; tree . update ( 0 , new QuadrantData ( 0 , 1 , 0 , 0 ) ) ; tree . update ( 1 , new QuadrantData ( 0 , 0 , 0 , 1 ) ) ; if ( debug > 1 ) System . out . println ( tree ) ; query = tree . query ( 0 , 2 ) ; if ( debug > 1 ) System . out . println ( " 0->2:  " + query + " \ n " ) ; if ( debug > 1 ) System . out . println ( ) ; } { if ( debug > 1 ) System . out . println ( " Range Maximum Segment Tree. " ) ; java . util . List < NonOverlappingSegment < RangeMaximumData < Integer > > > segments = new ArrayList < NonOverlappingSegment < RangeMaximumData < Integer > > > ( ) ; segments . add ( new NonOverlappingSegment < RangeMaximumData < Integer > > ( 0 , new RangeMaximumData < Integer > ( 4 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMaximumData < Integer > > ( 1 , new RangeMaximumData < Integer > ( 2 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMaximumData < Integer > > ( 2 , new RangeMaximumData < Integer > ( 6 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMaximumData < Integer > > ( 3 , new RangeMaximumData < Integer > ( 3 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMaximumData < Integer > > ( 4 , new RangeMaximumData < Integer > ( 1 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMaximumData < Integer > > ( 5 , new RangeMaximumData < Integer > ( 5 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMaximumData < Integer > > ( 6 , new RangeMaximumData < Integer > ( 0 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMaximumData < Integer > > ( 7 , new RangeMaximumData < Integer > ( 7 ) ) ) ; FlatSegmentTree < RangeMaximumData < Integer > > tree = new FlatSegmentTree < RangeMaximumData < Integer > > ( segments ) ; if ( debug > 1 ) System . out . println ( tree ) ; RangeMaximumData < Integer > query = tree . query ( 0 , 7 ) ; if ( debug > 1 ) System . out . println ( " 0->7:  " + query + " \ n " ) ; tree . update ( 6 , new RangeMaximumData < Integer > ( 8 ) ) ; if ( debug > 1 ) System . out . println ( tree ) ; query = tree . query ( 0 , 7 ) ; if ( debug > 1 ) System . out . println ( " 0->7:  " + query + " \ n " ) ; query = tree . query ( 2 , 5 ) ; if ( debug > 1 ) System . out . println ( " 2->5:  " + query + " \ n " ) ; if ( debug > 1 ) System . out . println ( ) ; } { if ( debug > 1 ) System . out . println ( " Range Minimum Segment Tree. " ) ; java . util . List < NonOverlappingSegment < RangeMinimumData < Integer > > > segments = new ArrayList < NonOverlappingSegment < RangeMinimumData < Integer > > > ( ) ; segments . add ( new NonOverlappingSegment < RangeMinimumData < Integer > > ( 0 , new RangeMinimumData < Integer > ( 9 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMinimumData < Integer > > ( 1 , new RangeMinimumData < Integer > ( 2 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMinimumData < Integer > > ( 2 , new RangeMinimumData < Integer > ( 6 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMinimumData < Integer > > ( 3 , new RangeMinimumData < Integer > ( 3 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMinimumData < Integer > > ( 4 , new RangeMinimumData < Integer > ( 1 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMinimumData < Integer > > ( 5 , new RangeMinimumData < Integer > ( 5 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeMinimumData < Integer > > ( 6 , new RangeMinimumData < Integer > ( 0 ) ) ) ; FlatSegmentTree < RangeMinimumData < Integer > > tree = new FlatSegmentTree < RangeMinimumData < Integer > > ( segments ) ; if ( debug > 1 ) System . out . println ( tree ) ; RangeMinimumData < Integer > query = tree . query ( 0 , 7 ) ; if ( debug > 1 ) System . out . println ( " 0->7:  " + query + " \ n " ) ; tree . update ( 6 , new RangeMinimumData < Integer > ( 8 ) ) ; if ( debug > 1 ) System . out . println ( tree ) ; query = tree . query ( 0 , 7 ) ; if ( debug > 1 ) System . out . println ( " 0->7:  " + query + " \ n " ) ; query = tree . query ( 1 , 3 ) ; if ( debug > 1 ) System . out . println ( " 1->3:  " + query + " \ n " ) ; if ( debug > 1 ) System . out . println ( ) ; } { if ( debug > 1 ) System . out . println ( " Range Sum Segment Tree. " ) ; java . util . List < NonOverlappingSegment < RangeSumData < Integer > > > segments = new ArrayList < NonOverlappingSegment < RangeSumData < Integer > > > ( ) ; segments . add ( new NonOverlappingSegment < RangeSumData < Integer > > ( 0 , new RangeSumData < Integer > ( 4 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeSumData < Integer > > ( 1 , new RangeSumData < Integer > ( 2 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeSumData < Integer > > ( 2 , new RangeSumData < Integer > ( 6 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeSumData < Integer > > ( 3 , new RangeSumData < Integer > ( 3 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeSumData < Integer > > ( 4 , new RangeSumData < Integer > ( 1 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeSumData < Integer > > ( 5 , new RangeSumData < Integer > ( 5 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeSumData < Integer > > ( 6 , new RangeSumData < Integer > ( 0 ) ) ) ; segments . add ( new NonOverlappingSegment < RangeSumData < Integer > > ( 7 , new RangeSumData < Integer > ( 7 ) ) ) ; FlatSegmentTree < RangeSumData < Integer > > tree = new FlatSegmentTree < RangeSumData < Integer > > ( segments ) ; if ( debug > 1 ) System . out . println ( tree ) ; RangeSumData < Integer > query = tree . query ( - 1 , 8 ) ; if ( debug > 1 ) System . out . println ( " -1->8:  " + query + " \ n " ) ; tree . update ( 6 , new RangeSumData < Integer > ( 8 ) ) ; if ( debug > 1 ) System . out . println ( tree ) ; query = tree . query ( 0 , 7 ) ; if ( debug > 1 ) System . out . println ( " 0->7:  " + query + " \ n " ) ; query = tree . query ( 2 , 5 ) ; if ( debug > 1 ) System . out . println ( " 2->5:  " + query + " \ n " ) ; if ( debug > 1 ) System . out . println ( ) ; } { if ( debug > 1 ) System . out . println ( " Interval Segment Tree. " ) ; java . util . List < OverlappingSegment < IntervalData < String > > > segments = new ArrayList < OverlappingSegment < IntervalData < String > > > ( ) ; segments . add ( new OverlappingSegment < IntervalData < String > > ( 1 , 7 , new IntervalData < String > ( " RED " ) ) ) ; segments . add ( new OverlappingSegment < IntervalData < String > > ( 2 , 6 , new IntervalData < String > ( " ORANGE " ) ) ) ; segments . add ( new OverlappingSegment < IntervalData < String > > ( 3 , 10 , new IntervalData < String > ( " GREEN " ) ) ) ; segments . add ( new OverlappingSegment < IntervalData < String > > ( 4 , 9 , new IntervalData < String > ( " DARK_GREEN " ) ) ) ; segments . add ( new OverlappingSegment < IntervalData < String > > ( 7 , 11 , new IntervalData < String > ( " BLUE " ) ) ) ; segments . add ( new OverlappingSegment < IntervalData < String > > ( 8 , 13 , new IntervalData < String > ( " PURPLE " ) ) ) ; segments . add ( new OverlappingSegment < IntervalData < String > > ( 12 , 14 , new IntervalData < String > ( " BLACK " ) ) ) ; DynamicSegmentTree < IntervalData < String > > tree = new DynamicSegmentTree < IntervalData < String > > ( segments ) ; if ( debug > 1 ) System . out . println ( tree ) ; IntervalData < String > query = tree . query ( 1 ) ; if ( debug > 1 ) System . out . println ( " 1:  " + query ) ; query = tree . query ( 4 ) ; if ( debug > 1 ) System . out . println ( " 4:  " + query ) ; query = tree . query ( 9 ) ; if ( debug > 1 ) System . out . println ( " 9:  " + query ) ; query = tree . query ( 0 , 15 ) ; if ( debug > 1 ) System . out . println ( " 0->15:  " + query ) ; query = tree . query ( 7 , 14 ) ; if ( debug > 1 ) System . out . println ( " 7->14:  " + query ) ; if ( debug > 1 ) System . out . println ( ) ; } return true ; }
public String whyNonTraversible ( GridAgent agent , int x , int y , int tx , int ty ) { int dx = Math . abs ( tx - x ) ; int dy = Math . abs ( ty - y ) ; if ( ! ( ( dx < = 1 ) & & ( dy < = 1 ) ) ) return " Too far " ; if ( ( tx < 0 ) | | ( ty < 0 ) | | ( tx > = cells . w ) | | ( ty > = cells . h ) ) return " Out of bounds:  " + tx + "   " + ty ; Cell from = cells . at ( x , y ) ; Cell to = cells . at ( tx , ty ) ; if ( ( to . material = = Material . StoneWall ) | | to . is_solid | | to . material = = Material . Water | | to . logic = = Logic . BRIDGE ) return " Too solid " ; final float maxTraversableHeight = 8 ; float dHeight = to . height - from . height ; return null ; }
private static void initializeStreamingJob ( ) { int batchMilliseconds = INSTANCE . config . getInt ( BATCH_MILLISECONDS_PROPERTY ) ; final Duration batchDuration = Durations . milliseconds ( batchMilliseconds ) ; JavaStreamingContext jsc = new JavaStreamingContext ( new JavaSparkContext ( getSparkSession ( ) . sparkContext ( ) ) , batchDuration ) ; INSTANCE . jsc = jsc ; }
abstract public boolean allow ( Sentence s ) ; abstract public boolean allow ( Statement st ) ; public void remove ( final Sentence s ) { if ( ! containsEdge ( s ) ) return ; Term from = getEdgeSource ( s ) ; Term to = getEdgeTarget ( s ) ; boolean r = removeEdge ( s ) ; if ( inDegreeOf ( from ) + outDegreeOf ( from ) = = 0 ) removeVertex ( from ) ; if ( inDegreeOf ( to ) + outDegreeOf ( to ) = = 0 ) removeVertex ( to ) ; if ( r ) event . emit ( GraphChange . class , null , s ) ; } public void add ( final Sentence s ) { if ( s . content instanceof CompoundTerm ) { CompoundTerm cs = ( CompoundTerm ) s . content ; if ( cs instanceof Statement ) { Statement st = ( Statement ) cs ; if ( allow ( st ) ) { Term subject = st . getSubject ( ) ; Term predicate = st . getPredicate ( ) ; addVertex ( subject ) ; addVertex ( predicate ) ; addEdge ( subject , predicate , s ) ; event . emit ( GraphChange . class , st , null ) ; } } } } }
public List < Partnership > getAllPartnerships ( ) { m_aRWLock . readLock ( ) . lock ( ) ; try {
protected List < Term > plan ( Term target , double distance , int particles ) { List < Term > p = planParticle ( target , distance , particles ) ; if ( ! p . isEmpty ( ) ) System . out . println ( " plan:  " + target ) ; return p ; }
public void clear ( ) { throw new UnsupportedOperationException ( ) ; }
public void show ( ) { enabler . doClick ( ) ; }
void dragElems ( ) { } void checkSelect ( ) { double selection_distanceSq = selection_distance * selection_distance ; { } } } class Hamlib { void Init ( ) { noStroke ( ) ; hnav . Init ( ) ; hsim . Init ( ) ; } void mousePressed ( ) { hnav . mousePressed ( ) ; hsim . mousePressed ( ) ; } void mouseDragged ( ) { hnav . mouseDragged ( ) ; hsim . mouseDragged ( ) ; } void mouseReleased ( ) { hnav . mouseReleased ( ) ; hsim . mouseReleased ( ) ; } public void mouseMoved ( ) { } void keyPressed ( ) { hnav . keyPressed ( ) ; } void mouseScrolled ( ) { hnav . mouseScrolled ( ) ; } void Camera ( ) { hnav . Transform ( ) ; } void Update ( int r , int g , int b ) { background ( r , g , b ) ; pushMatrix ( ) ; Camera ( ) ; hrend_DrawBegin ( ) ; drawit ( ) ; hrend_DrawEnd ( ) ; popMatrix ( ) ; } } } public class ProcessingGraphPanel extends JFrame { papplet app = null ; private final NAR nar ; private final Filter filter ; float edgeDistance = 10 ; private boolean showSyntax ; public ProcessingGraphPanel ( NAR n ) { this ( n , IncludeEverything ) ; } public ProcessingGraphPanel ( NAR n , Filter filter ) { super ( " NARS Graph " ) ; this . nar = n ; this . filter = filter ; app = new papplet ( ) ; app . init ( ) ; this . setSize ( 1000 , 860 ) ; this . setVisible ( true ) ; Container content = getContentPane ( ) ; content . setLayout ( new BorderLayout ( ) ) ; JPanel menu = new JPanel ( new FlowLayout ( FlowLayout . LEFT ) ) ; final JCheckBox beliefsEnable = new JCheckBox ( " Syntax " ) ; beliefsEnable . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent e ) { showSyntax = beliefsEnable . isSelected ( ) ; ProcessingGraphPanel . this . update ( ) ; } } ) ; menu . add ( beliefsEnable ) ; NSlider nodeSize = new NSlider ( app . nodeSize , 1 , app . maxNodeSize ) { @Override public void onChange ( double v ) { app . nodeSize = ( float ) v ; } } ; nodeSize . setPrefix ( " Node Size:  " ) ; nodeSize . setPreferredSize ( new Dimension ( 125 , 25 ) ) ; menu . add ( nodeSize ) ; NSlider edgeDist = new NSlider ( edgeDistance , 1 , 100 ) { @Override public void onChange ( double v ) { edgeDistance = ( float ) v ; ProcessingGraphPanel . this . update ( ) ; } } ; edgeDist . setPrefix ( " Separation:  " ) ; edgeDist . setPreferredSize ( new Dimension ( 125 , 25 ) ) ; menu . add ( edgeDist ) ; content . add ( menu , BorderLayout . NORTH ) ; content . add ( app , BorderLayout . CENTER ) ; update ( ) ; addWindowListener ( new WindowAdapter ( ) { @Override public void windowClosing ( WindowEvent e ) { app . stop ( ) ; app = null ; } } ) ; } public void update ( ) { app . updating = true ; NARGraph g = new NARGraph ( ) ; g . add ( nar , filter , new NARGraph . DefaultGraphizer ( true , true , false , false , showSyntax ) ) ; app . graph = g ; JGraphXAdapter layout = new JGraphXAdapter ( g ) { } ; app . layout = layout ; mxFastOrganicLayout l = new mxFastOrganicLayout ( layout ) ; l . setForceConstant ( edgeDistance * 10 f ) ; l . execute ( layout . getDefaultParent ( ) ) ; app . updating = false ; } }
public Object doTask ( ) ; public Object doTask ( TaskMonitor monitor , ObjectRepository repository ) ; }
public void run ( ) { new SymRecognizer ( ) . setVisible ( true ) ; }
static void analogy ( final Term subj , final Term pred , final Sentence asym , final Sentence sym , final int figure , final DerivationContext nal ) { if ( Statement . invalidStatement ( subj , pred ) ) { return ; } final int order1 = asym . term . getTemporalOrder ( ) ; final int order2 = sym . term . getTemporalOrder ( ) ; final int order = analogyOrder ( order1 , order2 , figure ) ; if ( order = = ORDER_INVALID ) { return ; } final Statement st = ( Statement ) asym . term ; TruthValue truth = null ; final BudgetValue budget ; final Sentence sentence = nal . getCurrentTask ( ) . sentence ; final CompoundTerm taskTerm = ( CompoundTerm ) sentence . term ; if ( sentence . isQuestion ( ) | | sentence . isQuest ( ) ) { if ( taskTerm . isCommutative ( ) ) { if ( asym . truth = = null ) { return ; } budget = BudgetFunctions . backwardWeak ( asym . truth , nal ) ; } else { if ( sym . truth = = null ) { return ; } budget = BudgetFunctions . backward ( sym . truth , nal ) ; } } else { if ( sentence . isGoal ( ) ) { truth = TruthFunctions . dispatchBinary2 ( taskTerm . isCommutative ( ) , TruthFunctions . EnumType . DESIREWEAK , TruthFunctions . EnumType . DESIRESTRONG , asym . truth , sym . truth ) ; } else { truth = TruthFunctions . analogy ( asym . truth , sym . truth ) ; } budget = BudgetFunctions . forward ( truth , nal ) ; } nal . doublePremiseTask ( Statement . make ( st , subj , pred , order ) , truth , budget , false , false ) ; }
private void beginStreaming ( ) { if ( DEBUG ) { Log . d ( TAG , " StreamHandler.beginStreaming() " ) ; } if ( mMediaPlayer = = null ) { windUpResources ( ) ; } mServiceHandler . sendEmptyMessage ( BUFFERING_BEGIN ) ; final String streamSource = getStreamSource ( ) ; final long asyncIdle = 1500L ; mPreparingStreaming = true ; mServiceHandler . removeMessages ( STOP ) ; try { mMediaPlayer . reset ( ) ;
@Test public void testParseOperationInFunctionalForm ( ) throws Narsese . InvalidInputException { Parameters . FUNCTIONAL_OPERATIONAL_FORMAT = true ; final Nar n = new Nar ( ) ; final Narsese p = new Narsese ( n ) ; final Term x = p . parseTerm ( " wonder(a,b) " ) ; assertEquals ( Operation . class , x . getClass ( ) ) ; assertEquals ( " (^wonder,a,b) " , x . toString ( ) ) ; }
public void onItemClick ( AdapterView adapterView , View v , int position , long id ) { ( ( ILibraryFragmentActivity ) getActivity ( ) ) . pushLibraryFragment ( new AlbumsFragment ( ) . init ( ( Artist ) items . get ( position ) ) , " album " ) ; }
public void testEarlierExistingWithNewValues ( ) { p = new EventTimeUpsertPlanner ( ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( recordSchema , " a " , " world " , 50L ) ) ; arriving . add ( new RowWithSchema ( recordSchema , " a " , " hello " , 100L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 1 ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . UPDATE ) ; }
BlockingQueue < Operation > createWriteOperationQueue ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; boolean isDaemon ( ) ; boolean useNagleAlgorithm ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; int getReadBufSize ( ) ; public HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; }
public final boolean handleMessage ( final Message msg ) { boolean result = true ; if ( DEBUG ) { Log . d ( TAG , " Message received:  " + ServiceBinder . getHandlerValue ( msg . what ) + "  with value:  " + ServiceBinder . getHandlerValue ( msg . arg1 ) ) ; } switch ( msg . what ) { case MPDroidService . REQUEST_UNBIND : if ( DEBUG ) { Log . d ( TAG , " Service requested unbind, complying. " ) ; } mServiceBinder . doUnbindService ( ) ; break ; case NotificationHandler . IS_ACTIVE : mIsNotificationActive = ServiceBinder . TRUE = = msg . arg1 ; mServiceBinder . setServicePersistent ( true ) ; break ; case ServiceBinder . CONNECTED : Log . d ( TAG , " MPDApplication is bound to the service. " ) ; oMPDAsyncHelper . addConnectionInfoListener ( this ) ; break ; case ServiceBinder . DISCONNECTED : oMPDAsyncHelper . removeConnectionInfoListener ( this ) ; break ; case StreamHandler . IS_ACTIVE : mIsStreamActive = ServiceBinder . TRUE = = msg . arg1 ; mServiceBinder . setServicePersistent ( true ) ; break ; case ServiceBinder . SET_PERSISTENT : if ( ! isNotificationPersistent ( ) | | ServiceBinder . TRUE = = msg . arg1 ) { mServiceBinder . setServicePersistent ( ServiceBinder . TRUE = = msg . arg1 ) ; } break ; default : result = false ; break ; } return result ; }
public ObjectTaskInPort addInput ( final Input channel ) { ObjectTaskInPort i = new ObjectTaskInPort ( channel , new ArrayDeque ( ) , 1.0f ) ; try { i . update ( ) ; newInputChannels . add ( i ) ; } catch ( IOException ex ) { if ( Parameters . DEBUG ) throw new RuntimeException ( ex . toString ( ) ) ; emit ( ERR . class , ex ) ; } ioChanged = true ; if ( ! running ) updatePorts ( ) ; return i ; }
public static com . cloudera . labs . envelope . input . translate . ProtobufSingleMessage . SingleExample . NestedExample parseFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ;
public boolean onKey ( DialogInterface dialog , int keyCode , KeyEvent event ) { return true ; }
public boolean requestFeature ( int featureId ) { if ( DEBUG ) Log . d ( TAG , " [requestFeature] featureId:  " + featureId ) ; if ( mContentParent ! = null ) { throw new AndroidRuntimeException ( " requestFeature() must be called before adding content " ) ; } switch ( featureId ) { case Window . FEATURE_ACTION_BAR :
< T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; void authenticate ( String username , String password ) throws OperationException ; }
protected void Add ( Item item ) { try { app . oMPDAsyncHelper . oMPD . getPlaylist ( ) . addAll ( app . oMPDAsyncHelper . oMPD . getSongs ( artist , item . getName ( ) ) ) ;
@Override public boolean putIn ( final E newItem ) { final CharSequence newKey = newItem . name ( ) ; final E existingItemWithSameKey = nameTable . remove ( newKey ) ; if ( existingItemWithSameKey ! = null ) { outOfBase ( existingItemWithSameKey ) ; newItem . merge ( existingItemWithSameKey ) ; } final E overflowItem = intoBase ( newItem ) ; if ( overflowItem = = newItem ) { return false ; } nameTable . put ( newKey , newItem ) ; if ( overflowItem ! = null ) { final CharSequence overflowKey = overflowItem . name ( ) ; if ( ! overflowKey . equals ( newKey ) ) { nameTable . remove ( overflowKey ) ; } } return true ; }
@Override public Chart newChart ( ) { return new LineChart ( trace . getCharts ( " emotion.busy " ) ) . height ( 1 ) ; }
public List < String > listArtists ( boolean sortInsensitive ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; List < String > response = mpdConnection . sendCommand ( MPD_CMD_LIST_TAG , MPD_TAG_ARTIST ) ; ArrayList < String > result = new ArrayList < String > ( ) ; for ( String s : response ) { String name = s . substring ( " Artist:  " . length ( ) ) ; if ( name . length ( ) > 0 ) result . add ( name ) ; } if ( sortInsensitive ) Collections . sort ( result , String . CASE_INSENSITIVE_ORDER ) ; else Collections . sort ( result ) ; return result ; }
public void test_expression_comparison_2_36 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch('=<'(1, 1//0), error(evaluation_error(Error), evaluation_error(Goal, ArgNo, Error)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " expression_less_or_equal_than " , new Int ( 1 ) , new Struct ( " // " , new Int ( 1 ) , new Int ( 0 ) ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 2 ) ; Struct validType = ( Struct ) info . getTerm ( " Error " ) ; assertTrue ( validType . isEqual ( new Struct ( " zero_divisor " ) ) ) ; }
private E intoBase ( E newItem ) { E oldItem = null ; int inLevel = getLevel ( newItem ) ; if ( size ( ) > capacity ) { int outLevel = 0 ; while ( emptyLevel ( outLevel ) ) { outLevel + + ; } if ( outLevel > inLevel ) { return newItem ; } else { oldItem = takeOutFirst ( outLevel ) ; } } itemTable [ inLevel ] . add ( newItem ) ; mass + = ( inLevel + 1 ) ; refresh ( ) ; return oldItem ; }
private void rotateLeft ( Node < T > node ) { System . out . println ( " Rotating left  " + node . value + " \ n " + this . toString ( ) ) ; Node < T > parent = node . parent ; Node < T > greater = node . greater ; if ( parent = = null ) { root = greater ; root . parent = null ; } else { if ( node . equals ( parent . lesser ) ) { parent . lesser = greater ; greater . parent = parent ; } else { parent . greater = greater ; greater . parent = parent ; } } Node < T > lesser = greater . lesser ; greater . lesser = node ; node . parent = greater ; node . greater = lesser ; if ( lesser ! = null ) lesser . parent = node ; System . out . println ( " Rotating left  " + node . value + " \ n " + this . toString ( ) ) ; }
protected void asyncUpdate ( ) { } public void updateFromItems ( ) { if ( items ! = null ) { ArrayIndexerAdapter < String > listAdapter = new ArrayIndexerAdapter < String > ( this , android . R . layout . simple_list_item_1 , items ) ; setListAdapter ( listAdapter ) ; try { getListView ( ) . setEmptyView ( noResultView ) ; loadingView . setVisibility ( View . GONE ) ; } catch ( Exception e ) { } } } @Override public void asyncExecSucceeded ( int jobID ) { if ( iJobID = = jobID ) { updateFromItems ( ) ; } } }
Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public URL get ( String url , String name ) throws MalformedURLException { String parsed = null ; if ( url . startsWith ( " http:// " ) ) { parsed = check ( url ) ; if ( null ! = parsed & & parsed . startsWith ( " http:// " ) ) { parsed = check ( parsed ) ; } } return new URL ( addName ( null = = parsed ? url : parsed , name ) ) ; }
private boolean generateLevel ( ) { random = new Random ( seed ) ; ImprovedNoise n0 = new ImprovedNoise ( random . nextLong ( ) ) ; ImprovedNoise n1 = new ImprovedNoise ( random . nextLong ( ) ) ; ImprovedNoise dec = new ImprovedNoise ( random . nextLong ( ) ) ; int width = 320 / 16 + 1 ; int height = 240 / 16 + 1 ; level = new int [ width ] [ height ] ; data = new int [ width ] [ height ] ; double xo0 = random . nextDouble ( ) * 512 ; double yo0 = random . nextDouble ( ) * 512 ; double xo1 = random . nextDouble ( ) * 512 ; double yo1 = random . nextDouble ( ) * 512 ; for ( int x = 0 ; x < width ; x + + ) { for ( int y = 0 ; y < height ; y + + ) { double xd = ( ( x + 1 ) / ( double ) width - 0.5 ) * 2 ; double yd = ( ( y + 1 ) / ( double ) height - 0.5 ) * 2 ; double d = Math . sqrt ( xd * xd + yd * yd ) * 2 ; if ( x = = 0 | | y = = 0 | | x > = width - 3 | | y > = height - 3 ) d = 100 ; double t0 = n0 . perlinNoise ( x * 10.0 + xo0 , y * 10.0 + yo0 ) ; double t1 = n1 . perlinNoise ( x * 10.0 + xo1 , y * 10.0 + yo1 ) ; double td = ( t0 - t1 ) ; double t = ( td * 2 ) ; level [ x ] [ y ] = t > 0 ? TILE_WATER : TILE_GRASS ; } } int lowestX = 9999 ; int lowestY = 9999 ; int t = 0 ; for ( int i = 0 ; i < 100 & & t < 12 ; i + + ) { int x = random . nextInt ( ( width - 1 ) / 3 ) * 3 + 2 ; int y = random . nextInt ( ( height - 1 ) / 3 ) * 3 + 1 ; if ( level [ x ] [ y ] = = TILE_GRASS ) { if ( x < lowestX ) { lowestX = x ; lowestY = y ; } level [ x ] [ y ] = TILE_LEVEL ; data [ x ] [ y ] = - 1 ; t + + ; } } data [ lowestX ] [ lowestY ] = - 2 ; while ( findConnection ( width , height ) ) ; findCaps ( width , height ) ; if ( xFarthestCap = = 0 ) return false ; data [ xFarthestCap ] [ yFarthestCap ] = - 2 ; data [ xMario / 16 ] [ yMario / 16 ] = - 11 ; for ( int x = 0 ; x < width ; x + + ) { for ( int y = 0 ; y < height ; y + + ) { if ( level [ x ] [ y ] = = TILE_GRASS & & ( x ! = xFarthestCap | | y ! = yFarthestCap - 1 ) ) { double t0 = dec . perlinNoise ( x * 10.0 + xo0 , y * 10.0 + yo0 ) ; if ( t0 > 0 ) level [ x ] [ y ] = TILE_DECORATION ; } } } return true ; }
private boolean addMultiLineInput ( final String text ) { final String [ ] lines = text . split ( " \ n " ) ; for ( final String s : lines ) { addInput ( s ) ; if ( ! running ) { this . cycle ( ) ; } } return true ; }
public static void reset ( ) { handlers . clear ( ) ; registered = false ; }
private void tryToGetAudioFocus ( ) { if ( ( ! sApp . isStreamingServiceRunning ( ) | | mStreamingServiceWoundDown ) & & ! mIsAudioFocusedOnThis ) {
private OutputsFragment initializeOutputsFragment ( ) { OutputsFragment fragment = ( OutputsFragment ) mFragmentManager . findFragmentByTag ( FRAGMENT_TAG_OUTPUTS ) ; if ( fragment = = null ) { fragment = new OutputsFragment ( ) ; final FragmentTransaction ft = getSupportFragmentManager ( ) . beginTransaction ( ) ; ft . setTransition ( FragmentTransaction . TRANSIT_FRAGMENT_OPEN ) ; ft . replace ( R . id . outputs_root_frame , fragment , FRAGMENT_TAG_OUTPUTS ) ; ft . commit ( ) ; } return fragment ; }
public MPDStatus getStatus ( ) throws MPDServerException { List < String > response = mpdConnection . sendCommand ( MPD_CMD_STATUS ) ; mpdStatus . updateStatus ( response ) ; return mpdStatus ; }
public void setVolume ( int volume ) throws MPDServerException { int vol = Math . max ( MPDCommand . MIN_VOLUME , Math . min ( MPDCommand . MAX_VOLUME , volume ) ) ; mpdConnection . sendCommand ( MPDCommand . MPD_CMD_SET_VOLUME , Integer . toString ( vol ) ) ; }
void writeComment ( String commentString , CharacterOutput output ) { List < String > comments = StringUtils . splitLines ( commentString ) ; for ( String comment : comments ) { writeIndent ( output ) ;
public void addPath ( final List < Sentence > path , final double dist ) { if ( dist < distance ) { this . path = path . toArray ( new Sentence [ path . size ( ) ] ) ;
private void readObject ( @Nonnull final ObjectInputStream aOIS ) throws ParseException , IOException , ClassNotFoundException { m_aContentType = new ContentType ( ( String ) aOIS . readObject ( ) ) ; m_aAttributes = ( Map < String , String > ) aOIS . readObject ( ) ; }
private String toStringIfNotNull ( Object item , String title ) { return item = = null ? " " : " \ n  " + title + " : \ n " + item . toString ( ) ;
protected void not_null ( Object obj ) throws internal_error { if ( obj = = null ) throw new internal_error ( " Null object used in set operation " ) ;
AttributeBatchContentEvent build ( ) { return new AttributeBatchContentEvent ( this ) ; }
public V remove ( Object key ) { return map . remove ( ( K ) key ) ; }
protected void fireTaskLink ( ) { final Task task = currentTaskLink . getTargetTask ( ) ; setCurrentTerm ( currentConcept . term ) ; setCurrentTaskLink ( currentTaskLink ) ; setCurrentBeliefLink ( null ) ; setCurrentTask ( task ) ; mem . logic . TASKLINK_FIRE . commit ( currentTaskLink . budget . getPriority ( ) ) ; emit ( Events . ConceptFire . class , currentConcept , currentTaskLink ) ; if ( currentTaskLink . type = = TermLink . TRANSFORM ) { setCurrentBelief ( null ) ;
public boolean equals ( final Object that ) { if ( this = = that ) return true ; if ( ! ( that instanceof CompoundTerm ) ) return false ; final CompoundTerm t = ( CompoundTerm ) that ; if ( hashCode ( ) ! = t . hashCode ( ) ) return false ; return name ( ) . equals ( t . name ( ) ) ; }
public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } enum AudioFocus { NoFocusNoDuck , NoFocusCanDuck , Focused } }
public void applyDataOntoMimeBodyPart ( @Nonnull final MimeBodyPart aPart ) throws MessagingException { if ( m_aDataByteArray ! = null ) { aPart . setDataHandler ( new DataHandler ( m_aDataByteArray , m_sContentType ) ) ; } else if ( m_sDataText ! = null ) { aPart . setText ( m_sDataText , m_aDataCharset = = null ? null : m_aDataCharset . name ( ) ) ; if ( m_sContentType ! = null ) aPart . setHeader ( CHTTPHeader . CONTENT_TYPE , m_sContentType ) ; } else if ( m_aDataHandler ! = null ) { aPart . setDataHandler ( m_aDataHandler ) ; } else throw new IllegalStateException ( " No data specified in AS2 client request! " ) ; if ( m_sFilename ! = null ) aPart . setFileName ( m_sFilename ) ; if ( m_eCTE ! = null ) aPart . setHeader ( CHTTPHeader . CONTENT_TRANSFER_ENCODING , m_eCTE . getID ( ) ) ; if ( StringHelper . hasText ( m_sContentDescription ) ) aPart . setHeader ( " Content-Description " , m_sContentDescription ) ;
public static Collection params ( ) { List l = new LinkedList ( ) ; for ( int i = 0 ; i < = 8 ; i + + ) l . add ( new Object [ ] { " nal1. " + i + " .nal " } ) ; return l ; }
private void handleConnectionFailure ( MPDCommandResult result , MPDServerException ex ) { try { result . setLastexception ( ex ) ;
public boolean tryAdvance ( Consumer < ? super ExternalV > action ) { return internalSpliterator . tryAdvance ( internalV - > action . accept ( readTransformation . apply ( internalV ) ) ) ;
public boolean contains ( K key ) { return list . contains ( key ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . BudgetPD p , A arg ) { return visitDefault ( p , arg ) ; } public R visitDefault ( com . googlecode . opennars . parser . loan . Loan . Absyn . Budget p , A arg ) {
public void verifyRemoval ( ) throws Exception { DummyListenableFuture < String > future = new DummyListenableFuture < String > ( false , service ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; final GenericCompletionListener listener = new GenericCompletionListener ( ) { @Override public void onComplete ( Future future ) throws Exception { latch . countDown ( ) ; } } ; future . addListener ( listener ) ; future . removeListener ( listener ) ; Thread . sleep ( 500 ) ; assertEquals ( 1 , latch . getCount ( ) ) ; }
private void jLabel2MouseClicked ( java . awt . event . MouseEvent evt ) { nars . tictactoe . play . main ( new String [ ] { } ) ; }
Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
private Image scaleImage ( Image before ) { int bw = before . getWidth ( this ) , bh = before . getHeight ( this ) ; int aw = snapwidth , ah = SNAPHEIGHT ; int bp [ ] = new int [ bw * bh ] , ap [ ] = new int [ aw * ah ] ; double rx = ( double ) bw / ( double ) aw , ry = ( double ) bh / ( double ) ah ; PixelGrabber bpp = new PixelGrabber ( before , 0 , 0 , bw , bh , bp , 0 , bw ) ; try { bpp . grabPixels ( ) ; } catch ( InterruptedException ie ) { System . out . println ( " interrupted waiting for pixels! " ) ; return null ; } if ( ( bpp . status ( ) & ImageObserver . ABORT ) ! = 0 ) { System . out . println ( " image fetch aborted or errored " ) ; return null ; } for ( int ar = 0 ; ar < ah ; ar + + ) { for ( int ac = 0 ; ac < aw ; ac + + ) { double ta = 0 , tr = 0 , tg = 0 , tb = 0 ; for ( int br = ( int ) Math . floor ( ar * ry ) ; br < ( int ) Math . ceil ( ( ar + 1 ) * ry ) ; br + + ) for ( int bc = ( int ) Math . floor ( ac * rx ) ; bc < ( int ) Math . ceil ( ( ac + 1 ) * rx ) ; bc + + ) { double xmin = Math . max ( bc , ac * rx ) ; double xmax = Math . min ( bc + 1 , ( ac + 1 ) * rx ) ; double ymin = Math . max ( br , ar * ry ) ; double ymax = Math . min ( br + 1 , ( ar + 1 ) * ry ) ; double fac = ( xmax - xmin ) * ( ymax - ymin ) ; int pix = br * bw + bc ; int r = ( bp [ pix ] & 0xff0000 ) > > 16 ; int g = ( bp [ pix ] & 0xff00 ) > > 8 ; int b = bp [ pix ] & 0xff ; tr + = ( double ) r * fac ; tg + = ( double ) g * fac ; tb + = ( double ) b * fac ; } double area = rx * ry ; ap [ ar * aw + ac ] = 0xff000000 | ( ( int ) Math . round ( tr / area ) < < 16 ) | ( ( int ) Math . round ( tg / area ) < < 8 ) | ( int ) Math . round ( tb / area ) ; } } Image after = createImage ( new MemoryImageSource ( aw , ah , ap , 0 , aw ) ) ; System . out . println ( after + "    " + after . getWidth ( this ) + " , " + after . getHeight ( this ) ) ; return after ; }
static TruthValue implied ( TruthValue v1 ) { float f1 = v1 . getFrequency ( ) ; float c1 = v1 . getConfidence ( ) ; float c = w2c ( c1 ) ; return new TruthValue ( f1 , c ) ; }
private void buildExpandedNotification ( ) { final PendingIntent previousAction = buildPendingIntent ( MPDControl . ACTION_PREVIOUS ) ; final RemoteViews resultView = new RemoteViews ( mServiceContext . getPackageName ( ) , R . layout . notification_big ) ; buildBaseNotification ( resultView ) ; resultView . setOnClickPendingIntent ( R . id . notificationPrev , previousAction ) ; mNotification . bigContentView = resultView ; }
void onCreate ( int id ) ; Processor newProcessor ( Processor p ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( super . toString ( ) ) . append ( "   " ) ; builder . append ( " sum= " ) . append ( sum ) ; return builder . toString ( ) ; }
public static ICryptoHelper getCryptoHelper ( ) { return SingletonHolder . s_aInstance ; }
public void start ( final long minTickPeriodMS ) { if ( thread = = null ) { thread = new Thread ( this , " Inference " ) ; thread . start ( ) ; } this . minTickPeriodMS = minTickPeriodMS ; running = true ; }
public static Collection params ( ) { final Map < String , Object > et = ExampleFileInput . getUnitTests ( ) ; final Collection t = et . values ( ) ; for ( final String x : et . keySet ( ) ) addTest ( x ) ; return t ; }
KeyStore getKeyStore ( ) throws Exception ; KeyStore loadKeyStore ( InputStream in , char [ ] password ) throws Exception ; KeyStore loadKeyStore ( String filename , char [ ] password ) throws Exception ; boolean isSigned ( MimeBodyPart part ) throws Exception ; String calculateMIC ( MimeBodyPart part , String digest , boolean includeHeaders ) throws Exception ; MimeBodyPart decrypt ( MimeBodyPart part , Certificate cert , Key key ) throws Exception ; MimeBodyPart encrypt ( MimeBodyPart part , Certificate cert , String algorithm ) throws Exception ; MimeBodyPart sign ( MimeBodyPart part , Certificate cert , Key key , String sAlgorithm ) throws Exception ; MimeBodyPart verify ( MimeBodyPart part , Certificate cert ) throws Exception ; }
public void test_agent_file_1_3 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch(agent_file(text), error(existence_error(ObjectType, Culprit), existence_error(Goal, ArgNo, ObjectType, Culprit, Message)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . match ( new Struct ( " text_from_file " , new Struct ( " text " ) , new Var ( " Y " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 1 ) ; Struct validType = ( Struct ) info . getTerm ( " ObjectType " ) ; assertTrue ( validType . isEqual ( new Struct ( " stream " ) ) ) ; Struct culprit = ( Struct ) info . getTerm ( " Culprit " ) ; assertTrue ( culprit . isEqual ( new Struct ( " text " ) ) ) ; Term message = info . getTerm ( " Message " ) ; assertTrue ( message . isEqual ( new Struct ( " File not found. " ) ) ) ; }
public static void cleanupSpec ( ) { if ( s_aMongoClient ! = null ) s_aMongoClient . close ( ) ; if ( s_aMongodExecutable ! = null ) s_aMongodExecutable . close ( ) ;
protected static Set < String > getKeysByValue ( final Map < String , Set < String > > map , final String val ) { final Set < String > result = new HashSet < > ( ) ; final Set < String > keys = map . keySet ( ) ; for ( final String k : keys ) { final Set < String > values = map . get ( k ) ; if ( val ! = null & & val . isEmpty ( ) | | values . contains ( val ) ) { result . add ( k ) ; } } return result ; }
CASResponse cas ( String key , long casId , Object value ) ; CASResponse cas ( String key , long casId , int exp , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public boolean validate ( ) { Node < T > node = head ; if ( node = = null ) return true ; int level = node . getLevel ( ) ; for ( int i = level ; i > = 0 ; i - - ) { Node < T > prev = null ; while ( node ! = null ) { if ( prev ! = null & & ( node . value . compareTo ( prev . value ) = = - 1 ) ) { System . err . println ( " List is not in order. " ) ; return false ; } prev = node ; node = node . getNext ( i ) ; } } return true ; }
public void test_$append_2_1 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch('$append'(a, X), error(instantiation_error, instantiation_error(Goal, ArgNo)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " $append " , new Struct ( " a " ) , new Var ( " X " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 2 ) ; }
private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; }
public void test_unload_library_1_1 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch(unload_library(X), error(instantiation_error, instantiation_error(Goal, ArgNo)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " unload_library " , new Var ( " X " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 1 ) ; }
public D query ( long start , long end , D result ) { for ( long i = start ; i < = end ; i + + ) { D r = ( this . query ( i , result ) ) ; if ( r = = null ) { } else if ( result = = null ) { result = ( D ) r . copy ( ) ; } else if ( r ! = null ) { result . combined ( r ) ; } } return result ; }
private void applyBorderLayout ( JScrollPane textScrollPane ) { setLayout ( new BorderLayout ( ) ) ; add ( textScrollPane , BorderLayout . CENTER ) ; JPanel bottomPanel = new JPanel ( ) ; add ( bottomPanel , BorderLayout . SOUTH ) ; bottomPanel . add ( valueLabel ) ; bottomPanel . add ( valueBar ) ; bottomPanel . add ( playButton ) ; bottomPanel . add ( stopButton ) ; bottomPanel . add ( closeButton ) ; }
static void initializeUDFs ( Config config ) { if ( ! config . hasPath ( UDFS_SECTION_CONFIG ) ) return ; ConfigList udfList = config . getList ( UDFS_SECTION_CONFIG ) ; for ( ConfigValue udfValue : udfList ) { ConfigValueType udfValueType = udfValue . valueType ( ) ;
public void testGetAllDependentSteps ( ) { Step step1 = new BatchStep ( " step1 " , ConfigFactory . empty ( ) . withValue ( " dependencies " , ConfigValueFactory . fromIterable ( Sets . newHashSet ( ) ) ) ) ; Step step2 = new BatchStep ( " step2 " , ConfigFactory . empty ( ) . withValue ( " dependencies " , ConfigValueFactory . fromIterable ( Sets . newHashSet ( " step1 " ) ) ) ) ; Step step3 = new BatchStep ( " step3 " , ConfigFactory . empty ( ) . withValue ( " dependencies " , ConfigValueFactory . fromIterable ( Sets . newHashSet ( " step2 " ) ) ) ) ; Step step4 = new BatchStep ( " step4 " , ConfigFactory . empty ( ) . withValue ( " dependencies " , ConfigValueFactory . fromIterable ( Sets . newHashSet ( " step3 " ) ) ) ) ; Step step5 = new BatchStep ( " step5 " , ConfigFactory . empty ( ) . withValue ( " dependencies " , ConfigValueFactory . fromIterable ( Sets . newHashSet ( ) ) ) ) ; Step step6 = new BatchStep ( " step6 " , ConfigFactory . empty ( ) . withValue ( " dependencies " , ConfigValueFactory . fromIterable ( Sets . newHashSet ( " step5 " ) ) ) ) ; Set < Step > steps = Sets . newHashSet ( step1 , step2 , step3 , step4 , step5 , step6 ) ; Set < Step > step1AllDependents = StepUtils . getAllDependentSteps ( step1 , steps ) ; Set < Step > step2AllDependents = StepUtils . getAllDependentSteps ( step2 , steps ) ; Set < Step > step3AllDependents = StepUtils . getAllDependentSteps ( step3 , steps ) ; Set < Step > step4AllDependents = StepUtils . getAllDependentSteps ( step4 , steps ) ; Set < Step > step5AllDependents = StepUtils . getAllDependentSteps ( step5 , steps ) ; Set < Step > step6AllDependents = StepUtils . getAllDependentSteps ( step6 , steps ) ; assertEquals ( step1AllDependents . size ( ) , 3 ) ; assertEquals ( step2AllDependents . size ( ) , 2 ) ; assertEquals ( step3AllDependents . size ( ) , 1 ) ; assertEquals ( step4AllDependents . size ( ) , 0 ) ; assertEquals ( step5AllDependents . size ( ) , 1 ) ; assertEquals ( step6AllDependents . size ( ) , 0 ) ; assertEquals ( step1AllDependents , Sets . newHashSet ( step2 , step3 , step4 ) ) ; assertEquals ( step2AllDependents , Sets . newHashSet ( step3 , step4 ) ) ; assertEquals ( step3AllDependents , Sets . newHashSet ( step4 ) ) ; assertEquals ( step4AllDependents , Sets . newHashSet ( ) ) ; assertEquals ( step5AllDependents , Sets . newHashSet ( step6 ) ) ; assertEquals ( step6AllDependents , Sets . newHashSet ( ) ) ; }
Collection < StatsSession > getSessions ( ) ; Collection < StatsSession > getSessions ( StatsKeyMatcher keyMatcher ) ; StatsSession getSession ( StatsKey key ) ; StatsSession getOrCreateSession ( StatsKey key ) ; StatsSession remove ( StatsKey key ) ; boolean remove ( StatsSession session ) ; void clear ( ) ; void clearAllSessions ( ) ; }
R visit ( ImageInt p , A arg ) ; R visit ( Implication p , A arg ) ; R visit ( ImplicationAfter p , A arg ) ; R visit ( ImplicationBefore p , A arg ) ; R visit ( Inheritance p , A arg ) ; R visit ( Instance p , A arg ) ; R visit ( InstanceProperty p , A arg ) ; R visit ( IntersectionExt p , A arg ) ; R visit ( IntersectionInt p , A arg ) ; R visit ( Negation p , A arg ) ; R visit ( NumericLiteral p , A arg ) ; R visit ( Product p , A arg ) ; R visit ( Property p , A arg ) ; R visit ( SetExt p , A arg ) ; R visit ( SetInt p , A arg ) ; R visit ( Similarity p , A arg ) ; R visit ( TenseFuture p , A arg ) ; R visit ( TensePast p , A arg ) ; R visit ( TensePresent p , A arg ) ; R visit ( StringLiteral p , A arg ) ; R visit ( URIRef p , A arg ) ; R visit ( Variable p , A arg ) ; R visit ( Term p , A arg ) ; }
@Override public String toParamString ( ) { return o . getClass ( ) . getSimpleName ( ) ; }
protected void addNewTask ( final Task t , final String reason ) { newTasks . add ( t ) ; if ( recorder . isActive ( ) ) { recorder . onTaskAdd ( t , reason ) ;
public lalr_item shift ( ) throws internal_error { lalr_item result ; if ( dot_at_end ( ) ) throw new internal_error ( " Attempt to shift past end of an lalr_item " ) ; result = new lalr_item ( the_production ( ) , dot_pos ( ) + 1 , new terminal_set ( lookahead ( ) ) ) ; add_propagate ( result ) ; return result ; }
public void addToPlaylist ( String playlistName , Collection < Music > c ) throws MPDServerException { if ( null = = c | | c . size ( ) < 1 ) { return ; } for ( Music m : c ) { getMpdConnection ( ) . queueCommand ( MPD_CMD_PLAYLIST_ADD , playlistName , m . getFullpath ( ) ) ; } getMpdConnection ( ) . sendCommandQueue ( ) ; }
int UpdateSOM ( float [ ] viewField , float reward ) { lastAction = 0 ; k + + ; if ( k % 4 = = 0 ) { nar . addInput ( " <{SELF} --> [good]>! :|: " ) ; } if ( k % 4 = = 0 ) { Sentence hypo_left = ConceptMonitor . strongestPrecondition ( nar , " <{SELF} --> [good]> " , " <(&/,<{left} --> [on]>,+1,(^Right,{SELF}),+1) =/> <{SELF} --> [good]>> " ) ; if ( hypo_left ! = null ) { System . out . println ( " HypLeftWrong:  " + hypo_left . truth ) ; } Sentence hypo_right = ConceptMonitor . strongestPrecondition ( nar , " <{SELF} --> [good]> " , " <(&/,<{right} --> [on]>,+12,(^Left,{SELF}),+13) =/> <{SELF} --> [good]>> " ) ; if ( hypo_right ! = null ) { System . out . println ( " HypRightWrong:  " + hypo_right . truth ) ; } Sentence hypo_left_false = ConceptMonitor . strongestPrecondition ( nar , " <{SELF} --> [good]> " , " <(&/,<{left} --> [on]>,+1,(^Left,{SELF}),+1) =/> <{SELF} --> [good]>> " ) ; if ( hypo_left_false ! = null ) { System . out . println ( " HypLeft:  " + hypo_left_false . truth ) ; } Sentence hypo_right_false = ConceptMonitor . strongestPrecondition ( nar , " <{SELF} --> [good]> " , " <(&/,<{right} --> [on]>,+12,(^Right,{SELF}),+13) =/> <{SELF} --> [good]>> " ) ; if ( hypo_right_false ! = null ) { System . out . println ( " HypRight:  " + hypo_right_false . truth ) ; } } if ( k % 20 = = 0 ) { this . LastInput = " " ; } float middle_distance = 100.0f ; if ( Math . abs ( agent . x - ball . x ) < middle_distance ) { if ( Math . abs ( agent . x - ball . x ) < middle_distance & & ball . y < 120 ) { String s = " <{SELF} --> [good]>. :|: " ; if ( ! s . equals ( this . LastInput ) ) { System . out . println ( " good mr_nars " ) ; nar . addInput ( s ) ; System . out . println ( s ) ; } this . LastInput = s ; } else { String s = " <{middle} --> [on]>. :|: " ; if ( ! s . equals ( this . LastInput ) ) { nar . addInput ( s ) ; } this . LastInput = s ; } } else { if ( agent . x < ball . x ) { String s = " <{right} --> [on]>. :|: " ; if ( ! s . equals ( this . LastInput ) ) { nar . addInput ( s ) ; System . out . println ( s ) ; } this . LastInput = s ; } else { String s = " <{left} --> [on]>. :|: " ; if ( ! s . equals ( this . LastInput ) ) { nar . addInput ( s ) ; System . out . println ( s ) ; } this . LastInput = s ; } } nar . step ( 10 ) ; if ( lastAction = = 0 & & random ( 1.0f ) < Alpha ) { lastAction = ( int ) random ( ( float ) nActions ) ; if ( obj . x = = 0 ) { lastAction = 1 ; } if ( obj . x = = width ) { lastAction = 2 ; } if ( lastAction = = 1 ) { nar . addInput ( " Right({SELF}). :|: " ) ; } if ( lastAction = = 2 ) { nar . addInput ( " Left({SELF}). :|: " ) ; } } return lastAction ; }
static TempSharedFileInputStream getTempSharedFileInputStream ( @Nonnull final InputStream aIS , final String name ) throws IOException { final File aDest = storeContentToTempFile ( aIS , name ) ; return new TempSharedFileInputStream ( aDest , aIS ) ; }
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; setContentView ( R . layout . playlist_removelist_activity ) ; this . setTitle ( " Edit playlist " ) ; try { MPDPlaylist playlist = app . oMPDAsyncHelper . oMPD . getPlaylist ( ) ; playlist . refresh ( ) ; musics = playlist . getMusics ( ) ; for ( Music m : musics ) { HashMap < String , Object > item = new HashMap < String , Object > ( ) ; item . put ( " songid " , m . getSongId ( ) ) ; item . put ( " artist " , m . getArtist ( ) ) ; item . put ( " title " , m . getTitle ( ) ) ; item . put ( " marked " , false ) ; if ( m . getSongId ( ) = = app . oMPDAsyncHelper . oMPD . getStatus ( ) . getSongId ( ) ) item . put ( " play " , android . R . drawable . ic_media_play ) ; else item . put ( " play " , 0 ) ; songlist . add ( item ) ; } SimpleAdapter songs = new SimpleAdapter ( this , songlist , R . layout . playlist_removelist_item , new String [ ] { " play " , " title " , " artist " , " marked " } , new int [ ] { R . id . picture , android . R . id . text1 , android . R . id . text2 , R . id . removeCBox } ) ; setListAdapter ( songs ) ; } catch ( MPDServerException e ) { } app . oMPDAsyncHelper . addStatusChangeListener ( this ) ; ListView trackList = getListView ( ) ; trackList . setOnCreateContextMenuListener ( this ) ; ( ( TouchInterceptor ) trackList ) . setDropListener ( mDropListener ) ; ( ( TouchInterceptor ) trackList ) . setRemoveListener ( mRemoveListener ) ; trackList . setCacheColorHint ( 0 ) ; Button button = ( Button ) findViewById ( R . id . Remove ) ; button . setOnClickListener ( this ) ; button = ( Button ) findViewById ( R . id . Cancel ) ; button . setOnClickListener ( this ) ;
public String toString ( ) { final int argsLength = args . toString ( ) . length ( ) ; final int approximateLength = argsLength + argsLength * ( command . length ( ) + 10 ) ; final StringBuffer outBuf = new StringBuffer ( approximateLength ) ; outBuf . append ( command ) ; for ( String arg : args ) { if ( arg = = null ) { continue ; } arg = QUOTATION_DELIMITER . matcher ( arg ) . replaceAll ( " \\ \\ \" " ) ; outBuf . append ( "   \" " ) ; outBuf . append ( arg ) ; outBuf . append ( '"' ) ; } outBuf . append ( '\n' ) ; final String outString = outBuf . toString ( ) ; if ( DEBUG ) { Log . d ( " JMPDComm " , " Mpd command :  " + ( outString . startsWith ( " password  " ) ? " password **censored** " : outString ) ) ; } return outString ; }
public static void main ( String [ ] args ) throws Exception { NAR n = new NAR ( ) ; new TextOutput ( n , System . out ) ; new NARSwing ( n ) ; new OWLInput ( n , " /home/me/Downloads/schemaorg.owl " ) ;
public void updateEntranceProcessingItem ( ParallelEntranceProcessingItem epi ) { for ( IProcessingItem pi : listProcessingItem ) { if ( pi instanceof ParallelMasterProcessingItem ) {
public boolean equalsOne ( ) { return ( value + 50 ) > = 10000 ; }
public int processNewTasks ( int maxTasks , Collection < Runnable > queue ) { if ( maxTasks = = 0 ) return 0 ; int processed = 0 ; int numTasks = Math . min ( maxTasks , newTasks . size ( ) ) ; for ( int i = 0 ; ( ! newTasks . isEmpty ( ) ) & & ( i < numTasks ) ; i + + ) { final Task task = newTasks . removeFirst ( ) ; processed + + ; emotion . adjustBusy ( task . getPriority ( ) , task . getDurability ( ) ) ; if ( task . isInput ( ) | | concept ( task . sentence . content ) ! = null | | ! task . sentence . isJudgment ( ) ) { queue . add ( new ImmediateProcess ( this , task , numTasks - 1 ) ) ; } else { final Sentence s = task . sentence ; if ( ( s ! = null ) & & ( s . isJudgment ( ) ) ) { final double exp = s . truth . getExpectation ( ) ; if ( exp > Parameters . DEFAULT_CREATION_EXPECTATION ) { logic . TASK_ADD_NOVEL . commit ( ) ; Task displacedNovelTask = novelTasks . putIn ( task ) ; if ( displacedNovelTask ! = null ) { if ( displacedNovelTask = = task ) { removeTask ( task , " Ignored " ) ; } else { removeTask ( displacedNovelTask , " Displaced novel task " ) ; } } } else { removeTask ( task , " Neglected " ) ; } } } } return processed ; }
public static com . cloudera . labs . envelope . input . translate . ProtobufMultipleMessage . MultipleExample parseFrom ( com . google . protobuf . ByteString data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
public void initDynamicComponent ( @Nonnull final ISession session , @Nullable final IStringMap parameters ) throws OpenAS2Exception { super . initDynamicComponent ( session , parameters ) ; refresh ( ) ; }
public void reinitKeyStore ( ) throws AS2Exception { debugLog ( ( ) - > " reinitKeyStore () " ) ; initEmptyKeyStore ( ) ; final String sFilename = getFilename ( ) ; if ( StringHelper . hasText ( sFilename ) ) load ( sFilename , getPassword ( ) ) ; debugLog ( ( ) - > " reinitKeyStore -> done " ) ; }
long getOpQueueMaxBlockTime ( ) ; NodeLocator createLocator ( List < MemcachedNode > nodes ) ; OperationFactory getOperationFactory ( ) ; long getOperationTimeout ( ) ; boolean isDaemon ( ) ; boolean useNagleAlgorithm ( ) ; Collection < ConnectionObserver > getInitialObservers ( ) ; FailureMode getFailureMode ( ) ; Transcoder < Object > getDefaultTranscoder ( ) ; boolean shouldOptimize ( ) ; int getReadBufSize ( ) ; public HashAlgorithm getHashAlg ( ) ; long getMaxReconnectDelay ( ) ; AuthDescriptor getAuthDescriptor ( ) ; int getTimeoutExceptionThreshold ( ) ; }
public Concept concept ( Term term ) ; public Concept addConcept ( Term term , Memory memory ) ; public void activate ( Concept c , BudgetValue b ) ; public void forget ( Concept c ) ; public Concept sampleNextConcept ( ) ; }
static void analogy ( Term subj , Term pred , Sentence asym , Sentence sym , int figure , DerivationContext nal ) { if ( Statement . invalidStatement ( subj , pred ) ) { return ; } int order1 = asym . term . getTemporalOrder ( ) ; int order2 = sym . term . getTemporalOrder ( ) ; int order = analogyOrder ( order1 , order2 , figure ) ; if ( order = = ORDER_INVALID ) { return ; } Statement st = ( Statement ) asym . term ; TruthValue truth = null ; BudgetValue budget ; Sentence sentence = nal . getCurrentTask ( ) . sentence ; CompoundTerm taskTerm = ( CompoundTerm ) sentence . term ; if ( sentence . isQuestion ( ) | | sentence . isQuest ( ) ) { if ( taskTerm . isCommutative ( ) ) { if ( asym . truth = = null ) { return ; } budget = BudgetFunctions . backwardWeak ( asym . truth , nal ) ; } else { if ( sym . truth = = null ) { return ; } budget = BudgetFunctions . backward ( sym . truth , nal ) ; } } else { if ( sentence . isGoal ( ) ) { if ( taskTerm . isCommutative ( ) ) { truth = TruthFunctions . desireWeak ( asym . truth , sym . truth ) ; } else { truth = TruthFunctions . desireStrong ( asym . truth , sym . truth ) ; } } else { truth = TruthFunctions . analogy ( asym . truth , sym . truth ) ; } budget = BudgetFunctions . forward ( truth , nal ) ; } nal . doublePremiseTask ( Statement . make ( st , subj , pred , order ) , truth , budget , false , true ) ; }
public Iterator < Term > iterator ( ) { return Iterators . forArray ( term ) ; }
public void testReadContentTransferEncodingBase64 ( ) throws MessagingException , IOException { final String sHTTP = " Content-Type: text/plain " + HTTPHelper . EOL + " Content-Transfer-Encoding: base64 " + HTTPHelper . EOL + " x-custom: junit " + HTTPHelper . EOL + " Content-Length: 44 " + HTTPHelper . EOL + HTTPHelper . EOL + " VGVzdCBtZXNzYWdlCkxpbmUgMgoKTGluZSA0CkVPRg== " + HTTPHelper . EOL ; InputStream aIS = new StringInputStream ( sHTTP , StandardCharsets . ISO_8859_1 ) ; final InternetHeaders aHeaders = new InternetHeaders ( aIS ) ; final String sCTE = aHeaders . getHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING ) [ 0 ] ; if ( StringHelper . hasText ( sCTE ) ) aIS = MimeUtility . decode ( aIS , sCTE ) ; final byte [ ] aData = StreamHelper . getAllBytes ( aIS ) ; final ContentType aReceivedContentType = new ContentType ( aHeaders . getHeader ( CAS2Header . HEADER_CONTENT_TYPE ) [ 0 ] ) ; final String sReceivedContentType = aReceivedContentType . toString ( ) ; final MimeBodyPart aReceivedPart = new MimeBodyPart ( ) ; aReceivedPart . setDataHandler ( new ByteArrayDataSource ( aData , sReceivedContentType , null ) . getAsDataHandler ( ) ) ; aReceivedPart . setHeader ( " x-received " , " true " ) ; final NonBlockingByteArrayOutputStream aBAOS = new NonBlockingByteArrayOutputStream ( ) ; aReceivedPart . writeTo ( aBAOS ) ; StreamHelper . close ( aBAOS ) ; final String sMsgPart = aBAOS . getAsString ( StandardCharsets . ISO_8859_1 ) ; if ( true ) s_aLogger . info ( sMsgPart ) ;
public void writeJsonArray ( Collection < ? > collection , CharacterOutput output ) { if ( collection . isEmpty ( ) ) { output . write ( EMPTY_ARRAY ) ; return ; } Iterator < ? > it = collection . iterator ( ) ; output . write ( '[' ) ; while ( true ) { Object value = it . next ( ) ; writeJsonValue ( value , output ) ; if ( it . hasNext ( ) ) { output . write ( ',' ) ; } else { break ; } } output . write ( ']' ) ; }
public void connectionStateChanged ( MPDConnectionStateChangedEvent event ) { } @Override public void playlistChanged ( MPDPlaylistChangedEvent event ) { } @Override public void randomChanged ( MPDRandomChangedEvent event ) { } @Override public void repeatChanged ( MPDRepeatChangedEvent event ) { } @Override public void stateChanged ( MPDStateChangedEvent event ) { } @Override public void updateStateChanged ( MPDUpdateStateChangedEvent event ) { } @Override public void volumeChanged ( MPDVolumeChangedEvent event ) { } }
String getContentDisposition ( ) ; void setContentDisposition ( @Nullable String sContentDisposition ) ; @Nullable String getSubject ( ) ; void setSubject ( @Nullable String sSubject ) ; @Nullable MimeBodyPart getData ( ) ; void setData ( @Nullable MimeBodyPart aData , @Nullable DataHistoryItem aHistoryItem ) throws OpenAS2Exception ; @Nonnull DataHistoryItem setData ( @Nonnull MimeBodyPart aData ) throws OpenAS2Exception ; @Nullable IMessageMDN getMDN ( ) ; void setMDN ( @Nullable IMessageMDN aMDN ) ; @Nonnull @Nonempty String getLoggingText ( ) ; @Nonnull @ReturnsMutableObject ( " design " ) DataHistory getHistory ( ) ; String getProtocol ( ) ; boolean isRequestingMDN ( ) ; boolean isRequestingAsynchMDN ( ) ; }
public void run ( ) { version . setSummary ( versionText ) ; artists . setSummary ( artistsText ) ; albums . setSummary ( albumsText ) ; songs . setSummary ( songsText ) ; }
public boolean dispatchPopulateAccessibilityEvent ( AccessibilityEvent event ) { onPopulateAccessibilityEvent ( event ) ; return true ; }
public void onClick ( View v ) { popupSongID = ( Integer ) v . getTag ( ) ; popupMenu = new PopupMenu ( activity , v ) ; popupMenu . getMenuInflater ( ) . inflate ( R . menu . mpd_playlistcnxmenu , popupMenu . getMenu ( ) ) ; popupMenu . setOnMenuItemClickListener ( PlaylistFragment . this ) ; popupMenu . show ( ) ; }
syntaxEnable9 . addActionListener ( new ActionListener ( ) { @Override public void actionPerformed ( ActionEvent e ) { cells . click ( syntaxEnable9 . getLabel ( ) ) ; } } ) ; menu . add ( syntaxEnable9 ) ;
static void writeBasic ( String str , CharacterOutput output ) { output . write ( '\"' ) ; for ( char c : str . toCharArray ( ) ) { writeBasicChar ( c , output ) ; } output . write ( '\"' ) ; }
static BudgetValue revise ( final TruthValue tTruth , final TruthValue bTruth , final TruthValue truth , final boolean feedbackToLinks , final org . opennars . control . DerivationContext nal ) { final float difT = truth . getExpDifAbs ( tTruth ) ; final Task task = nal . getCurrentTask ( ) ; task . decPriority ( 1 - difT ) ; task . decDurability ( 1 - difT ) ; if ( feedbackToLinks ) { TaskLink tLink = nal . getCurrentTaskLink ( ) ; tLink . decPriority ( 1 - difT ) ; tLink . decDurability ( 1 - difT ) ; TermLink bLink = nal . getCurrentBeliefLink ( ) ; final float difB = truth . getExpDifAbs ( bTruth ) ; bLink . decPriority ( 1 - difB ) ; bLink . decDurability ( 1 - difB ) ; } float dif = truth . getConfidence ( ) - max ( tTruth . getConfidence ( ) , bTruth . getConfidence ( ) ) ; float priority = or ( dif , task . getPriority ( ) ) ; float durability = aveAri ( dif , task . getDurability ( ) ) ; float quality = truthToQuality ( truth ) ; return new BudgetValue ( priority , durability , quality ) ; }
public void initTest ( boolean deserialized ) { m_speed = 3.0f ; if ( deserialized ) { return ; } Body ground = null ; { BodyDef bd = new BodyDef ( ) ; ground = getWorld ( ) . createBody ( bd ) ; EdgeShape shape = new EdgeShape ( ) ; shape . set ( new Vec2 ( - 20.0f , 0.0f ) , new Vec2 ( 20.0f , 0.0f ) ) ; FixtureDef fd = new FixtureDef ( ) ; fd . shape = shape ; ground . createFixture ( fd ) ; } { BodyDef bd = new BodyDef ( ) ; bd . type = BodyType . DYNAMIC ; bd . position . set ( 0.0f , 3.0f ) ; m_attachment = getWorld ( ) . createBody ( bd ) ; PolygonShape shape = new PolygonShape ( ) ; shape . setAsBox ( 0.5f , 2.0f ) ; m_attachment . createFixture ( shape , 2.0f ) ; } { BodyDef bd = new BodyDef ( ) ; bd . type = BodyType . DYNAMIC ; bd . position . set ( - 4.0f , 5.0f ) ; m_platform = getWorld ( ) . createBody ( bd ) ; PolygonShape shape = new PolygonShape ( ) ; shape . setAsBox ( 0.5f , 4.0f , new Vec2 ( 4.0f , 0.0f ) , 0.5f * MathUtils . PI ) ; FixtureDef fd = new FixtureDef ( ) ; fd . shape = shape ; fd . friction = 0.6f ; fd . density = 2.0f ; m_platform . createFixture ( fd ) ; RevoluteJointDef rjd = new RevoluteJointDef ( ) ; rjd . initialize ( m_attachment , m_platform , new Vec2 ( 0.0f , 5.0f ) ) ; rjd . maxMotorTorque = 50.0f ; rjd . enableMotor = true ; getWorld ( ) . createJoint ( rjd ) ; PrismaticJointDef pjd = new PrismaticJointDef ( ) ; pjd . initialize ( ground , m_platform , new Vec2 ( 0.0f , 5.0f ) , new Vec2 ( 1.0f , 0.0f ) ) ; pjd . maxMotorForce = 1000.0f ; pjd . enableMotor = true ; pjd . lowerTranslation = - 10.0f ; pjd . upperTranslation = 10.0f ; pjd . enableLimit = true ; getWorld ( ) . createJoint ( pjd ) ; } { BodyDef bd = new BodyDef ( ) ;
public void run ( ) { try { app . oMPDAsyncHelper . oMPD . previous ( ) ;
public void frame ( int cycles ) { long timeStart = System . currentTimeMillis ( ) ; emit ( FrameStart . class ) ; updatePorts ( ) ; try { for ( int i = 0 ; i < cycles ; i + + ) memory . cycle ( this ) ; } catch ( Throwable e ) { if ( Parameters . SHOW_REASONING_ERRORS ) { emit ( ERR . class , e ) ; } if ( Parameters . DEBUG ) { e . printStackTrace ( ) ; } } emit ( FrameEnd . class ) ; }
public boolean add ( String key , int value ) { int length = ( key . length ( ) - 1 ) ; Node prev = root ; for ( int i = 0 ; i < length ; i + + ) { Node n = null ; char c = key . charAt ( i ) ; if ( prev . children . containsKey ( c ) ) { n = prev . children . get ( c ) ; } else { n = new Node ( c ) ; prev . children . put ( c , n ) ; } prev = n ; } Node n = null ; char c = key . charAt ( length ) ; if ( prev . children . containsKey ( c ) ) { n = prev . children . get ( c ) ;
public static com . cloudera . labs . envelope . input . translate . ProtobufSingleMessage . SingleExample parseDelimitedFrom ( java . io . InputStream input ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input ) ;
public Dataset < Row > check ( Dataset < Row > dataset , Map < String , Dataset < Row > > stepDependencies ) { boolean schemasMatch = schemasMatch ( requiredSchema , dataset . schema ( ) , exactMatch ) ; List < Row > datasetRows = Lists . newArrayList ( ( Row ) new RowWithSchema ( SCHEMA , name , schemasMatch ) ) ; return Contexts . getSparkSession ( ) . createDataFrame ( datasetRows , SCHEMA ) ; }
public < T > Map < StatsKey , T > filterToMap ( final Collection < ? extends StatsKeyAssociation < T > > associations ) { Map < StatsKey , T > filteredMap = new HashMap < StatsKey , T > ( associations . size ( ) / 2 ) ; StatsKey key ; for ( StatsKeyAssociation < T > ka : associations ) { key = ka . getKey ( ) ; if ( matches ( key ) ) { filteredMap . put ( key , ka . getValue ( ) ) ; } } return Collections . unmodifiableMap ( filteredMap ) ; }
public static ContentType parseContentType ( @Nullable final String sContentType ) { if ( StringHelper . hasText ( sContentType ) ) try { return new ContentType ( sContentType ) ; } catch ( final ParseException ex ) { if ( LOGGER . isDebugEnabled ( ) ) LOGGER . debug ( " Error parsing Content-Type " , ex ) ; } return null ; }
public String toString ( ) { switch ( type ) { case 0 : return " ENEMY " ; case 1 : return " ENEMY " ; case 2 : return " ENEMY " ; case 3 : return " ENEMY " ; case 4 : return " ENEMY " ; } return super . toString ( ) ; }
public void onCreate ( Bundle icicle ) { super . onCreate ( icicle ) ; if ( icicle ! = null ) init ( ( Artist ) icicle . getParcelable ( EXTRA_ARTIST ) , ( Album ) icicle . getParcelable ( EXTRA_ALBUM ) ) ;
public void clear ( ) { product . set ( 1 ) ; sumOfInverses . set ( 0 ) ; sumOfSquares . set ( 0 ) ; }
public void knapsack ( ) { int [ ] values = { 7 , 4 , 8 , 6 , 2 , 5 } ; int [ ] weights = { 2 , 3 , 5 , 4 , 2 , 3 } ; int capacity = 9 ; int [ ] result = Knapsack . zeroOneKnapsack ( values , weights , capacity ) ; int [ ] check = new int [ ] { 5 , 3 , 0 } ; for ( int i = 0 ; i < result . length ; i + + ) { int r = result [ i ] ;
public void writeTo ( final Object obj , final String sMimeType , @Nonnull final OutputStream aOS ) throws IOException { if ( obj instanceof MimeBodyPart ) {
public static void unregisterMediaButtonEventReceiverCompat ( AudioManager audioManager , ComponentName receiver ) { if ( sMethodUnregisterMediaButtonEventReceiver = = null ) return ; try { sMethodUnregisterMediaButtonEventReceiver . invoke ( audioManager , receiver ) ;
public boolean isEnabled ( int position ) { return dataBinder . isEnabled ( position , items , getItem ( position ) ) ; }
public static void main ( String [ ] args ) throws Exception { NAR n = new DefaultNARBuilder ( ) . setConceptBagSize ( 2048 ) . setConceptBagLevels ( 512 ) . build ( ) ; n . param . setSilenceLevel ( 99 ) ; KIFInput k = new KIFInput ( n , " /home/me/sigma/KBs/Merge.kif " ) ; k . setIncludeSubclass ( true ) ; k . start ( ) ; TextOutput t = new TextOutput ( n , System . out ) ; t . setErrors ( true ) ; t . setErrorStackTrace ( true ) ; n . finish ( 16 ) ; new NARSwing ( n ) ; System . err . println ( new NARState ( n ) . measure ( ) ) ; }
public void onDestroyView ( ) { mCoverArt . setImageResource ( AlbumCoverDownloadListener . getNoCoverResource ( ) ) ; mCoverDownloadListener . freeCoverDrawable ( ) ; super . onDestroyView ( ) ; }
protected void onCreate ( Bundle arg0 ) { super . onCreate ( arg0 ) ; setContentView ( R . layout . main_activity ) ; }
OperationState getState ( ) ; ByteBuffer getBuffer ( ) ; void writing ( ) ; void writeComplete ( ) ; void initialize ( ) ; void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; MemcachedNode getHandlingNode ( ) ; void setHandlingNode ( MemcachedNode to ) ; void timeOut ( ) ; boolean isTimedOut ( ) ; boolean isTimedOut ( long ttlMillis ) ; boolean isTimedOutUnsent ( ) ; long getWriteCompleteTimestamp ( ) ; byte [ ] getErrorMsg ( ) ; }
public abstract T pop ( ) ; public abstract boolean contains ( T value ) ; public abstract int size ( ) ; public static < T > Stack < T > createStack ( StackType type ) { switch ( type ) { case ArrayStack : return new ArrayStack < T > ( ) ; default : return new LinkedStack < T > ( ) ; } } public static class ArrayStack < T > extends Stack < T > { private static final int MINIMUM_SIZE = 10 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ MINIMUM_SIZE ] ; private int size = 0 ; @Override public void push ( T value ) { if ( size > = array . length ) { array = Arrays . copyOf ( array , ( ( size * 3 ) / 2 ) + 1 ) ; } array [ size + + ] = value ; } @Override public T pop ( ) { if ( size < = 0 ) return null ; T t = array [ - - size ] ; array [ size ] = null ; if ( size > = MINIMUM_SIZE & & size < array . length / 2 ) { array = Arrays . copyOf ( array , size ) ; } return t ; } @Override public boolean contains ( T value ) { for ( int i = 0 ; i < size ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = size - 1 ; i > = 0 ; i - - ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } @Override public Iterator < T > iterator ( ) { return ( new ArrayStackIterator < T > ( this ) ) ; } private static class ArrayStackIterator < T > implements Iterator < T > { private ArrayStack < T > stack = null ; private int index = 0 ; private ArrayStackIterator ( ArrayStack < T > stack ) { this . stack = stack ; } @Override public boolean hasNext ( ) { return ( index + 1 < = stack . size ) ; } @Override public T next ( ) { if ( index > = stack . size ) return null ; return stack . array [ index + + ] ; } @Override public void remove ( ) { throw new UnsupportedOperationException ( " OperationNotSupported " ) ; } } } public static class LinkedStack < T > extends Stack < T > { private Node < T > top = null ; private int size = 0 ; public LinkedStack ( ) { top = null ; size = 0 ; } @Override public void push ( T value ) { push ( new Node < T > ( value ) ) ; } private void push ( Node < T > node ) { if ( top = = null ) { top = node ; } else { Node < T > oldTop = top ; top = node ; top . below = oldTop ; oldTop . above = top ; } size + + ; } @Override public T pop ( ) { Node < T > nodeToRemove = top ; top = nodeToRemove . below ; if ( top ! = null ) top . above = null ; T value = null ; if ( nodeToRemove ! = null ) { value = nodeToRemove . value ; size - - ; } return value ; } @Override public boolean contains ( T value ) { if ( top = = null ) return false ; Node < T > node = top ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . below ; } return false ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = top ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . below ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > above = null ; private Node < T > below = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  above= " + ( ( above ! = null ) ? above . value : " NULL " ) + "  below= " + ( ( below ! = null ) ? below . value : " NULL " ) ; } } @Override public Iterator < T > iterator ( ) { return ( new LinkedStackIterator < T > ( this . top ) ) ; } private static class LinkedStackIterator < T > implements Iterator < T > { private Node < T > nextNode = null ; private LinkedStackIterator ( Node < T > top ) { Node < T > current = top ; while ( current . below ! = null ) current = current . below ; this . nextNode = current ; } @Override public boolean hasNext ( ) { return ( nextNode ! = null ) ; } @Override public T next ( ) { Node < T > current = nextNode ; if ( current ! = null ) { nextNode = current . above ; return current . value ; } return null ; } @Override public void remove ( ) { System . err . println ( " OperationNotSupported " ) ; } } } }
public List < Row > planMutationsForKey ( Row key , List < Row > arrivingForKey , List < Row > existingForKey ) { resetCurrentSystemTime ( ) ; if ( key . schema ( ) = = null ) { throw new RuntimeException ( " Key sent to event time upsert planner does not contain a schema " ) ; } List < Row > planned = Lists . newArrayList ( ) ; if ( arrivingForKey . size ( ) > 1 ) { Collections . sort ( arrivingForKey , Collections . reverseOrder ( eventTimeModel ) ) ; } Row arriving = arrivingForKey . get ( 0 ) ; if ( arriving . schema ( ) = = null ) { throw new RuntimeException ( " Arriving row sent to event time upsert planner does not contain a schema " ) ; } arriving = PlannerUtils . appendMutationTypeField ( arriving ) ; if ( hasLastUpdatedField ( ) ) { arriving = lastUpdatedTimeModel . appendFields ( arriving ) ; } Row existing = null ; if ( ! existingForKey . isEmpty ( ) ) { existing = existingForKey . get ( 0 ) ; if ( arriving . schema ( ) = = null ) { throw new RuntimeException ( " Existing row sent to event time upsert planner does not contain a schema " ) ; } } if ( existing = = null ) { if ( hasLastUpdatedField ( ) ) { arriving = lastUpdatedTimeModel . setCurrentSystemTime ( arriving ) ; } if ( hasSurrogateKeyField ( ) ) { arriving = PlannerUtils . appendSurrogateKey ( arriving , getSurrogateKeyFieldName ( ) ) ; } planned . add ( PlannerUtils . setMutationType ( arriving , MutationType . INSERT ) ) ; } else if ( PlannerUtils . before ( eventTimeModel , arriving , existing ) ) { } else if ( ( PlannerUtils . simultaneous ( eventTimeModel , arriving , existing ) | | PlannerUtils . after ( eventTimeModel , arriving , existing ) ) & & RowUtils . different ( arriving , existing , valueFieldNames ) ) { if ( hasLastUpdatedField ( ) ) { arriving = lastUpdatedTimeModel . setCurrentSystemTime ( arriving ) ; } planned . add ( PlannerUtils . setMutationType ( arriving , MutationType . UPDATE ) ) ; } return planned ; }
protected void processQuestion ( final NAL nal , final Task task ) { Sentence ques = task . sentence ; boolean newQuestion = true ; for ( final Task t : questions ) { final Sentence q = t . sentence ; if ( q . equalsContent ( ques ) ) { ques = q ; newQuestion = false ; break ; } } if ( newQuestion ) { if ( questions . size ( ) + 1 > memory . param . conceptQuestionsMax . get ( ) ) { Task removed = questions . remove ( 0 ) ; memory . event . emit ( ConceptQuestionRemove . class , this , removed ) ; } questions . add ( task ) ; memory . event . emit ( ConceptQuestionAdd . class , this , task ) ; } final Task newAnswerT = ( ques . isQuestion ( ) ) ? selectCandidate ( ques , beliefs ) : selectCandidate ( ques , desires ) ; if ( newAnswerT ! = null ) { trySolution ( newAnswerT . sentence , task , nal ) ;
Collection < SocketAddress > getAvailableServers ( ) ; Collection < SocketAddress > getUnavailableServers ( ) ; Transcoder < Object > getTranscoder ( ) ; NodeLocator getNodeLocator ( ) ; Future < Boolean > append ( long cas , String key , Object val ) ; < T > Future < Boolean > append ( long cas , String key , T val , Transcoder < T > tc ) ; Future < Boolean > prepend ( long cas , String key , Object val ) ; < T > Future < Boolean > prepend ( long cas , String key , T val , Transcoder < T > tc ) ; < T > Future < CASResponse > asyncCAS ( String key , long casId , T value , Transcoder < T > tc ) ; Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) ; CASResponse cas ( String key , long casId , Object value ) ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; Future < CASValue < Object > > asyncGetAndTouch ( final String key , final int exp ) ; < T > Future < CASValue < T > > asyncGetAndTouch ( final String key , final int exp , final Transcoder < T > tc ) ; CASValue < Object > getAndTouch ( String key , int exp ) ; < T > CASValue < T > getAndTouch ( String key , int exp , Transcoder < T > tc ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) ; CASValue < Object > gets ( String key ) ; < T > T get ( String key , Transcoder < T > tc ) ; Object get ( String key ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Iterator < Transcoder < T > > tcs ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
protected void initClient ( ConnectionFactory cf ) throws Exception { client = new MemcachedClient ( cf , AddrUtil . getAddresses ( " 127.0.0.1:11213 " ) ) ;
public boolean equals ( Object v1 ) { if ( ! ( v1 instanceof Vertex ) ) return false ; Vertex v = ( Vertex ) v1 ; boolean values = this . value = = v . value ; if ( ! values ) return false ; boolean weight = this . weight = = v . weight ; if ( ! weight ) return false ; return true ; }
protected void setUp ( ) throws Exception { super . setUp ( ) ; ts = new TranscodeService ( false ) ; }
public static Result share ( String artist , String track , String message , String recipient , Session session ) { Map < String , String > params = StringUtilities . map ( " artist " , artist , " track " , track , " recipient " , recipient ) ; if ( message ! = null ) params . put ( " message " , message ) ; return Caller . getInstance ( ) . call ( " track.share " , session , params ) ; }
void __recover ( ) { if ( logger . isLoggable ( Level . FINER ) ) { logger . finer ( this . getName ( ) + " recover() Cleanning up " ) ; } logger . warning ( " RECOVERING " ) ; this . purgeTimer ( ) ; final Collection < ServiceInfo > oldServiceInfos = new ArrayList < ServiceInfo > ( getServices ( ) . values ( ) ) ; this . unregisterAllServices ( ) ; this . disposeServiceCollectors ( ) ; this . waitForCanceled ( DNSConstants . CLOSE_TIMEOUT ) ; this . purgeStateTimer ( ) ; this . closeMulticastSocket ( ) ; this . getCache ( ) . clear ( ) ; if ( logger . isLoggable ( Level . FINER ) ) { logger . finer ( this . getName ( ) + " recover() All is clean " ) ; } if ( this . isCanceled ( ) ) {
public Builder clearRepeatingMessage ( ) { if ( repeatingMessageBuilder_ = = null ) { repeatingMessage_ = java . util . Collections . emptyList ( ) ; bitField0_ = ( bitField0_ & ~ 0x00040000 ) ; onChanged ( ) ; } else { repeatingMessageBuilder_ . clear ( ) ; } return this ; }
List < Partnership > getAllPartnerships ( ) ; @Nonnull IPartnershipMap getPartnershipMap ( ) ; }
public JavaStreamingContext create ( ) { return new JavaStreamingContext ( sparkConf , batchDuration ) ; }
public void testConvertFromResults ( ) { byte [ ] rowKey = Bytes . add ( Bytes . toBytes ( " GOOG: " ) , Bytes . toBytes ( 1000L ) ) ; byte [ ] cf = Bytes . toBytes ( " cf1 " ) ; byte [ ] clordid = Bytes . toBytes ( " clordid " ) ; byte [ ] orderqty = Bytes . toBytes ( " orderqty " ) ; byte [ ] leavesqty = Bytes . toBytes ( " leavesqty " ) ; byte [ ] cumqty = Bytes . toBytes ( " cumqty " ) ; List < Cell > cells1 = Lists . newArrayList ( ( Cell ) new KeyValue ( rowKey , cf , clordid , 1000L , Bytes . toBytes ( " abcd " ) ) , new KeyValue ( rowKey , cf , orderqty , 1000L , Bytes . toBytes ( 100 ) ) , new KeyValue ( rowKey , cf , leavesqty , 1000L , Bytes . toBytes ( 10 ) ) , new KeyValue ( rowKey , cf , cumqty , 1000L , Bytes . toBytes ( 5 ) ) ) ; Result result1 = Result . create ( cells1 ) ; byte [ ] rowKey2 = Bytes . add ( Bytes . toBytes ( " AAPL: " ) , Bytes . toBytes ( 1004L ) ) ; List < Cell > cells2 = Lists . newArrayList ( ( Cell ) new KeyValue ( rowKey2 , cf , clordid , 1004L , Bytes . toBytes ( " efgh " ) ) , new KeyValue ( rowKey2 , cf , orderqty , 1004L , Bytes . toBytes ( 99 ) ) , new KeyValue ( rowKey2 , cf , leavesqty , 1004L , Bytes . toBytes ( 9 ) ) , new KeyValue ( rowKey2 , cf , cumqty , 1004L , Bytes . toBytes ( 4 ) ) ) ; Result result2 = Result . create ( cells2 ) ; List < Row > rows = serde . convertFromResults ( Lists . newArrayList ( result1 , result2 ) ) ; assertEquals ( " Two Rows should be returned " , 2 , rows . size ( ) ) ; assertEquals ( " Symbol should be GOOG " , " GOOG " , RowUtils . < String > getAs ( rows . get ( 0 ) , " symbol " ) ) ; assertEquals ( " Transacttime should be 1000L " , 1000L , RowUtils . < Long > getAs ( rows . get ( 0 ) , " transacttime " ) . longValue ( ) ) ; assertEquals ( " Clordid should be abcd " , " abcd " , RowUtils . < String > getAs ( rows . get ( 0 ) , " clordid " ) ) ; assertEquals ( " Orderqty should be 100 " , 100 , RowUtils . < Integer > getAs ( rows . get ( 0 ) , " orderqty " ) . intValue ( ) ) ; assertEquals ( " Leavesqty should be 10 " , 10 , RowUtils . < Integer > getAs ( rows . get ( 0 ) , " leavesqty " ) . intValue ( ) ) ; assertEquals ( " Cumqty should be 5 " , 5 , RowUtils . < Integer > getAs ( rows . get ( 0 ) , " cumqty " ) . intValue ( ) ) ; assertEquals ( " Symbol should be AAPL " , " AAPL " , RowUtils . < String > getAs ( rows . get ( 1 ) , " symbol " ) ) ; assertEquals ( " Transacttime should be 1004L " , 1004L , RowUtils . < Long > getAs ( rows . get ( 1 ) , " transacttime " ) . longValue ( ) ) ; assertEquals ( " Clordid should be efgh " , " efgh " , RowUtils . < String > getAs ( rows . get ( 1 ) , " clordid " ) ) ; assertEquals ( " Orderqty should be 99 " , 99 , RowUtils . < Integer > getAs ( rows . get ( 1 ) , " orderqty " ) . intValue ( ) ) ; assertEquals ( " Leavesqty should be 9 " , 9 , RowUtils . < Integer > getAs ( rows . get ( 1 ) , " leavesqty " ) . intValue ( ) ) ; assertEquals ( " Cumqty should be 4 " , 4 , RowUtils . < Integer > getAs ( rows . get ( 1 ) , " cumqty " ) . intValue ( ) ) ; }
protected void fireEvent ( Object . . . objects ) { if ( eventHandlerMethod ! = null ) { try {
public void testNARState ( ) { int N = 2 ; double [ ] x = randomArray ( N , 1.0 , 0 ) ; NAR n = new NAR ( ) ; new Number1DInput ( n , " x " , x ) ; n . finish ( 16 ) ; HashMap < String , Object > d = new NARState ( n ) . measure ( ) ; assert ( d . keySet ( ) . size ( ) > 0 ) ;
public void conceptActivate ( final Concept c , final BudgetValue b ) { conceptProcessor . conceptActivate ( c , b ) ; }
public static final double squaredDistance ( double x1 , double y1 , double x2 , double y2 ) { double x = x1 - x2 ; double y = y1 - y2 ; double sqr = ( x * x ) + ( y * y ) ; return sqr ; }
public int compare ( final Album lhs , final Album rhs ) { int compare = 0 ; final int leftYear = formattedYear ( lhs . mYear ) ; final int rightYear = formattedYear ( rhs . mYear ) ; if ( leftYear < rightYear ) { compare = - 1 ; } else if ( leftYear > rightYear ) { compare = 1 ; } if ( compare = = 0 ) { compare = lhs . compareTo ( rhs ) ; } return compare ; }
protected void processQuestion ( final Task task ) { Sentence ques = task . sentence ; boolean newQuestion = true ; for ( final Task t : questions ) { final Sentence q = t . sentence ; if ( q . content . equals ( ques . content ) ) { ques = q ; newQuestion = false ; break ; } } if ( newQuestion ) { questions . add ( task ) ; } if ( questions . size ( ) > Parameters . MAXIMUM_QUESTIONS_LENGTH ) { questions . remove ( 0 ) ; } final Sentence newAnswer = ( ques . isQuestion ( ) ) ? selectCandidate ( ques , beliefs ) : selectCandidate ( ques , desires ) ; if ( newAnswer ! = null ) { trySolution ( newAnswer , task , memory ) ;
public void initialize ( ) { try { SaslClient sc = Sasl . createSaslClient ( mech , null ,
public boolean isGreaterRelink ( Term t , ArrayList < String > vorder ) { return false ; }
void load ( ) ; static FileConfig of ( File file , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return builder ( file , format ) . build ( ) ; } static FileConfigBuilder < Config > builder ( File file , ConfigFormat < ? extends Config , ? super Config , ? super Config > format ) { return new FileConfigBuilder < > ( file , format ) ; } }
public void remove ( String cacheEntryName ) { new File ( cacheDir , cacheEntryName + " .xml " ) . delete ( ) ; new File ( cacheDir , cacheEntryName + " .meta " ) . delete ( ) ; }
public ValidationResult validate ( Config config ) { try { parseSchema ( config . getObjectList ( FIELDS_CONFIG ) ) ; } catch ( Exception e ) { return new ValidationResult ( Validity . INVALID , " Schema configuration is invalid " ) ; } return new ValidationResult ( Validity . VALID , " Schema configuration is valid " ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; if ( list ! = null & & list . head ! = null ) { Node < K > node = list . head ; while ( node ! = null ) { if ( ! ( node instanceof SkipListMapNode ) ) continue ; SkipListMapNode < K , V > sln = ( SkipListMapNode < K , V > ) node ; builder . append ( sln . data ) . append ( " = " ) . append ( sln . value ) ; node = node . getNext ( 0 ) ; if ( node ! = null ) builder . append ( " \ n " ) ; } } return builder . toString ( ) ; }
public void subtractTest ( ) { assertEquals ( 0 , Modular . subtract ( - 22 , 3 , 5 ) ) ; assertEquals ( Long . MAX_VALUE - 1 , Modular . subtract ( Long . MAX_VALUE - 2 , Long . MAX_VALUE - 1 , Long . MAX_VALUE ) ) ; assertEquals ( Long . MAX_VALUE - 1 , Modular . subtract ( 1 - Long . MAX_VALUE , 2 , Long . MAX_VALUE ) ) ; assertEquals ( 0 , Modular . subtract ( - 1000 , - 10000000 , 10 ) ) ; boolean exception = true ; try { Modular . subtract ( 1 , 1 , 0 ) ; exception = false ; } catch ( IllegalArgumentException e ) { } assertTrue ( " Exception expected " , exception ) ; }
public AbstractTask nextTask ( ) { if ( ! newInputChannels . isEmpty ( ) ) { for ( final InPort n : newInputChannels ) inputChannels . add ( n ) ; newInputChannels . clear ( ) ; } if ( ! oldOutputChannels . isEmpty ( ) ) { for ( final Output n : oldOutputChannels ) outputChannels . remove ( n ) ; oldOutputChannels . clear ( ) ; } if ( ! newOutputChannels . isEmpty ( ) ) { for ( final Output n : newOutputChannels ) outputChannels . add ( n ) ; newOutputChannels . clear ( ) ; } if ( ( ! inputting ) | | ( inputChannels . isEmpty ( ) ) ) return null ; int remainingChannels = inputChannels . size ( ) ; while ( ( remainingChannels > 0 ) & & ( inputChannels . size ( ) > 0 ) ) { inputSelected % = inputChannels . size ( ) ; final InPort i = inputChannels . get ( inputSelected + + ) ; remainingChannels - - ; if ( i . finished ( ) ) { inputChannels . remove ( i ) ; continue ; } try { i . update ( ) ; } catch ( IOException ex ) { output ( ERR . class , ex ) ; } if ( i . hasNext ( ) ) { try { Object input = i . next ( ) ; AbstractTask task = perception . perceive ( input ) ; if ( task ! = null ) { return task ; } } catch ( IOException e ) { output ( ERR . class , e ) ; } } } return null ; }
public int nextRemovalIndex ( ) { final int s = size ( ) ; if ( randomRemoval ) { x = Memory . randomNumber . nextFloat ( ) ; } else { x + = scanningRate * 1.0f / ( 1 + s ) ; if ( x > = 1.0f ) x - = 1.0f ; if ( x < = 0.0f ) x + = 1.0f ; } double y = curve . y ( x ) ; int result = ( int ) fastRound ( ( 1.0 - y ) * ( s - 1 ) ) ; if ( result = = s ) { throw new RuntimeException ( " Invalid removal index:  " + x + "  ->  " + y ) ; } return result ; }
default C parse ( File file , FileNotFoundAction notFoundAction , Charset charset ) { return parse ( file . toPath ( ) , notFoundAction , charset ) ; }
public void solveAll ( ) { if ( getGoal ( ) . length ( ) > 0 ) {
public void mouseUp ( Vec2 p , int button ) { mouseTracing = false ; if ( button = = MOUSE_JOINT_BUTTON ) { destroyMouseJoint ( ) ; } completeBombSpawn ( p ) ; }
public static Term [ ] cloneTermsAppend ( boolean deep , final Term [ ] original , Term . . . additional ) { if ( original = = null ) { return null ; } final Term [ ] arr = new Term [ original . length + additional . length ] ; int i ; for ( i = 0 ; i < original . length ; i + + ) { final Term t = original [ i ] ; if ( preventUnnecessaryDeepCopy & & t . getClass ( ) = = Term . class ) arr [ i ] = t ; else arr [ i ] = ( deep ? t . clone ( ) : t ) ; } for ( int j = 0 ; j < additional . length ; j + + ) { final Term t = additional [ j ] ; if ( preventUnnecessaryDeepCopy & & t . getClass ( ) = = Term . class ) arr [ i + j ] = t ; else arr [ i + j ] = ( deep ? t . clone ( ) : t ) ; } return arr ;
private void _loadPartnershipFactory ( final IMicroElement eRootNode ) throws OpenAS2Exception { s_aLogger . info ( " Loading partnerships " ) ; final IPartnershipFactory aFactory = AS2XMLHelper . createComponent ( eRootNode , IPartnershipFactory . class , this , m_sBaseDirectory ) ; setPartnershipFactory ( aFactory ) ; }
public void testMultipleKeyFields ( ) { Dataset < Row > data = Contexts . getSparkSession ( ) . createDataFrame ( Lists . newArrayList ( RowFactory . create ( " a1 " , " a1 " , " hello " , new Timestamp ( 10000 ) ) , RowFactory . create ( " a1 " , " a1 " , " world " , new Timestamp ( 5000 ) ) , RowFactory . create ( " b1 " , " b1 " , " hello! " , new Timestamp ( 10000 ) ) , RowFactory . create ( " b1 " , " b1 " , " world! " , new Timestamp ( 20000 ) ) , RowFactory . create ( " c1 " , " c1 " , " hello? " , new Timestamp ( 10000 ) ) , RowFactory . create ( " a1 " , " a2 " , " hello!! " , new Timestamp ( 10000 ) ) , RowFactory . create ( " a1 " , " a2 " , " hello?? " , new Timestamp ( 30000 ) ) ) , DataTypes . createStructType ( Lists . newArrayList ( DataTypes . createStructField ( " key1 " , DataTypes . StringType , false ) , DataTypes . createStructField ( " key2 " , DataTypes . StringType , false ) , DataTypes . createStructField ( " value " , DataTypes . StringType , false ) , DataTypes . createStructField ( " ts " , DataTypes . TimestampType , false ) ) ) ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; dependencies . put ( " dep1 " , data ) ; Map < String , Object > configMap = Maps . newHashMap ( ) ; configMap . put ( LatestDeriver . KEY_FIELD_NAMES_CONFIG , Lists . newArrayList ( " key1 " , " key2 " ) ) ; configMap . put ( LatestDeriver . TIMESTAMP_FIELD_NAME_CONFIG , " ts " ) ; Config config = ConfigFactory . parseMap ( configMap ) ; LatestDeriver d = new LatestDeriver ( ) ; assertNoValidationFailures ( d , config ) ; d . configure ( config ) ; Dataset < Row > derived = d . derive ( dependencies ) ; assertEquals ( 4 , derived . count ( ) ) ; assertEquals ( data . schema ( ) . size ( ) , derived . schema ( ) . size ( ) ) ; Set < Row > rows = Sets . newHashSet ( derived . collectAsList ( ) ) ; assertTrue ( rows . contains ( RowFactory . create ( " a1 " , " a1 " , " hello " , new Timestamp ( 10000 ) ) ) ) ; assertTrue ( rows . contains ( RowFactory . create ( " a1 " , " a2 " , " hello?? " , new Timestamp ( 30000 ) ) ) ) ; assertTrue ( rows . contains ( RowFactory . create ( " b1 " , " b1 " , " world! " , new Timestamp ( 20000 ) ) ) ) ; assertTrue ( rows . contains ( RowFactory . create ( " c1 " , " c1 " , " hello? " , new Timestamp ( 10000 ) ) ) ) ; }
public void executePipelineNoRecords ( final @Mocked MorphlineUtils . Pipeline pipeline , final @Mocked Command morphline ) throws Exception { final Record inputRecord = new Record ( ) ; new Expectations ( ) { { morphline . process ( inputRecord ) ; result = true ; pipeline . getCollector ( ) . getRecords ( ) ; result = Lists . newArrayList ( ) ; } } ; MorphlineUtils . executePipeline ( pipeline , inputRecord ) ; }
private void watch ( final String key , final Future < Boolean > f ) { if ( executorService ! = null & & storageListener ! = null ) { executorService . execute ( new Runnable ( ) {
public static com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . MultipleExample parseFrom ( com . google . protobuf . CodedInputStream input ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseWithIOException ( PARSER , input ) ;
public Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) { final Map < String , Object > m = new ConcurrentHashMap < String , Object > ( ) ; Map < MemcachedNode , Collection < String > > chunks = new HashMap < MemcachedNode , Collection < String > > ( ) ; NodeLocator locator = conn . getLocator ( ) ; for ( String key : keys ) { MemcachedNode node = locator . getPrimary ( key ) ; Collection < String > ks = chunks . get ( node ) ; if ( ks = = null ) { ks = new ArrayList < String > ( ) ; chunks . put ( node , ks ) ; } ks . add ( key ) ; } final CountDownLatch latch = new CountDownLatch ( chunks . size ( ) ) ; final Collection < Operation > ops = new ArrayList < Operation > ( ) ; GetOperation . Callback cb = new GetOperation . Callback ( ) { @SuppressWarnings ( " synthetic-access " ) public void receivedStatus ( String line ) { if ( ! line . equals ( " END " ) ) { getLogger ( ) . warn ( " Expected ``END'', was ``%s'' " , line ) ; } } public void gotData ( String k , int flags , byte [ ] data ) { m . put ( k , transcoder . decode ( new CachedData ( flags , data ) ) ) ; } public void complete ( ) { latch . countDown ( ) ; } } ; for ( Map . Entry < MemcachedNode , Collection < String > > me : chunks . entrySet ( ) ) { ops . add ( addOp ( me . getKey ( ) , new GetOperation ( me . getValue ( ) , cb ) ) ) ; } return new BulkGetFuture ( m , ops , latch ) ; }
public void draw ( Grid2DSpace s , boolean edge , float wx , float wy , float x , float y , float z ) { int ambientLight = 100 ; int r = 0 , g = 0 , b = 0 , a = 1 ; a = ambientLight ; if ( material = = Material . Empty ) { } else if ( material = = Material . Machine ) { g = b = 127 ; r = 200 ; } else if ( material = = Material . StoneWall | | ( material = = Material . Door & & is_solid ) ) { r = g = b = 255 ; } else if ( material = = Material . DirtFloor | | material = = Material . GrassFloor | | ( material = = Material . Door & & ! is_solid ) ) { if ( height = = Float . MAX_VALUE ) { r = g = b = 255 ; } else { r = g = b = ( int ) ( 128 + height ) ; } } if ( material = = Material . Door & & is_solid ) { b = 0 ; g = ( int ) ( g / 2.0f ) ; } if ( material = = Material . Door ) { r = 200 ; } if ( ( charge > 0 ) | | ( chargeFront ) ) { { float freq = 4 ; int chargeBright = ( int ) ( ( Math . cos ( s . getRealtime ( ) * freq ) + 1 ) * 25 ) ; if ( charge > 0 ) { r + = chargeBright ; g + = chargeBright / 2 ; } else { g + = chargeBright ; r + = chargeBright / 2 ; } if ( chargeFront ) { freq = 7 ; b + = 25 ; } a + = 150 ; } } if ( edge ) { light = 255 ; } a + = light * 255 ; if ( material = = Material . StoneWall ) { a = r = g = b = ( int ) ( 200 + light * 255 ) ; } if ( material = = Material . Water ) { b = 64 ; g = 32 ; } r = Math . min ( 255 , r ) ; g = Math . min ( 255 , g ) ; b = Math . min ( 255 , b ) ; a = Math . min ( 255 , a ) ; state . cr = lerp ( state . cr , r , 0.19f ) ; state . cg = lerp ( state . cg , g , 0.19f ) ; state . cb = lerp ( state . cb , b , 0.19f ) ; state . ca = lerp ( state . ca , a , 0.19f ) ; if ( material = = Material . GrassFloor ) { state . cr + = 8 ; state . cg + = 16 ; } s . fill ( state . cr , state . cg , state . cb , state . ca ) ; if ( logic ! = Logic . NotALogicBlock ) { s . fill ( state . cr / 2.0f ) ; s . rect ( 0 , 0 , 1.0f , 1.0f ) ; } else if ( material ! = Material . Water & & material ! = Material . StoneWall ) { s . rect ( 0 , 0 , 1.0f , 1.0f ) ; } else if ( material = = Material . Water ) { float verschx = ( float ) Math . max ( - 0.5f , Math . min ( 0.5f , 0.1 * ( x - wx ) ) ) ; float verschy = ( float ) Math . max ( - 0.5f , Math . min ( 0.5f , 0.1 * ( y - wy ) ) ) ; float add = 0.0f ; s . rect ( add - verschx , add - verschy , 1.1f , 1.1f ) ; } else if ( material = = Material . StoneWall | | material = = Material . Water ) { float verschx = ( float ) Math . max ( - 0.5f , Math . min ( 0.5f , 0.1 * ( x - wx ) ) ) ; float verschy = ( float ) Math . max ( - 0.5f , Math . min ( 0.5f , 0.1 * ( y - wy ) ) ) ; float add = 0.0f ; s . rect ( add + verschx , add + verschy , 1.1f , 1.1f ) ; s . rect ( add + verschx , add + verschy , 1.1f , 1.1f ) ; } s . textSize ( 1 ) ; if ( logic = = Logic . SWITCH | | logic = = Logic . OFFSWITCH ) { s . fill ( state . cr , state . cg , state . cb , state . ca ) ; s . ellipse ( 0.5f , 0.5f , 1.0f , 1.0f ) ; } else if ( logic ! = Logic . BRIDGE & & logic ! = Logic . NotALogicBlock & & logic ! = Logic . WIRE ) { s . fill ( state . cr + 30 , state . cg + 30 , state . cb + 30 , state . ca + 30 ) ; s . triangle ( 0.25f , 1.0f , 0.5f , 0.5f , 0.75f , 1.0f ) ; s . triangle ( 0.25f , 0.0f , 0.5f , 0.5f , 0.75f , 0.0f ) ; s . fill ( state . cr + 30 , state . cg + 30 , state . cb + 30 , state . ca + 30 ) ; s . rect ( 0 , 0.3f , 1 , 0.4f ) ; } else if ( logic = = Logic . WIRE | | logic = = Logic . BRIDGE ) { s . fill ( state . cr , state . cg , state . cb , state . ca ) ; s . rect ( 0 , 0.3f , 1 , 0.4f ) ; s . rect ( 0.3f , 0 , 0.4f , 1 ) ; } s . fill ( 255 , 255 , 255 , 128 ) ; if ( logic = = Logic . AND ) { drawtext ( s , " ^ " ) ; } if ( logic = = Logic . OR ) { drawtext ( s , " v " ) ; } if ( logic = = Logic . XOR ) { drawtext ( s , " x " ) ; } if ( logic = = Logic . NOT ) { drawtext ( s , " ~ " ) ; } if ( logic = = Logic . BRIDGE ) { drawtext ( s , " H " ) ; } if ( logic = = Logic . SWITCH ) { drawtext ( s , " 1 " ) ; } if ( logic = = Logic . OFFSWITCH ) { drawtext ( s , " 0 " ) ; } if ( machine ! = null ) { switch ( machine ) { case Light : if ( charge > 0 ) drawtext ( s , " + " ) ; else drawtext ( s , " - " ) ; break ; case Turret : if ( charge > 0 ) s . particles . emitParticles ( 0.5f , 0.3f , s . getTime ( ) / 40 f , 0.07f , state . x + 0.5f , state . y + 0.5f , 1 ) ; break ; } } if ( ! " " . equals ( name ) ) {
public void testDijstraUndirected ( ) { if ( debug > 0 ) System . out . println ( " Undirected Graph. " ) ; Graph . Vertex < Integer > start = undirected . v1 ; Graph . Vertex < Integer > end = undirected . v5 ; { if ( debug > 0 ) System . out . println ( " Dijstra's shortest paths of the undirected graph from  " + start . getValue ( ) + "  to all. " ) ;
public Memory NewMemory ( RuntimeParameters p ) { return new Memory ( p , new LevelBag ( Parameters . CONCEPT_BAG_LEVELS , Parameters . CONCEPT_BAG_SIZE ) ,
public ConfigWriter createWriter ( ) { throw new UnsupportedOperationException ( " In memory configurations aren't mean to be  " + " written. " ) ;
public V remove ( K key ) { Node node = find ( key . hashCode ( ) ) ; if ( node = = null ) return null ; if ( node instanceof ArrayNode ) return null ; KeyValueNode < V > kvNode = ( KeyValueNode < V > ) node ; V value = kvNode . value ; if ( node . parent = = null ) { root = null ; } else { ArrayNode parent = node . parent ; int position = getPosition ( parent . height , node . key ) ; parent . removeChild ( position ) ; int numOfChildren = parent . getNumberOfChildren ( ) ; while ( numOfChildren = = 0 ) { node = parent ; parent = node . parent ; if ( parent = = null ) { root = null ; break ; } position = getPosition ( parent . height , node . key ) ; parent . removeChild ( position ) ; numOfChildren = parent . getNumberOfChildren ( ) ; } } kvNode . key = 0 ; kvNode . value = null ; size - - ; return value ; }
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; try { OperationStatus status = parseViewForStatus ( json , errorcode ) ; ViewResponseWithDocs vr = null ; if ( status . isSuccess ( ) ) { vr = parseDocsViewResult ( json ) ; } ( ( DocsCallback ) callback ) . gotData ( vr ) ; callback . receivedStatus ( status ) ; } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }
public static void createMDNData ( @Nonnull final IAS2Session aSession , @Nonnull final IMessageMDN aMdn , final boolean bSignMDN , final boolean bIncludeCertificateInSignedContent , @Nullable final ECryptoAlgorithmSign eMICAlg , final boolean bUseOldRFC3851MicAlgs ) throws Exception { ValueEnforcer . notNull ( aSession , " AS2Session " ) ; ValueEnforcer . notNull ( aMdn , " MDN " ) ; if ( bSignMDN ) ValueEnforcer . notNull ( eMICAlg , " MICAlg " ) ; final MimeMultipart aReportParts = new MimeMultipart ( ) ; final MimeBodyPart aTextPart = new MimeBodyPart ( ) ; final String sText = aMdn . getText ( ) + CHttp . EOL ; aTextPart . setContent ( sText , CMimeType . TEXT_PLAIN . getAsString ( ) ) ; aTextPart . setHeader ( CHttpHeader . CONTENT_TYPE , CMimeType . TEXT_PLAIN . getAsString ( ) ) ; aReportParts . addBodyPart ( aTextPart ) ; final MimeBodyPart aReportPart = new MimeBodyPart ( ) ; { final InternetHeaders aReportValues = new InternetHeaders ( ) ; aReportValues . setHeader ( HEADER_REPORTING_UA , aMdn . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_REPORTING_UA ) ) ; aReportValues . setHeader ( HEADER_ORIGINAL_RECIPIENT , aMdn . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_ORIG_RECIPIENT ) ) ; aReportValues . setHeader ( HEADER_FINAL_RECIPIENT , aMdn . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_FINAL_RECIPIENT ) ) ; aReportValues . setHeader ( HEADER_ORIGINAL_MESSAGE_ID , aMdn . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_ORIG_MESSAGEID ) ) ; aReportValues . setHeader ( HEADER_DISPOSITION , aMdn . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_DISPOSITION ) ) ; aReportValues . setHeader ( HEADER_RECEIVED_CONTENT_MIC , aMdn . attrs ( ) . getAsString ( AS2MessageMDN . MDNA_MIC ) ) ; final Enumeration < ? > aReportEn = aReportValues . getAllHeaderLines ( ) ; final StringBuilder aReportData = new StringBuilder ( ) ; while ( aReportEn . hasMoreElements ( ) ) aReportData . append ( ( String ) aReportEn . nextElement ( ) ) . append ( CHttp . EOL ) ; aReportData . append ( CHttp . EOL ) ; aReportPart . setContent ( aReportData . toString ( ) , " message/disposition-notification " ) ; } aReportPart . setHeader ( CHttpHeader . CONTENT_TYPE , " message/disposition-notification " ) ; aReportParts . addBodyPart ( aReportPart ) ; final MimeBodyPart aReport = new MimeBodyPart ( ) ; aReportParts . setSubType ( " report; report-type=disposition-notification " ) ; aReport . setContent ( aReportParts ) ; aReport . setHeader ( CHttpHeader . CONTENT_TYPE , aReportParts . getContentType ( ) ) ; if ( bSignMDN ) { final ICertificateFactory aCertFactory = aSession . getCertificateFactory ( ) ; try { final X509Certificate aSenderCert = aCertFactory . getCertificate ( aMdn , ECertificatePartnershipType . SENDER ) ; final PrivateKey aSenderKey = aCertFactory . getPrivateKey ( aMdn , aSenderCert ) ; final MimeBodyPart aSignedReport = getCryptoHelper ( ) . sign ( aReport , aSenderCert , aSenderKey , eMICAlg , bIncludeCertificateInSignedContent , bUseOldRFC3851MicAlgs , EContentTransferEncoding . BASE64 ) ; aMdn . setData ( aSignedReport ) ; } catch ( final CertificateNotFoundException | KeyNotFoundException ex ) { ex . terminate ( ) ; aMdn . setData ( aReport ) ; } } else { aMdn . setData ( aReport ) ; } final MimeBodyPart aData = aMdn . getData ( ) ; aMdn . headers ( ) . setContentType ( aData . getContentType ( ) ) ;
public ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) { try { return asyncQueryAndExcludeDocs ( view , query ) . get ( ) ;
private static void test1Ret ( NarseseConsumer consumer , String expectedResultType ) { consumer . addInput ( " <(&/, <cond0-->Cond0>, (^system, {SELF}, ./src/main/resources/unittest/TestscriptRet " + expectedResultType + " .sh, Arg0, $ret)) =/> <{$ret}-->res>>. " ) ; consumer . addInput ( " <cond0-->Cond0>. :|: " ) ; consumer . addInput ( " <{#0}-->res>! " ) ; }
public Row call ( Row toHash ) { sb . setLength ( 0 ) ; for ( int fieldNum = 0 ; fieldNum < toHash . schema ( ) . size ( ) ; fieldNum + + ) { if ( includeInConcatenation ( toHash , fieldNum ) ) { Object value = toHash . get ( fieldNum ) ; sb . append ( value ! = null ? value : nullString ) ; sb . append ( delimiter ) ; } } return RowUtils . append ( toHash , sb . toString ( ) . getBytes ( ) ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( "   " ) ; for ( int i = TOTAL_LEVEL ; i > = 0 ; i - - ) { if ( ! emptyLevel ( i - 1 ) ) { buf = buf . append ( " \ n --- Level  " + i + " : \ n  " ) ; for ( int j = 0 ; j < itemTable . get ( i - 1 ) . size ( ) ; j + + ) { buf = buf . append ( itemTable . get ( i - 1 ) . get ( j ) . toString ( ) + " \ n  " ) ; } } } return buf . toString ( ) ; }
public final void insertOp ( Operation op ) { ArrayList < Operation > tmp = new ArrayList < Operation > ( inputQueue . size ( ) + 1 ) ; tmp . add ( op ) ; inputQueue . drainTo ( tmp ) ; inputQueue . addAll ( tmp ) ; }
void check_in ( double [ ] array ) { this . pointSet . add ( array ) ; }
GetsOperation gets ( String key , GetsOperation . Callback callback ) ; GetOperation get ( Collection < String > keys , GetOperation . Callback cb ) ; MutatorOperation mutate ( Mutator m , String key , int by , long def , int exp , OperationCallback cb ) ; StatsOperation stats ( String arg , StatsOperation . Callback cb ) ; StoreOperation store ( StoreType storeType , String key , int flags , int exp , byte [ ] data , OperationCallback cb ) ; KeyedOperation touch ( String key , int expiration , OperationCallback cb ) ; ConcatenationOperation cat ( ConcatenationType catType , long casId , String key , byte [ ] data , OperationCallback cb ) ; CASOperation cas ( StoreType t , String key , long casId , int flags , int exp , byte [ ] data , OperationCallback cb ) ; VersionOperation version ( OperationCallback cb ) ; SASLMechsOperation saslMechs ( OperationCallback cb ) ; SASLAuthOperation saslAuth ( String [ ] mech , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; SASLStepOperation saslStep ( String [ ] mech , byte [ ] challenge , String serverName , Map < String , ? > props , CallbackHandler cbh , OperationCallback cb ) ; Collection < Operation > clone ( KeyedOperation op ) ; TapOperation tapBackfill ( String id , long date , OperationCallback cb ) ; TapOperation tapCustom ( String id , RequestMessage message , OperationCallback cb ) ; TapOperation tapAck ( TapOpcode opcode , int opaque , OperationCallback cb ) ; TapOperation tapDump ( String id , OperationCallback cb ) ; }
public void testMultipleOperation ( ) { Collection < Operation > ops = new ArrayList < Operation > ( ) ; ops . add ( buildOp ( 11211 ) ) ; ops . add ( buildOp ( 64212 ) ) ; assertEquals ( CheckedOperationTimeoutException . class . getName ( ) + " : test - failing nodes:  " + TestConfig . IPV4_ADDR + " :11211,  "
public static byte [ ] readHttpPayload ( @Nonnull final InputStream aIS , @Nonnull final IAS2HttpResponseHandler aResponseHandler , @Nonnull final IMessage aMsg ) throws IOException { ValueEnforcer . notNull ( aIS , " InputStream " ) ; ValueEnforcer . notNull ( aResponseHandler , " ResponseHandler " ) ; ValueEnforcer . notNull ( aMsg , " Msg " ) ; final DataInputStream aDataIS = new DataInputStream ( aIS ) ; byte [ ] aData = null ; final String sContentLength = aMsg . getHeader ( CAS2Header . HEADER_CONTENT_LENGTH ) ; if ( sContentLength = = null ) { final String sTransferEncoding = aMsg . getHeader ( CAS2Header . HEADER_TRANSFER_ENCODING ) ; if ( sTransferEncoding ! = null ) { if ( sTransferEncoding . replaceAll ( " \\ s+ " , " " ) . equalsIgnoreCase ( " chunked " ) ) { int nLength = 0 ; for ( ; ; ) { int nBlocklen = 0 ; for ( ; ; ) { int ch = aDataIS . readByte ( ) ; if ( ch = = '\n' ) break ; if ( ch > = 'a' & & ch < = 'f' ) ch - = ( 'a' - 10 ) ; else if ( ch > = 'A' & & ch < = 'F' ) ch - = ( 'A' - 10 ) ; else if ( ch > = '0' & & ch < = '9' ) ch - = '0' ; else continue ; nBlocklen = ( nBlocklen * 16 ) + ch ; } if ( nBlocklen = = 0 ) break ; final int nNewlen = nLength + nBlocklen ; final byte [ ] aNewData = new byte [ nNewlen ] ; if ( nLength > 0 ) System . arraycopy ( aData , 0 , aNewData , 0 , nLength ) ; aDataIS . readFully ( aNewData , nLength , nBlocklen ) ; aData = aNewData ; nLength = nNewlen ; while ( aDataIS . readByte ( ) ! = '\n' ) { } } aMsg . setHeader ( CAS2Header . HEADER_CONTENT_LENGTH , Integer . toString ( nLength ) ) ; } else { sendSimpleHTTPResponse ( aResponseHandler , HttpURLConnection . HTTP_LENGTH_REQUIRED ) ; throw new IOException ( " Transfer-Encoding unimplemented:  " + sTransferEncoding ) ; } } else { sendSimpleHTTPResponse ( aResponseHandler , HttpURLConnection . HTTP_LENGTH_REQUIRED ) ; throw new IOException ( " Content-Length missing " ) ; } } else { final int nContentSize = Integer . parseInt ( sContentLength ) ; aData = new byte [ nContentSize ] ; aDataIS . readFully ( aData ) ; } final String sContentTransferEncoding = aMsg . getHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING ) ; if ( StringHelper . hasText ( sContentTransferEncoding ) ) { final EContentTransferEncoding eCTE = EContentTransferEncoding . getFromIDCaseInsensitiveOrNull ( sContentTransferEncoding ) ; if ( eCTE = = null ) s_aLogger . warn ( " Unsupported Content-Transfer-Encoding ' " + sContentTransferEncoding + " ' is used - ignoring! " ) ; else { final IDecoder < byte [ ] > aDecoder = eCTE . createDecoder ( ) ; if ( ! ( aDecoder instanceof IdentityCodec < ? > ) ) { final int nOriginalContentLength = aData . length ; s_aLogger . info ( " Incoming message uses Content-Transfer-Encoding ' " + sContentTransferEncoding + " ' - decoding " ) ; aData = aDecoder . getDecoded ( aData ) ; aMsg . setAttribute ( MA_HTTP_ORIGINAL_CONTENT_TRANSFER_ENCODING , sContentTransferEncoding ) ; aMsg . setAttribute ( MA_HTTP_ORIGINAL_CONTENT_LENGTH , Integer . toString ( nOriginalContentLength ) ) ; } } } return aData ; }
public void onTaskAdd ( Task task , String reason ) { append ( " Task Added ( " + reason + " ):  " + task + " \ n " ) ; }
public void testCrc32Hash ( ) { Map < String , Long > exp = new HashMap < String , Long > ( ) ; exp . put ( " Test1 " , 19315L ) ; exp . put ( " Test2 " , 21114L ) ; exp . put ( " Test3 " , 9597L ) ; exp . put ( " Test4 " , 15129L ) ; exp . put ( " UDATA:edevil@sapo.pt " , 558L ) ; for ( Map . Entry < String , Long > me : exp . entrySet ( ) ) { assertHash ( DefaultHashAlgorithm . CRC32_HASH , me . getKey ( ) , me . getValue ( ) ) ;
public static final TruthValue deduction ( final TruthValue v1 , final float reliance , Parameters narParameters ) { final float f1 = v1 . getFrequency ( ) ; final double c1 = v1 . getConfidence ( ) ; final double c = and ( f1 , c1 , reliance ) ; return new TruthValue ( f1 , c , true , narParameters ) ; }
public boolean remove ( Object o ) { synchronized ( rootMonitor ) { return coll . remove ( o ) ;
public void handleResponse ( HttpResponse response ) { String json = getEntityString ( response ) ; try { View view = parseDesignDocumentForView ( bucketName , designDocName , viewName , json ) ; int errorcode = response . getStatusLine ( ) . getStatusCode ( ) ; if ( errorcode = = HttpURLConnection . HTTP_OK ) { ( ( ViewCallback ) callback ) . gotData ( view ) ; callback . receivedStatus ( new OperationStatus ( true , " OK " ) ) ; } else { callback . receivedStatus ( new OperationStatus ( false , Integer . toString ( errorcode ) ) ) ; } } catch ( ParseException e ) { exception = new OperationException ( OperationErrorType . GENERAL , " Error parsing JSON " ) ; } callback . complete ( ) ; }
public boolean add ( int index , T value ) { int growSize = size + ( size > > 1 ) ; if ( growSize > = array . length ) { array = Arrays . copyOf ( array , growSize ) ; } if ( index = = size ) { array [ size + + ] = value ; } else { System . arraycopy ( array , index , array , index + 1 , size - index ) ; array [ index ] = value ; } return true ; }
public void connectionFailed ( String message ) { } @Override public void connectionSucceeded ( String message ) { } @Override public void volumeChanged ( MPDStatus mpdStatus , int oldVolume ) { } @Override public void playlistChanged ( MPDStatus mpdStatus , int oldPlaylistVersion ) { } @Override public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { oldStatus = " " ; showNotification ( ) ; } @Override public void stateChanged ( MPDStatus mpdStatus , String oldState ) { Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = oldStatus ) return ; if ( state = = MPDStatus . MPD_STATE_PLAYING ) { isPaused = false ; resumeStreaming ( ) ; isPlaying = true ; } else { oldStatus = state ; isPlaying = false ; stopStreaming ( ) ; } } } } @Override public void repeatChanged ( boolean repeating ) { } @Override public void randomChanged ( boolean random ) { } @Override public void connectionStateChanged ( boolean connected , boolean connectionLost ) { } @Override public void libraryStateChanged ( boolean updating ) { } @Override public void onAudioFocusChange ( int focusChange ) { if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS_TRANSIENT ) { mediaPlayer . setVolume ( 0.2f , 0.2f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_GAIN ) { mediaPlayer . setVolume ( 1f , 1f ) ; } else if ( focusChange = = AudioManager . AUDIOFOCUS_LOSS ) { stop ( ) ; } } }
public void add ( final Runnable runnable , final boolean replace , final boolean playAfterAdd ) throws MPDServerException { int playPos = 0 ; final MPDStatus status = getStatus ( ) ; final boolean isPlaying = status . isState ( MPDStatus . STATE_PLAYING ) ; final boolean isConsume = status . isConsume ( ) ; final boolean isRandom = status . isRandom ( ) ; if ( replace ) { if ( isPlaying ) { playlist . crop ( ) ; } else { playlist . clear ( ) ; } } else if ( playAfterAdd & & ! isRandom ) { playPos = playlist . size ( ) ; } runnable . run ( ) ; if ( replace ) { if ( isPlaying ) { next ( ) ; } else if ( playAfterAdd ) { skipToPosition ( playPos ) ; } } else if ( playAfterAdd ) { skipToPosition ( playPos ) ; } if ( replace & & isPlaying & & ! isConsume ) { try {
public void setupEndValues ( ) { for ( Node node : mNodes ) { node . animation . setupEndValues ( ) ;
public static IMessageMDN createMDN ( @Nonnull final IAS2Session aSession , @Nonnull final AS2Message aMsg , @Nonnull final DispositionType aDisposition , @Nonnull final String sText ) throws Exception { final AS2MessageMDN aMdn = new AS2MessageMDN ( aMsg ) ; aMdn . setHeader ( CAS2Header . HEADER_AS2_VERSION , CAS2Header . DEFAULT_AS2_VERSION ) ; aMdn . setHeader ( CAS2Header . HEADER_DATE , DateUtil . getFormattedDateNow ( CAS2Header . DEFAULT_DATE_FORMAT ) ) ; aMdn . setHeader ( CAS2Header . HEADER_SERVER , CAS2Info . NAME_VERSION ) ; aMdn . setHeader ( CAS2Header . HEADER_MIME_VERSION , CAS2Header . DEFAULT_MIME_VERSION ) ; aMdn . setHeader ( CAS2Header . HEADER_AS2_FROM , aMsg . getPartnership ( ) . getReceiverID ( CPartnershipIDs . PID_AS2 ) ) ; aMdn . setHeader ( CAS2Header . HEADER_AS2_TO , aMsg . getPartnership ( ) . getSenderID ( CPartnershipIDs . PID_AS2 ) ) ; aMdn . getPartnership ( ) . setSenderID ( CPartnershipIDs . PID_AS2 , aMdn . getHeader ( CAS2Header . HEADER_AS2_FROM ) ) ; aMdn . getPartnership ( ) . setReceiverID ( CPartnershipIDs . PID_AS2 , aMdn . getHeader ( CAS2Header . HEADER_AS2_TO ) ) ; aSession . getPartnershipFactory ( ) . updatePartnership ( aMdn , true ) ; aMdn . setHeader ( CAS2Header . HEADER_FROM , aMsg . getPartnership ( ) . getReceiverID ( CPartnershipIDs . PID_EMAIL ) ) ; final String sSubject = aMdn . getPartnership ( ) . getAttribute ( CPartnershipIDs . PA_MDN_SUBJECT ) ; if ( sSubject ! = null ) { aMdn . setHeader ( CAS2Header . HEADER_SUBJECT , AbstractParameterParser . parse ( sSubject , new MessageParameters ( aMsg ) ) ) ; } else { aMdn . setHeader ( CAS2Header . HEADER_SUBJECT , " Your Requested MDN Response " ) ; } aMdn . setText ( AbstractParameterParser . parse ( sText , new MessageParameters ( aMsg ) ) ) ; aMdn . setAttribute ( AS2MessageMDN . MDNA_REPORTING_UA , CAS2Info . NAME_VERSION + " @ " + aMsg . getAttribute ( CNetAttribute . MA_DESTINATION_IP ) + " : " + aMsg . getAttribute ( CNetAttribute . MA_DESTINATION_PORT ) ) ; aMdn . setAttribute ( AS2MessageMDN . MDNA_ORIG_RECIPIENT , " rfc822;  " + aMsg . getHeader ( CAS2Header . HEADER_AS2_TO ) ) ; aMdn . setAttribute ( AS2MessageMDN . MDNA_FINAL_RECIPIENT , " rfc822;  " + aMsg . getPartnership ( ) . getReceiverID ( CPartnershipIDs . PID_AS2 ) ) ; aMdn . setAttribute ( AS2MessageMDN . MDNA_ORIG_MESSAGEID , aMsg . getHeader ( CAS2Header . HEADER_MESSAGE_ID ) ) ; aMdn . setAttribute ( AS2MessageMDN . MDNA_DISPOSITION , aDisposition . getAsString ( ) ) ; final String sDispositionOptions = aMsg . getHeader ( CAS2Header . HEADER_DISPOSITION_NOTIFICATION_OPTIONS ) ; final DispositionOptions aDispositionOptions = DispositionOptions . createFromString ( sDispositionOptions ) ; String sMIC = null ; if ( aDispositionOptions . getMICAlg ( ) ! = null ) { sMIC = getCryptoHelper ( ) . calculateMIC ( aMsg . getData ( ) , aDispositionOptions . getMICAlg ( ) , aMsg . getHistory ( ) . getItemCount ( ) > 1 ) ; } aMdn . setAttribute ( AS2MessageMDN . MDNA_MIC , sMIC ) ; createMDNData ( aSession , aMdn , aDispositionOptions . getMICAlg ( ) , aDispositionOptions . getProtocol ( ) ) ; aMdn . updateMessageID ( ) ; aMsg . setMDN ( aMdn ) ; return aMdn ; }
public int execAsync ( Runnable run ) { int actjobid = iJobID + + ; oMPDAsyncWorker . obtainMessage ( EVENT_EXECASYNC , actjobid , 0 , run ) . sendToTarget ( ) ; return actjobid ; }
public synchronized void clear ( ) { items . clear ( ) ; pending . clear ( ) ; mass = 0 ; numPriorityThru = 0 ; totalPriorityThru = 0 ; }
String showSizes ( ) { StringBuilder buf = new StringBuilder ( "   " ) ; int levels = 0 ; for ( ArrayList < Type > items : itemTable ) { if ( ( items ! = null ) & & ! items . isEmpty ( ) ) { levels + + ; buf . append ( items . size ( ) ) . append ( "   " ) ; } } return " Levels:  " + Integer . toString ( levels ) + " , sizes:  " + buf ; }
protected Term function ( Memory memory , Term [ ] x ) { if ( x . length ! = 2 ) { throw new IllegalStateException ( " Requires 2 arguments " ) ; } int n1 , n2 ; if ( StringUtils . isNumeric ( x [ 0 ] . name ( ) ) ) { n1 = Integer . parseInt ( String . valueOf ( x [ 0 ] . name ( ) ) ) ; } else { throw new IllegalArgumentException ( " 1st parameter not an integer " ) ; } if ( StringUtils . isNumeric ( ( x [ 1 ] . name ( ) ) ) ) { n2 = Integer . parseInt ( String . valueOf ( x [ 1 ] . name ( ) ) ) ; } else { throw new IllegalArgumentException ( " 2nd parameter not an integer " ) ; } return new Term ( String . valueOf ( n1 + n2 ) ) ; }
protected abstract OperationFactory getOperationFactory ( ) ; public void testDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , genericCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertCallback ( op2 ) ; } public void testCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , genericCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getBytes ( ) ) ; assertCallback ( op2 ) ; } public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } public void testMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; int by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } public void testStoreOperationAddCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . add , TEST_KEY , flags , exp , testData , genericCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . add , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testStoreOperationSetCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . set , TEST_KEY , flags , exp , testData , genericCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . set , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testConcatenationOperationAppendCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . append , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . append , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testConcatenationOperationPrependCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . prepend , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . prepend , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testSingleGetOperationCloning ( ) { GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( TEST_KEY , callback ) ; GetOperation op2 = cloneOne ( GetOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; } public void testSingleGetsOperationCloning ( ) { GetsOperation . Callback callback = ( GetsOperation . Callback ) mock ( GetsOperation . Callback . class ) . proxy ( ) ; GetsOperation op = ofact . gets ( TEST_KEY , callback ) ; GetsOperation op2 = cloneOne ( GetsOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; } public void testMultipleGetOperationCloning ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Collection < Operation > ops = ofact . clone ( op ) ; assertEquals ( 3 , ops . size ( ) ) ; Collection < String > mutableKeys = new ArrayList < String > ( keys ) ; int i = 3 ; for ( Operation o : ops ) { assertEquals ( i , mutableKeys . size ( ) ) ; GetOperation go = ( GetOperation ) o ; mutableKeys . removeAll ( go . getKeys ( ) ) ; assertEquals ( - - i , mutableKeys . size ( ) ) ; } } public void testMultipleGetOperationFanout ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; Mock m = mock ( GetOperation . Callback . class ) ; OperationStatus st = new OperationStatus ( true , " blah " ) ; m . expects ( once ( ) ) . method ( " complete " ) ; m . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; GetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Iterator < String > ki = keys . iterator ( ) ; int i = 0 ; for ( Operation o : ofact . clone ( op ) ) { GetOperation . Callback cb = ( GetOperation . Callback ) o . getCallback ( ) ; cb . gotData ( ki . next ( ) , + + i , new byte [ 3 ] ) ; cb . receivedStatus ( st ) ; cb . complete ( ) ; } } protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; } protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; } private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( testData , bytes ) ) ; } @SuppressWarnings ( " unchecked " ) private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; } protected < T > T cloneOne ( Class < T > c , KeyedOperation t ) { return assertOne ( c , ofact . clone ( t ) ) ; } }
public Object visit ( TrmExDif p , LoanParser arg ) { Term t1 = ( Term ) p . term_1 . accept ( this , arg ) ; Term t2 = ( Term ) p . term_2 . accept ( this , arg ) ; ArrayList < Term > ts = new ArrayList < Term > ( ) ; ts . add ( t1 ) ; ts . add ( t2 ) ; return CompoundTerm . make ( Symbols . DIFFERENCE_EXT_OPERATOR , ts , memory ) ; }
public void start ( ) { this . sourceProcessor . sendInstances ( this . inputStream , this . numInstances , false , true , this . numberEvaluations ) ;
public void initialize ( ) { if ( exp > 0 ) { prepareBuffer ( key , 0 , EMPTY_BYTES , exp ) ;
protected void getAlbumDetails ( final List < Album > albums , final boolean findYear ) throws IOException , MPDException { if ( isCached ( ) ) { for ( final Album album : albums ) {
protected void onPostExecute ( final Void result ) { super . onPostExecute ( result ) ; if ( songPos = = - 1 ) { Log . d ( TAG , " Missing list item. " ) ;
public List < OutputCondition > enableConditions ( final NAR n , final int similarResultsToSave ) { return OutputCondition . getConditions ( n , source , similarResultsToSave ) ; }
public Map < String , T > get ( long to , TimeUnit unit ) throws InterruptedException , ExecutionException , TimeoutException { Collection < Operation > timedoutOps = new HashSet < Operation > ( ) ; Map < String , T > ret = internalGet ( to , unit , timedoutOps ) ; if ( timedoutOps . size ( ) > 0 ) { this . timeout = true ; throw new CheckedOperationTimeoutException ( " Operation timed out. " , timedoutOps ) ; } return ret ; }
public Meter reset ( ) { super . reset ( ) ; lastHitStamp = - 1 ; return this ; }
public void run ( ) { final String input = NALTest . getExample ( example ) ; Memory . resetStatic ( ) ; final List < OutputCondition > expects = new ArrayList ( ) ; List < OutputCondition > extractedExpects = OutputCondition . getConditions ( nar , input , 5 ) ; for ( OutputCondition e1 : extractedExpects ) { expects . add ( e1 ) ; } nar . addInput ( input ) ; boolean error = false ; int successes = 0 ; fields . add ( " id " ) ; fields . add ( " time " ) ; fields . add ( " absTime " ) ; fields . add ( " successes " ) ; fields . add ( " error " ) ; additionalCycles + = 1 ; do { double successRate = successes / ( ( double ) expects . size ( ) ) ; if ( error ) break ; if ( successes = = expects . size ( ) ) { if ( additionalCycles = = 0 ) break ; additionalCycles - - ; } try { nar . step ( 1 ) ; } catch ( Exception e ) { error = true ; } successes = 0 ; for ( OutputCondition e : expects ) { if ( e . succeeded ) { successes + + ; } } } while ( nar . time ( ) < maxCycles ) ; exampleNum + + ; if ( error ) { failAt = ( int ) nar . time ( ) ; } if ( successes = = expects . size ( ) ) { successAt = ( int ) nar . time ( ) ; } if ( ! expects . isEmpty ( ) ) { success = successes / expects . size ( ) ;
long getHits ( ) ; long getFirstHitStamp ( ) ; long getLastHitStamp ( ) ; long getCommits ( ) ; double getFirst ( ) ; double getLast ( ) ; double getMin ( ) ; double getMax ( ) ; double getSum ( ) ; Object getField ( String name ) ; DataSet collectData ( ) ; DataSet drainData ( ) ; void restore ( DataSet dataSet ) ; void track ( Tracker tracker , long now ) ; void update ( Tracker tracker , long now ) ; void clear ( ) ; }
public void step ( ) { for ( VisionRay v : vision ) v . step ( ) ; if ( Rover . cnt > = do_sth_importance ) { Rover . cnt = 0 ; Rover . do_sth_importance + = decrease_of_importance_step ; ArrayList < String > candids = new ArrayList < > ( ) ; candids . add ( " (^motor,left). :|: " ) ; candids . add ( " (^motor,right). :|: " ) ; candids . add ( " (^motor,forward). :|: " ) ; int candid = ( int ) ( Math . random ( ) * candids . size ( ) - 0.001 ) ; nar . addInput ( candids . get ( candid ) ) ; switch ( candids . get ( candid ) ) { case " (^motor,left). :|: " : rover . rotate ( rotationSpeed ) ; break ; case " (^motor,right). :|: " : rover . rotate ( - rotationSpeed ) ; break ; case " (^motor,forward). :|: " : rover . thrust ( 0 , linearSpeed ) ; break ; } } if ( feel_motion ) { feelMotion ( ) ; } Rover . cnt + + ; }
public boolean remove ( T value ) { boolean result = super . remove ( value ) ; return result ; }
protected void print ( final Color color , final String text ) { StyleContext sc = StyleContext . getDefaultStyleContext ( ) ; MutableAttributeSet aset = getInputAttributes ( ) ; StyleConstants . setForeground ( aset , color ) ; StyleConstants . setBackground ( aset , Color . BLACK ) ; try { doc . insertString ( doc . getLength ( ) , text , aset ) ;
public String externalName ( ) { return _externalName ; }
public R visitDefault ( com . googlecode . opennars . parser . loan . Loan . Absyn . Stm p , A arg ) { throw new IllegalArgumentException ( this . getClass ( ) . getName ( ) + " :  " + p ) ; }
protected List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) { String state = args [ 0 ] . toString ( ) ; Task task = operation . getTask ( ) ; if ( ! task . isInput ( ) ) { int delta = 0 ; if ( state . equals ( " on " ) ) { delta = 1 ; } else if ( state . equals ( " off " ) ) { delta = - 1 ; } } return super . execute ( operation , args , memory ) ; }
protected void finalize ( ) throws Throwable { try { closeAndDelete ( ) ; } catch ( final Exception ex ) { LOGGER . error ( " Exception in finalize() " , ex ) ; } super . finalize ( ) ; }
private void initAbsSpinner ( ) { setFocusable ( true ) ; setWillNotDraw ( false ) ; }
public void getByFullKeyAndValues ( ) throws Exception { truncate ( ) ; RandomOutput zkOutput = new ZooKeeperOutput ( ) ; zkOutput . configure ( config ) ; Row row1 = new RowWithSchema ( schema , " hello " , 100 , 1000L , true , 1.0f , - 1.0 ) ; Row row2 = new RowWithSchema ( schema , " world " , - 100 , - 1000L , false , - 1.0f , 1.0 ) ; List < Row > upsertPlan = Lists . newArrayList ( PlannerUtils . setMutationType ( row1 , MutationType . UPSERT ) , PlannerUtils . setMutationType ( row2 , MutationType . UPSERT ) ) ; zkOutput . applyRandomMutations ( upsertPlan ) ; StructType keySchemaWithValues = keySchema . add ( DataTypes . createStructField ( " field4 " , DataTypes . BooleanType , false ) ) . add ( DataTypes . createStructField ( " field6 " , DataTypes . DoubleType , false ) ) ; Row filter1 = new RowWithSchema ( keySchemaWithValues , " hello " , 100 , 1000L , true , - 1.0 ) ; Row filter2 = new RowWithSchema ( keySchemaWithValues , " world " , - 100 , - 1000L , true , - 1.0 ) ; List < Row > filters = Lists . newArrayList ( filter1 , filter2 ) ; List < Row > rows = Lists . newArrayList ( zkOutput . getExistingForFilters ( filters ) ) ; assertEquals ( rows . size ( ) , 1 ) ; assertEquals ( rows . get ( 0 ) , row1 ) ; }
public PrivateKey getPrivateKey ( final IMessage aMsg , final X509Certificate aCert ) throws OpenAS2Exception { return getPrivateKey ( aCert ) ; }
public boolean nextInput ( ) { if ( timer > 0 ) { timer - - ; return true ; } if ( inExp = = null ) { return false ; } String line = null ; while ( timer = = 0 ) { try { line = inExp . readLine ( ) ; if ( line = = null ) { inExp . close ( ) ; inExp = null ; return false ; } } catch ( IOException ex ) { reasoner . output ( " i/o error:  " + ex . getMessage ( ) ) ; inExp = null ; } if ( ! parse ( line ) ) break ; } return true ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmFut p , A arg ) { R r = leaf ( arg ) ; r = combine ( p . stm_ . accept ( this , arg ) , r , arg ) ; return r ; }
protected MIC calculateAndStoreMIC ( @Nonnull final AS2Message aMsg ) throws Exception { final Partnership aPartnership = aMsg . partnership ( ) ; final boolean bIncludeHeadersInMIC = aPartnership . getSigningAlgorithm ( ) ! = null | | aPartnership . getEncryptAlgorithm ( ) ! = null | | aPartnership . getCompressionType ( ) ! = null ; final String sSigningAlgorithm = aPartnership . getSigningAlgorithm ( ) ; ECryptoAlgorithmSign eSigningAlgorithm = ECryptoAlgorithmSign . getFromIDOrNull ( sSigningAlgorithm ) ; if ( eSigningAlgorithm = = null ) { final boolean bUseRFC3851MICAlg = aPartnership . isRFC3851MICAlgs ( ) ; eSigningAlgorithm = bUseRFC3851MICAlg ? ECryptoAlgorithmSign . DEFAULT_RFC_3851 : ECryptoAlgorithmSign . DEFAULT_RFC_5751 ; if ( LOGGER . isWarnEnabled ( ) ) LOGGER . warn ( " The partnership signing algorithm name ' " + sSigningAlgorithm + " ' is unknown. Fallbacking back to the default ' " + eSigningAlgorithm . getID ( ) + " ' " ) ; } final MIC aMIC = AS2Helper . getCryptoHelper ( ) . calculateMIC ( aMsg . getData ( ) , eSigningAlgorithm , bIncludeHeadersInMIC ) ; aMsg . attrs ( ) . putIn ( AS2Message . ATTRIBUTE_MIC , aMIC . getAsAS2String ( ) ) ; if ( aPartnership . getAS2ReceiptDeliveryOption ( ) ! = null ) { storePendingInfo ( aMsg , aMIC ) ; } return aMIC ; }
public void testApplyBulkMutations ( ) throws Exception { Table table = connection . getTable ( TableName . valueOf ( TABLE ) ) ; Config config = ConfigUtils . configFromResource ( " /hbase/hbase-output-test.conf " ) . getConfig ( " output " ) ; config = config . withValue ( " zookeeper " , ConfigValueFactory . fromAnyRef ( " localhost: " + utility . getZkCluster ( ) . getClientPort ( ) ) ) ; HBaseOutput output = new HBaseOutput ( ) ; output . configure ( config ) ; Dataset < Row > upserts = createBulkMutations ( INPUT_ROWS ) ; Dataset < Row > deletes = createBulkMutations ( INPUT_ROWS ) ; List < Tuple2 < MutationType , Dataset < Row > > > bulk1 = Lists . newArrayList ( ) ; bulk1 . add ( new Tuple2 < > ( MutationType . UPSERT , upserts ) ) ; List < Tuple2 < MutationType , Dataset < Row > > > bulk2 = Lists . newArrayList ( ) ; bulk2 . add ( new Tuple2 < > ( MutationType . DELETE , deletes ) ) ; List < Tuple2 < MutationType , Dataset < Row > > > bulk3 = Lists . newArrayList ( ) ; bulk3 . add ( new Tuple2 < > ( MutationType . UPSERT , upserts ) ) ; bulk3 . add ( new Tuple2 < > ( MutationType . DELETE , deletes ) ) ; output . applyBulkMutations ( bulk1 ) ; scanAndCountTable ( table , INPUT_ROWS * 4 ) ; output . applyBulkMutations ( bulk2 ) ; scanAndCountTable ( table , 0 ) ; output . applyBulkMutations ( bulk3 ) ; scanAndCountTable ( table , 0 ) ; }
public T get ( long duration , TimeUnit units ) throws InterruptedException , TimeoutException , ExecutionException { if ( ! latch . await ( duration , units ) ) { MemcachedConnection . opTimedOut ( op ) ; if ( op ! = null ) { op . timeOut ( ) ; } throw new CheckedOperationTimeoutException ( " Timed out waiting for operation " , op ) ; } else { MemcachedConnection . opSucceeded ( op ) ; } if ( op ! = null & & op . hasErrored ( ) ) { throw new ExecutionException ( op . getException ( ) ) ; } if ( isCancelled ( ) ) { throw new ExecutionException ( new RuntimeException ( " Cancelled " ) ) ; } if ( op ! = null & & op . isTimedOut ( ) ) { throw new ExecutionException ( new CheckedOperationTimeoutException ( " Operation timed out. " , op ) ) ; } return objRef . get ( ) ; }
public static void InternalExperienceFromBelief ( Memory memory , Task task , Sentence belief ) { Task T = new Task ( belief . clone ( ) , task . budget . clone ( ) , null ) ; InternalExperienceFromTask ( memory , T , false ) ; }
public void savePlaylist ( String file ) throws MPDServerException { try { this . mpd . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_DELETE , file ) ; } catch ( MPDServerException e ) { } this . mpd . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_SAVE , file ) ; }
public void testOverflowingWriteQueue ( ) throws Exception { byte [ ] b = new byte [ 8192 ] ; Random r = new Random ( ) ; if ( TestConfig . isCITest ( ) ) { return ; } r . nextBytes ( b ) ; runOverflowTest ( b ) ; }
public SolveInfo solveNext ( double maxTimeSec ) throws NoMoreSolutionException { if ( hasOpenAlternatives ( ) ) { refreeze ( ) ;
public FrameLayout . LayoutParams generateLayoutParams ( AttributeSet attrs ) { return new PullToRefreshLayout . LayoutParams ( getContext ( ) , attrs ) ; }
public void die ( ) { xDeathPos = ( int ) x ; yDeathPos = ( int ) y ; world . paused = true ; deathTime = 1 ; Art . stopMusic ( ) ; world . sound . play ( Art . samples [ Art . SAMPLE_MARIO_DEATH ] , this , 1 , 1 , 1 ) ; }
public void removeComment ( List < String > path ) { final int lastIndex = path . size ( ) - 1 ; Map < String , CommentInfos > currentMap = commentsMap ; for ( String key : path . subList ( 0 , lastIndex ) ) { CommentInfos infos = currentMap . get ( key ) ; if ( ! infos . hasSubInfos ( ) ) { return ; } currentMap = infos . subInfos ; } String lastKey = path . get ( lastIndex ) ; currentMap . remove ( lastKey ) ; }
public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < size ; i + + ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; }
private int decrementColor ( int colorIndex ) { - - colorIndex ; if ( colorIndex < 0 ) colorIndex = mColors . length - 1 ; return colorIndex ; }
public static String htmlParaphrase ( String href , String stmt , Map phraseMap , Map termMap , String language ) { int end ; int start = - 1 ; String nlFormat = nlStmtPara ( stmt , false , phraseMap , termMap , language , 1 ) ; if ( nlFormat ! = null ) { while ( nlFormat . contains ( " &% " ) ) { start = nlFormat . indexOf ( " &% " , start + 1 ) ; int word = nlFormat . indexOf ( '$' , start ) ; if ( word = = - 1 ) { end = start + 2 ; } else { end = word + 1 ; } while ( end < nlFormat . length ( ) & & Character . isJavaIdentifierPart ( nlFormat . charAt ( end ) ) ) { end + + ; } if ( word = = - 1 ) { nlFormat = ( nlFormat . substring ( 0 , start ) + " <a href= \" " + href + " &term= " + nlFormat . substring ( start + 2 , end ) + " \" > " + nlFormat . substring ( start + 1 , end ) + " </a> " + nlFormat . substring ( end , nlFormat . length ( ) ) ) ; } else { nlFormat = ( nlFormat . substring ( 0 , start ) + " <a href= \" " + href + " &term= " + nlFormat . substring ( start + 2 , word ) + " \" > " + nlFormat . substring ( word + 1 , end ) + " </a> " + nlFormat . substring ( end , nlFormat . length ( ) ) ) ; } } } else { nlFormat = " " ; } return nlFormat ; }
ICertificateFactory getCertificateFactory ( ) throws ComponentNotFoundException ; @Nonnull IPartnershipFactory getPartnershipFactory ( ) throws ComponentNotFoundException ; @Nonnull IMessageProcessor getMessageProcessor ( ) throws ComponentNotFoundException ; }
public static final long fibonacciSequenceUsingMatrixMultiplication ( int n ) { long [ ] [ ] matrix = new long [ 2 ] [ 2 ] ; matrix [ 0 ] [ 0 ] = 1 ; matrix [ 0 ] [ 1 ] = 1 ; matrix [ 1 ] [ 0 ] = 1 ; matrix [ 1 ] [ 1 ] = 0 ; long [ ] [ ] temp = new long [ 2 ] [ 2 ] ; temp [ 0 ] [ 0 ] = 1 ; temp [ 0 ] [ 1 ] = 1 ; temp [ 1 ] [ 0 ] = 1 ; temp [ 1 ] [ 1 ] = 0 ; int counter = n ; while ( counter > 0 ) { temp = multiplyMatrices ( matrix , temp ) ; counter - = ( counter = = n ) ? 2 : 1 ; } return temp [ 0 ] [ 1 ] ; }
public boolean isMonitorAlive ( ) { if ( mStatusMonitor = = null ) { return false ;
Rule CompoundTerm ( ) { return sequence ( " { " , Term ( ) , zeroOrMore ( sequence ( " , " , Term ( ) ) ) , " } " ) ;
private static void runStreaming ( final Set < Step > steps ) throws Exception { final Set < Step > independentNonStreamingSteps = StepUtils . getIndependentNonStreamingSteps ( steps ) ; runBatch ( independentNonStreamingSteps ) ; Set < StreamingStep > streamingSteps = StepUtils . getStreamingSteps ( steps ) ; for ( final StreamingStep streamingStep : streamingSteps ) { LOG . debug ( " Setting up streaming step:  " + streamingStep . getName ( ) ) ; JavaDStream stream = streamingStep . getStream ( ) ; stream . foreachRDD ( new VoidFunction < JavaRDD < ? > > ( ) { @Override public void call ( JavaRDD < ? > raw ) throws Exception { StepUtils . resetRepeatingSteps ( steps ) ; runBatch ( independentNonStreamingSteps ) ; streamingStep . setData ( streamingStep . translate ( raw ) ) ; streamingStep . setSubmitted ( true ) ; Set < Step > dependentSteps = StepUtils . getAllDependentSteps ( streamingStep , steps ) ; Set < Step > batchSteps = Sets . newHashSet ( dependentSteps ) ; batchSteps . add ( streamingStep ) ; batchSteps . addAll ( independentNonStreamingSteps ) ; runBatch ( batchSteps ) ; StepUtils . resetSteps ( dependentSteps ) ; streamingStep . recordProgress ( raw ) ; } } ) ; LOG . debug ( " Finished setting up streaming step:  " + streamingStep . getName ( ) ) ; } JavaStreamingContext jsc = Contexts . getJavaStreamingContext ( ) ; jsc . start ( ) ; LOG . debug ( " Streaming context started " ) ; jsc . awaitTermination ( ) ; LOG . debug ( " Streaming context terminated " ) ; }
public Partnership loadPartnership ( @Nonnull final IMicroElement aElement , @Nonnull final IPartnerMap aAllPartners , @Nonnull final IPartnershipMap aAllPartnerships ) throws OpenAS2Exception { final IStringMap aPartnershipAttrs = XMLUtil . getAttrsWithLowercaseNameWithRequired ( aElement , PARTNER_NAME ) ; final String sPartnershipName = aPartnershipAttrs . getAttributeAsString ( PARTNER_NAME ) ; if ( aAllPartnerships . getPartnershipByName ( sPartnershipName ) ! = null ) throw new OpenAS2Exception ( " Partnership is defined more than once:  " + sPartnershipName ) ; final Partnership aPartnership = new Partnership ( sPartnershipName ) ; loadPartnerIDs ( aElement , aAllPartners , aPartnership , true ) ; loadPartnerIDs ( aElement , aAllPartners , aPartnership , false ) ; loadAttributes ( aElement , aPartnership ) ; return aPartnership ; }
public String toString ( ) { final StringBuilder s = new StringBuilder ( ) ; s . append ( super . toString ( ) ) . append ( ' ' ) . append ( sentence . stamp ) ; if ( parentTask ! = null ) { s . append ( "    \ n from task:  " ) . append ( parentTask . toStringBrief ( ) ) ; if ( parentBelief ! = null ) { s . append ( "    \ n from belief:  " ) . append ( parentBelief . toStringBrief ( ) ) ; } } if ( bestSolution ! = null ) { s . append ( "    \ n solution:  " ) . append ( bestSolution . toStringBrief ( ) ) ; } return s . toString ( ) ; }
public Integer [ ] sort ( Integer [ ] input ) { return BubbleSort . sort ( input ) ; }
public void pauseStreaming ( ) { Log . d ( TAG , " StreamingService.pauseStreaming() " ) ; if ( ! isPlaying ) { return ; } isPlaying = false ; isPaused = true ; isBuffering ( false ) ; if ( mediaPlayer ! = null ) { mediaPlayer . stop ( ) ;
static void transformProductImage ( Inheritance inh , CompoundTerm oldContent , short [ ] indices , NAL nal ) { final Memory memory = nal . mem ( ) ; Term subject = inh . getSubject ( ) ; Term predicate = inh . getPredicate ( ) ; if ( inh . equals ( oldContent ) ) { if ( subject instanceof CompoundTerm ) { transformSubjectPI ( ( CompoundTerm ) subject , predicate , nal ) ; } if ( predicate instanceof CompoundTerm ) { transformPredicatePI ( subject , ( CompoundTerm ) predicate , nal ) ; } return ; } short index = indices [ indices . length - 1 ] ; short side = indices [ indices . length - 2 ] ; Term compT = inh . term [ side ] ; if ( ! ( compT instanceof CompoundTerm ) ) return ; CompoundTerm comp = ( CompoundTerm ) compT ; if ( comp instanceof Product ) { if ( side = = 0 ) { subject = comp . term [ index ] ; predicate = ImageExt . make ( ( Product ) comp , inh . getPredicate ( ) , index , memory ) ; } else { subject = ImageInt . make ( ( Product ) comp , inh . getSubject ( ) , index , memory ) ; predicate = comp . term [ index ] ; } } else if ( ( comp instanceof ImageExt ) & & ( side = = 1 ) ) { if ( index = = ( ( ImageExt ) comp ) . relationIndex ) { subject = Product . make ( comp , inh . getSubject ( ) , index , memory ) ; predicate = comp . term [ index ] ; } else { subject = comp . term [ index ] ; predicate = ImageExt . make ( ( ImageExt ) comp , inh . getSubject ( ) , index , memory ) ; } } else if ( ( comp instanceof ImageInt ) & & ( side = = 0 ) ) { if ( index = = ( ( ImageInt ) comp ) . relationIndex ) { subject = comp . term [ index ] ; predicate = Product . make ( comp , inh . getPredicate ( ) , index , memory ) ; } else { subject = ImageInt . make ( ( ImageInt ) comp , inh . getPredicate ( ) , index , memory ) ; predicate = comp . term [ index ] ; } } else { return ; } Inheritance newInh = Inheritance . make ( subject , predicate , memory ) ; if ( newInh = = null ) return ; Term content = null ; if ( indices . length = = 2 ) { content = newInh ; } else if ( ( oldContent instanceof Statement ) & & ( indices [ 0 ] = = 1 ) ) { content = Statement . make ( ( Statement ) oldContent , oldContent . term [ 0 ] , newInh , oldContent . getTemporalOrder ( ) , memory ) ; } else { Term [ ] componentList ; Term condition = oldContent . term [ 0 ] ; if ( ( ( oldContent instanceof Implication ) | | ( oldContent instanceof Equivalence ) ) & & ( condition instanceof Conjunction ) ) { componentList = ( ( CompoundTerm ) condition ) . cloneTerms ( ) ; componentList [ indices [ 1 ] ] = newInh ; Term newCond = memory . term ( ( CompoundTerm ) condition , componentList ) ; content = Statement . make ( ( Statement ) oldContent , newCond , ( ( Statement ) oldContent ) . getPredicate ( ) , oldContent . getTemporalOrder ( ) , memory ) ; } else { componentList = oldContent . cloneTerms ( ) ; componentList [ indices [ 0 ] ] = newInh ; if ( oldContent instanceof Conjunction ) { content = memory . term ( oldContent , componentList ) ; } else if ( ( oldContent instanceof Implication ) | | ( oldContent instanceof Equivalence ) ) { content = Statement . make ( ( Statement ) oldContent , componentList [ 0 ] , componentList [ 1 ] , oldContent . getTemporalOrder ( ) , memory ) ; } } } if ( content = = null ) return ; Sentence sentence = nal . getCurrentTask ( ) . sentence ; TruthValue truth = sentence . truth ; BudgetValue budget ; if ( sentence . isQuestion ( ) ) { budget = BudgetFunctions . compoundBackward ( content , nal ) ; } else { budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; } nal . singlePremiseTask ( content , truth , budget ) ; }
public static File resource ( String path ) { return new File ( " ./nars_lab/nars/lab/launcher/ " + path ) ; }
private static void transformPredicatePI ( Term subject , CompoundTerm predicate , NAL nal ) { TruthValue truth = nal . getCurrentTask ( ) . sentence . truth ; BudgetValue budget ; Inheritance inheritance ; Term newSubj , newPred ; if ( predicate instanceof Product ) { Product product = ( Product ) predicate ;
public static Term make ( Term [ ] argList ) { if ( argList . length < 2 ) { return null ; } Term relation = argList [ 0 ] ; Term [ ] argument = new Term [ argList . length - 1 ] ; int index = 0 , n = 0 ; for ( int j = 1 ; j < argList . length ; j + + ) { if ( isPlaceHolder ( argList [ j ] ) ) { index = j - 1 ; argument [ n ] = relation ; } else { argument [ n ] = argList [ j ] ; } n + + ; } return new ImageExt ( argument , ( short ) index ) ; }
public void applyPlannedMutations ( List < PlannedRecord > planned ) throws Exception { List < Operation > operations = extractOperations ( planned ) ; for ( Operation operation : operations ) { session . apply ( operation ) ; } while ( session . hasPendingOperations ( ) ) { Thread . sleep ( 1 ) ; } if ( session . countPendingErrors ( ) > 0 ) { RowError [ ] errors = session . getPendingErrors ( ) . getRowErrors ( ) ;
void hcam_mouseDragged ( ) { if ( mouseButton = = CENTER ) {
protected abstract List < Task > execute ( Operation operation , Term [ ] args , Memory memory ) ; public final boolean call ( final Operation operation , final Term [ ] args , final Memory memory ) { try { List < Task > feedback = execute ( operation , args , memory ) ; memory . executedTask ( operation ) ; reportExecution ( operation , args , feedback , memory ) ; if ( feedback ! = null ) { for ( final Task t : feedback ) { memory . inputTask ( t ) ; } } return true ; } catch ( Exception e ) { reportExecution ( operation , args , e , memory ) ; } return false ; } public static String operationExecutionString ( final Statement operation ) { Term operator = operation . getPredicate ( ) ; Term arguments = operation . getSubject ( ) ; String argList = arguments . toString ( ) . substring ( 3 ) ; return operator + " ( " + argList ; } @Override public Operator clone ( ) { return this ; } public static void reportExecution ( final Operation operation , final Term [ ] args , Object feedback , final Memory memory ) { final Term opT = operation . getPredicate ( ) ; if ( ! ( opT instanceof Operator ) ) { return ; } if ( memory . emitting ( EXE . class ) ) { final Operator operator = ( Operator ) opT ; Task t = operation . getTask ( ) ; BudgetValue b = null ; if ( t ! = null ) { b = operation . getTask ( ) . budget ; } if ( feedback instanceof Exception ) feedback = feedback . getClass ( ) . getSimpleName ( ) + " :  " + ( ( Throwable ) feedback ) . getMessage ( ) ; memory . emit ( EXE . class , ( ( b ! = null ) ? ( b . toStringExternal ( ) + "   " ) : " " ) + operator + " ( " + Arrays . toString ( args ) + " )= " + feedback ) ; } } public final boolean call ( final Operation op , final Memory memory ) { Product args = op . getArguments ( ) ; return call ( op , args . term , memory ) ; } }
public void gotData ( long cas ) { } public void receivedStatus ( OperationStatus status ) { fail ( " Unexpected status:   " + status ) ; } } ; testData = new byte [ 64 ] ; new Random ( ) . nextBytes ( testData ) ; } protected abstract OperationFactory getOperationFactory ( ) ; public void testDeleteOperationCloning ( ) { DeleteOperation op = ofact . delete ( TEST_KEY , deleteCallback ) ; DeleteOperation op2 = cloneOne ( DeleteOperation . class , op ) ; assertEquals ( TEST_KEY , op2 . getKeys ( ) . iterator ( ) . next ( ) ) ; assertDeleteCallback ( op2 ) ; } public void testCASOperationCloning ( ) { CASOperation op = ofact . cas ( StoreType . set , " someKey " , 727582 , 8174 , 7175 , testData , storeCallback ) ; CASOperation op2 = cloneOne ( CASOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( 727582 , op2 . getCasValue ( ) ) ; assertEquals ( 8174 , op2 . getFlags ( ) ) ; assertEquals ( 7175 , op2 . getExpiration ( ) ) ; assertBytes ( op2 . getData ( ) ) ; assertStoreCallback ( op2 ) ; } public void testMutatorOperationIncrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . incr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . incr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } public void testMutatorOperationDecrCloning ( ) { int exp = 823862 ; long def = 28775 ; long by = 7735 ; MutatorOperation op = ofact . mutate ( Mutator . decr , TEST_KEY , by , def , exp , genericCallback ) ; MutatorOperation op2 = cloneOne ( MutatorOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( def , op2 . getDefault ( ) ) ; assertEquals ( by , op2 . getBy ( ) ) ; assertSame ( Mutator . decr , op2 . getType ( ) ) ; assertCallback ( op2 ) ; } public void testStoreOperationAddCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . add , TEST_KEY , flags , exp , testData , storeCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . add , op2 . getStoreType ( ) ) ; assertStoreCallback ( op2 ) ; } public void testStoreOperationSetCloning ( ) { int exp = 823862 ; int flags = 7735 ; StoreOperation op = ofact . store ( StoreType . set , TEST_KEY , flags , exp , testData , storeCallback ) ; StoreOperation op2 = cloneOne ( StoreOperation . class , op ) ; assertKey ( op2 ) ; assertEquals ( exp , op2 . getExpiration ( ) ) ; assertEquals ( flags , op2 . getFlags ( ) ) ; assertSame ( StoreType . set , op2 . getStoreType ( ) ) ; assertStoreCallback ( op2 ) ; } public void testConcatenationOperationAppendCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . append , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . append , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testConcatenationOperationPrependCloning ( ) { long casId = 82757248 ; ConcatenationOperation op = ofact . cat ( ConcatenationType . prepend , casId , TEST_KEY , testData , genericCallback ) ; ConcatenationOperation op2 = cloneOne ( ConcatenationOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( ConcatenationType . prepend , op2 . getStoreType ( ) ) ; assertCallback ( op2 ) ; } public void testSingleGetOperationCloning ( ) { GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( TEST_KEY , callback ) ; GetOperation op2 = cloneOne ( GetOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; } public void testSingleGetsOperationCloning ( ) { GetsOperation . Callback callback = ( GetsOperation . Callback ) mock ( GetsOperation . Callback . class ) . proxy ( ) ; GetsOperation op = ofact . gets ( TEST_KEY , callback ) ; GetsOperation op2 = cloneOne ( GetsOperation . class , op ) ; assertKey ( op2 ) ; assertSame ( callback , op . getCallback ( ) ) ; } public void testMultipleGetOperationCloning ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; GetOperation . Callback callback = ( GetOperation . Callback ) mock ( GetOperation . Callback . class ) . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Collection < Operation > ops = ofact . clone ( op ) ; assertEquals ( 3 , ops . size ( ) ) ; Collection < String > mutableKeys = new ArrayList < String > ( keys ) ; int i = 3 ; for ( Operation o : ops ) { assertEquals ( i , mutableKeys . size ( ) ) ; GetOperation go = ( GetOperation ) o ; mutableKeys . removeAll ( go . getKeys ( ) ) ; assertEquals ( - - i , mutableKeys . size ( ) ) ; } } public void testMultipleGetOperationFanout ( ) { Collection < String > keys = Arrays . asList ( " k1 " , " k2 " , " k3 " ) ; Mock m = mock ( GetOperation . Callback . class ) ; OperationStatus st = new OperationStatus ( true , " blah " ) ; m . expects ( once ( ) ) . method ( " complete " ) ; m . expects ( once ( ) ) . method ( " receivedStatus " ) . with ( same ( st ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k1 " ) , eq ( 1 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k2 " ) , eq ( 2 ) , isA ( byte [ ] . class ) ) ; m . expects ( once ( ) ) . method ( " gotData " ) . with ( eq ( " k3 " ) , eq ( 3 ) , isA ( byte [ ] . class ) ) ; GetOperation . Callback callback = ( GetOperation . Callback ) m . proxy ( ) ; GetOperation op = ofact . get ( keys , callback ) ; Iterator < String > ki = keys . iterator ( ) ; int i = 0 ; for ( Operation o : ofact . clone ( op ) ) { GetOperation . Callback cb = ( GetOperation . Callback ) o . getCallback ( ) ; cb . gotData ( ki . next ( ) , + + i , new byte [ 3 ] ) ; cb . receivedStatus ( st ) ; cb . complete ( ) ; } } protected void assertKey ( KeyedOperation op ) { assertEquals ( TEST_KEY , op . getKeys ( ) . iterator ( ) . next ( ) ) ; } protected void assertCallback ( Operation op ) { assertSame ( genericCallback , op . getCallback ( ) ) ; } protected void assertStoreCallback ( Operation op ) { assertSame ( storeCallback , op . getCallback ( ) ) ; } protected void assertDeleteCallback ( Operation op ) { assertSame ( deleteCallback , op . getCallback ( ) ) ; } private void assertBytes ( byte [ ] bytes ) { assertTrue ( Arrays . equals ( testData , bytes ) ) ; } @SuppressWarnings ( " unchecked " ) private < T > T assertOne ( Class < T > class1 , Collection < Operation > ops ) { assertEquals ( 1 , ops . size ( ) ) ; Operation op = ops . iterator ( ) . next ( ) ; return ( T ) op ; } protected < T > T cloneOne ( Class < T > c , KeyedOperation t ) { return assertOne ( c , ofact . clone ( t ) ) ; } }
public void removeProperty ( Property property ) { model . removeProperty ( property ) ; }
public void push ( T value ) { if ( size > = array . length ) { array = Arrays . copyOf ( array , ( ( size * 3 ) / 2 ) + 1 ) ; } array [ size + + ] = value ; }
public void AddABlock ( PhysicsModel p , float w , float h ) { float x = ( float ) Math . random ( ) * w - w / 2f ; float y = ( float ) Math . random ( ) * h - h / 2f ; float bw = 1.0f ; float bh = 1.6f ; float a = 0 ; addBlock ( p , x * 2.0f , y * 2.0f , bw , bh , a ) ; }
public void onStop ( ) { super . onStop ( ) ; app . oMPDAsyncHelper . removeStatusChangeListener ( this ) ; app . oMPDAsyncHelper . removeTrackPositionListener ( this ) ; stopPosTimer ( ) ; app . unsetActivity ( this ) ; }
public void testDeriveDropRangePartitionBoundariesQuery ( ) { Map < String , Object > configMap = new HashMap < > ( ) ; configMap . put ( HOST_CONFIG , " testhost " ) ; configMap . put ( QUERY_TYPE_CONFIG , " drop_partition " ) ; configMap . put ( QUERY_TABLE_CONFIG , " testtable " ) ; configMap . put ( QUERY_PART_RANGE_START_CONFIG , " 20190122 " ) ; configMap . put ( QUERY_PART_RANGE_END_CONFIG , " 20190123 " ) ; configMap . put ( AUTH_CONFIG , " none " ) ; Config config = ConfigFactory . parseMap ( configMap ) ; ImpalaMetadataTask metadataTask = new ImpalaMetadataTask ( ) ; metadataTask . configure ( config ) ; Map < String , Dataset < Row > > dependencies = Maps . newHashMap ( ) ; String query = metadataTask . deriveQuery ( dependencies ) ; assertEquals ( " ALTER TABLE testtable DROP IF EXISTS RANGE PARTITION 20190122 <= VALUES < 20190123 " , query ) ; }
public static int compareTimestamp ( Row first , Row second , String timestampFieldName ) { Long ts1 = ( Long ) first . get ( first . fieldIndex ( timestampFieldName ) ) ; Long ts2 = ( Long ) second . get ( second . fieldIndex ( timestampFieldName ) ) ; if ( ts1 < ts2 ) { return - 1 ;
< T , R > ValueDeserializer < T , R > findValueDeserializer ( T value , Class < ? > resultClass ) { Class < ? > valueClass = value = = null ? null : value . getClass ( ) ; for ( ValueDeserializerProvider provider : this . generalDeserializers ) { ValueDeserializer < ? , ? > maybeDeser = provider . provide ( valueClass , resultClass ) ; if ( maybeDeser ! = null ) { return ( ValueDeserializer < T , R > ) maybeDeser ; } } String ofTypeStr = valueClass = = null ? " " : "  of type  " + valueClass ; throw new DeserializationException ( " No suitable deserializer found for value " + ofTypeStr + " : " + value ) ;
private static boolean shouldPauseForCall ( ) { boolean result = false ; boolean isPlaying = false ; try { isPlaying = APP . oMPDAsyncHelper . oMPD . getStatus ( ) . isState ( MPDStatus . STATE_PLAYING ) ; } catch ( final MPDServerException e ) { Log . e ( TAG , " Failed to get a server state. " , e ) ; } if ( isPlaying ) { if ( APP . isLocalAudible ( ) ) { if ( DEBUG ) { Log . d ( TAG , " App is local audible. " ) ; } result = true ; } else { result = SETTINGS . getBoolean ( " pauseOnPhoneStateChange " , false ) ; if ( DEBUG ) { Log . d ( TAG , " pauseOnPhoneStateChange:  " + result ) ; } } } return result ; }
public static void main ( String [ ] arg ) { NAR nar = new DiscretinuousBagNARBuilder ( ) . setConceptBagSize ( 1024 ) . simulationTime ( ) . build ( ) ; nar . param ( ) . noiseLevel . set ( 0 ) ; float fps = 20 f ; gameRate = 1.0f / fps ; NARio nario = new NARio ( nar ) ; new NARSwing ( nar ) ; nar . startFPS ( fps , 200 , 1f ) ; }
public CachedData encode ( Object o ) { CachedData rv = null ; byte [ ] b = null ; int flags = 0 ; if ( o instanceof String ) { b = ( ( String ) o ) . getBytes ( ) ; } else if ( o instanceof Long ) { b = encodeLong ( ( Long ) o ) ; flags | = SPECIAL_LONG ; } else if ( o instanceof Integer ) { b = encodeInt ( ( Integer ) o ) ; flags | = SPECIAL_INT ; } else if ( o instanceof Boolean ) { b = encodeBoolean ( ( Boolean ) o ) ; flags | = SPECIAL_BOOLEAN ; } else if ( o instanceof Date ) { b = encodeLong ( ( ( Date ) o ) . getTime ( ) ) ; flags | = SPECIAL_DATE ; } else if ( o instanceof Byte ) { b = encodeByte ( ( Byte ) o ) ; flags | = SPECIAL_BYTE ; } else if ( o instanceof Float ) { b = encodeInt ( Float . floatToRawIntBits ( ( Float ) o ) ) ; flags | = SPECIAL_FLOAT ; } else if ( o instanceof Double ) { b = encodeLong ( Double . doubleToRawLongBits ( ( Double ) o ) ) ; flags | = SPECIAL_DOUBLE ; } else { b = serialize ( o ) ; flags | = SERIALIZED ; } if ( b ! = null ) { if ( b . length > compressionThreshold ) { b = compress ( b ) ; flags | = COMPRESSED ; } rv = new CachedData ( flags , b ) ; } return rv ; }
protected E addItem ( E x ) { E previous = items . put ( x . name ( ) , x ) ; if ( x . budget . getLastForgetTime ( ) = = - 1 ) x . budget . setLastForgetTime ( now ) ; return null ; }
public void connectionStateChanged ( MPDConnectionStateChangedEvent event ) { } @Override public void playlistChanged ( MPDPlaylistChangedEvent event ) { } @Override public void randomChanged ( MPDRandomChangedEvent event ) { } @Override public void repeatChanged ( MPDRepeatChangedEvent event ) { } @Override public void stateChanged ( MPDStateChangedEvent event ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = oldStatus ) return ; if ( state = = MPDStatus . MPD_STATE_PLAYING ) { resumeStreaming ( ) ; } else { oldStatus = state ; stopStreaming ( ) ; } } } } @Override public void updateStateChanged ( MPDUpdateStateChangedEvent event ) { } @Override public void volumeChanged ( MPDVolumeChangedEvent event ) { } @Override public void onPrepared ( MediaPlayer mp ) { buffering = false ; oldStatus = " " ; showNotification ( ) ; mediaPlayer . start ( ) ; } @Override public void onCompletion ( MediaPlayer mp ) { MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = MPDStatus . MPD_STATE_PLAYING ) { resumeStreaming ( ) ; } else { oldStatus = state ; stopForeground ( true ) ; } } } } @Override public void onBufferingUpdate ( MediaPlayer mp , int percent ) { Toast . makeText ( this , " Buf update " , Toast . LENGTH_SHORT ) . show ( ) ; } @Override public boolean onError ( MediaPlayer mp , int what , int extra ) { Toast . makeText ( this , " onError " , Toast . LENGTH_SHORT ) . show ( ) ; mediaPlayer . reset ( ) ; return false ; } @Override public boolean onInfo ( MediaPlayer mp , int what , int extra ) { Toast . makeText ( this , " onInfo : " , Toast . LENGTH_SHORT ) . show ( ) ; return false ; } @Override public void connectionFailed ( String message ) { Toast . makeText ( this , " connectionFailed : " , Toast . LENGTH_SHORT ) . show ( ) ; } @Override public void connectionSucceeded ( String message ) { Toast . makeText ( this , " connectionSucceeded : " , Toast . LENGTH_SHORT ) . show ( ) ; } }
protected int addKey ( String k ) { Integer rv = rkeys . get ( k ) ; if ( rv = = null ) { rv = generateOpaque ( ) ; keys . put ( rv , k ) ; bkeys . put ( rv , KeyUtil . getKeyBytes ( k ) ) ; rkeys . put ( k , rv ) ; } return rv ; }
public CountDownLatch broadcastOperation ( final BroadcastOpFactory of ) { return broadcastOperation ( of , locator . getAll ( ) ) ; }
public AbstractBag < Concept > newConceptBag ( Param p ) { return new ContinuousBag < Concept > ( getConceptBagSize ( ) , CONCEPT_FORGETTING_CYCLE , true ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . SentOp p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . SentJudge p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . SentQuest p , A arg ) ; public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . SentGoal p , A arg ) ; } }
void setAttribute ( String sKey , String sValue ) ; void setAttributes ( @Nullable Map < String , String > aAttributes ) ; @Nullable String getHeader ( String sKey ) ; String getHeader ( String sKey , String sDelimiter ) ; @Nonnull InternetHeaders getHeaders ( ) ; void setHeader ( String sKey , String sValue ) ; void addHeader ( String sKey , String sValue ) ; void setHeaders ( @Nullable InternetHeaders aHeaders ) ; @Nonnull DataHistory getHistory ( ) ; void setHistory ( @Nullable DataHistory aHistory ) ; String getMessageID ( ) ; void setMessageID ( String sMessageID ) ; @Nonnull Partnership getPartnership ( ) ; void setPartnership ( @Nullable Partnership aPartnership ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; }
public String getAsString ( ) { final char cNewLine = '\n' ; final StringBuilder aSB = new StringBuilder ( ) ; aSB . append ( " Message From: " ) . append ( partnership ( ) . getAllSenderIDs ( ) ) ; aSB . append ( cNewLine ) . append ( " To: " ) . append ( partnership ( ) . getAllReceiverIDs ( ) ) ; aSB . append ( cNewLine ) . append ( " Headers: " ) . append ( headers ( ) . toString ( ) ) ; aSB . append ( cNewLine ) . append ( " Attributes: " ) . append ( attrs ( ) . toString ( ) ) ; final IMessageMDN aMDN = getMDN ( ) ; if ( aMDN ! = null ) aSB . append ( cNewLine ) . append ( " MDN: " ) . append ( aMDN . getAsString ( ) ) ; return aSB . toString ( ) ; }
public void pause ( ) throws MPDServerException { if ( ! isConnected ( ) ) throw new MPDServerException ( " MPD Connection is not established " ) ; mpdConnection . sendCommand ( MPDCommand . MPD_CMD_PAUSE ) ; }
public final IAS2Session getSession ( ) { if ( m_aSession = = null ) throw new IllegalStateException ( " No session present so far! " ) ; return m_aSession ; }
private String whyNonTraversible ( GridAgent agent , int x , int y , int tx , int ty ) { int dx = Math . abs ( tx - x ) ; int dy = Math . abs ( ty - y ) ; if ( ! ( ( dx < = 1 ) & & ( dy < = 1 ) ) ) return " Too far " ; Cell from = cells . at ( x , y ) ; Cell to = cells . at ( tx , ty ) ; if ( to . isSolid ( ) ) return " Too solid " ; final float maxTraversableHeight = 8 ; float dHeight = to . height - from . height ; if ( dHeight > maxTraversableHeight ) return " Too high " ; return null ; }
public static String getOption ( char flag , String [ ] options ) throws Exception { return getOption ( " " + flag , options ) ; }
public void complete ( ) { if ( - - remaining = = 0 ) { originalCallback . receivedStatus ( mostRecentStatus ) ;
protected void updatePosition ( int x ) { double p = ( ( double ) x ) / ( ( double ) getWidth ( ) ) ; double v = p * ( max - min ) + min ; v = Math . max ( v , min ) ; v = Math . min ( v , max ) ; setValue ( v ) ; repaint ( ) ; }
public String calculateMIC ( final MimeBodyPart part , final String digest , final boolean includeHeaders ) throws GeneralSecurityException , MessagingException , IOException { final String micAlg = convertAlgorithm ( digest , true ) ; final MessageDigest md = MessageDigest . getInstance ( micAlg , " BC " ) ; final NonBlockingByteArrayOutputStream aBAOS = new NonBlockingByteArrayOutputStream ( ) ; if ( includeHeaders ) { part . writeTo ( aBAOS ) ; } else { StreamUtils . copyInputStreamToOutputStream ( part . getInputStream ( ) , aBAOS ) ; } final byte [ ] data = aBAOS . toByteArray ( ) ; final InputStream bIn = trimCRLFPrefix ( data ) ; final DigestInputStream digIn = new DigestInputStream ( bIn , md ) ; final byte [ ] buf = new byte [ 4096 ] ; while ( digIn . read ( buf ) > = 0 ) { } aBAOS . close ( ) ; final byte [ ] mic = digIn . getMessageDigest ( ) . digest ( ) ; final String micString = new String ( Base64 . encode ( mic ) ) ; final StringBuilder micResult = new StringBuilder ( micString ) ; micResult . append ( " ,  " ) . append ( digest ) ; return micResult . toString ( ) ; }
public int containedTemporalRelations ( ) { if ( containedTemporalRelations = = - 1 ) { containedTemporalRelations = 0 ; if ( ( this instanceof Equivalence ) | | ( this instanceof Implication ) ) { int temporalOrder = ( ( Statement ) this ) . getTemporalOrder ( ) ; switch ( temporalOrder ) { case TemporalRules . ORDER_FORWARD : case TemporalRules . ORDER_CONCURRENT : case TemporalRules . ORDER_BACKWARD : containedTemporalRelations = 1 ; } } for ( final Term t : term ) containedTemporalRelations + = t . containedTemporalRelations ( ) ; } return this . containedTemporalRelations ; }
public int compare ( final Directory o1 , final Directory o2 ) { return StringComparators . compareNatural ( o1 . getName ( ) , o2 . getName ( ) ) ; }
private void writeObject ( Config config ) { output . write ( '{' ) ; final Iterator < Map . Entry < String , Object > > it = config . asMap ( ) . entrySet ( ) . iterator ( ) ; do { final Map . Entry < String , Object > entry = it . next ( ) ; final String key = entry . getKey ( ) ; final Object value = entry . getValue ( ) ; writeString ( key ) ; output . write ( ':' ) ; writeValue ( value ) ; if ( it . hasNext ( ) ) output . write ( ',' ) ; else break ; } while ( true ) ; output . write ( '}' ) ; }
protected void onCreate ( Bundle arg0 ) { if ( ! Tools . isTabletMode ( this ) ) { setTheme ( android . R . style . Theme_Black_NoTitleBar ) ; } super . onCreate ( arg0 ) ; setContentView ( R . layout . artists_activity ) ; }
private static double dot ( Grad g , double x , double y ) { return g . x * x + g . y * y ; }
public void libraryStateChanged ( boolean updating , boolean dbChanged ) { mHelperHandler . obtainMessage ( MPDAsyncHelper . EVENT_UPDATESTATE , Tools . toObjectArray ( updating , dbChanged ) ) . sendToTarget ( ) ;
public boolean contains ( float px , float py ) { if ( ( px - x ) * ( px - x ) + ( py - y ) * ( py - y ) > r2 ) return false ; float a = ( float ) Math . toDegrees ( Math . atan2 ( py - y , px - x ) ) ; if ( a < 0 ) a + = 360 ; if ( a < sa ) a + = 360 ; return ( a > = sa & & a < = ea ) ; }
public void forEachRemaining ( Consumer < ? super Entry < String , Object > > action ) { wrapped . forEachRemaining ( new CheckedEntryAction ( action ) ) ; }
public void test_set_prolog_flag_2_3 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch(set_prolog_flag(1, 1), error(type_error(ValidType, Culprit), type_error(Goal, ArgNo, ValidType, Culprit)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " set_prolog_flag " , new Int ( 1 ) , new Int ( 1 ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 1 ) ; Struct validType = ( Struct ) info . getTerm ( " ValidType " ) ; assertTrue ( validType . isEqual ( new Struct ( " struct " ) ) ) ; Int culprit = ( Int ) info . getTerm ( " Culprit " ) ; assertTrue ( culprit . intValue ( ) = = 1 ) ; }
protected boolean removeItem ( final E oldItem ) { if ( items . remove ( oldItem ) ) { nameTable . remove ( oldItem . name ( ) ) ; mass - = oldItem . getPriority ( ) ; return true ; } return false ; }
public void clearGlobalEventHandlers ( ) { globalEventHandlers . clear ( ) ; }
public void onCreate ( ) { super . onCreate ( ) ; System . err . println ( " onCreate Application " ) ; MPD . setApplicationContext ( getApplicationContext ( ) ) ; StrictMode . VmPolicy vmpolicy = new StrictMode . VmPolicy . Builder ( ) . penaltyLog ( ) . build ( ) ; StrictMode . ThreadPolicy policy = new StrictMode . ThreadPolicy . Builder ( ) . permitAll ( ) . build ( ) ; StrictMode . setThreadPolicy ( policy ) ; StrictMode . setVmPolicy ( vmpolicy ) ; oMPDAsyncHelper = new MPDAsyncHelper ( ) ; oMPDAsyncHelper . addConnectionListener ( ( MPDApplication ) getApplicationContext ( ) ) ; settingsHelper = new SettingsHelper ( this , oMPDAsyncHelper ) ; disconnectSheduler = new Timer ( ) ; SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( this ) ; if ( ! settings . contains ( " albumTrackSort " ) ) settings . edit ( ) . putBoolean ( " albumTrackSort " , true ) . commit ( ) ;
public void testOneArrivingOneExistingWhereArrivingEarlierThanExisting ( ) { p = new EventTimeHistoryPlanner ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , EventTimeHistoryPlanner . FAR_FUTURE_MILLIS , EventTimeHistoryPlanner . CURRENT_FLAG_YES , " " ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 50L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < PlannedRow > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 1 ) ; assertEquals ( planned . get ( 0 ) . getMutationType ( ) , MutationType . INSERT ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " startdate " ) , 50L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " enddate " ) , 99L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) . getRow ( ) , " currentflag " ) , EventTimeHistoryPlanner . CURRENT_FLAG_NO ) ; }
HttpFuture < List < View > > asyncGetViews ( final String designDocumentName ) ; View getView ( final String designDocumentName , final String viewName ) ; List < View > getViews ( final String designDocumentName ) ; HttpFuture < ViewResponseWithDocs > asyncQuery ( View view , Query query ) ; HttpFuture < ViewResponseNoDocs > asyncQueryAndExcludeDocs ( View view , Query query ) ; HttpFuture < ViewResponseReduced > asyncQueryAndReduce ( View view , Query query ) ; ViewResponseWithDocs query ( View view , Query query ) ; ViewResponseNoDocs queryAndExcludeDocs ( View view , Query query ) ; ViewResponseReduced queryAndReduce ( View view , Query query ) ; }
public Matrix < T > add ( Matrix < T > input ) { Matrix < T > output = new Matrix < T > ( this . rows , this . cols ) ; if ( ( this . cols ! = input . cols ) | | ( this . rows ! = input . rows ) ) return output ; for ( int r = 0 ; r < output . rows ; r + + ) { for ( int c = 0 ; c < output . cols ; c + + ) { for ( int i = 0 ; i < cols ; i + + ) { T m1 = this . get ( r , c ) ; T m2 = input . get ( r , c ) ; Long l = m1 . longValue ( ) + m2 . longValue ( ) ; output . set ( r , c , ( T ) l ) ; } } } return output ; }
protected void heapUp ( Node < T > node ) { while ( node ! = null ) { Node < T > heapNode = node ;
IDynamicComponent getComponent ( String componentID ) throws ComponentNotFoundException ; Map < String , IDynamicComponent > getComponents ( ) ; IPartnershipFactory getPartnershipFactory ( ) throws ComponentNotFoundException ; IProcessor getProcessor ( ) throws ComponentNotFoundException ; }
public boolean isDigesting ( ) { return m_eMode . isDigesting ( ) ; }
public void test_set_prolog_flag_2_6 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch(set_prolog_flag(bounded, a), error(domain_error(ValidDomain, Culprit), domain_error(Goal, ArgNo, ValidDomain, Culprit)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " set_prolog_flag " , new Struct ( " bounded " ) , new Struct ( " a " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 2 ) ; Struct validDomain = ( Struct ) info . getTerm ( " ValidDomain " ) ; assertTrue ( validDomain . isEqual ( new Struct ( " flag_value " ) ) ) ; Struct culprit = ( Struct ) info . getTerm ( " Culprit " ) ; assertTrue ( culprit . isEqual ( new Struct ( " a " ) ) ) ; }
public void onActivityCreated ( Bundle savedInstanceState ) { super . onActivityCreated ( savedInstanceState ) ; this . activity = getActivity ( ) ; app = ( MPDApplication ) activity . getApplication ( ) ; refreshListColorCacheHint ( ) ; cacheOnly = ! PreferenceManager . getDefaultSharedPreferences ( activity ) . getBoolean ( PREFERENCE_ALBUM_LIBRARY , false ) ;
void setData ( MimeBodyPart aData , DataHistoryItem aHistoryItem ) throws OpenAS2Exception ; DataHistoryItem setData ( MimeBodyPart aData ) throws OpenAS2Exception ; IMessageMDN getMDN ( ) ; void setMDN ( IMessageMDN aMDN ) ; String getProtocol ( ) ; boolean isRequestingMDN ( ) ; boolean isRequestingAsynchMDN ( ) ; String getSubject ( ) ; void setSubject ( String sSubject ) ; String getLoggingText ( ) ; }
public void trackChanged ( MPDStatus mpdStatus , int oldTrack ) { MPDAsyncHelper . this . obtainMessage ( EVENT_TRACK , Tools . toObjectArray ( mpdStatus , oldTrack ) ) . sendToTarget ( ) ; }
protected static final < O extends Object > Interval < O > createFromList ( List < IntervalData < O > > intervals ) { Interval < O > newInterval = new Interval < O > ( ) ; int half = intervals . size ( ) / 2 ; IntervalData < O > middle = intervals . get ( half ) ; newInterval . center = ( ( middle . start + middle . end ) / 2 ) ; List < IntervalData < O > > leftIntervals = new ArrayList < IntervalData < O > > ( ) ; List < IntervalData < O > > rightIntervals = new ArrayList < IntervalData < O > > ( ) ; for ( IntervalData < O > interval : intervals ) { if ( interval . end < newInterval . center ) { leftIntervals . add ( interval ) ; } else if ( interval . start > newInterval . center ) { rightIntervals . add ( interval ) ; } else { newInterval . overlap . add ( interval ) ; } } if ( leftIntervals . size ( ) > 0 ) newInterval . left = createFromList ( leftIntervals ) ; if ( rightIntervals . size ( ) > 0 ) newInterval . right = createFromList ( rightIntervals ) ; return newInterval ; }
public boolean postUpdate ( AbstractGraphVis < V , E > g ) { return true ; }
public void refresh ( ) { bagObserver . refresh ( toString ( ) ) ;
MimeBodyPart getData ( ) ; void setData ( @Nonnull MimeBodyPart aData ) ; @Nullable IMessageMDN getMDN ( ) ; void setMDN ( @Nullable IMessageMDN aMDN ) ; @Nonnull @Nonempty String getLoggingText ( ) ; String getProtocol ( ) ; boolean isRequestingMDN ( ) ; boolean isRequestingAsynchMDN ( ) ; @Nullable TempSharedFileInputStream getTempSharedFileInputStream ( ) ; void setTempSharedFileInputStream ( @Nullable TempSharedFileInputStream m_TempSharedFileInputStream ) ; }
protected Node < T > addValue ( T id ) { Node < T > nodeToReturn = super . addValue ( id ) ; AVLNode < T > nodeAdded = ( AVLNode < T > ) nodeToReturn ; while ( nodeAdded ! = null ) { nodeAdded . updateHeight ( ) ; balanceAfterInsert ( nodeAdded ) ; nodeAdded = ( AVLNode < T > ) nodeAdded . parent ; } return nodeToReturn ; }
static boolean isPrimitiveOrWrapperNumber ( Class < ? > type ) { return isPrimitiveOrWrapper ( type ) & & type ! = Boolean . class & & type ! = boolean . class & & type ! = Character . class & & type ! = char . class ;
public boolean process ( ContentEvent event ) { if ( event instanceof InstanceContentEvent ) { InstanceContentEvent instanceEvent = ( InstanceContentEvent ) event ; this . processInstanceEvent ( instanceEvent ) ; } else if ( event instanceof PredicateContentEvent ) { this . updateRuleSplitNode ( ( PredicateContentEvent ) event ) ; } else if ( event instanceof RuleContentEvent ) { RuleContentEvent rce = ( RuleContentEvent ) event ; if ( rce . isRemoving ( ) ) { this . removeRule ( rce . getRuleNumberID ( ) ) ; } } return true ; }
public void test_atom_chars_2_1 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch(atom_chars(1, X), error(type_error(ValidType, Culprit), type_error(Goal, ArgNo, ValidType, Culprit)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " atom_chars " , new Int ( 1 ) , new Var ( " X " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 1 ) ; Struct validType = ( Struct ) info . getTerm ( " ValidType " ) ; assertTrue ( validType . isEqual ( new Struct ( " atom " ) ) ) ; Int culprit = ( Int ) info . getTerm ( " Culprit " ) ; assertTrue ( culprit . intValue ( ) = = 1 ) ; }
public Void call ( JavaRDD < GenericRecord > batchRecords ) throws Exception { boolean prePartitioned = Boolean . parseBoolean ( props . getProperty ( " source.partition " , " false " ) ) ; if ( ! prePartitioned ) { int numPartitions = Integer . parseInt ( props . getProperty ( " source.partition.number " , " 1 " ) ) ; batchRecords = partitionByKey ( batchRecords , numPartitions , qs . getRecordModel ( ) ) ; } JavaRDD < Row > batchRows = SparkSQLAvroUtils . rowsForRecords ( batchRecords ) ; StructType batchStructType = SparkSQLAvroUtils . structTypeForSchema ( qs . getSchema ( ) ) ; DataFrame batchDataFrame = sqlc . createDataFrame ( batchRows , batchStructType ) ; batchDataFrame . registerTempTable ( " stream " ) ; batchDataFrame . persist ( StorageLevel . MEMORY_ONLY ( ) ) ; for ( Flow flow : Flow . flowsFor ( props ) ) { flow . runFlow ( batchDataFrame ) ; } batchDataFrame . unpersist ( ) ; return null ; }
public void actionPerformed ( ActionEvent e ) { new NWindow ( " Forgot " , new SwingLogPanel ( NARControls . this , Events . TaskRemove . class
private void _loadCertificateFactory ( @Nonnull final IMicroElement aElement ) throws AS2Exception { LOGGER . info ( " Loading certificates " ) ; final ICertificateFactory aFactory = AS2XMLHelper . createComponent ( aElement , ICertificateFactory . class , this , m_sBaseDirectory ) ; setCertificateFactory ( aFactory ) ; }
private void jButton7ActionPerformed ( java . awt . event . ActionEvent evt ) { nar . addInput ( " <8 --> set>. :|: " ) ; jButton7 . setText ( " X " ) ; field [ 7 ] = 1 ; check_field ( ) ; narstart ( ) ; }
private long mutate ( Mutator m , String key , long by , long def , int exp ) { final AtomicLong rv = new AtomicLong ( ) ; final CountDownLatch latch = new CountDownLatch ( 1 ) ; mconn . enqueueOperation ( key , opFact . mutate ( m , key , by , def , exp , new OperationCallback ( ) { @Override public void receivedStatus ( OperationStatus s ) { rv . set ( new Long ( s . isSuccess ( ) ? s . getMessage ( ) : " -1 " ) ) ; } @Override public void complete ( ) { latch . countDown ( ) ; } } ) ) ; try { if ( ! latch . await ( operationTimeout , TimeUnit . MILLISECONDS ) ) { throw new OperationTimeoutException ( " Mutate operation timed out, " + " unable to modify counter [ " + key + ']' ) ; } } catch ( InterruptedException e ) { throw new RuntimeException ( " Interrupted " , e ) ; } getLogger ( ) . debug ( " Mutation returned %s " , rv ) ; return rv . get ( ) ; }
public void put ( final String name , final Object value ) { dataMap . put ( name , value ) ; }
public void clear ( ) { for ( Map . Entry < String , Object > dataEntry : dataConfig . asMap ( ) . entrySet ( ) ) { final Object value = dataEntry . getValue ( ) ; if ( value instanceof FieldInfos ) { removeFieldValue ( ( FieldInfos ) value ) ; } } dataConfig . clear ( ) ; }
public void removeCertificate ( @Nullable final String sAlias ) throws AS2Exception { final String sRealAlias = getUnifiedAlias ( sAlias ) ; final Certificate aCert ; m_aRWLock . writeLock ( ) . lock ( ) ; try { aCert = m_aKeyStore . getCertificate ( sRealAlias ) ; if ( aCert = = null ) throw new AS2CertificateNotFoundException ( null , sRealAlias ) ; m_aKeyStore . deleteEntry ( sRealAlias ) ; } catch ( final GeneralSecurityException ex ) { throw WrappedAS2Exception . wrap ( ex ) ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } onChange ( ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " Removed certificate alias ' " +
public final int compareTo ( Term that ) { return ( that instanceof Variable ) ? name . compareTo ( that . getName ( ) ) : - 1 ; }
public void draw ( Timeline2DCanvas l , float y , float timeScale , float yScale ) { yScale = yScale * height ; float screenyHi = l . screenY ( l . cycleStart * timeScale , y - yScale ) ; float screenyLo = l . screenY ( l . cycleStart * timeScale , y ) ; min = Double . NaN ; max = 0 ; for ( TimeSeries chart : sensors ) { chart . updateMinMax ( l . cycleStart , l . cycleEnd ) ; if ( Double . isNaN ( min ) ) { min = ( chart . getMin ( ) ) ; max = ( chart . getMax ( ) ) ; } else { min = Math . min ( min , chart . getMin ( ) ) ; max = Math . max ( max , chart . getMax ( ) ) ; } } l . stroke ( 127 ) ; l . strokeWeight ( 0.5f ) ; l . line ( l . cycleStart * timeScale , y , l . cycleEnd * timeScale , y ) ; l . line ( l . cycleStart * timeScale , y - yScale , l . cycleEnd * timeScale , y - yScale ) ; drawData ( l , timeScale , yScale , y ) ; drawOverlay ( l , screenyLo , screenyHi ) ;
public float averagePriority ( ) { if ( nameTable . size ( ) = = 0 ) return 0.01f ; float f = ( float ) mass / ( nameTable . size ( ) * TOTAL_LEVEL ) ; if ( f > 1 ) return 1.0f ; return f ; }
public static void main ( String args [ ] ) { NARSBatch nars = new NARSBatch ( ) ; setStandAlone ( true ) ; nars . runInference ( args ) ; if ( nars . dumpLastState ) System . out . println ( " ==== Dump Last State ==== \ n " + nars . reasoner . toString ( ) ) ;
public abstract String getName ( ) ; public abstract ServiceInfo getServiceInfo ( String type , String name ) ; public abstract ServiceInfo getServiceInfo ( String type , String name , boolean persistent ) ; public abstract ServiceInfo getServiceInfo ( String type , String name , boolean persistent , long timeout ) ; public abstract ServiceInfo getServiceInfo ( String type , String name , long timeout ) ; public abstract ServiceInfo [ ] list ( String type ) ; public abstract ServiceInfo [ ] list ( String type , long timeout ) ; public abstract Map < String , ServiceInfo [ ] > listBySubtype ( String type ) ; public abstract Map < String , ServiceInfo [ ] > listBySubtype ( String type , long timeout ) ; @Deprecated public abstract void printServices ( ) ; public abstract void registerService ( ServiceInfo info ) throws IOException ; public abstract boolean registerServiceType ( String type ) ; public abstract void removeServiceListener ( String type , ServiceListener listener ) ; public abstract void removeServiceTypeListener ( ServiceTypeListener listener ) ; public abstract void requestServiceInfo ( String type , String name ) ; public abstract void requestServiceInfo ( String type , String name , boolean persistent ) ; public abstract void requestServiceInfo ( String type , String name , boolean persistent , long timeout ) ; public abstract void requestServiceInfo ( String type , String name , long timeout ) ; public abstract Delegate setDelegate ( Delegate value ) ; public abstract void unregisterAllServices ( ) ; public abstract void unregisterService ( ServiceInfo info ) ; }
public void writeFile ( String fname ) throws IOException { FileWriter fr = null ; PrintWriter pr = null ; Iterator it ; HashSet formulaSet = new HashSet ( ) ; ArrayList formulaArray ; String key ; ArrayList list ; Formula f ; String s ; try { fr = new FileWriter ( fname ) ;
Future < CASResponse > asyncCAS ( String key , long casId , Object value ) ; < T > CASResponse cas ( String key , long casId , T value , Transcoder < T > tc ) throws OperationTimeoutException ; CASResponse cas ( String key , long casId , Object value ) throws OperationTimeoutException ; < T > Future < Boolean > add ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > add ( String key , int exp , Object o ) ; < T > Future < Boolean > set ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > set ( String key , int exp , Object o ) ; < T > Future < Boolean > replace ( String key , int exp , T o , Transcoder < T > tc ) ; Future < Boolean > replace ( String key , int exp , Object o ) ; < T > Future < T > asyncGet ( String key , Transcoder < T > tc ) ; Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; }
protected final void decryptAndVerify ( final IMessage aMsg ) throws OpenAS2Exception { final ICertificateFactory aCertFactory = getModule ( ) . getSession ( ) . getCertificateFactory ( ) ; final ICryptoHelper aCryptoHelper = AS2Util . getCryptoHelper ( ) ; try { if ( aCryptoHelper . isEncrypted ( aMsg . getData ( ) ) ) { s_aLogger . debug ( " decrypting " + aMsg . getLoggingText ( ) ) ; final X509Certificate aReceiverCert = aCertFactory . getCertificate ( aMsg , Partnership . PARTNERSHIP_TYPE_RECEIVER ) ; final PrivateKey aReceiverKey = aCertFactory . getPrivateKey ( aMsg , aReceiverCert ) ; final MimeBodyPart aDecryptedData = aCryptoHelper . decrypt ( aMsg . getData ( ) , aReceiverCert , aReceiverKey ) ; aMsg . setData ( aDecryptedData ) ; new ContentType ( aMsg . getData ( ) . getContentType ( ) ) ; } } catch ( final Exception ex ) { s_aLogger . error ( " Error decrypting  " + aMsg . getLoggingText ( ) + " :  " + ex . getMessage ( ) ) ; throw new DispositionException ( new DispositionType ( " automatic-action " , " MDN-sent-automatically " , " processed " , " Error " , " decryption-failed " ) , AS2ReceiverModule . DISP_DECRYPTION_ERROR , ex ) ; } try {
public static String join ( final Collection < String > chunks , final String delimiter ) { StringBuilder sb = new StringBuilder ( ) ; if ( ! chunks . isEmpty ( ) ) { Iterator < String > itr = chunks . iterator ( ) ; sb . append ( itr . next ( ) ) ; while ( itr . hasNext ( ) ) { sb . append ( delimiter ) ; sb . append ( itr . next ( ) ) ; } } return sb . toString ( ) ; }
public Symbol parse ( ) throws java . lang . Exception { int act ; Symbol lhs_sym = null ; short handle_size , lhs_sym_num ; production_tab = production_table ( ) ; action_tab = action_table ( ) ; reduce_tab = reduce_table ( ) ; init_actions ( ) ; user_init ( ) ; cur_token = scan ( ) ; stack . removeAllElements ( ) ; stack . push ( new Symbol ( 0 , start_state ( ) ) ) ; tos = 0 ; for ( _done_parsing = false ; ! _done_parsing ; ) { if ( cur_token . used_by_parser ) throw new Error ( " Symbol recycling detected (fix your scanner). " ) ; act = get_action ( ( ( Symbol ) stack . peek ( ) ) . parse_state , cur_token . sym ) ; if ( act > 0 ) { cur_token . parse_state = act - 1 ; cur_token . used_by_parser = true ; stack . push ( cur_token ) ; tos + + ; cur_token = scan ( ) ; } else if ( act < 0 ) { lhs_sym = do_action ( ( - act ) - 1 , this , stack , tos ) ; lhs_sym_num = production_tab [ ( - act ) - 1 ] [ 0 ] ; handle_size = production_tab [ ( - act ) - 1 ] [ 1 ] ; for ( int i = 0 ; i < handle_size ; i + + ) { stack . pop ( ) ; tos - - ; } act = get_reduce ( ( ( Symbol ) stack . peek ( ) ) . parse_state , lhs_sym_num ) ; lhs_sym . parse_state = act ; lhs_sym . used_by_parser = true ; stack . push ( lhs_sym ) ; tos + + ; } else if ( act = = 0 ) { syntax_error ( cur_token ) ; if ( ! error_recovery ( false ) ) { unrecovered_syntax_error ( cur_token ) ; done_parsing ( ) ; } else { lhs_sym = ( Symbol ) stack . peek ( ) ; } } } return lhs_sym ; }
public abstract int size ( ) ; public static < T > Queue < T > createQueue ( QueueType type ) { switch ( type ) { case ArrayQueue : return new ArrayQueue < T > ( ) ; default : return new LinkedQueue < T > ( ) ; } } public static class LinkedQueue < T > extends Queue < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; public LinkedQueue ( ) { head = null ; tail = null ; size = 0 ; } @Override public void enqueue ( T value ) { enqueue ( new Node < T > ( value ) ) ; } private void enqueue ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > oldHead = head ; head = node ; node . next = oldHead ; oldHead . prev = node ; } size + + ; } @Override public T dequeue ( ) { T result = null ; if ( tail ! = null ) { result = tail . value ; Node < T > prev = tail . prev ; if ( prev ! = null ) { prev . next = null ; tail = prev ; } else { head = null ; tail = null ; } size - - ; } return result ; } @Override public boolean contains ( T value ) { if ( head = = null ) return false ; Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . next ; } return false ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . next ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > prev = null ; private Node < T > next = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( prev ! = null ) ? prev . value : " NULL " ) + "  next= " + ( ( next ! = null ) ? next . value : " NULL " ) ; } } } public static class ArrayQueue < T > extends Queue < T > { private static final int GROW_IN_CHUNK_SIZE = 1000 ; private static final int SHRINK_IN_CHUNK_SIZE = 1000 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int nextIndex = 0 ; private int firstIndex = 0 ; @Override @SuppressWarnings ( " unchecked " ) public void enqueue ( T value ) { if ( ( nextIndex - firstIndex ) > = array . length ) { int currentLength = nextIndex - firstIndex ; int newLength = currentLength + GROW_IN_CHUNK_SIZE ; T [ ] temp = ( T [ ] ) new Object [ newLength ] ; System . arraycopy ( array , firstIndex , temp , 0 , currentLength ) ; temp [ nextIndex + + ] = value ; array = temp ; firstIndex = 0 ; } else { array [ nextIndex + + ] = value ; } } @Override @SuppressWarnings ( " unchecked " ) public T dequeue ( ) { if ( ( nextIndex - firstIndex ) < 0 ) return null ; T t = array [ firstIndex ] ; array [ firstIndex + + ] = null ; if ( ( nextIndex - firstIndex ) = = 0 ) { firstIndex = 0 ; nextIndex = 0 ; } else if ( array . length - ( nextIndex - firstIndex ) > = SHRINK_IN_CHUNK_SIZE ) { int newLength = nextIndex - firstIndex ; T [ ] temp = ( T [ ] ) new Object [ newLength ] ; System . arraycopy ( array , firstIndex , temp , 0 , newLength ) ; array = temp ; nextIndex = nextIndex - firstIndex ; firstIndex = 0 ; } return t ; } @Override public boolean contains ( T value ) { for ( int i = firstIndex ; i < nextIndex ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public int size ( ) { return nextIndex - firstIndex ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = nextIndex - 1 ; i > = firstIndex ; i - - ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } }
public void configure ( String name , Config config ) { this . name = name ; if ( config . hasPath ( EXPECTED_LITERAL_CONFIG ) ) { expected = config . getLong ( EXPECTED_LITERAL_CONFIG ) ; } if ( config . hasPath ( EXPECTED_DEPENDENCY_CONFIG ) ) { dependency = config . getString ( EXPECTED_DEPENDENCY_CONFIG ) ; } if ( ( ! isLiteral ( ) & & ! isDependency ( ) | | ( isLiteral ( ) & & isDependency ( ) ) ) ) { throw new RuntimeException ( " Must specify either literal or dependency for expected count " ) ;
private static String [ ] _readRequest ( @Nonnull final InputStream aIS ) throws IOException { int nByteBuf = aIS . read ( ) ; final StringBuilder aSB = new StringBuilder ( ) ; while ( nByteBuf ! = - 1 & & nByteBuf ! = '\r' ) { aSB . append ( ( char ) nByteBuf ) ; nByteBuf = aIS . read ( ) ; } if ( nByteBuf ! = - 1 ) { aIS . read ( ) ; } final StringTokenizer aTokens = new StringTokenizer ( aSB . toString ( ) , "   " ) ; final int nTokenCount = aTokens . countTokens ( ) ; if ( nTokenCount > = 3 ) { final String [ ] aRequestParts = new String [ nTokenCount ] ; for ( int i = 0 ; i < nTokenCount ; i + + ) aRequestParts [ i ] = aTokens . nextToken ( ) ; return aRequestParts ; } if ( nTokenCount = = 2 ) { final String [ ] aRequestParts = new String [ 3 ] ; aRequestParts [ 0 ] = aTokens . nextToken ( ) ; aRequestParts [ 1 ] = " / " ; aRequestParts [ 2 ] = aTokens . nextToken ( ) ; return aRequestParts ; } throw new IOException ( " Invalid HTTP Request " ) ; }
public void testIntervalTree5 ( ) { List < IntervalTree . IntervalData < String > > intervals = new ArrayList < IntervalTree . IntervalData < String > > ( ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 17 , 19 , " a " ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 5 , 11 , " b " ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 23 , 23 , " c " ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 4 , 8 , " d " ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 15 , 18 , " e " ) ) ) ; intervals . add ( ( new IntervalTree . IntervalData < String > ( 7 , 10 , " f " ) ) ) ; IntervalTree < String > tree = new IntervalTree < String > ( intervals ) ; IntervalTree . IntervalData < String > query = tree . query ( 14 , 16 ) ; assertTrue ( " Interval Tree query error. returned= " + query , tree , collectionsEqual ( query . getData ( ) , Arrays . asList ( " e " ) ) ) ; query = tree . query ( 12 , 14 ) ; assertTrue ( " Interval Tree query error. returned= " + query , tree , query = = null ) ; }
public static void main ( String [ ] arg ) { NAR nar = new CurveBagNARBuilder ( true ) . build ( ) ; ( nar . param ) . cycleConceptsFired . set ( 16 ) ; new TestChamber2 ( nar ) ; new NARSwing ( nar ) ; nar . start ( 200 ) ; }
public void testOneMatched ( ) { List < Graph . Edge < Integer > > edges = new ArrayList < Graph . Edge < Integer > > ( ) ; { edges . add ( new Graph . Edge < Integer > ( 1 , v_a1 , v_b1 ) ) ; edges . add ( new Graph . Edge < Integer > ( 1 , v_a1 , v_b2 ) ) ; edges . add ( new Graph . Edge < Integer > ( 1 , v_a1 , v_b3 ) ) ; } final Graph < Integer > graph = new Graph < Integer > ( vertices , edges ) ; TurboMatching . MatchingResult < Integer > matchingResult = TurboMatching . getMaximumMatching ( graph ) ; assertTrue ( matchingResult . getSize ( ) = = 1 ) ; assertTrue ( matchingResult . getMate ( ) . containsKey ( v_a1 ) ) ; assertTrue ( matchingResult . getMate ( ) . containsValue ( v_a1 ) ) ; assertFalse ( matchingResult . getMate ( ) . containsKey ( v_a2 ) ) ; assertFalse ( matchingResult . getMate ( ) . containsValue ( v_a2 ) ) ; assertFalse ( matchingResult . getMate ( ) . containsKey ( v_a3 ) ) ; assertFalse ( matchingResult . getMate ( ) . containsValue ( v_a3 ) ) ; }
public void testCAS ( ) throws Exception { final String key = " castestkey " ; assertSame ( " Expected error CASing with no existing value. " , CASResponse . NOT_FOUND , client . cas ( key , 0x7fffffffffL , " bad value " ) ) ; assertTrue ( client . add ( key , 5 , " original value " ) . get ( ) ) ; CASValue < ? > getsVal = client . gets ( key ) ; assertEquals ( " original value " , getsVal . getValue ( ) ) ; assertSame ( " Expected error CASing with invalid id " , CASResponse . EXISTS , client . cas ( key , getsVal . getCas ( ) + 1 , " broken value " ) ) ; assertEquals ( " original value " , getsVal . getValue ( ) ) ; assertSame ( " Expected successful CAS with correct id ( " + getsVal . getCas ( ) + " ) " , CASResponse . OK , client . cas ( key , getsVal . getCas ( ) , " new value " ) ) ; assertEquals ( " new value " , client . get ( key ) ) ; assertSame ( " Expected unsuccessful CAS with replayed id " , CASResponse . EXISTS , client . cas ( key , getsVal . getCas ( ) , " crap value " ) ) ; assertEquals ( " new value " , client . get ( key ) ) ; }
public void updateFromItems ( ) { super . updateFromItems ( ) ; if ( mItems ! = null & & mHeaderArtist ! = null & & mHeaderInfo ! = null ) { final AlbumInfo fixedAlbumInfo ;
public Object clone ( ) { return new DifferenceExt ( getName ( ) , cloneList ( components ) , isConstant ( ) , complexity ) ; }
public void moveWorld ( Vec2 screenDiff ) { transform . getScreenVectorToWorld ( screenDiff , worldDiff ) ; if ( ! transform . isYFlip ( ) ) { worldDiff . y = - worldDiff . y ; } transform . setCenter ( transform . getCenter ( ) . addLocal ( worldDiff ) ) ; }
private void writeSimpleFiles ( String path , String ext , int numOfFiles ) { File folder = new File ( path ) ; if ( ! folder . exists ( ) ) { try { folder . mkdir ( ) ; } catch ( SecurityException se ) { fail ( " Failed creating directory: " + path + se ) ; } } for ( int i = 1 ; i < = numOfFiles ; i + + ) { String fn = null ;
public boolean equals ( Object o ) { if ( this = = o ) return true ; if ( o = = null | | getClass ( ) ! = o . getClass ( ) ) return false ; CoverInfo coverInfo = ( CoverInfo ) o ; if ( album ! = null ? ! album . equals ( coverInfo . album ) : coverInfo . album ! = null ) return false ; if ( artist ! = null ? ! artist . equals ( coverInfo . artist ) : coverInfo . artist ! = null ) return false ; return true ; }
public static Collection < Object [ ] > generateParameters ( ) { return Arrays . asList ( new Object [ ] [ ] { { 3 , PartitioningScheme . SHUFFLE } ,
public X509Certificate getCertificate ( @Nullable final String sAlias ) throws AS2Exception { debugLog ( ( ) - > " getCertificate ( " + sAlias + " ) " ) ; final X509Certificate ret = internalGetCertificate ( sAlias , null ) ; debugLog ( ( ) - > " getCertificate ->  " + _debug ( ret ) ) ; return ret ; }
static void resemblance ( Term term1 , Term term2 , Sentence belief , Sentence sentence , int figure , NAL nal ) { if ( Statement . invalidStatement ( term1 , term2 ) ) { return ; } int order1 = belief . term . getTemporalOrder ( ) ; int order2 = sentence . term . getTemporalOrder ( ) ; int order = resemblanceOrder ( order1 , order2 , figure ) ; if ( order = = ORDER_INVALID ) { return ; } Statement st = ( Statement ) belief . term ; TruthValue truth = null ; BudgetValue budget ; if ( sentence . isQuestion ( ) | | sentence . isQuest ( ) ) { budget = BudgetFunctions . backward ( belief . truth , nal ) ; } else { if ( sentence . isGoal ( ) ) { truth = TruthFunctions . desireStrong ( sentence . truth , belief . truth ) ; } else { truth = TruthFunctions . resemblance ( belief . truth , sentence . truth ) ; } budget = BudgetFunctions . forward ( truth , nal ) ; } nal . doublePremiseTask ( Statement . make ( st , term1 , term2 , order ) , truth , budget , false , true ) ; if ( Parameters . BREAK_NAL_HOL_BOUNDARY & & ( st instanceof Equivalence ) & & order1 = = order2 ) {
String getHeader ( @Nonnull String sKey ) ; @Nullable String getHeader ( @Nonnull String sKey , @Nullable String sDelimiter ) ; @Nonnull InternetHeaders getHeaders ( ) ; void setHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void addHeader ( @Nonnull String sKey , @Nullable String sValue ) ; void setHeaders ( @Nullable InternetHeaders aHeaders ) ; @Nullable String getMessageID ( ) ; void setMessageID ( @Nullable String sMessageID ) ; @Nonnull String generateMessageID ( ) ; void updateMessageID ( ) ; @Nonnull @ReturnsMutableObject ( reason = " Design " ) Partnership getPartnership ( ) ; void setPartnership ( @Nonnull Partnership aPartnership ) ; }
public Product clone ( ) { return new Product ( cloneTerms ( ) , getTemporalOrder ( ) , isConstant ( ) , containsVar ( ) , getComplexity ( ) , hashCode ( ) ) ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; final Intent queryIntent = getIntent ( ) ; final String queryAction = queryIntent . getAction ( ) ; if ( Intent . ACTION_SEARCH . equals ( queryAction ) ) { searchKeywords = queryIntent . getStringExtra ( SearchManager . QUERY ) ; } else { return ; } setContentView ( R . layout . artists ) ; setTitle ( getTitle ( ) + "  :  " + searchKeywords ) ; pd = ProgressDialog . show ( SearchSongActivity . this , getResources ( ) . getString ( R . string . loading ) , getResources ( ) . getString ( R . string . loading ) ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; final String finalSearch = searchKeywords ; itemsList = new ArrayList < String > ( ) ; app . oMPDAsyncHelper . addAsyncExecListener ( this ) ; iJobID = app . oMPDAsyncHelper . execAsync ( new Runnable ( ) { @Override
public Object extractGroupByKey ( String input ) { String [ ] kvps = input . split ( String . valueOf ( ( char ) 1 ) ) ; for ( String kvp : kvps ) { String [ ] components = kvp . split ( " = " ) ; if ( components [ 0 ] . equals ( " 11 " ) ) return components [ 1 ] ; } return null ; }
public abstract int size ( ) ; public static < T > Queue < T > createQueue ( QueueType type ) { switch ( type ) { case ArrayQueue : return new ArrayQueue < T > ( ) ; default : return new LinkedQueue < T > ( ) ; } } public static class ArrayQueue < T > extends Queue < T > { private static final int GROW_IN_CHUNK_SIZE = 1000 ; private static final int SHRINK_IN_CHUNK_SIZE = 1000 ; @SuppressWarnings ( " unchecked " ) private T [ ] array = ( T [ ] ) new Object [ GROW_IN_CHUNK_SIZE ] ; private int nextIndex = 0 ; private int firstIndex = 0 ; @Override public void enqueue ( T value ) { if ( nextIndex > = array . length ) { array = Arrays . copyOfRange ( array , firstIndex , nextIndex + GROW_IN_CHUNK_SIZE ) ; firstIndex = 0 ; } array [ nextIndex + + ] = value ; } @Override public T dequeue ( ) { int length = nextIndex - firstIndex ; if ( length < 0 ) return null ; T t = array [ firstIndex ] ; array [ firstIndex + + ] = null ; if ( length = = 0 ) { nextIndex = 0 ; firstIndex = 0 ; } else if ( ( array . length - nextIndex ) > = SHRINK_IN_CHUNK_SIZE ) { array = Arrays . copyOfRange ( array , firstIndex , nextIndex ) ; nextIndex = length ; firstIndex = 0 ; } return t ; } @Override public boolean contains ( T value ) { for ( int i = firstIndex ; i < nextIndex ; i + + ) { T obj = array [ i ] ; if ( obj . equals ( value ) ) return true ; } return false ; } @Override public int size ( ) { return nextIndex - firstIndex ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = nextIndex - 1 ; i > = firstIndex ; i - - ) { builder . append ( array [ i ] ) . append ( " ,  " ) ; } return builder . toString ( ) ; } } public static class LinkedQueue < T > extends Queue < T > { private Node < T > head = null ; private Node < T > tail = null ; private int size = 0 ; public LinkedQueue ( ) { head = null ; tail = null ; size = 0 ; } @Override public void enqueue ( T value ) { enqueue ( new Node < T > ( value ) ) ; } private void enqueue ( Node < T > node ) { if ( head = = null ) { head = node ; tail = node ; } else { Node < T > oldHead = head ; head = node ; node . next = oldHead ; oldHead . prev = node ; } size + + ; } @Override public T dequeue ( ) { T result = null ; if ( tail ! = null ) { result = tail . value ; Node < T > prev = tail . prev ; if ( prev ! = null ) { prev . next = null ; tail = prev ; } else { head = null ; tail = null ; } size - - ; } return result ; } @Override public boolean contains ( T value ) { if ( head = = null ) return false ; Node < T > node = head ; while ( node ! = null ) { if ( node . value . equals ( value ) ) return true ; node = node . next ; } return false ; } @Override public int size ( ) { return size ; } @Override public String toString ( ) { StringBuilder builder = new StringBuilder ( ) ; Node < T > node = head ; while ( node ! = null ) { builder . append ( node . value ) . append ( " ,  " ) ; node = node . next ; } return builder . toString ( ) ; } private static class Node < T > { private T value = null ; private Node < T > prev = null ; private Node < T > next = null ; private Node ( T value ) { this . value = value ; } @Override public String toString ( ) { return " value= " + value + "  previous= " + ( ( prev ! = null ) ? prev . value : " NULL " ) + "  next= " + ( ( next ! = null ) ? next . value : " NULL " ) ; } } } }
public void testStructTypeFor ( ) { List < String > fieldNames = Lists . newArrayList ( " field1 " , " field2 " , " field3 " , " field4 " , " field5 " , " field6 " ) ; List < String > fieldTypes = Lists . newArrayList ( " string " , " float " , " double " , " int " , " long " , " boolean " ) ; StructType structFromRowUtils = RowUtils . structTypeFor ( fieldNames , fieldTypes ) ; StructField field1 = DataTypes . createStructField ( " field1 " , DataTypes . StringType , true ) ; StructField field2 = DataTypes . createStructField ( " field2 " , DataTypes . FloatType , true ) ; StructField field3 = DataTypes . createStructField ( " field3 " , DataTypes . DoubleType , true ) ; StructField field4 = DataTypes . createStructField ( " field4 " , DataTypes . IntegerType , true ) ; StructField field5 = DataTypes . createStructField ( " field5 " , DataTypes . LongType , true ) ; StructField field6 = DataTypes . createStructField ( " field6 " , DataTypes . BooleanType , true ) ; StructType structFromAPI = DataTypes . createStructType ( Lists . newArrayList ( field1 , field2 , field3 , field4 , field5 , field6 ) ) ; assertEquals ( structFromRowUtils , structFromAPI ) ; }
abstract public void onConceptNew ( Concept concept ) ; abstract public void onCycleStart ( long clock ) ; abstract public void onCycleEnd ( long clock ) ; abstract public void onTaskAdd ( Task task , String reason ) ; abstract public void onTaskRemove ( Task task , String reason ) ; }
public void event ( Class event , Object [ ] arguments ) { if ( ( event = = CycleStop . class ) & & ( changed ) & & ( sentence ! = null ) ) { changed = false ;
public void previous ( ) throws MPDServerException { if ( mpdConnection = = null ) { throw new MPDServerException ( " MPD Connection is not established " ) ; } mpdConnection . sendCommand ( MPD_CMD_PREV ) ; }
public void readValidString ( ) { String toml = " string =  \" value \" \ n " + " integer = 2 \ n " + " long = 1234567890000 \ n " + " double = 1.2345678901 \ n " + " bool_array=[true, false, true, false,] # comment \ n " + " [table] #comment	 \ n " + " 	'key' = ' \" literal string \" \\ n \\ t' \ n " + " [table.subTable.subDefinedFirst] \ n " + "    test = 'this is valid TOML' \ n " + " [table.subTable] \ n " + "      \" subkey \" =2017-02-25T12:00:01.123456789    \ n " + "     date=2017-04-04 \ n " + "     time=16:41:20 \ n " + "     preciseTime=16:41:20.00700 \ n " + " [[array.ofTables]] \ n " + "     a = false \ n " + " [[array.ofTables]] \ n " + "     a = [,] \ n " + " [[array.ofTables]] \ n " + "     a = true \ n " + " basicMultiline =  \" \" \" \ n " + " First line \ n " + " \\ tSecond line \\ \ n  " + " Still second line \" \" \" \ n " + " literalMultiline=  \ ' \ ' \ ' \ n " + " First line \ n " + " Second line \ ' \ ' \ ' " ; parseAndPrint ( toml ) ; }
protected void finishedPayload ( byte [ ] pl ) throws IOException { ErrorCode ec = ErrorCode . getErrorCode ( ( byte ) errorCode ) ; if ( ec = = ErrorCode . ERR_AUTH_CONTINUE ) { getCallback ( ) . receivedStatus ( new OperationStatus ( true , new String ( pl ) ,
public void call ( Iterator < PlannedRow > t ) throws Exception { if ( output = = null ) { output = ( RandomWriteOutput ) Output . outputFor ( config ) ; } output . applyMutations ( Lists . newArrayList ( t ) ) ; }
void save ( ) ; void load ( ) ; @Override void close ( ) ; @Override default FileConfig checked ( ) { return new CheckedFileConfig ( this ) ; } static FileConfig of ( File file ) { return of ( file . toPath ( ) ) ; } static FileConfig of ( File file , ConfigFormat < ? extends Config > format ) { return of ( file . toPath ( ) , format ) ; } static FileConfig of ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return of ( file , format ) ; } static FileConfig of ( Path file , ConfigFormat < ? extends Config > format ) { return builder ( file , format ) . build ( ) ; } static FileConfig of ( String filePath ) { return of ( Paths . get ( filePath ) ) ; } static FileConfig of ( String filePath , ConfigFormat < ? > format ) { return of ( Paths . get ( filePath ) , format ) ; } static FileConfig ofConcurrent ( File file ) { return ofConcurrent ( file . toPath ( ) ) ; } static FileConfig ofConcurrent ( File file , ConfigFormat < ? > format ) { return ofConcurrent ( file . toPath ( ) , format ) ; } static FileConfig ofConcurrent ( Path file ) { return builder ( file ) . concurrent ( ) . build ( ) ; } static FileConfig ofConcurrent ( Path file , ConfigFormat < ? > format ) { return builder ( file , format ) . concurrent ( ) . build ( ) ; } static FileConfig ofConcurrent ( String filePath ) { return ofConcurrent ( Paths . get ( filePath ) ) ; } static FileConfig ofConcurrent ( String filePath , ConfigFormat < ? > format ) { return ofConcurrent ( Paths . get ( filePath ) , format ) ; } static FileConfigBuilder builder ( File file ) { return builder ( file . toPath ( ) ) ; } static FileConfigBuilder builder ( File file , ConfigFormat < ? > format ) { return builder ( file . toPath ( ) , format ) ; } static FileConfigBuilder builder ( Path file ) { ConfigFormat < ? > format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } return builder ( file , format ) ; } static FileConfigBuilder builder ( Path file , ConfigFormat < ? > format ) { return new FileConfigBuilder ( file , format ) ; } static FileConfigBuilder builder ( String filePath ) { return builder ( Paths . get ( filePath ) ) ; } static FileConfigBuilder builder ( String filePath , ConfigFormat < ? > format ) { return builder ( Paths . get ( filePath ) , format ) ; } }
public void warn ( Object message , Throwable exception ) { log ( Level . WARN , message , exception ) ; }
String getAttributeObject ( @Nullable String sName ) ; @Nullable String getAttributeAsString ( @Nullable String sName ) ; @Nullable String getAttributeAsString ( @Nullable String sName , @Nullable String sDefault ) ; int getAttributeAsInt ( @Nullable String sName ) ; int getAttributeAsInt ( @Nullable String sName , int nDefault ) ; long getAttributeAsLong ( @Nullable String sName ) ; long getAttributeAsLong ( @Nullable String sName , long nDefault ) ; double getAttributeAsDouble ( @Nullable String sName ) ; double getAttributeAsDouble ( @Nullable String sName , double dDefault ) ; boolean getAttributeAsBoolean ( @Nullable String sName ) ; boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; @Nonnull @ReturnsMutableCopy Enumeration < String > getAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Collection < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; Iterator < Entry < String , String > > iterator ( ) ; }
@Override public void run ( ) { s . cells . click ( " Water " ) ; } } ) ;
public void testConcept ( ) { testBagSequence ( new GearBag ( 2 , 2 ) ) ; }
public void testViewNoDocsWithErrors ( ) throws Exception { HttpOperation op = new NoDocsOperationImpl ( null , new NoDocsCallback ( ) { @Override public void receivedStatus ( OperationStatus status ) { assert status . isSuccess ( ) ; } @Override public void complete ( ) { } @Override public void gotData ( ViewResponse response ) { assert response . getErrors ( ) . size ( ) = = 2 ; Iterator < RowError > row = response . getErrors ( ) . iterator ( ) ; assert row . next ( ) . getFrom ( ) . equals ( " 127.0.0.1:5984 " ) ; assert response . size ( ) = = 0 ; } } ) ; HttpResponse response = new BasicHttpResponse ( HttpVersion . HTTP_1_1 , 200 , " " ) ; String entityString = " { \" total_rows \" :0, \" rows \" :[], \" errors \" : [{ \" from " + " \" : \" 127.0.0.1:5984 \" , \" reason \" : \" Design document `_design/test " + " foobar` missing in database `test_db_b`. \" },{ \" from \" : \" http:// " + " localhost:5984/_view_merge/ \" , \" reason \" : \" Design document ` " + " _design/testfoobar` missing in database `test_db_c`. \" }]} " ; StringEntity entity = new StringEntity ( entityString ) ; response . setEntity ( entity ) ; op . handleResponse ( response ) ; }
public void propertyChange ( PropertyChangeEvent event ) { String propertyName = event . getPropertyName ( ) ; if ( propertyName . equals ( " selectDisplayModality " ) ) { selectDisplayModality = ( ( Integer ) event . getNewValue ( ) ) . intValue ( ) ; if ( bindings ! = null ) draw ( ) ; } if ( propertyName . equals ( " notifyExceptionEvent " ) ) {
public List < Music > getSongs ( Artist artist , Album album ) throws MPDServerException { List < Music > aasongs = getSongs ( artist , album , true ) ; if ( aasongs = = null | | aasongs . size ( ) = = 0 ) return getSongs ( artist , album , false ) ;
private void _resend ( @Nonnull final IMessage aMsg , final OpenAS2Exception aCause , final int nTries ) throws OpenAS2Exception { if ( ! doResend ( IProcessorSenderModule . DO_SEND , aMsg , aCause , nTries ) ) {
public boolean set_prolog_flag_2 ( Term arg0 , Term arg1 ) throws PrologError { arg0 = arg0 . getTerm ( ) ; arg1 = arg1 . getTerm ( ) ; if ( arg0 instanceof Var ) throw PrologError . instantiation_error ( engineManager , 1 ) ; if ( arg1 instanceof Var ) throw PrologError . instantiation_error ( engineManager , 2 ) ; if ( ( ! arg0 . isAtom ( ) & & ! ( arg0 instanceof Struct ) ) ) throw PrologError . type_error ( engineManager , 1 , " struct " , arg0 ) ; if ( ! arg1 . isGround ( ) ) throw PrologError . type_error ( engineManager , 2 , " ground " , arg1 ) ; String name = arg0 . toString ( ) ; if ( flagManager . getFlag ( name ) = = null ) throw PrologError . domain_error ( engineManager , 1 , " prolog_flag " , arg0 ) ; if ( ! flagManager . isValidValue ( name , arg1 ) ) throw PrologError . domain_error ( engineManager , 2 , " flag_value " , arg1 ) ; if ( ! flagManager . isModifiable ( name ) ) throw PrologError . permission_error ( engineManager , " modify " , " flag " , arg0 , new Int ( 0 ) ) ; return flagManager . setFlag ( name , arg1 ) ; }
public void testIntOverflow ( ) { try { int b = TranscoderUtils . decodeInt ( oversizeBytes ) ;
public E putBack ( final E oldItem , final float forgetCycles , final Memory m ) { float relativeThreshold = Parameters . FORGET_QUALITY_RELATIVE ; m . forget ( oldItem , getForgetCycles ( forgetCycles , oldItem ) , relativeThreshold ) ; return putIn ( oldItem ) ; }
public void testUndecodeableCompressed ( ) throws Exception { CachedData cd = new CachedData ( WhalinTranscoder . COMPRESSED , tu . encodeInt ( Integer . MAX_VALUE ) ) ; assertNull ( tc . decode ( cd ) ) ; }
public static void introVarOuter ( final Statement taskContent , final Statement beliefContent , final int index , final DerivationContext nal ) { if ( ! ( taskContent instanceof Inheritance ) ) { return ; } final Variable varInd1 = new Variable ( " $varInd1 " ) ; final Variable varInd2 = new Variable ( " $varInd2 " ) ; Term term11dependent = null , term12dependent = null , term21dependent = null , term22dependent = null ; Term term11 , term12 , term21 , term22 , commonTerm = null ; final Map < Term , Term > subs = new HashMap < > ( ) ; if ( index = = 0 ) { term11 = varInd1 ; term21 = varInd1 ; term12 = taskContent . getPredicate ( ) ; term22 = beliefContent . getPredicate ( ) ; term12dependent = term12 ; term22dependent = term22 ; if ( term12 instanceof ImageExt ) { if ( ( term12 ) . containsTermRecursively ( term22 ) ) { commonTerm = term22 ; } if ( commonTerm = = null & & term12 instanceof ImageExt ) { commonTerm = ( ( Image ) term12 ) . getTheOtherComponent ( ) ; if ( ! ( term22 . containsTermRecursively ( commonTerm ) ) ) { commonTerm = null ; } if ( term22 instanceof ImageExt & & ( ( commonTerm = = null ) | | ! ( term22 ) . containsTermRecursively ( commonTerm ) ) ) { commonTerm = ( ( Image ) term22 ) . getTheOtherComponent ( ) ; if ( ( commonTerm = = null ) | | ! ( term12 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = null ; } } } if ( commonTerm ! = null ) { subs . put ( commonTerm , varInd2 ) ; term12 = ( ( CompoundTerm ) term12 ) . applySubstitute ( subs ) ; if ( ! ( term22 instanceof CompoundTerm ) ) { term22 = varInd2 ; } else { term22 = ( ( CompoundTerm ) term22 ) . applySubstitute ( subs ) ; } } } if ( commonTerm = = null & & term22 instanceof ImageExt ) { if ( ( term22 ) . containsTermRecursively ( term12 ) ) { commonTerm = term12 ; } if ( commonTerm = = null & & term22 instanceof ImageExt ) { commonTerm = ( ( Image ) term22 ) . getTheOtherComponent ( ) ; if ( ! ( term12 . containsTermRecursively ( commonTerm ) ) ) { commonTerm = null ; } if ( term12 instanceof ImageExt & & ( ( commonTerm = = null ) | | ! ( term12 ) . containsTermRecursively ( commonTerm ) ) ) { commonTerm = ( ( Image ) term12 ) . getTheOtherComponent ( ) ; if ( ( commonTerm = = null ) | | ! ( term22 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = null ; } } } if ( commonTerm ! = null ) { subs . put ( commonTerm , varInd2 ) ; term22 = ( ( CompoundTerm ) term22 ) . applySubstitute ( subs ) ; if ( ! ( term12 instanceof CompoundTerm ) ) { term12 = varInd2 ; } else { term12 = ( ( CompoundTerm ) term12 ) . applySubstitute ( subs ) ; } } } } else { term11 = taskContent . getSubject ( ) ; term21 = beliefContent . getSubject ( ) ; term12 = varInd1 ; term22 = varInd1 ; term11dependent = term11 ; term21dependent = term21 ; if ( term21 instanceof ImageInt ) { if ( ( term21 ) . containsTermRecursively ( term11 ) ) { commonTerm = term11 ; } if ( term11 instanceof ImageInt & & commonTerm = = null & & term21 instanceof ImageInt ) { commonTerm = ( ( Image ) term11 ) . getTheOtherComponent ( ) ; if ( ! ( term21 . containsTermRecursively ( commonTerm ) ) ) { commonTerm = null ; } if ( ( commonTerm = = null ) | | ! ( term21 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = ( ( Image ) term21 ) . getTheOtherComponent ( ) ; if ( ( commonTerm = = null ) | | ! ( term11 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = null ; } } } if ( commonTerm ! = null ) { subs . put ( commonTerm , varInd2 ) ; term21 = ( ( CompoundTerm ) term21 ) . applySubstitute ( subs ) ; if ( ! ( term11 instanceof CompoundTerm ) ) { term11 = varInd2 ; } else { term11 = ( ( CompoundTerm ) term11 ) . applySubstitute ( subs ) ; } } } if ( commonTerm = = null & & term11 instanceof ImageInt ) { if ( ( term11 ) . containsTermRecursively ( term21 ) ) { commonTerm = term21 ; } if ( term21 instanceof ImageInt & & commonTerm = = null & & term11 instanceof ImageInt ) { commonTerm = ( ( Image ) term21 ) . getTheOtherComponent ( ) ; if ( ! ( term11 . containsTermRecursively ( commonTerm ) ) ) { commonTerm = null ; } if ( ( commonTerm = = null ) | | ! ( term11 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = ( ( Image ) term11 ) . getTheOtherComponent ( ) ; if ( ( commonTerm = = null ) | | ! ( term21 ) . containsTermRecursively ( commonTerm ) ) { commonTerm = null ; } } } if ( commonTerm ! = null ) { subs . put ( commonTerm , varInd2 ) ; term11 = ( ( CompoundTerm ) term11 ) . applySubstitute ( subs ) ; if ( ! ( term21 instanceof CompoundTerm ) ) { term21 = varInd2 ; } else { term21 = ( ( CompoundTerm ) term21 ) . applySubstitute ( subs ) ; } } } } Statement state1 = Inheritance . make ( term11 , term12 ) ; Statement state2 = Inheritance . make ( term21 , term22 ) ; Term content = Implication . make ( state1 , state2 ) ; if ( content = = null ) { return ; } final TruthValue truthT = nal . getCurrentTask ( ) . sentence . truth ; final TruthValue truthB = nal . getCurrentBelief ( ) . truth ; if ( ( truthT = = null ) | | ( truthB = = null ) ) { if ( Parameters . DEBUG ) { System . out . println ( " ERROR: Belief with null truth value. (introVarOuter) " ) ; } return ; } TruthValue truth = induction ( truthT , truthB ) ; BudgetValue budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; nal . doublePremiseTask ( content , truth , budget , false , false ) ; content = Implication . make ( state2 , state1 ) ; truth = induction ( truthB , truthT ) ; budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; nal . doublePremiseTask ( content , truth , budget , false , false ) ; content = Equivalence . make ( state1 , state2 ) ; truth = comparison ( truthT , truthB ) ; budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; nal . doublePremiseTask ( content , truth , budget , false , false ) ; final Variable varDep = new Variable ( " #varDep " ) ; if ( index = = 0 ) { state1 = Inheritance . make ( varDep , term12dependent ) ; state2 = Inheritance . make ( varDep , term22dependent ) ; } else { state1 = Inheritance . make ( term11dependent , varDep ) ; state2 = Inheritance . make ( term21dependent , varDep ) ; } if ( ( state1 = = null ) | | ( state2 = = null ) ) return ; content = Conjunction . make ( state1 , state2 ) ; truth = intersection ( truthT , truthB ) ; budget = BudgetFunctions . compoundForward ( truth , content , nal ) ; nal . doublePremiseTask ( content , truth , budget , false , false ) ; }
public void clicked ( int x , int y , Grid2DSpace space ) { if ( ( int ) x = = 0 | | ( int ) y = = 0 | | ( int ) x = = w - 1 | | ( int ) y = = h - 1 ) return ; if ( ! doorname . equals ( " " ) & & ! doorname . contains ( " { " ) ) { doorname = " { " + doorname + " } " ; } if ( oper . equals ( " perceive " ) ) { readCells [ ( int ) x ] [ ( int ) y ] . name = " place " + entityID . toString ( ) ; writeCells [ ( int ) x ] [ ( int ) y ] . name = " place " + entityID . toString ( ) ; if ( TestChamber . staticInformation ) nar . addInput ( " < " + " {place " + entityID . toString ( ) + " } --> place>. " ) ; if ( TestChamber . curiousity ) { space . nar . addInput ( " <(^go-to, " + " place " + entityID . toString ( ) + " ) =/> <Self --> [curious]>>. " ) ; } entityID + + ; return ; } if ( ! " " . equals ( oper ) ) { if ( ! " " . equals ( readCells [ x ] [ y ] . name ) & & ! " pick " . equals ( oper ) ) { if ( allow_imitating ) { nar . addInput ( " (^ " + oper + " , " + readCells [ x ] [ y ] . name + " )! :|: " ) ; } else { nar . executeDummyDecision ( " (^ " + oper + " , " + readCells [ x ] [ y ] . name + " ) " ) ; TestChamber . operateObj ( readCells [ x ] [ y ] . name , oper ) ; } } String s = TestChamber . getobj ( x , y ) ; if ( ! s . equals ( " " ) ) { if ( allow_imitating ) { nar . addInput ( " (^ " + oper + " , " + s + " )! :|: " ) ; } else { nar . executeDummyDecision ( " (^ " + oper + " , " + s + " ) " ) ; TestChamber . operateObj ( s , oper ) ; } } return ; } if ( ! " " . equals ( wish ) ) { boolean inverse = false ; if ( wish . equals ( " closed " ) | | wish . equals ( " off " ) ) { inverse = true ; } String wishreal = wish . replace ( " closed " , " opened " ) . replace ( " off " , " on " ) ; if ( ! " " . equals ( readCells [ x ] [ y ] . name ) ) { if ( ! inverse ) { nar . addInput ( " < " + readCells [ x ] [ y ] . name + "  --> [ " + wishreal + " ]>! :|: " ) ; } else { nar . addInput ( " (--,< " + readCells [ x ] [ y ] . name + "  --> [ " + wishreal + " ]>)! :|: %1.00;0.90% " ) ; } } String s = TestChamber . getobj ( x , y ) ; if ( ! s . equals ( " " ) ) { if ( ! inverse ) { nar . addInput ( " < " + s + "  --> [ " + wishreal + " ]>! :|: " ) ; } else { nar . addInput ( " (--,< " + s + "  --> [ " + wishreal + " ]>)! :|: %1.00;0.90% " ) ; } } return ; } if ( ! " " . equals ( doorname ) & & selected . material = = Material . Door ) { space . add ( new Key ( ( int ) x , ( int ) y , doorname . replace ( " door " , " key " ) ) ) ; if ( TestChamber . staticInformation ) nar . addInput ( " < " + doorname . replace ( " door " , " key " ) + "  --> key>. " ) ; if ( TestChamber . curiousity ) { space . nar . addInput ( " <(^go-to, " + doorname . replace ( " door " , " key " ) + " ) =/> <Self --> [curious]>>. " ) ; space . nar . addInput ( " <(^pick, " + doorname . replace ( " door " , " key " ) + " ) =/> <Self --> [curious]>>. " ) ; } doorname = " " ; return ; } if ( selected . material = = Material . Pizza ) { doorname = " {pizza " + entityID . toString ( ) + " } " ; } if ( ! " " . equals ( doorname ) & & selected . material = = Material . Pizza ) { space . add ( new Pizza ( ( int ) x , ( int ) y , doorname ) ) ; if ( TestChamber . staticInformation ) nar . addInput ( " < " + doorname + "  --> pizza>. " ) ; if ( TestChamber . curiousity ) { space . nar . addInput ( " <(^go-to, " + doorname + " ) =/> <Self --> [curious]>>. " ) ; } entityID + + ; doorname = " " ; return ; } if ( ! ( selected . material = = Material . Door ) & & ! ( selected . material = = Material . Pizza ) ) doorname = " " ; readCells [ ( int ) x ] [ ( int ) y ] . charge = selected . charge ; writeCells [ ( int ) x ] [ ( int ) y ] . charge = selected . charge ; readCells [ ( int ) x ] [ ( int ) y ] . logic = selected . logic ; writeCells [ ( int ) x ] [ ( int ) y ] . logic = selected . logic ; readCells [ ( int ) x ] [ ( int ) y ] . material = selected . material ; writeCells [ ( int ) x ] [ ( int ) y ] . material = selected . material ; readCells [ ( int ) x ] [ ( int ) y ] . machine = selected . machine ; writeCells [ ( int ) x ] [ ( int ) y ] . machine = selected . machine ; if ( selected . material = = Material . Pizza | | selected . material = = Material . Door | | selected . logic = = Logic . OFFSWITCH | | selected . logic = = Logic . SWITCH | | selected . machine = = Machine . Light | | selected . machine = = Machine . Turret ) {
public static ECryptoAlgorithmCrypt getFromIDOrNull ( @Nullable final String sID ) { return EnumHelper . getFromIDOrNull ( ECryptoAlgorithmCrypt . class , sID ) ; }
public void draw ( Grid2DSpace s , boolean edge ) { int ambientLight = 100 ; int r = 0 , g = 0 , b = 0 , a = 1 ; a = ambientLight ; if ( material = = Material . Empty ) { } else if ( material = = Material . Machine ) { g = b = 127 ; r = 200 ; } else if ( material = = Material . StoneWall | | ( material = = Material . Door & & state . is_solid ) ) { r = g = b = 255 ; } else if ( material = = Material . DirtFloor | | ( material = = Material . Door & & ! state . is_solid ) ) { if ( height = = Float . MAX_VALUE ) { r = g = b = 255 ; } else { r = g = b = ( int ) ( 128 + height ) ; } } if ( material = = Material . Door & & state . is_solid ) { b = 0 ; g = ( int ) ( g / 2.0f ) ; } if ( material = = Material . Door ) { r = 200 ; } if ( ( charge > 0 ) | | ( chargeFront ) ) { { float freq = 4 ; int chargeBright = ( int ) ( ( Math . cos ( s . getRealtime ( ) * freq ) + 1 ) * 25 ) ; if ( charge > 0 ) { r + = chargeBright ; g + = chargeBright / 2 ; } else { g + = chargeBright ; r + = chargeBright / 2 ; } if ( chargeFront ) { freq = 7 ; b + = 25 ; } a + = 150 ; } } if ( edge ) { state . light = 255 ; } a + = state . light * 255 ; if ( material = = Material . StoneWall ) { a = r = g = b = ( int ) ( 200 + state . light * 255 ) ; } if ( state . light > 0 ) { r + = state . light ; g + = state . light ; b + = state . light ; a + = state . light ; } if ( logic ! = Logic . NotALogicBlock ) { r / = 2.0f ; } r = Math . min ( 255 , r ) ; g = Math . min ( 255 , g ) ; b = Math . min ( 255 , b ) ; a = Math . min ( 255 , a ) ; state . cr = lerp ( state . cr , r , 0.19f ) ; state . cg = lerp ( state . cg , g , 0.19f ) ; state . cb = lerp ( state . cb , b , 0.19f ) ; state . ca = lerp ( state . ca , a , 0.19f ) ; s . fill ( state . cr , state . cg , state . cb , state . ca ) ; s . rect ( 0 , 0 , 1.0f , 1.0f ) ; s . textSize ( 1 ) ; if ( logic = = Logic . SWITCH | | logic = = Logic . OFFSWITCH ) { s . fill ( state . cr , state . cg , state . cb , state . ca ) ; s . ellipse ( 0.5f , 0.5f , 1.0f , 1.0f ) ; } else if ( logic ! = Logic . BRIDGE & & logic ! = Logic . NotALogicBlock & & logic ! = Logic . WIRE ) { s . fill ( state . cr + 30 , state . cg + 30 , state . cb + 30 , state . ca + 30 ) ; s . triangle ( 0.25f , 1.0f , 0.5f , 0.5f , 0.75f , 1.0f ) ; s . triangle ( 0.25f , 0.0f , 0.5f , 0.5f , 0.75f , 0.0f ) ; s . fill ( state . cr + 30 , state . cg + 30 , state . cb + 30 , state . ca + 30 ) ; s . rect ( 0 , 0.3f , 1 , 0.4f ) ; } else if ( logic = = Logic . WIRE | | logic = = Logic . BRIDGE ) { s . fill ( state . cr , state . cg , state . cb , state . ca ) ; s . rect ( 0 , 0.3f , 1 , 0.4f ) ; s . rect ( 0.3f , 0 , 0.4f , 1 ) ; } if ( logic = = Logic . AND ) { drawtext ( s , " ^ " ) ; } if ( logic = = Logic . OR ) { drawtext ( s , " v " ) ; } if ( logic = = Logic . XOR ) { drawtext ( s , " x " ) ; } if ( logic = = Logic . NOT ) { drawtext ( s , " ~ " ) ; } if ( logic = = Logic . BRIDGE ) { drawtext ( s , " H " ) ; } if ( logic = = Logic . SWITCH ) { drawtext ( s , " 1 " ) ; } if ( logic = = Logic . OFFSWITCH ) { drawtext ( s , " 0 " ) ; } if ( machine ! = null ) { switch ( machine ) {
protected void asyncUpdate ( ) { try { MPDApplication app = ( MPDApplication ) getApplication ( ) ;
public static ICommonsList < String > getAllHTTPHeaderLines ( @Nonnull final InternetHeaders aHeaders ) { final ICommonsList < String > ret = new CommonsArrayList < > ( ) ; final Enumeration < ? > aEnum = aHeaders . getAllHeaderLines ( ) ; while ( aEnum . hasMoreElements ( ) ) ret . add ( ( String ) aEnum . nextElement ( ) ) ; return ret ; }
Future < Object > asyncGet ( String key ) ; < T > Future < CASValue < T > > asyncGets ( String key , Transcoder < T > tc ) ; Future < CASValue < Object > > asyncGets ( String key ) ; < T > CASValue < T > gets ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; CASValue < Object > gets ( String key ) throws OperationTimeoutException ; < T > T get ( String key , Transcoder < T > tc ) throws OperationTimeoutException ; Object get ( String key ) throws OperationTimeoutException ; < T > Future < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; Future < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > Future < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; Future < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) throws OperationTimeoutException ; Map < String , Object > getBulk ( Collection < String > keys ) throws OperationTimeoutException ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) throws OperationTimeoutException ; Map < String , Object > getBulk ( String . . . keys ) throws OperationTimeoutException ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , int by ) throws OperationTimeoutException ; long decr ( String key , int by ) throws OperationTimeoutException ; long incr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; long decr ( String key , int by , long def , int exp ) throws OperationTimeoutException ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , int by , long def ) throws OperationTimeoutException ; long decr ( String key , int by , long def ) throws OperationTimeoutException ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; }
MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert ) throws Exception ; }
ConfigParser < C > createParser ( ) ; C createConfig ( ) ; C createConcurrentConfig ( ) ; boolean supportsComments ( ) ; default boolean supportsType ( Class < ? > type ) { return InMemoryFormat . DEFAULT_PREDICATE . test ( type ) ; } default boolean isInMemory ( ) { return false ; } default void initEmptyFile ( Path f ) throws IOException { initEmptyFile ( ( ) - > Files . newBufferedWriter ( f ) ) ; } default void initEmptyFile ( File f ) throws IOException { initEmptyFile ( f . toPath ( ) ) ; } default void initEmptyFile ( WriterSupplier ws ) throws IOException { } }
public void addInput ( final String text ) { Narsese narsese = new Narsese ( this ) ; if ( addMultiLineInput ( text ) ) { return ; } if ( addCommand ( text ) ) { return ; } Task task ; try { task = narsese . parseTask ( text . trim ( ) ) ; } catch ( InvalidInputException e ) { throw new IllegalStateException ( " Invalid input " , e ) ; } Term t = ( ( Task ) task ) . getTerm ( ) ; if ( t ! = null & & t instanceof Inheritance ) { Term predicate = ( ( Inheritance ) t ) . getPredicate ( ) ; if ( this . sensoryChannels . containsKey ( predicate ) ) { Inheritance inh = ( Inheritance ) task . sentence . term ; SetExt subj = ( SetExt ) inh . getSubject ( ) ; if ( subj . term [ 0 ] . term_indices = = null ) { String variable = subj . toString ( ) . split ( " \\ [ " ) [ 0 ] ; String [ ] vals = subj . toString ( ) . split ( " \\ [ " ) [ 1 ] . split ( " \\ ] " ) [ 0 ] . split ( " , " ) ; double height = Double . parseDouble ( vals [ 0 ] ) ; double width = Double . parseDouble ( vals [ 1 ] ) ; int wval = ( int ) Math . round ( ( width + 1.0f ) / 2.0f * ( this . sensoryChannels . get ( predicate ) . width - 1 ) ) ; int hval = ( int ) Math . round ( ( ( height + 1.0f ) / 2.0f * ( this . sensoryChannels . get ( predicate ) . height - 1 ) ) ) ; String ev = task . sentence . isEternal ( ) ? "   " : "  :|:  " ; String newInput = " < " + variable + " [ " + hval + " , " + wval + " ]} -->  " + predicate + " > " + task . sentence . punctuation + ev + task . sentence . truth . toString ( ) ; this . emit ( OutputHandler . IN . class , task ) ; this . addInput ( newInput ) ; return ; } this . sensoryChannels . get ( predicate ) . addInput ( ( Task ) task ) ; return ; } } this . memory . inputTask ( task ) ; }
private static int greatestPowerOfTwoDividing ( int x ) { return x & ( - x ) ; }
public V fromBytes ( byte [ ] byteArr ) { Input input = new Input ( byteArr ) ; Object obj = kryo . readClassAndObject ( input ) ; input . close ( ) ; return ( V ) obj ; }
public ProcessingItem connectInputKeyStream ( Stream inputStream , Processor processor ) { ProcessingItem pi = ( ProcessingItem ) this . mapProcessorToProcessingItem . get ( processor ) ; ProcessingItem ret = null ; if ( pi ! = null ) { ret = pi . connectInputKeyStream ( inputStream ) ; } return ret ; }
public synchronized boolean refresh ( final boolean force ) { if ( ! mEnabled ) { return false ; } if ( ! updateConnection ( ) ) { return false ; } if ( ! force & & isUpToDate ( ) ) { Log . d ( TAG , " Cache is up to date " ) ; return true ; } Log . d ( TAG , " Cache is NOT up to date. fetching ... " ) ; mLastUpdate = Calendar . getInstance ( ) . getTime ( ) ; Tools . notifyUser ( R . string . updatingLocalAlbumCacheNote ) ; final Date oldUpdate = mLastUpdate ; mAlbumDetails = new HashMap < > ( ) ; mAlbumSet = new HashSet < > ( ) ; final List < Music > allmusic ; try { allmusic = mMPD . listAllInfo ( ) ; Log . d ( TAG , " allmusic  " + allmusic . size ( ) ) ; } catch ( final MPDServerException e ) { mEnabled = false ; mLastUpdate = null ; updateConnection ( ) ; Log . d ( TAG , " disabled AlbumCache " , e ) ; Tools . notifyUser ( " Error with the 'listallinfo' command. Probably you have to adjust your server's 'max_output_buffer_size' " ) ; return false ; } try { for ( final Music music : allmusic ) { final String albumArtist = music . getAlbumArtist ( ) ; final String artist = music . getArtist ( ) ; String album = music . getAlbum ( ) ; if ( album = = null ) { album = " " ; } final List < String > albumInfo = Arrays . asList ( album , artist = = null ? " " : artist , albumArtist = = null ? " " : albumArtist ) ; mAlbumSet . add ( albumInfo ) ; final boolean isAlbumArtist = albumArtist ! = null & & ! albumArtist . isEmpty ( ) ; final String thisAlbum = albumCode ( isAlbumArtist ? albumArtist : artist , album , isAlbumArtist ) ; final AlbumDetails details ; if ( mAlbumDetails . containsKey ( thisAlbum ) ) { details = mAlbumDetails . get ( thisAlbum ) ; } else { details = new AlbumDetails ( ) ; mAlbumDetails . put ( thisAlbum , details ) ; } if ( details . mPath = = null ) { details . mPath = music . getPath ( ) ; } details . mNumTracks + = 1 ; details . mTotalTime + = music . getTime ( ) ; if ( details . mDate = = 0 ) { details . mDate = music . getDate ( ) ; } } Log . d ( TAG , " albumDetails:  " + mAlbumDetails . size ( ) ) ; Log . d ( TAG , " albumSet:  " + mAlbumSet . size ( ) ) ; makeUniqueAlbumSet ( ) ; Log . d ( TAG , " uniqueAlbumSet:  " + mUniqueAlbumSet . size ( ) ) ; if ( ! save ( ) ) { mLastUpdate = oldUpdate ; return false ; } } catch ( final Exception e ) { Tools . notifyUser ( " Error updating Album Cache " ) ; mLastUpdate = oldUpdate ; Log . e ( TAG , " Error updating Album Cache. " , e ) ; return false ; } return true ; }
public void update ( final Tracker tracker , long now ) { final double currentValue = tracker . getValue ( ) ; double tmp ; commits . incrementAndGet ( ) ; if ( first . get ( ) = = null ) { first . compareAndSet ( null , currentValue ) ; } last = currentValue ; for ( ; ; ) { tmp = min . get ( ) ; if ( currentValue < tmp ) { if ( min . compareAndSet ( tmp , currentValue ) ) { break ; } } else { break ; } } for ( ; ; ) { tmp = max . get ( ) ; if ( currentValue > tmp ) { if ( max . compareAndSet ( tmp , currentValue ) ) { break ; } } else { break ; } } sum . addAndGet ( currentValue ) ; for ( DataRecorder dataRecorder : dataRecorders ) { try { dataRecorder . update ( this , tracker , now ) ; } catch ( Exception e ) { Misc . logHandledException ( logger , e , " Failed to update {} " , dataRecorder ) ; Misc . handleUncaughtException ( getKey ( ) , e ) ; } } eventManager . fireEvent ( EventType . TRACKER_COMMITTED , key , tracker ) ; }
static List < String > parseTableName ( CharacterInput input , TomlParser parser ) { List < String > list = new ArrayList < > ( parser . getInitialListCapacity ( ) ) ; while ( true ) { char firstChar = Toml . readNonSpaceChar ( input , false ) ;
String getAttributeAsString ( @Nullable String sName , @Nullable String sDefault ) ; int getAttributeAsInt ( @Nullable String sName ) ; int getAttributeAsInt ( @Nullable String sName , int nDefault ) ; long getAttributeAsLong ( @Nullable String sName ) ; long getAttributeAsLong ( @Nullable String sName , long nDefault ) ; double getAttributeAsDouble ( @Nullable String sName ) ; double getAttributeAsDouble ( @Nullable String sName , double dDefault ) ; boolean getAttributeAsBoolean ( @Nullable String sName ) ; boolean getAttributeAsBoolean ( @Nullable String sName , boolean bDefault ) ; @Nonnull @ReturnsMutableCopy Enumeration < String > getAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Set < String > getAllAttributeNames ( ) ; @Nonnull @ReturnsMutableCopy Collection < String > getAllAttributeValues ( ) ; @Nonnegative int getAttributeCount ( ) ; boolean containsNoAttribute ( ) ; boolean getAndSetAttributeFlag ( String sName ) ; @Nonnull Iterator < Entry < String , String > > iterator ( ) ; }
public void draw ( ) { if ( ! visible ) return ; updateBuffer ( ) ; winApp . pushStyle ( ) ; winApp . pushMatrix ( ) ; applyTransform ( ) ; winApp . pushMatrix ( ) ; winApp . translate ( - halfWidth , - halfHeight ) ; winApp . imageMode ( PApplet . CORNER ) ; if ( alphaLevel < 255 ) winApp . tint ( TINT_FOR_ALPHA , alphaLevel ) ; winApp . image ( buffer , 0 , 0 ) ; if ( focusIsWith = = this & & showCaret & & endTLHI . tli ! = null ) { float [ ] cinfo = endTLHI . tli . layout . getCaretInfo ( endTLHI . thi ) ; float x_left = - ptx + cinfo [ 0 ] ; float y_top = - pty + endTLHI . tli . yPosInPara ; float y_bot = y_top - cinfo [ 3 ] + cinfo [ 5 ] ; if ( x_left > = 0 & & x_left < = tw & & y_top > = 0 & & y_bot < = th ) { winApp . strokeWeight ( 1.5f ) ; winApp . stroke ( palette [ 12 ] ) ; winApp . line ( tx + x_left , ty + Math . max ( 0 , y_top ) , tx + x_left , ty + Math . min ( th , y_bot ) ) ; } } winApp . popMatrix ( ) ; if ( children ! = null ) { for ( GControl c : children ) c . draw ( ) ; } winApp . popMatrix ( ) ; winApp . popStyle ( ) ; }
public void processNewTasks ( Parameters narParameters ) { synchronized ( tasksMutex ) { Task task ;
public boolean requestFeature ( int featureId ) { if ( DEBUG ) Log . d ( TAG , " [requestFeature] featureId:  " + featureId ) ; final boolean result = mActivity . getWindow ( ) . requestFeature ( featureId ) ; if ( DEBUG ) Log . d ( TAG , " [requestFeature] returning  " + result ) ; return result ; }
public void runStep ( Set < Step > dependencySteps ) throws Exception { Contexts . getJavaSparkContext ( ) . sc ( ) . setJobDescription ( " Step:  " + getName ( ) ) ; DataFrame data ; if ( hasInput ( ) ) { data = ( ( BatchInput ) input ) . read ( ) ; } else if ( hasDeriver ( ) ) { Map < String , DataFrame > dependencies = getStepDataFrames ( dependencySteps ) ; data = deriver . derive ( dependencies ) ; } else { deriver = new PassthroughDeriver ( ) ; Map < String , DataFrame > dependencies = getStepDataFrames ( dependencySteps ) ; data = deriver . derive ( dependencies ) ; } setData ( data ) ; setFinished ( true ) ; }
public BufferedImage scale ( double scaleX , double scaleY ) { int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; Image scaledImage = image . getScaledInstance ( ( int ) ( width * scaleX ) , ( int ) ( height * scaleY ) , Image . SCALE_SMOOTH ) ; BufferedImage bufferedScaledImage = imageToBufferedImage ( scaledImage ) ; return bufferedScaledImage ; }
ByteBuffer getBuffer ( ) ; void writeComplete ( ) ; void initialize ( ) ; void readFromBuffer ( ByteBuffer data ) throws IOException ; void handleRead ( ByteBuffer data ) ; MemcachedNode getHandlingNode ( ) ; void setHandlingNode ( MemcachedNode to ) ; void timeOut ( ) ; boolean isTimedOut ( ) ; boolean isTimedOut ( long ttlMillis ) ; boolean isTimedOutUnsent ( ) ; }
void onLink ( TLink l , double progress , List < Runnable > queue ) { if ( l instanceof TaskLink ) { TaskLink taskLink = ( TaskLink ) l ;
public void test_expression_comparison_2_2 ( ) throws Exception { Prolog engine = new Prolog ( ) ; String goal = " catch('=:='(1, X), error(instantiation_error, instantiation_error(Goal, ArgNo)), true). " ; SolveInfo info = engine . solve ( goal ) ; assertTrue ( info . isSuccess ( ) ) ; Struct g = ( Struct ) info . getTerm ( " Goal " ) ; assertTrue ( g . isEqual ( new Struct ( " expression_equality " , new Int ( 1 ) , new Var ( " X " ) ) ) ) ; Int argNo = ( Int ) info . getTerm ( " ArgNo " ) ; assertTrue ( argNo . intValue ( ) = = 2 ) ; }
public void connectionStateChanged ( boolean connected , boolean connectionLost ) { settingsFragment . onConnectionStateChanged ( ) ; }
public String toString ( OperatorManager op ) { int p ; if ( ( p = op . opPrio ( " :- " , " xfx " ) ) > = OperatorManager . OP_LOW ) { String st = indentPredicatesAsArgX ( clause . getArg ( 1 ) , op , p ) ; String head = clause . getArg ( 0 ) . toStringAsArgX ( op , p ) ; if ( st . equals ( " true " ) ) { return head + " . \ n " ; } else { return ( head + "  :- \ n \ t " + st + " . \ n " ) ; } } if ( ( p = op . opPrio ( " :- " , " yfx " ) ) > = OperatorManager . OP_LOW ) { String st = indentPredicatesAsArgX ( clause . getArg ( 1 ) , op , p ) ; String head = clause . getArg ( 0 ) . toStringAsArgY ( op , p ) ; if ( st . equals ( " true " ) ) { return head + " . \ n " ; } else { return ( head + "  :- \ n \ t " + st + " . \ n " ) ; } } if ( ( p = op . opPrio ( " :- " , " xfy " ) ) > = OperatorManager . OP_LOW ) { String st = indentPredicatesAsArgY ( clause . getArg ( 1 ) , op , p ) ; String head = clause . getArg ( 0 ) . toStringAsArgX ( op , p ) ; if ( st . equals ( " true " ) ) { return head + " . \ n " ; } else { return ( head + "  :- \ n \ t " + st + " . \ n " ) ; } } return ( clause . toString ( ) ) ; }
public void forceMoveShoulder ( boolean addInput , float angle ) { int a = ( int ) angle ; if ( addInput ) nar . addInput ( " (^joint,shoulder,a " + a + " )! " ) ; shoulderAngle = angle ; if ( shoulderAngle < - shoulderRange ) shoulderAngle = - shoulderRange ; if ( shoulderAngle > shoulderRange ) shoulderAngle = shoulderRange ; }
public Stm visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . StmDisj p , A arg ) { Stm stm_1 = p . stm_1 . accept ( this , arg ) ; Stm stm_2 = p . stm_2 . accept ( this , arg ) ; return new com . googlecode . opennars . parser . loan . Loan . Absyn . StmDisj ( stm_1 , stm_2 ) ; }
public < T > T set ( List < String > path , Object value ) { final int lastIndex = path . size ( ) - 1 ; Map < String , Object > currentMap = map ; for ( String currentKey : path . subList ( 0 , lastIndex ) ) { final Object currentValue = currentMap . get ( currentKey ) ; final Config config ; if ( currentValue = = null ) { config = createSubConfig ( ) ; currentMap . put ( currentKey , config ) ; } else if ( ! ( currentValue instanceof Config ) ) { throw new IllegalArgumentException ( " Cannot add an element to an intermediary value of type:  " + currentValue . getClass ( ) ) ; } else { config = ( Config ) currentValue ; } currentMap = config . valueMap ( ) ; } String lastKey = path . get ( lastIndex ) ; return ( T ) currentMap . put ( lastKey , value ) ; }
public Object getContent ( URLConnection urlc ) throws IOException { List list = new LinkedList ( ) ; LineNumberReader reader = new LineNumberReader ( new InputStreamReader ( urlc . getInputStream ( ) ) ) ; for ( String line = reader . readLine ( ) ; line ! = null ; line = reader . readLine ( ) ) { line . trim ( ) ; if ( " " . equals ( line ) | | line . startsWith ( " # " ) ) { continue ; } list . add ( line ) ; } return list ; }
public List < PlannedRecord > planOperations ( List < GenericRecord > arrivingRecords , List < GenericRecord > existingRecords , RecordModel recordModel ) throws Exception { List < PlannedRecord > planned = Lists . newArrayList ( ) ; for ( GenericRecord arriving : arrivingRecords ) { arriving . put ( recordModel . getKeyFieldNames ( ) . get ( 0 ) , UUID . randomUUID ( ) . toString ( ) ) ; planned . add ( new PlannedRecord ( arriving , OperationType . INSERT ) ) ; } return planned ; }
public int hashCode ( ) { return 31 * ( int ) ( this . start + this . end + this . set . size ( ) ) ; }
public void load ( String file ) throws MPDServerException { this . mpd . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_LOAD , file ) ; this . refresh ( ) ; }
public double [ ] normalizedInstance ( Instance inst ) { double [ ] normalizedInstance = new double [ inst . numAttributes ( ) ] ; for ( int j = 0 ; j < inst . numAttributes ( ) - 1 ; j + + ) { int instAttIndex = modelAttIndexToInstanceAttIndex ( j ) ; double mean = perceptronattributeStatistics . getValue ( j ) / perceptronYSeen ; double sd = computeSD ( squaredperceptronattributeStatistics . getValue ( j ) , perceptronattributeStatistics . getValue ( j ) , perceptronYSeen ) ; if ( sd > SD_THRESHOLD ) normalizedInstance [ j ] = ( inst . value ( instAttIndex ) - mean ) / sd ; else normalizedInstance [ j ] = inst . value ( instAttIndex ) - mean ; } return normalizedInstance ; }
public static OneofCase valueOf ( int value ) { return forNumber ( value ) ; }
public static Term make ( Term [ ] argList , Memory memory ) { if ( argList . length = = 1 ) { return argList [ 0 ] ; } if ( argList . length ! = 2 ) { return null ; } if ( ( argList [ 0 ] instanceof SetInt ) & & ( argList [ 1 ] instanceof SetInt ) ) { TreeSet < Term > set = new TreeSet < Term > ( ( ( CompoundTerm ) argList [ 0 ] ) . cloneComponentsList ( ) ) ; set . removeAll ( ( ( CompoundTerm ) argList [ 1 ] ) . cloneComponentsList ( ) ) ; return SetInt . make ( set , memory ) ; } String name = makeCompoundName ( NativeOperator . DIFFERENCE_INT , argList ) ; Term t = memory . nameToTerm ( name ) ; return ( t ! = null ) ? t : new DifferenceInt ( argList ) ; }
public TermLink selectTermLink ( final TaskLink taskLink , final long time ) { if ( termLinks . size ( ) = = 0 ) return null ; int toMatch = memory . param . termLinkMaxMatched . get ( ) ; for ( int i = 0 ; i < toMatch ; i + + ) { final TermLink termLink = termLinks . takeNext ( ) ; if ( taskLink . novel ( termLink , time ) ) { return termLink ; } returnTermLink ( termLink ) ; } return null ;
private static ECryptoAlgorithmSign _getUnified ( @Nonnull final ECryptoAlgorithmSign eAlgorithm ) { switch ( eAlgorithm ) {
public Task doublePremiseTask ( final Term newContent , final TruthValue newTruth , final BudgetValue newBudget , boolean temporalInduction , boolean overlapAllowed ) { if ( newContent = = null ) { return null ; } if ( ! newBudget . aboveThreshold ( ) ) { return null ; } if ( ( newContent ! = null ) & & ( ! ( newContent instanceof Interval ) ) & & ( ! ( newContent instanceof Variable ) ) ) { if ( newContent . subjectOrPredicateIsIndependentVar ( ) ) { return null ; } Task derived = null ; try { final Sentence newSentence = new Sentence ( newContent , getCurrentTask ( ) . sentence . punctuation , newTruth , getTheNewStamp ( ) ) ; newSentence . producedByTemporalInduction = temporalInduction ; final Task newTask = Task . make ( newSentence , newBudget , getCurrentTask ( ) , getCurrentBelief ( ) ) ; if ( newTask ! = null ) { boolean added = derivedTask ( newTask , false , false , null , null , overlapAllowed ) ; if ( added ) { derived = newTask ; } } } catch ( CompoundTerm . UnableToCloneException e ) { return null ; } if ( temporalInduction & & Parameters . IMMEDIATE_ETERNALIZATION ) { try { TruthValue truthEt = TruthFunctions . eternalize ( newTruth ) ; Stamp st = getTheNewStamp ( ) . clone ( ) ; st . setEternal ( ) ; final Sentence newSentence = new Sentence ( newContent , getCurrentTask ( ) . sentence . punctuation , truthEt , st ) ; newSentence . producedByTemporalInduction = temporalInduction ; final Task newTask = Task . make ( newSentence , newBudget , getCurrentTask ( ) , getCurrentBelief ( ) ) ; if ( newTask ! = null ) { boolean added = derivedTask ( newTask , false , false , null , null , overlapAllowed ) ; } } catch ( CompoundTerm . UnableToCloneException e ) { return null ; } } return derived ; } return null ; }
public synchronized final void connect ( InetAddress server , int port , String password ) throws MPDServerException { if ( ! isConnected ( ) ) { this . mpdConnection = new MPDConnectionMultiSocket ( server , port , 3 , password , 5000 ) ;
public static Term make ( final CompoundTerm image , final Term component , final int index ) { final Term [ ] argument = image . cloneTerms ( ) ; argument [ index ] = component ; return new Product ( argument ) ; }
public void addCertificate ( @Nonnull @Nonempty final String sAlias , @Nonnull final X509Certificate aCert , final boolean bOverwrite ) throws AS2Exception { ValueEnforcer . notEmpty ( sAlias , " Alias " ) ; ValueEnforcer . notNull ( aCert , " Cert " ) ; final String sRealAlias = getUnifiedAlias ( sAlias ) ; m_aRWLock . writeLock ( ) . lock ( ) ; try { if ( m_aKeyStore . containsAlias ( sRealAlias ) & & ! bOverwrite ) throw new CertificateExistsException ( sRealAlias ) ; m_aKeyStore . setCertificateEntry ( sRealAlias , aCert ) ; } catch ( final GeneralSecurityException ex ) { throw WrappedAS2Exception . wrap ( ex ) ; } finally { m_aRWLock . writeLock ( ) . unlock ( ) ; } onChange ( ) ; if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " Added certificate alias ' " + sRealAlias + " ' of certificate ' " + aCert . getSubjectDN ( ) + " ' " ) ;
public void updateMessage ( final IMessage aMsg , final File aFile ) throws OpenAS2Exception { final MessageParameters aParams = new MessageParameters ( aMsg ) ; final String sDefaults = getAttributeAsString ( PARAM_DEFAULTS ) ; if ( sDefaults ! = null ) aParams . setParameters ( sDefaults ) ; final String sFilename = aFile . getName ( ) ; final String sFormat = getAttributeAsString ( PARAM_FORMAT ) ; if ( sFormat ! = null ) { final String sDelimiters = getAttributeAsString ( PARAM_DELIMITERS , " .- " ) ; aParams . setParameters ( sFormat , sDelimiters , sFilename ) ; } try { final byte [ ] aData = SimpleFileIO . readFileBytes ( aFile ) ; String sContentType = getAttributeAsString ( PARAM_MIMETYPE ) ; if ( sContentType = = null ) { sContentType = CMimeType . APPLICATION_OCTET_STREAM . getAsString ( ) ; } else { try { sContentType = AbstractParameterParser . parse ( sContentType , aParams ) ; } catch ( final InvalidParameterException ex ) { s_aLogger . error ( " Bad content-type " + sContentType + aMsg . getLoggingText ( ) ) ; sContentType = CMimeType . APPLICATION_OCTET_STREAM . getAsString ( ) ; } } final ByteArrayDataSource aByteSource = new ByteArrayDataSource ( aData , sContentType , null ) ; final MimeBodyPart aBody = new MimeBodyPart ( ) ; aBody . setDataHandler ( new DataHandler ( aByteSource ) ) ; final String sEncodeType = aMsg . getPartnership ( ) . getAttribute ( Partnership . PA_CONTENT_TRANSFER_ENCODING ) ; if ( sEncodeType ! = null ) aBody . setHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING , sEncodeType ) ; else { aBody . setHeader ( CAS2Header . HEADER_CONTENT_TRANSFER_ENCODING , " 8bit " ) ; } aBody . setHeader ( CAS2Header . HEADER_CONTENT_TYPE , sContentType ) ; final String sSendFilename = getAttributeAsString ( " sendfilename " ) ; if ( " true " . equals ( sSendFilename ) ) { final String sMAFilename = aMsg . getAttribute ( CFileAttribute . MA_FILENAME ) ; aBody . setHeader ( CAS2Header . HEADER_CONTENT_DISPOSITION , " Attachment; filename= \" " + sMAFilename + " \" " ) ; aMsg . setContentDisposition ( " Attachment; filename= \" " + sMAFilename + " \" " ) ; } aMsg . setData ( aBody ) ; } catch ( final MessagingException ex ) { throw new WrappedOpenAS2Exception ( ex ) ; } getSession ( ) . getPartnershipFactory ( ) . updatePartnership ( aMsg , true ) ; aMsg . updateMessageID ( ) ; }
ByteBuffer getWbuf ( ) ; SocketAddress getSocketAddress ( ) ; boolean isActive ( ) ; boolean isAuthenticated ( ) ; long lastReadDelta ( ) ; void completedRead ( ) ; void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; MemcachedConnection getConnection ( ) ; void setConnection ( MemcachedConnection connection ) ; }
private void jLabel9MouseClicked ( java . awt . event . MouseEvent evt ) { nars . lab . microworld . Pong . main ( null ) ; this . dispose ( ) ; }
public void receivedStatus ( OperationStatus status ) { mostRecentStatus = status ; }
public static Term make ( ArrayList < Term > argList , int temporalOrder , final Memory memory ) { if ( argList . isEmpty ( ) ) { return null ; } if ( argList . size ( ) = = 1 ) { return argList . get ( 0 ) ; } if ( temporalOrder = = TemporalRules . ORDER_FORWARD ) { final String name = makeCompoundName ( Operator . SEQUENCE , argList ) ;
public synchronized void step ( TestbedSettings settings ) { super . step ( settings ) ; shape . set ( m_points , m_count ) ; addTextLine ( " Press g to generate a new random convex hull " ) ; getDebugDraw ( ) . drawPolygon ( shape . m_vertices , shape . m_count , color ) ; for ( int i = 0 ; i < m_count ; + + i ) { getDebugDraw ( ) . drawPoint ( m_points [ i ] , 2.0f , color2 ) ; getDebugDraw ( ) . drawString ( m_points [ i ] . add ( new Vec2 ( 0.05f , 0.05f ) ) , i + " " , Color3f . WHITE ) ; } assert ( shape . validate ( ) ) ; if ( m_auto ) { generate ( ) ;
protected void updateDueToValueChanging ( ) { hotspots [ 0 ] . x = ( width / 2 + ( parametricPos - 0.5f ) * trackLength ) ; }
public void output ( final Channel c , final Object o ) { if ( ( ! showErrors ) & & ( c = = Channel . ERR ) ) { return ; } final String line = c . toString ( ) + " :  " + o . toString ( ) + " \ n " ; nextOutput . append ( line ) ; SwingUtilities . invokeLater ( nextOutputRunnable ) ; }
public static void main ( String [ ] args ) { NAR n = new NAR ( ) ; new TextInput ( n , " <a --> b>. " ) ; new TextInput ( n , " <b --> c>. " ) ; new TextInput ( n , " <a --> c>? " ) ; n . run ( 6 ) ; Window w = new Window ( " GraphPanel " , new GraphPanel ( n ) ) { @Override protected void close ( ) { } } ; w . setSize ( 1200 , 900 ) ; w . setVisible ( true ) ; }
public void volumeChanged ( MPDVolumeChangedEvent event ) { } @Override public void onPrepared ( MediaPlayer mp ) { buffering = false ; isPlaying = true ; oldStatus = " " ; showNotification ( ) ; mediaPlayer . start ( ) ; } @Override public void onCompletion ( MediaPlayer mp ) { Message msg = delayedStopHandler . obtainMessage ( ) ; delayedStopHandler . sendMessageDelayed ( msg , IDLE_DELAY ) ; MPDApplication app = ( MPDApplication ) getApplication ( ) ; MPDStatus statusMpd = null ; try { statusMpd = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; } catch ( MPDServerException e ) { } if ( statusMpd ! = null ) { String state = statusMpd . getState ( ) ; if ( state ! = null ) { if ( state = = MPDStatus . MPD_STATE_PLAYING ) { resumeStreaming ( ) ; } else { oldStatus = state ; die ( ) ; } } } } @Override public void onBufferingUpdate ( MediaPlayer mp , int percent ) { } @Override public boolean onError ( MediaPlayer mp , int what , int extra ) { mediaPlayerError = what ; pauseStreaming ( ) ; return false ; } @Override public boolean onInfo ( MediaPlayer mp , int what , int extra ) { return false ; } @Override public void connectionFailed ( String message ) { Toast . makeText ( this , " Connection Failed ! " , Toast . LENGTH_SHORT ) . show ( ) ; } @Override public void connectionSucceeded ( String message ) { } }
private static void temporalInduce ( final NAL nal , final Task task , final Sentence taskSentence , final Memory memory ) { for ( int i = 0 ; i < Parameters . TEMPORAL_INDUCTION_SAMPLES ; i + + ) {
public Set < Characteristics > characteristics ( ) { return wrapped . characteristics ( ) ; }
public void missingConfig ( ) { Map < String , Object > paramMap = new HashMap < > ( ) ; paramMap . put ( SchemaFactory . TYPE_CONFIG_NAME , " flat " ) ; config = ConfigFactory . parseMap ( paramMap ) ; FlatSchema flatSchema = new FlatSchema ( ) ; assertValidationFailures ( flatSchema , config ) ; }
public void draw ( Grid2DSpace s , boolean edge , float wx , float wy , float x , float y , float z ) { int ambientLight = 100 ; int r = 0 , g = 0 , b = 0 , a = 1 ; a = ambientLight ; if ( material = = Material . Empty ) { } else if ( material = = Material . Machine ) { g = b = 127 ; r = 200 ; } else if ( material = = Material . StoneWall | | ( material = = Material . Door & & is_solid ) ) { r = g = b = 255 ; } else if ( material = = Material . DirtFloor | | material = = Material . GrassFloor | | ( material = = Material . Door & & ! is_solid ) ) { if ( height = = Float . MAX_VALUE ) { r = g = b = 255 ; } else { r = g = b = ( int ) ( 128 + height ) ; } } if ( material = = Material . Door & & is_solid ) { b = 0 ; g = ( int ) ( g / 2.0f ) ; } if ( material = = Material . Door ) { r = 200 ; } if ( ( charge > 0 ) | | ( chargeFront ) ) { { float freq = 4 ; int chargeBright = ( int ) ( ( Math . cos ( s . getRealtime ( ) * freq ) + 1 ) * 25 ) ; if ( charge > 0 ) { r + = chargeBright ; g + = chargeBright / 2 ; } else { g + = chargeBright ; r + = chargeBright / 2 ; } if ( chargeFront ) { freq = 7 ; b + = 25 ; } a + = 150 ; } } if ( edge ) { light = 255 ; } a + = light * 255 ; if ( material = = Material . StoneWall ) { a = r = g = b = ( int ) ( 200 + light * 255 ) ; } if ( material = = Material . Water ) { b = 64 ; g = 32 ; } r = Math . min ( 255 , r ) ; g = Math . min ( 255 , g ) ; b = Math . min ( 255 , b ) ; a = Math . min ( 255 , a ) ; state . cr = lerp ( state . cr , r , 0.19f ) ; state . cg = lerp ( state . cg , g , 0.19f ) ; state . cb = lerp ( state . cb , b , 0.19f ) ; state . ca = lerp ( state . ca , a , 0.19f ) ; if ( material = = Material . GrassFloor ) { state . cr + = 8 ; state . cg + = 16 ; } s . fill ( state . cr , state . cg , state . cb , state . ca ) ; boolean full3d = false ; double v = full3d ? 0.5f : 0.0f ; if ( logic ! = Logic . NotALogicBlock ) { s . fill ( state . cr / 2.0f ) ; s . rect ( 0 , 0 , 1.0f , 1.0f ) ; } else if ( material ! = Material . Water & & material ! = Material . StoneWall ) { s . rect ( 0 , 0 , 1.0f , 1.0f ) ; } else if ( material = = Material . Water ) { float verschx = ( float ) Math . max ( - 0.5f , Math . min ( v , 0.05 * ( x - wx ) ) ) ; float verschy = ( float ) Math . max ( - 0.5f , Math . min ( v , 0.05 * ( y - wy ) ) ) ; float add = 0.0f ; s . rect ( add - verschx , add - verschy , 1.05f , 1.05f ) ; } else if ( material = = Material . StoneWall | | material = = Material . Water ) { float verschx = ( float ) Math . max ( - 0.3f , Math . min ( v , 0.05 * ( x - wx ) ) ) ; float verschy = ( float ) Math . max ( - 0.3f , Math . min ( v , 0.05 * ( y - wy ) ) ) ; float add = - 0.2f ; s . rect ( add + verschx , add + verschy , 1.1f , 1.1f ) ; s . rect ( add + verschx , add + verschy , 1.1f , 1.1f ) ; } s . textSize ( 1 ) ; if ( logic = = Logic . SWITCH | | logic = = Logic . OFFSWITCH ) { s . fill ( state . cr + 30 , state . cg + 30 , 0 , state . ca + 30 ) ; s . ellipse ( 0.5f , 0.5f , 1.0f , 1.0f ) ; } else if ( logic ! = Logic . BRIDGE & & logic ! = Logic . NotALogicBlock & & logic ! = Logic . WIRE ) { s . fill ( state . cr + 30 , state . cg + 30 , 0 , state . ca + 30 ) ; s . triangle ( 0.25f , 1.0f , 0.5f , 0.5f , 0.75f , 1.0f ) ; s . triangle ( 0.25f , 0.0f , 0.5f , 0.5f , 0.75f , 0.0f ) ; s . rect ( 0 , 0.3f , 1 , 0.4f ) ; } else if ( logic = = Logic . WIRE | | logic = = Logic . BRIDGE ) { s . fill ( state . cr , state . cg , state . cb , state . ca ) ; if ( logic = = Logic . BRIDGE ) { s . fill ( state . cr + 30 , state . cg + 30 , 0 , state . ca + 30 ) ; } s . rect ( 0 , 0.3f , 1 , 0.4f ) ; s . rect ( 0.3f , 0 , 0.4f , 1 ) ; } s . fill ( 255 , 255 , 255 , 128 ) ; if ( logic = = Logic . AND ) { drawtext ( s , " ^ " ) ; } if ( logic = = Logic . OR ) { drawtext ( s , " v " ) ; } if ( logic = = Logic . XOR ) { drawtext ( s , " x " ) ; } if ( logic = = Logic . NOT ) { drawtext ( s , " ~ " ) ; } if ( logic = = Logic . BRIDGE ) { drawtext ( s , " H " ) ; } if ( logic = = Logic . SWITCH ) { drawtext ( s , " 1 " ) ; } if ( logic = = Logic . OFFSWITCH ) { drawtext ( s , " 0 " ) ; } if ( machine ! = null ) { switch ( machine ) { case Light : if ( charge > 0 ) drawtext ( s , " + " ) ; else drawtext ( s , " - " ) ; break ; case Turret : if ( charge > 0 ) s . particles . emitParticles ( 0.5f , 0.3f , s . getTime ( ) / 40 f , 0.07f , state . x + 0.5f , state . y + 0.5f , 1 ) ; break ; } } if ( ! " " . equals ( name ) ) {
public final int getAttributeAsInt ( @Nullable final String sName , final int nDefault ) { final String sValue = getAttributeObject ( sName ) ; return AbstractReadOnlyAttributeContainer . getAsInt ( sName , sValue , nDefault ) ; }
private static final void swapWords ( int startA , int endA , int startB , int endB , char [ ] array ) { int lengthA = endA - startA + 1 ; int lengthB = endB - startB + 1 ; int length = lengthA ; if ( lengthA > lengthB ) length = lengthB ; int indexA = 0 ; int indexB = 0 ; char c = 0 ; for ( int i = 0 ; i < length ; i + + ) { indexA = startA + i ; indexB = startB + i ; c = array [ indexB ] ; array [ indexB ] = array [ indexA ] ; array [ indexA ] = c ; } if ( lengthB > lengthA ) { length = lengthB - lengthA ;
public synchronized void reshape ( int x , int y , int w , int h ) { super . reshape ( x , y , w , h ) ; if ( initdone ) { calcshape ( w , h ) ;
Builder changeDetector ( ChangeDetector changeDetector ) { this . changeDetector = changeDetector ; return this ; }
@Test public void testGraphPlan1Repeat ( ) throws Exception { String input = " " ; input + = " <(&/,<a --> b>,+1,(^pick,Y),+3,<c --> d>) =/> <goal --> reached>>. \ n " ; input + = " <(&/,(^pick,X),+2) =/> <a --> b>>. \ n " ; input + = " <(&/,(^pick,Z),+1) =/> <c --> d>>. \ n " ; input + = " <goal --> reached>! \ n " ; String exp = " <(&/,(^pick,X),+3,(^pick,Y),+3,(^pick,Z)) =/> <goal --> reached>>! " ; testGraphPlan ( input , exp , true , true , 44 ) ; testGraphPlan ( input , exp , false , false , 1000 ) ; }
public V put ( K key , V value ) { V prev = value ; SkipList . Node < K > node = list . addValue ( key ) ; if ( node instanceof SkipListMapNode ) { SkipListMapNode < K , V > treeMapNode = ( SkipListMapNode < K , V > ) node ; if ( treeMapNode . value ! = null ) prev = treeMapNode . value ; treeMapNode . value = value ; } return prev ; }
static FileNotFoundAction copyData ( File file ) { return ( f , c ) - > { Files . copy ( new FileInputStream ( file ) , f ) ;
public void cycleParallel ( ) { final List < Runnable > run = new ArrayList ( ) ; memory . processNewTasks ( loop . newTasksPriority ( ) , run ) ; memory . processNovelTasks ( loop . novelTasksPriority ( ) , run ) ; processConcepts ( loop . conceptsPriority ( ) , run ) ; memory . run ( run , Parameters . THREADS ) ; run . clear ( ) ;
public E peekNext ( ) { if ( size ( ) = = 0 ) return null ; if ( levelEmpty ( currentLevel ) | | ( currentCounter = = 0 ) ) { nextNonEmptyLevel ( ) ; } return level [ currentLevel ] . peekFirst ( ) ; }
public boolean expandItemActionView ( MenuItemImpl item ) { return mParentMenu . expandItemActionView ( item ) ; }
public void onCreateContextMenu ( ContextMenu menu , View v , ContextMenu . ContextMenuInfo menuInfo ) { super . onCreateContextMenu ( menu , v , menuInfo ) ; android . view . MenuItem editItem = menu . add ( ContextMenu . NONE , EDIT , 0 , R . string . editStream ) ; editItem . setOnMenuItemClickListener ( this ) ; android . view . MenuItem addAndReplaceItem = menu . add ( ContextMenu . NONE , DELETE , 0 , R . string . deleteStream ) ; addAndReplaceItem . setOnMenuItemClickListener ( this ) ; }
private static void inferToAsym ( final Sentence asym , final Sentence sym , final DerivationContext nal ) { final Statement statement = ( Statement ) asym . term ; final Term sub = statement . getPredicate ( ) ; final Term pre = statement . getSubject ( ) ; final Statement content = Statement . make ( statement , sub , pre , statement . getTemporalOrder ( ) ) ; if ( content = = null ) return ; final TruthValue truth = TruthFunctions . reduceConjunction ( sym . truth , asym . truth , nal . narParameters ) ; final BudgetValue budget = BudgetFunctions . forward ( truth , nal ) ; nal . doublePremiseTask ( content , truth , budget , false , false ) ; }
public abstract AbstractViewHolder findInnerViews ( View targetView ) ; @Override public abstract boolean isEnabled ( int position , List < ? extends Item > items , Object item ) ; @Override public abstract int getLayoutId ( ) ; protected void loadPlaceholder ( CoverAsyncHelper coverHelper ) { coverHelper . obtainMessage ( CoverAsyncHelper . EVENT_COVERNOTFOUND ) . sendToTarget ( ) ; } protected void loadArtwork ( CoverAsyncHelper coverHelper , AlbumInfo albumInfo ) { coverHelper . downloadCover ( albumInfo ) ; } }
public void switchMode ( DisplayMode newMode ) { currentDisplayMode = newMode ; switch ( currentDisplayMode ) { case MODE_QUEUE : case MODE_NOWPLAYING : if ( isDualPaneMode ) { nowPlayingDualPane . setVisibility ( View . VISIBLE ) ; } else { nowPlayingPager . setVisibility ( View . VISIBLE ) ; if ( currentDisplayMode = = DisplayMode . MODE_NOWPLAYING ) { nowPlayingPager . setCurrentItem ( 0 , true ) ; } else { nowPlayingPager . setCurrentItem ( 1 , true ) ; } } libraryRootFrame . setVisibility ( View . GONE ) ; outputsRootFrame . setVisibility ( View . GONE ) ; break ; case MODE_LIBRARY : if ( isDualPaneMode ) { nowPlayingDualPane . setVisibility ( View . GONE ) ; } else { nowPlayingPager . setVisibility ( View . GONE ) ; } libraryRootFrame . setVisibility ( View . VISIBLE ) ; outputsRootFrame . setVisibility ( View . GONE ) ; break ; case MODE_OUTPUTS : if ( isDualPaneMode ) { nowPlayingDualPane . setVisibility ( View . GONE ) ; } else { nowPlayingPager . setVisibility ( View . GONE ) ; } libraryRootFrame . setVisibility ( View . GONE ) ; outputsRootFrame . setVisibility ( View . VISIBLE ) ; outputsFragment . refreshOutputs ( ) ; break ; } refreshActionBarTitle ( ) ; }
void updatePlayingInfo ( int state ) { Log . d ( TAG , " update playing info: state= " + state + "  (previous state:  " + mPreviousState + " ), music= " + mCurrentMusic + " ) " ) ; if ( mRemoteControlClient = = null ) { Intent intent = new Intent ( Intent . ACTION_MEDIA_BUTTON ) ; intent . setComponent ( mMediaButtonReceiverComponent ) ; mRemoteControlClient = new RemoteControlClient ( PendingIntent . getBroadcast ( getApplicationContext ( ) , 0 , intent , 0 ) ) ; mRemoteControlClient . setTransportControlFlags ( RemoteControlClient . FLAG_KEY_MEDIA_PLAY | RemoteControlClient . FLAG_KEY_MEDIA_PAUSE | RemoteControlClient . FLAG_KEY_MEDIA_PREVIOUS | RemoteControlClient . FLAG_KEY_MEDIA_NEXT | RemoteControlClient . FLAG_KEY_MEDIA_STOP ) ; mAudioManager . registerRemoteControlClient ( mRemoteControlClient ) ; } if ( mCurrentMusic = = null ) { try { final MPDStatus status = app . oMPDAsyncHelper . oMPD . getStatus ( ) ; final int songPos = status . getSongPos ( ) ; if ( songPos > = 0 ) { mCurrentMusic = app . oMPDAsyncHelper . oMPD . getPlaylist ( ) . getByIndex ( songPos ) ; } } catch ( MPDServerException e ) { Log . w ( " NotificationService " , " MPDServerException playing next song:  " + e . getMessage ( ) ) ; } } if ( state = = RemoteControlClient . PLAYSTATE_STOPPED ) { if ( mNotificationManager ! = null ) {
public void configure ( Config config ) { this . config = config ; if ( ! config . hasPath ( JDBC_CONFIG_URL ) ) { throw new RuntimeException ( " JDBC output requires ' " + JDBC_CONFIG_URL + " ' property " ) ; } if ( ! config . hasPath ( JDBC_CONFIG_TABLENAME ) ) { throw new RuntimeException ( " JDBC output requires ' " + JDBC_CONFIG_TABLENAME + " ' property " ) ; } if ( ! config . hasPath ( JDBC_CONFIG_USERNAME ) ) { throw new RuntimeException ( " JDBC output requires ' " + JDBC_CONFIG_USERNAME + " ' property " ) ; } if ( ! config . hasPath ( JDBC_CONFIG_PASSWORD ) ) { throw new RuntimeException ( " JDBC output requires ' " + JDBC_CONFIG_PASSWORD + " ' property " ) ;
public static Term make ( final TreeSet < Term > set ) { if ( set . isEmpty ( ) ) { return null ; } Term [ ] argument = set . toArray ( new Term [ set . size ( ) ] ) ; return make ( argument ) ; }
OperationException getException ( ) ; void handleResponse ( HttpResponse response ) ; }
< T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
public boolean draw ( PGraphics g ) { this . g = g ; this . g2 = ( ( PGraphicsJava2D ) g ) . g2 ; int originalColorMode = g . colorMode ; g . colorMode ( HSB ) ; lastCameraUpdate = camera . lastUpdate ; float y = 0 ; float yMargin = camera . yScale * 0.1f ; cycleStart = Integer . MAX_VALUE ; cycleEnd = 0 ; for ( Chart c : charts ) { int cstart = c . getStart ( ) ; int cend = c . getEnd ( ) ; if ( cstart < cycleStart ) cycleStart = cstart ; if ( cend > cycleEnd ) cycleEnd = cend ; } for ( Chart c : charts ) { float h = c . height * camera . yScale ; try { c . draw ( this , y , camera . timeScale , camera . yScale ) ; } catch ( Exception e ) { System . err . println ( " Timeline draw:  " + e ) ; } y + = ( h + yMargin ) ; } g . colorMode ( originalColorMode ) ; return true ; }
boolean writesInline ( UnmodifiableConfig config ) { return writeTableInlinePredicate . test ( config ) ; }
public void processNovelTask ( ) { final Task task = novelTasks . takeNext ( ) ; if ( task ! = null ) { new ImmediateProcess ( this , task ) . run ( ) ;
public static ScrobbleResult updateNowPlaying ( String artistName , String trackName , Session session ) { ScrobbleData scrobbleData = new ScrobbleData ( ) ; scrobbleData . setArtist ( artistName ) ; scrobbleData . setTrack ( trackName ) ; return updateNowPlaying ( scrobbleData , session ) ; }
public void noNulls ( ) { Config config = TomlFormat . newConfig ( ) ; config . set ( " null " , null ) ; Assertions . assertThrows ( WritingException . class , ( ) - > TomlFormat . instance ( ) . createWriter ( ) . writeToString ( config ) ) ; config . set ( " null " , NullObject . NULL_OBJECT ) ; Assertions . assertThrows ( WritingException . class , ( ) - > TomlFormat . instance ( ) . createWriter ( ) . writeToString ( config ) ) ;
public Parcelable onSaveInstanceState ( ) { return null ; }
public View onLayoutInflation ( final Context context , final View targetView , final List < ? extends Item > items ) { targetView . findViewById ( R . id . playlist_cover ) . setVisibility ( mEnableCache ? View . VISIBLE : View . GONE ) ; return targetView ; }
@Override public void run ( ) { synchronized ( pendingDisplay ) { limitBuffer ( ) ;
public String cacheInfo ( ) { return " AlbumCache:  " + albumsByArtist . size ( ) + "  artists,  " + albumsByAlbumArtist . size ( ) + "  albumartists,  " +
public void testTwoArrivingOneExistingWhereArrivingEarlierThanExisting ( ) { p = new BitemporalHistoryPlanner ( ) ; assertNoValidationFailures ( p , config ) ; p . configure ( config ) ; existing . add ( new RowWithSchema ( existingSchema , " a " , " hello " , 100L , 100L , 253402214400000L , 1L , 253402214400000L , CURRENT_FLAG_DEFAULT_YES ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world " , 50L ) ) ; arriving . add ( new RowWithSchema ( arrivingSchema , " a " , " world! " , 75L ) ) ; Row key = new RowWithSchema ( keySchema , " a " ) ; List < Row > planned = p . planMutationsForKey ( key , arriving , existing ) ; assertEquals ( planned . size ( ) , 2 ) ; assertEquals ( PlannerUtils . getMutationType ( planned . get ( 0 ) ) , MutationType . INSERT ) ; Long systemStart0 = ( Long ) RowUtils . get ( planned . get ( 0 ) , " systemstart " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " value " ) , " world " ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventstart " ) , 50L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " eventend " ) , 74L ) ; assertTrue ( systemStart0 > = preplanSystemTime ) ; assertTrue ( systemStart0 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " systemend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 0 ) , " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " value " ) , " world! " ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " eventstart " ) , 75L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " eventend " ) , 99L ) ; assertTrue ( systemStart0 > = preplanSystemTime ) ; assertTrue ( systemStart0 < preplanSystemTime + 5000 ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " systemend " ) , 253402214400000L ) ; assertEquals ( RowUtils . get ( planned . get ( 1 ) , " currentflag " ) , CURRENT_FLAG_DEFAULT_NO ) ; }
static CommentedFileConfigBuilder builder ( Path file ) { ConfigFormat format = FormatDetector . detect ( file ) ; if ( format = = null ) { throw new NoFormatFoundException ( " No suitable format for  " + file . getFileName ( ) ) ; } else if ( ! format . supportsComments ( ) ) { throw new NoFormatFoundException ( " The available format doesn't support comments for  " + file . getFileName ( ) ) ; } return builder ( file , format ) ; }
public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmExDif p , A arg ) { return visitDefault ( p , arg ) ; } public R visit ( com . googlecode . opennars . parser . loan . Loan . Absyn . TrmInDif p , A arg ) { return visitDefault ( p , arg ) ; }
void conditionalDedInd ( Implication premise1 , short index , Term premise2 , int side ) { Task task = this . memory . currentTask ; Sentence sentence = task . getSentence ( ) ; Judgement belief = this . memory . currentBelief ; Conjunction oldCondition = ( Conjunction ) premise1 . getSubject ( ) ; CompoundTerm . TemporalOrder order1 = premise1 . getTemporalOrder ( ) ; CompoundTerm . TemporalOrder order2 = premise2 . getTemporalOrder ( ) ; boolean deduction = ( side ! = 0 ) ; if ( ! ( order1 = = order2 ) ) if ( ! ( deduction & & ( ( side = = - 1 ) | | ( index = = 0 ) ) ) ) return ; Term newComponent = null ; if ( side = = 0 ) newComponent = ( ( Statement ) premise2 ) . getPredicate ( ) ; else if ( side = = 1 ) newComponent = ( ( Statement ) premise2 ) . getSubject ( ) ; Term newCondition = CompoundTerm . replaceComponent ( oldCondition , index , newComponent , this . memory ) ; Term content = Statement . make ( premise1 , newCondition , premise1 . getPredicate ( ) , order1 , this . memory ) ; if ( content = = null ) return ; TruthValue value1 = sentence . getTruth ( ) ; TruthValue value2 = belief . getTruth ( ) ; TruthValue truth = null ; BudgetValue budget ; boolean conditionalTask = ( Variable . findSubstitute ( Variable . VarType . INDEPENDENT , premise2 , belief . getContent ( ) ) ! = null ) ; if ( sentence instanceof Question ) { budget = this . budgetfunctions . backwardWeak ( value2 ) ; } else { if ( sentence instanceof Goal ) { if ( conditionalTask ) truth = TruthFunctions . desireWeak ( value1 , value2 ) ; else if ( deduction ) truth = TruthFunctions . desireInd ( value1 , value2 ) ; else truth = TruthFunctions . desireDed ( value1 , value2 ) ; budget = this . budgetfunctions . forward ( truth ) ; } else { if ( deduction ) truth = TruthFunctions . deduction ( value1 , value2 ) ; else if ( conditionalTask ) truth = TruthFunctions . induction ( value2 , value1 ) ; else truth = TruthFunctions . induction ( value1 , value2 ) ; } budget = this . budgetfunctions . forward ( truth ) ; } this . memory . doublePremiseTask ( budget , content , truth ) ; }
public void playlistChanged ( MPDStatus mpdStatus , int oldPlaylistVersion ) { new updateTrackInfoAsync ( ) . execute ( ( MPDStatus [ ] ) null ) ; }
public Collection < Music > find ( final String type , final String locatorString ) throws IOException , MPDException { return genericSearch ( MPDCommand . MPD_CMD_FIND , type , locatorString ) ; }
public abstract void enqueueStringMessage ( String queue , String key , String message ) ; public void enqueueStringMessage ( String queue , String message ) { enqueueStringMessage ( queue , null , message ) ; } public abstract Schema getSchema ( ) throws Exception ; public static QueueSource queueSourceFor ( Properties props ) throws Exception { QueueSource qs = null ; String queueSourceName = props . getProperty ( " source " ) ; if ( queueSourceName . equals ( " kafka " ) ) { qs = new KafkaQueueSource ( props ) ; } else { Class < ? > clazz = Class . forName ( queueSourceName ) ; Constructor < ? > constructor = clazz . getConstructor ( ) ; qs = ( QueueSource ) constructor . newInstance ( props ) ; } return qs ; } }
public AbstractBag < Task , Sentence > newNovelTaskBag ( Param p ) { return new ContinuousBag2 < > ( getNovelTaskBagSize ( ) , curve , randomRemoval ) ; }
void reconnecting ( ) ; void connected ( ) ; int getReconnectCount ( ) ; void registerChannel ( SocketChannel ch , SelectionKey selectionKey ) ; void setChannel ( SocketChannel to ) ; SocketChannel getChannel ( ) ; void setSk ( SelectionKey to ) ; SelectionKey getSk ( ) ; int getBytesRemainingToWrite ( ) ; int writeSome ( ) throws IOException ; void fixupOps ( ) ; void authComplete ( ) ; void setupForAuth ( ) ; void setContinuousTimeout ( boolean timedOut ) ; int getContinuousTimeout ( ) ; }
public DataHistory getHistory ( ) { if ( m_aHistory = = null ) { m_aHistory = new DataHistory ( ) ; } return m_aHistory ; }
static CommentedFileConfig of ( File file ) { return of ( file . toPath ( ) ) ; }
protected abstract AS2Session createAS2Session ( @Nonnull ICommonsMap < String , String > aInitParams ) throws AS2Exception , ServletException ; @Override @OverridingMethodsMustInvokeSuper public void onServletInit ( @Nonnull final ICommonsMap < String , String > aInitParams ) throws ServletException { try { m_aSession = createAS2Session ( aInitParams ) ; } catch ( final AS2Exception ex ) { throw new ServletException ( " Failed to init AS2 configuration " , ex ) ; } } @Nonnull protected final AS2Session getSession ( ) { if ( m_aSession = = null ) throw new IllegalStateException ( " This servlet was not initialized properly! No AS2 session is present. " ) ; return m_aSession ; } @Nullable public final IHTTPIncomingDumper getHttpIncomingDumper ( ) { return m_aHttpIncomingDumper ; } @Nullable public final IHTTPIncomingDumper getEffectiveHttpIncomingDumper ( ) { IHTTPIncomingDumper ret = m_aHttpIncomingDumper ; if ( ret = = null ) { ret = HTTPHelper . getHTTPIncomingDumper ( ) ; } return ret ; } public final void setHttpIncomingDumper ( @Nullable final IHTTPIncomingDumper aHttpIncomingDumper ) { m_aHttpIncomingDumper = aHttpIncomingDumper ; } protected abstract boolean isQuoteHeaderValues ( ) ; protected abstract void handleIncomingMessage ( @Nonnull final String sClientInfo , @Nonnull final DataSource aMsgData , @Nonnull final AS2Message aMsg , @Nonnull final IAS2HttpResponseHandler aResponseHandler ) throws ServletException ; public final void onRequest ( @Nonnull final HttpServletRequest aHttpRequest , @Nonnull final HttpServletResponse aHttpResponse , @Nonnull final EHttpVersion eHttpVersion , @Nonnull final EHttpMethod eHttpMethod , @Nonnull final IRequestWebScope aRequestScope ) throws ServletException , IOException { final String sClientInfo = aHttpRequest . getRemoteAddr ( ) + " : " + aHttpRequest . getRemotePort ( ) ; final AS2Message aMsg = new AS2Message ( ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_SOURCE_IP , aHttpRequest . getRemoteAddr ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_SOURCE_PORT , aHttpRequest . getRemotePort ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_DESTINATION_IP , aHttpRequest . getLocalAddr ( ) ) ; aMsg . attrs ( ) . putIn ( CNetAttribute . MA_DESTINATION_PORT , aHttpRequest . getLocalPort ( ) ) ; aMsg . attrs ( ) . putIn ( HTTPHelper . MA_HTTP_REQ_TYPE , aHttpRequest . getMethod ( ) ) ; aMsg . attrs ( ) . putIn ( HTTPHelper . MA_HTTP_REQ_URL , ServletHelper . getRequestRequestURI ( aHttpRequest ) ) ; aMsg . headers ( ) . setAllHeaders ( aRequestScope . headers ( ) ) ; final boolean bQuoteHeaderValues = isQuoteHeaderValues ( ) ; final AS2OutputStreamCreatorHttpServletResponse aResponseHandler = new AS2OutputStreamCreatorHttpServletResponse ( aHttpResponse , bQuoteHeaderValues ) ; final long nContentLength = aHttpRequest . getContentLengthLong ( ) ; if ( nContentLength > Integer . MAX_VALUE ) throw new IllegalStateException ( " Currently only payload with up to 2GB can be handled! " ) ; try ( final ServletInputStream aRequestIS = aHttpRequest . getInputStream ( ) ) { final StopWatch aSW = StopWatch . createdStarted ( ) ; DataSource aMsgDataSource = null ; try { final IHTTPIncomingDumper aIncomingDumper = getEffectiveHttpIncomingDumper ( ) ; aMsgDataSource = HTTPHelper . readAndDecodeHttpRequest ( new AS2InputStreamProviderServletRequest ( aRequestIS ) , aResponseHandler , aMsg , aIncomingDumper ) ; } catch ( final Exception ex ) { AS2Exception . log ( ex . getClass ( ) , true , " Failed to read Servlet Request:  " + ex . getMessage ( ) , null , null , ex . getCause ( ) ) ; } aSW . stop ( ) ; if ( aMsgDataSource = = null ) { LOGGER . error ( " Not having a data source to operate on " ) ; } else { if ( aMsgDataSource instanceof ByteArrayDataSource ) { if ( LOGGER . isInfoEnabled ( ) ) LOGGER . info ( " received  " + AS2IOHelper . getTransferRate ( ( ( ByteArrayDataSource ) aMsgDataSource ) . directGetBytes ( ) . length , aSW ) + "  from  " + sClientInfo + aMsg . getLoggingText ( ) ) ; } else { LOGGER . info ( " received message from  " + sClientInfo + aMsg . getLoggingText ( ) + "  in  " + aSW . getMillis ( ) + "  ms " ) ; } handleIncomingMessage ( sClientInfo , aMsgDataSource , aMsg , aResponseHandler ) ; } } } }
private String parseString ( ) { StringBuilder builder = new StringBuilder ( ) ; boolean escape = false ; for ( char c = input . readChar ( ) ; c ! = '"' | | escape ; c = input . readChar ( ) ) { if ( escape ) { builder . append ( escape ( c ) ) ; escape = false ; } else if ( c = = '\\' ) { escape = true ; } else { builder . append ( c ) ; } } return builder . toString ( ) ; }
private void writePrologFormulas ( ArrayList forms , PrintWriter pr ) throws IOException { TreeSet ts = new TreeSet ( ) ; ts . addAll ( forms ) ; if ( forms ! = null ) { int i = 0 ;
public abstract ServiceInfo [ ] getServiceInfos ( String type , String name ) ; public abstract ServiceInfo [ ] getServiceInfos ( String type , String name , long timeout ) ; public abstract ServiceInfo [ ] getServiceInfos ( String type , String name , boolean persistent ) ; public abstract ServiceInfo [ ] getServiceInfos ( String type , String name , boolean persistent , long timeout ) ; public abstract void requestServiceInfo ( String type , String name ) ; public abstract void requestServiceInfo ( String type , String name , boolean persistent ) ; public abstract void requestServiceInfo ( String type , String name , long timeout ) ; public abstract void requestServiceInfo ( String type , String name , boolean persistent , long timeout ) ; public abstract void addServiceTypeListener ( ServiceTypeListener listener ) throws IOException ; public abstract void removeServiceTypeListener ( ServiceTypeListener listener ) ; public abstract void addServiceListener ( String type , ServiceListener listener ) ; public abstract void removeServiceListener ( String type , ServiceListener listener ) ; public abstract void registerService ( ServiceInfo info ) throws IOException ; public abstract void unregisterService ( ServiceInfo info ) ; public abstract void unregisterAllServices ( ) ; public abstract void registerServiceType ( String type ) ; public abstract ServiceInfo [ ] list ( String type ) ; public abstract ServiceInfo [ ] list ( String type , long timeout ) ; public abstract Map < String , ServiceInfo [ ] > listBySubtype ( String type ) ; public abstract Map < String , ServiceInfo [ ] > listBySubtype ( String type , long timeout ) ; public abstract void addNetworkTopologyListener ( NetworkTopologyListener listener ) ; public abstract void removeNetworkTopologyListener ( NetworkTopologyListener listener ) ; public abstract NetworkTopologyListener [ ] networkListeners ( ) ; }
private Stm wrapTerm ( Object o ) { if ( o instanceof com . googlecode . opennars . parser . loan . Loan . Absyn . Term ) { return new StmTrm ( ( com . googlecode . opennars . parser . loan . Loan . Absyn . Term ) o ) ;
public Idea get ( Concept c ) { CharSequence k = Idea . getKey ( c ) ; return get ( k ) ; }
public AS2ClientRequest setData ( @Nonnull @WillClose final InputStream aIS , @Nullable final Charset aCharset ) { ValueEnforcer . notNull ( aIS , " InputStream " ) ; final byte [ ] aBytes = StreamHelper . getAllBytes ( aIS ) ; if ( aCharset = = null ) { return setData ( aBytes ) ; } return setData ( new String ( aBytes , aCharset ) , aCharset ) ; }
public static com . cloudera . labs . envelope . translate . ProtobufMultipleMessage . MultipleExample parseFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ;
public static void main ( String [ ] args ) throws IOException , InterruptedException { File configFile = new File ( " autoreload.json " ) ; FileConfig config = FileConfig . builder ( configFile ) . autoreload ( ) . build ( ) ; System . out . println ( " Config:  " + config . valueMap ( ) ) ; Thread . sleep ( 250 ) ; try ( FileWriter writer = new FileWriter ( configFile ) ) { writer . write ( " {  \" value \" : 123 } " ) ; } Thread . sleep ( 100 ) ; System . out . println ( " Config:  " + config . valueMap ( ) ) ; try ( FileWriter writer = new FileWriter ( configFile ) ) { writer . write ( " {  \" value \" : -1,  \" it_works \" :  \" yes! \"  } " ) ; } System . out . println ( " Config:  " + config . valueMap ( ) ) ; Thread . sleep ( 500 ) ; System . out . println ( " Config:  " + config . valueMap ( ) ) ; config . close ( ) ; }
final public static Term make ( final Term [ ] argList , final int temporalOrder , final Memory memory ) { if ( argList . length = = 0 ) { return null ; } if ( argList . length = = 1 ) { return argList [ 0 ] ; } if ( temporalOrder = = TemporalRules . ORDER_FORWARD ) { final CharSequence name = makeCompoundName ( NativeOperator . SEQUENCE , argList ) ;
void setHeader ( String sKey , String sValue ) ; String getHeader ( String sKey ) ; String getHeader ( String sKey , String sDelimiter ) ; void setHeaders ( InternetHeaders aHeaders ) ; InternetHeaders getHeaders ( ) ; void setHistory ( DataHistory aHistory ) ; DataHistory getHistory ( ) ; void setMDN ( IMessageMDN aMDN ) ; IMessageMDN getMDN ( ) ; void setMessageID ( String sMessageID ) ; String getMessageID ( ) ; void setPartnership ( Partnership aPartnership ) ; Partnership getPartnership ( ) ; String getProtocol ( ) ; boolean isRequestingMDN ( ) ; boolean isRequestingAsynchMDN ( ) ; void setSubject ( String sSubject ) ; String getSubject ( ) ; void addHeader ( String sKey , String sValue ) ; String generateMessageID ( ) ; void updateMessageID ( ) ; String getLoggingText ( ) ; }
public boolean hasOpenAlternatives ( ) ; public S getSolution ( ) throws NoSolutionException ; public Q getQuery ( ) ; public java . util . List < ? extends T > getBindingVars ( ) throws nars . prolog . NoSolutionException ; }
public void run ( ) { w ( TAG , " Disconnecting ( " + DISCONNECT_TIMER + "  ms timeout) " ) ; oMPDAsyncHelper . stopMonitor ( ) ; oMPDAsyncHelper . disconnect ( ) ; }
public Operation newOp ( final MemcachedNode n , final CountDownLatch latch ) { return opFact . flush ( delay , new OperationCallback ( ) { public void receivedStatus ( OperationStatus s ) {
protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int height = MeasureSpec . getSize ( heightMeasureSpec ) ; int width = MeasureSpec . getSize ( widthMeasureSpec ) ; int heightMode = MeasureSpec . getMode ( heightMeasureSpec ) ; final View child = getChildAt ( 0 ) ; if ( child = = null ) { setMeasuredDimension ( 0 , width ) ; return ; } if ( child . isLayoutRequested ( ) ) { measureChild ( child , widthMeasureSpec , MeasureSpec . makeMeasureSpec ( 0 , MeasureSpec . UNSPECIFIED ) ) ; } if ( heightMode = = MeasureSpec . UNSPECIFIED ) { ViewGroup . LayoutParams lp = getLayoutParams ( ) ; if ( lp . height > 0 ) { height = lp . height ; } else { height = child . getMeasuredHeight ( ) ; } } setMeasuredDimension ( width , height ) ; }
< T > BulkFuture < Map < String , T > > asyncGetBulk ( Collection < String > keys , Transcoder < T > tc ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Iterator < String > keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( Collection < String > keys ) ; < T > BulkFuture < Map < String , T > > asyncGetBulk ( Transcoder < T > tc , String . . . keys ) ; BulkFuture < Map < String , Object > > asyncGetBulk ( String . . . keys ) ; < T > Map < String , T > getBulk ( Iterator < String > keys , Transcoder < T > tc ) ; < T > Map < String , T > getBulk ( Collection < String > keys , Transcoder < T > tc ) ; Map < String , Object > getBulk ( Iterator < String > keys ) ; Map < String , Object > getBulk ( Collection < String > keys ) ; < T > Map < String , T > getBulk ( Transcoder < T > tc , String . . . keys ) ; Map < String , Object > getBulk ( String . . . keys ) ; < T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; Set < String > listSaslMechanisms ( ) ; }
public void initDynamicComponent ( @Nonnull final IAS2Session aSession , @Nullable final IStringMap aParameters ) throws OpenAS2Exception { super . initDynamicComponent ( aSession , aParameters ) ; refresh ( ) ; }
public boolean unify ( List < Var > vl1 , List < Var > vl2 , Term t ) { t = t . getTerm ( ) ; if ( t instanceof Var ) { return t . unify ( vl1 , vl2 , this ) ;
public void shuffle ( ) throws MPDServerException { this . mpd . getMpdConnection ( ) . sendCommand ( MPD_CMD_PLAYLIST_SHUFFLE ) ; }
boolean isSigned ( @Nonnull MimeBodyPart aPart ) throws Exception ; @Nonnull String calculateMIC ( @Nonnull MimeBodyPart aPart , @Nonnull ECryptoAlgorithm eDigestAlgorithm , boolean bIncludeHeaders ) throws Exception ; @Nonnull MimeBodyPart decrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey ) throws Exception ; @Nonnull MimeBodyPart encrypt ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull ECryptoAlgorithm eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart sign ( @Nonnull MimeBodyPart aPart , @Nonnull X509Certificate aCert , @Nonnull PrivateKey aKey , @Nonnull ECryptoAlgorithm eAlgorithm ) throws Exception ; @Nonnull MimeBodyPart verify ( @Nonnull MimeBodyPart aPart , @Nullable X509Certificate aCert , boolean bAllowCertificateInBodyPart ) throws Exception ; }
public void testAsyncGetBulkCancellationVararg ( ) throws Exception { tryTestSequence ( client . asyncGetBulk ( " k " , " k2 " ) ) ; }
public static void forget ( final BudgetValue budget , final float forgetTime , float minPriority , final long currentTime ) { long forgetDelta = budget . getForgetPeriod ( currentTime ) ; float forgetProportion = forgetDelta / forgetTime ; if ( forgetProportion > 1.0f ) forgetProportion = 1.0f ; if ( forgetProportion < 0 ) forgetProportion = 0 ; minPriority * = budget . getQuality ( ) ; float currentPriority = budget . getPriority ( ) ; budget . setPriority ( currentPriority * ( 1.0f - forgetProportion ) + minPriority * ( forgetProportion ) ) ;
< T > Future < Boolean > touch ( final String key , final int exp , final Transcoder < T > tc ) ; < T > Future < Boolean > touch ( final String key , final int exp ) ; Map < SocketAddress , String > getVersions ( ) ; Map < SocketAddress , Map < String , String > > getStats ( ) ; Map < SocketAddress , Map < String , String > > getStats ( String prefix ) ; long incr ( String key , long by ) ; long incr ( String key , int by ) ; long decr ( String key , long by ) ; long decr ( String key , int by ) ; Future < Long > asyncIncr ( String key , long by ) ; Future < Long > asyncIncr ( String key , int by ) ; Future < Long > asyncDecr ( String key , long by ) ; Future < Long > asyncDecr ( String key , int by ) ; long incr ( String key , long by , long def , int exp ) ; long incr ( String key , int by , long def , int exp ) ; long decr ( String key , long by , long def , int exp ) ; long decr ( String key , int by , long def , int exp ) ; Future < Long > asyncIncr ( String key , long by , long def , int exp ) ; Future < Long > asyncIncr ( String key , int by , long def , int exp ) ; Future < Long > asyncDecr ( String key , long by , long def , int exp ) ; Future < Long > asyncDecr ( String key , int by , long def , int exp ) ; long incr ( String key , long by , long def ) ; long incr ( String key , int by , long def ) ; long decr ( String key , long by , long def ) ; long decr ( String key , int by , long def ) ; Future < Long > asyncIncr ( String key , long by , long def ) ; Future < Long > asyncIncr ( String key , int by , long def ) ; Future < Long > asyncDecr ( String key , long by , long def ) ; Future < Long > asyncDecr ( String key , int by , long def ) ; Future < Boolean > delete ( String key ) ; Future < Boolean > delete ( String key , long cas ) ; Future < Boolean > flush ( int delay ) ; Future < Boolean > flush ( ) ; void shutdown ( ) ; boolean shutdown ( long timeout , TimeUnit unit ) ; boolean waitForQueues ( long timeout , TimeUnit unit ) ; boolean addObserver ( ConnectionObserver obs ) ; boolean removeObserver ( ConnectionObserver obs ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of ) ; CountDownLatch broadcastOp ( final BroadcastOpFactory of , Collection < MemcachedNode > nodes ) ; Set < String > listSaslMechanisms ( ) ; }
